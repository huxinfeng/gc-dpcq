var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * 异步任务，多个任务同时进行，需要等待全部任务执行完毕后才回调
 * Created by 黑暗之神KDS
 *
 * 使用方式：
   var task = new AsynTask(Callback.New(() => {
            // 全部任务结束时
            
   }, this));
   task.execute(任意表达式); // 如 task.execute(1)
   task.execute(任意表达式);
   task.complete(); // 上面执行了两个任务，下方则需要完成两次complete则算完成
   task.complete();
 */
var AsynTask = /** @class */ (function () {
    /**
     * 异步 构造函数
     * @param onFin 回调方法
     * @param thisPtr 作用域
     */
    function AsynTask(onFin) {
        /**
         * 异步任务当前计数
         */
        this._asynCount = 0;
        /**
         * 异步任务总个数
         */
        this._asynLength = 0;
        this._onFin = onFin;
    }
    /**
     * 执行
     * @param code 直接执行代码即可，这里只是追加计数
     */
    AsynTask.prototype.execute = function (code) {
        this._asynLength++;
    };
    /**
     * 完成时回调
     */
    AsynTask.prototype.complete = function () {
        this._asynCount++;
        if (this._asynCount == this._asynLength) {
            this._onFin && this._onFin.run();
        }
    };
    Object.defineProperty(AsynTask.prototype, "length", {
        /**
         * 获取任务总数
         */
        get: function () {
            return this._asynLength;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AsynTask.prototype, "currentCount", {
        /**
         * 获取当前任务数
         */
        get: function () {
            return this._asynCount;
        },
        enumerable: false,
        configurable: true
    });
    return AsynTask;
}());
/**
 * 同步任务执行，任务类型相同的只能按照顺序执行下去，在当前任务未完成前后面的任务都处于等待状态
 *
 * Created by 黑暗之神KDS
 * 使用方式：
 * var taskName = "我的同步任务1";
 * // 第1个同步任务，同类型的任务会等待该任务执行完毕再接着执行
 * new SyncTask(taskName, function () {
         // 第1个顺序任务逻辑
         xxxxxxxxxxxxx
         // 第1个顺序任务执行完毕
         SyncTask.taskOver(taskName);
   });
   // 第2个同步任务，同类型的任务会等待该任务执行完毕再接着执行
   new SyncTask(taskName, function () {
         // 第2个顺序任务逻辑
         xxxxxxxxxxxxx
         // 第2个顺序任务执行完毕
         SyncTask.taskOver(taskName);
   });
 */
var SyncTask = /** @class */ (function () {
    /**
     * 同步任务执行 构造函数
     * @param taskName 任务名称
     * @param func 执行的方法
     * @param arg 参数
     * @param isConver 会否重复的任务覆盖掉
     * @param jumpQuere 是否插队，插队的话则插到最前方
     */
    function SyncTask(taskName, func, arg, thisPtr, isConver, jumpQuere) {
        if (func === void 0) { func = null; }
        if (arg === void 0) { arg = null; }
        if (thisPtr === void 0) { thisPtr = null; }
        if (isConver === void 0) { isConver = false; }
        if (jumpQuere === void 0) { jumpQuere = false; }
        var taskList = SyncTask.taskLists[taskName];
        if (!taskList)
            taskList = SyncTask.taskLists[taskName] = [];
        // 覆盖的话需要查找之前同taskName以及同func的，移除掉，保留最新的
        if (isConver) {
            var sameTaskList = ArrayUtils.matchAttributes(taskList, { func: func }, false);
            while (sameTaskList.length > 0) {
                var idx = taskList.indexOf(sameTaskList.shift());
                taskList.splice(idx, 1);
            }
        }
        if (jumpQuere) {
            taskList.unshift(this);
        }
        else {
            taskList.push(this);
        }
        this.func = func;
        this.arg = arg;
        this.thisPtr = thisPtr;
        SyncTask.doTask(taskName);
    }
    /**
     * 执行
     * @param taskName 任务名称
     */
    SyncTask.prototype.execute = function (taskName) {
        SyncTask.taskExecuteing[taskName] = true;
        if (!this.func)
            return;
        this.thisPtr ? this.func.apply(this.thisPtr, this.arg) : this.func.apply(this, this.arg);
    };
    /**
     * 执行一次某类型任务，会进入锁定状态，需要主动解锁才能执行下一次任务
     * @param taskName
     */
    SyncTask.doTask = function (taskName) {
        if (SyncTask.taskExecuteing[taskName])
            return;
        var taskList = SyncTask.taskLists[taskName];
        if (taskList && taskList.length > 0)
            taskList.shift().execute(taskName);
    };
    /**
     * 通知某个类型任务完成，直接进行同类型的下一个任务
     * @param taskName 任务名称
     */
    SyncTask.taskOver = function (taskName) {
        SyncTask.taskExecuteing[taskName] = false;
        SyncTask.doTask(taskName);
    };
    /**
     * 清除任务
     * @param taskName 任务名称
     */
    SyncTask.clear = function (taskName) {
        delete SyncTask.taskExecuteing[taskName];
        delete SyncTask.taskLists[taskName];
    };
    /**
     * 效果任务队列 同一批任务类型的话就只有在单个完成时才会继续
     * [taskName] = [task,task,task...]
     */
    SyncTask.taskLists = {};
    /**
     * 记录某一个taskName类型的任务是否正在进行
     */
    SyncTask.taskExecuteing = [];
    return SyncTask;
}());
/**
 * 数组工具类
 * Created by 黑暗之神KDS
 */
var ArrayUtils = /** @class */ (function () {
    function ArrayUtils() {
    }
    /**
     * 数组内随机打乱排序
     * @param arr 数组
     */
    ArrayUtils.randOrder = function (arr) {
        var arrClone = arr.concat();
        var newArr = [];
        while (arrClone.length > 0) {
            var obj = arrClone.splice(MathUtils.rand(arrClone.length), 1)[0];
            newArr.push(obj);
        }
        var len = arr.length;
        for (var i = 0; i < len; i++) {
            arr[i] = newArr[i];
        }
    };
    /**
     * 添加数据
     * @param arr 数据组
     * @param index 索引 -1=加入到数组尾端
     * @param arg 添加的数据
     */
    ArrayUtils.insert = function (arr, index) {
        var arg = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            arg[_i - 2] = arguments[_i];
        }
        var returnIndex;
        if (index == -1) {
            returnIndex = arr.length;
            arr.push.apply(arr, arg);
        }
        else {
            returnIndex = index;
            arr.splice.apply(arr, [index, 0].concat(arg));
        }
        return returnIndex;
    };
    /**
     * 删除数据
     * @param arr 数据组
     * @param index 索引 -1=删除尾端数据
     * @return [any] 被删除的数据对象
     */
    ArrayUtils.delete = function (arr, index) {
        return index == -1 ? arr.pop() : arr.splice(index, 1)[0];
    };
    /**
     * 移除数据
     * @param arr 数据组
     * @param obj 数据对象
     * @return [any]
     */
    ArrayUtils.remove = function (arr, obj) {
        var idx = arr.indexOf(obj);
        if (idx == -1)
            return null;
        return arr.splice(idx, 1)[0];
    };
    /**
     * 获取数据
     * @param arr 数据组
     * @param index 索引 -1=尾端数据
     * @return [any]
     */
    ArrayUtils.get = function (arr, index) {
        var index = index == -1 ? arr.length - 1 : index;
        return arr[index];
    };
    /**
     * 更改数据中的值
     * @param arr 数据组
     * @param index 索引
     * @param paramValue 参数和值Object
     * @param 实际被更改的对象数组
     */
    ArrayUtils.set = function (arr, index, paramValue) {
        function setValue(obj, paramValue) {
            for (var s in paramValue) {
                obj[s] = paramValue[s];
            }
        }
        if (index == -2) {
            var len = arr.length;
            for (var i = 0; i < len; i++) {
                setValue(arr[i], paramValue);
            }
            return arr;
        }
        else if (index == -1) {
            var obj = arr[arr.length - 1];
            setValue(obj, paramValue);
            return [obj];
        }
        else {
            var obj = arr[index];
            setValue(obj, paramValue);
            return [obj];
        }
    };
    /**
     * 插入数据 找到空值或添加
     * @param arr 数组
     * @param obj 要插入的对象
     * @return [number] 插入到的索引
     */
    ArrayUtils.insertToNullPosition = function (arr, obj) {
        var idx = ArrayUtils.getNullPosition(arr);
        arr[idx] = obj;
        return idx;
    };
    /**
     * 找到一个空的位置
     * @param arr 数组
     * @param startIndex [可选] 默认值=0 索引
     * @return [number] 找到空位置索引
     */
    ArrayUtils.getNullPosition = function (arr, startIndex) {
        if (startIndex === void 0) { startIndex = 0; }
        var index = -1;
        for (var i = startIndex; i < arr.length; i++) {
            if (!arr[i]) {
                index = i;
                break;
            }
        }
        if (index == -1)
            index = arr.length;
        return index;
    };
    /**
     * 剔除相同的元素，返回新的数组
     * @param arr 原数组
     * @return [any] 新数组
     */
    ArrayUtils.removeSameObject = function (arr) {
        var newArr = [];
        for (var i = arr.length - 1; i >= 0; i--) {
            var obj = arr[i];
            if (newArr.indexOf(obj) == -1) {
                newArr.push(obj);
            }
        }
        return newArr.reverse();
    };
    ;
    /**
     * 剔除相同的元素，根据子元素属性是否相同，返回新的数组
     * @param arr 原数组
     * @param attrName 属性名称
     * @param ifNullIgnore 是否如果属性为null时不会移除
     * @return [any] 新数组
     */
    ArrayUtils.removeSameObjectD2 = function (arr, attrName, ifNullIgnore) {
        var newArr = [];
        for (var i = arr.length - 1; i >= 0; i--) {
            var obj = arr[i];
            var matchValue = obj[attrName];
            if (matchValue == null && ifNullIgnore) {
                newArr.push(obj);
                return;
            }
            var matchObj = {};
            matchObj[attrName] = matchValue;
            if (ArrayUtils.matchAttributes(newArr, matchObj, true).length == 0) {
                newArr.push(obj);
            }
        }
        return newArr.reverse();
    };
    ;
    /**
     * 匹配数据
     * @param arr 数组
     * @param matchObj 参数
     * @param onlyOne 是否只找一个
     * @param symbol 对比符号
     * @param indexOfMode 返回匹配的索引而非返回匹配的对象
     * @return [any]
     */
    ArrayUtils.matchAttributes = function (arr, matchData, onlyOne, symbol, indexOfMode) {
        if (symbol === void 0) { symbol = "=="; }
        if (indexOfMode === void 0) { indexOfMode = false; }
        var matchs = [];
        for (var i in arr) {
            var obj = arr[i];
            if (!obj)
                continue;
            var isMatch = true;
            for (var s in matchData) {
                if ((symbol == "==" && obj[s] != matchData[s]) ||
                    (symbol == ">=" && obj[s] < matchData[s]) ||
                    (symbol == "<=" && obj[s] > matchData[s]) ||
                    (symbol == ">" && obj[s] <= matchData[s]) ||
                    (symbol == "<" && obj[s] >= matchData[s]) ||
                    (symbol == "!=" && obj[s] == matchData[s])) {
                    isMatch = false;
                    break;
                }
            }
            if (isMatch) {
                matchs.push(indexOfMode ? parseInt(i) : obj);
                if (onlyOne)
                    break;
            }
        }
        return matchs;
    };
    ;
    /**
     * 匹配数据 深度2
     * @param arr 数组
     * @param attribute 属性
     * @param matchObj 参数
     * @param onlyOne 是否仅返回一个
     * @param indexOfMode 返回匹配的索引而非返回匹配的对象
     * @return [any]
     */
    ArrayUtils.matchAttributesD2 = function (arr, attribute, matchData, onlyOne, symbol, indexOfMode) {
        if (symbol === void 0) { symbol = "=="; }
        if (indexOfMode === void 0) { indexOfMode = false; }
        var matchs = [];
        for (var i in arr) {
            var obj = arr[i];
            var isMatch = true;
            if (!obj[attribute])
                continue;
            for (var s in matchData) {
                if ((symbol == "==" && obj[attribute][s] != matchData[s]) ||
                    (symbol == ">=" && obj[attribute][s] < matchData[s]) ||
                    (symbol == "<=" && obj[attribute][s] > matchData[s]) ||
                    (symbol == ">" && obj[attribute][s] <= matchData[s]) ||
                    (symbol == "<" && obj[attribute][s] >= matchData[s]) ||
                    (symbol == "!=" && obj[attribute][s] == matchData[s])) {
                    isMatch = false;
                    break;
                }
            }
            if (isMatch) {
                matchs.push(indexOfMode ? parseInt(i) : obj);
                if (onlyOne)
                    break;
            }
        }
        return matchs;
    };
    ;
    /**
     * 匹配数据 深度2
     * @param arr 数组
     * @param attribute 属性
     * @param attribute2 属性2
     * @param matchObj 参数
     * @param onlyOne
     * @param indexOfMode 返回匹配的索引而非返回匹配的对象
     * @return [any]
     */
    ArrayUtils.matchAttributesD3 = function (arr, attribute, attribute2, matchData, onlyOne, symbol, indexOfMode) {
        if (symbol === void 0) { symbol = "=="; }
        if (indexOfMode === void 0) { indexOfMode = false; }
        var matchs = [];
        for (var i in arr) {
            var obj = arr[i];
            var isMatch = true;
            if (!obj[attribute])
                continue;
            if (!obj[attribute][attribute2])
                continue;
            for (var s in matchData) {
                if ((symbol == "==" && obj[attribute][attribute2][s] != matchData[s]) ||
                    (symbol == ">=" && obj[attribute][attribute2][s] < matchData[s]) ||
                    (symbol == "<=" && obj[attribute][attribute2][s] > matchData[s]) ||
                    (symbol == ">" && obj[attribute][attribute2][s] <= matchData[s]) ||
                    (symbol == "<" && obj[attribute][attribute2][s] >= matchData[s]) ||
                    (symbol == "!=" && obj[attribute][attribute2][s] == matchData[s])) {
                    isMatch = false;
                    break;
                }
            }
            if (isMatch) {
                matchs.push(indexOfMode ? parseInt(i) : obj);
                if (onlyOne)
                    break;
            }
        }
        return matchs;
    };
    ;
    /**
     * 获取对象/数组内对象的指定属性的值组成一个新的数组
     * @param arr 原对象/数组
     * @param attributeName 原数组内对象的指定属性名
     * @param ignoreNullChild [可选] 默认值=true 是否忽略掉在arr中为NULL的子对象，以便不会加入到新的数组中
     * @return [any]
     */
    ArrayUtils.getChildAttributeToCreateArray = function (arr, attributeName, ignoreNullChild) {
        if (ignoreNullChild === void 0) { ignoreNullChild = true; }
        var newArr = [];
        for (var i in arr) {
            var child = arr[i];
            if (child == null) {
                if (!ignoreNullChild)
                    newArr.push(child);
                continue;
            }
            newArr.push(child[attributeName]);
        }
        return newArr;
    };
    /**
     * 获取数组中元素出现的个数
     * @param arr 数组
     * @param value 元素
     * @return [number] 出现的个数
     */
    ArrayUtils.getElementSize = function (arr, value) {
        var n = 0;
        for (var i in arr) {
            if (arr[i] == value)
                n++;
        }
        return n;
    };
    /**
     * 批量装载创建对象
     * @param objCls 对象类
     * @param size 数目
     * @param obj
     * @param arr [可选] 默认值=null 装载至的数组，设置则以该数组为装载对象
     * @return [any]
     */
    ArrayUtils.createObjects = function (objCls, size, onCreateOne, arr) {
        if (onCreateOne === void 0) { onCreateOne = null; }
        if (arr === void 0) { arr = null; }
        if (!arr)
            arr = [];
        for (var i = 0; i < size; i++) {
            var o = new objCls();
            onCreateOne && onCreateOne(i, o);
            arr.push(o);
        }
        return arr;
    };
    /**
     * 互换数组中的位置
     * @param arr 数组
     * @param index1 位置1
     * @param index2 位置2
     */
    ArrayUtils.swap = function (arr, index1, index2) {
        var last = arr[index1];
        arr[index1] = arr[index2];
        arr[index2] = last;
    };
    /**
     * 调整数组中元素位置
     * @param arr 数组
     * @param element 元素
     * @param index 位置
     */
    ArrayUtils.setIndex = function (arr, element, index) {
        var idx = arr.indexOf(element);
        if (idx == -1)
            return;
        arr.splice(idx, 1);
        // idx < index && index--;
        // arr.splice(index+1, 0, element);
        arr.splice(index, 0, element);
    };
    /**
     * 按照asc排序（忽略大小写）
     * @param arr 数组
     * @param attributeName 属性的名称
     * @param isAsc 是否正序排序
     */
    ArrayUtils.sort = function (arr, attributeName, isAsc) {
        function order(a, b) {
            var aStr = a[attributeName];
            var bStr = b[attributeName];
            var min = Math.min(aStr.length, bStr.length);
            for (var i = 0; i < min; i++) {
                var code1 = aStr[i].toLocaleLowerCase().charCodeAt(0);
                var code2 = bStr[i].toLocaleLowerCase().charCodeAt(0);
                if (code1 == code2) {
                    continue;
                }
                return isAsc ? (code1 < code2 ? -1 : 1) : (code1 < code2 ? 1 : -1);
            }
            return -1;
        }
        arr.sort(order);
    };
    ;
    /**
     * 比较，列出B数组相对于A数组中不同的元素
     * @param aArr A数组
     * @param bArr B数组
     * @param appended 增加的元素 列表
     * @param subtract 减少的元素列表
     */
    ArrayUtils.compare = function (aArr, bArr) {
        var appended = [];
        if (aArr == null)
            aArr = [];
        if (bArr == null)
            bArr = [];
        var subtract = bArr.concat();
        var aLen = aArr.length;
        for (var i = 0; i < aLen; i++) {
            var a = aArr[i];
            var idx = subtract.indexOf(a);
            if (idx != -1) {
                subtract.splice(idx, 1);
            }
            else {
                appended.push(a);
            }
        }
        return {
            appended: appended,
            subtract: subtract
        };
    };
    /**
     * 获取树型结构下全部节点中的子节点列表（含自身节点）
     * @param reeNode 树型结构节点
     * @param childrenAttr 如 “children”
     * @param arrayList [可选] 默认值=null 装载数据的数组
     * @param checkIsOpen 是否需要检查开启状态，如果检查的话则未开启的数据不计入返回列表中
     * @param isOpenAttr 开启状态属性名
     * @param ignoreChildrenCondition [可选] 默认值=null 忽略子对象的条件 如 ignoreChildrenCondition(treeNode: any){return treeNode.ignoreChildren;}
     */
    ArrayUtils.getTreeNodeArray = function (treeNode, childrenAttr, arrayList, checkIsOpen, isOpenAttr, ignoreChildrenCondition) {
        if (childrenAttr === void 0) { childrenAttr = "children"; }
        if (arrayList === void 0) { arrayList = null; }
        if (checkIsOpen === void 0) { checkIsOpen = false; }
        if (isOpenAttr === void 0) { isOpenAttr = "isOpen"; }
        if (ignoreChildrenCondition === void 0) { ignoreChildrenCondition = null; }
        if (!arrayList)
            arrayList = [];
        arrayList.push(treeNode);
        if (ignoreChildrenCondition && ignoreChildrenCondition.runWith([treeNode]))
            return arrayList;
        var children = treeNode[childrenAttr];
        if (!children)
            return arrayList;
        if (!checkIsOpen || (checkIsOpen && treeNode[isOpenAttr])) {
            var len = children.length;
            for (var i = 0; i < len; i++) {
                ArrayUtils.getTreeNodeArray(children[i], childrenAttr, arrayList, checkIsOpen, isOpenAttr, ignoreChildrenCondition);
            }
        }
        return arrayList;
    };
    return ArrayUtils;
}());
/**
 * 回调方法：一般用于各种回调函数中为了携带执行域和参数
 * Created by 黑暗之神KDS
 *
 * 使用方法：
 * Callback.New(this.xxx,this,[1,2,3]);
 */
var Callback = /** @class */ (function () {
    /**
     * 构造函数
     */
    function Callback(callbackFunc, caller, args) {
        if (args === void 0) { args = null; }
        this.delayRunSigns = [];
        this.callbackFunc = callbackFunc;
        this.caller = caller;
        this.args = args;
    }
    /**
     * 运行
     * @param addArgs [可选] 默认值=null 追加的参数
     */
    Callback.prototype.run = function () {
        var r = this.callbackFunc.apply(this.caller, this.args);
        return r;
    };
    /**
     * 运行追加额外的参数 追加的参数在回调时总是在后面
     * @param addArgs  追加的参数
     */
    Callback.prototype.runWith = function (addArgs) {
        var r = this.callbackFunc.apply(this.caller, this.args ? this.args.concat(addArgs) : addArgs);
        return r;
    };
    /**
     * 延迟执行
     * @param delay 延迟的ms数
     * @param delayFunc [可选] 默认值=null 延迟使用的函数，默认setTimeout，可更换
     * @param args [可选] 默认值=null 参数
     * @return [Callback]
     */
    Callback.prototype.delayRun = function (delay, delayFunc, args) {
        if (delayFunc === void 0) { delayFunc = null; }
        if (args === void 0) { args = null; }
        var f = delayFunc ? delayFunc : setTimeout;
        this.delayRunSigns.push(f(function (callBack) {
            callBack.delayRunSigns.shift();
            args ? callBack.runWith(args) : callBack.run();
        }, delay, this));
        return this;
    };
    /**
     * 延迟执行，但会覆盖掉之前的延迟
     * @param delay 延迟的ms数
     * @param delayFunc [可选] 默认值=null 延迟使用的函数，默认setTimeout，可更换
     * @param clearDelayFunc [可选] 默认值=null 清理的延迟函数，默认 clearTimeout，可更换
     * @param args [可选] 默认值=null 参数
     * @return [Callback]
     */
    Callback.prototype.delayRunConver = function (delay, delayFunc, clearDelayFunc, args) {
        if (delayFunc === void 0) { delayFunc = null; }
        if (clearDelayFunc === void 0) { clearDelayFunc = null; }
        if (args === void 0) { args = null; }
        if (this.delayRunSign) {
            var f = clearDelayFunc ? clearDelayFunc : clearTimeout;
            f(this.delayRunSign);
        }
        this.delayRunSign = this.delayRun(delay, delayFunc, args);
        return this;
    };
    /**
     * 停止延期
     */
    Callback.prototype.stopDelay = function (clearDelayFunc) {
        if (clearDelayFunc === void 0) { clearDelayFunc = null; }
        var f = clearDelayFunc ? clearDelayFunc : clearTimeout;
        if (this.delayRunSign) {
            f(this.delayRunSign);
            this.delayRunSign = null;
        }
        for (var i in this.delayRunSigns) {
            f(this.delayRunSigns[i]);
        }
        this.delayRunSigns.length = 0;
    };
    //------------------------------------------------------------------------------------------------------
    // 对象池系统 
    //------------------------------------------------------------------------------------------------------
    /**
     * 新建回调对象，同new CallBack
     * @param callbackFunc 回调方法
     * @param caller 执行域
     * @param args [可选] 默认值=null 携带的参数
     * @return [Callback]
     */
    Callback.New = function (callbackFunc, caller, args) {
        if (args === void 0) { args = null; }
        var cb = new Callback(callbackFunc, caller, args);
        return cb;
    };
    /**
     * 延迟到下一帧执行，保证相同的方法和作用域只能执行一次，可用于优化效率
     * 相同的方法和作用域调用此方法，只有第一次生效，其中args参数会替换成最近一次调用的参数
     * 该方法可能在下一次渲染前也可能在下一帧渲染后执行，如果必须确定在下次渲染前就要执行可使用CallLaterBeforeRender
     * 内部使用setTimeout-0ms实现
     * @param func 执行的方法
     * @param caller 作用域
     * @param args [可选] 默认值=null 附带的参数
     * @param delay [可选] 默认值=0 延迟的ms
     */
    Callback.CallLater = function (func, caller, args, delay) {
        if (args === void 0) { args = null; }
        if (delay === void 0) { delay = 0; }
        // 初始化字典
        var map = caller["____clks"];
        if (!map)
            map = caller["____clks"] = new Dictionary();
        // 查询是否存在
        var keyInfo = map.get(func);
        if (keyInfo) {
            var key = keyInfo.key;
            var cb = keyInfo.cb;
            cb.args[2] = args;
        }
        else {
            key = ObjectUtils.getInstanceID();
            cb = Callback.New(function (func, caller, args, key) {
                if (args === void 0) { args = null; }
                var map = caller["____clks"];
                map.remove(func);
                func.apply(caller, args);
            }, this, [func, caller, args, key]).delayRun(delay);
            map.set(func, { key: key, cb: cb });
        }
    };
    /**
     * 延迟到下一次渲染时执行，保证相同的方法和作用域只能执行一次，可用于优化效率
     * 相同的方法和作用域调用此方法，只有第一次生效，其中args参数会替换成最近一次调用的参数
     * @param func 执行的方法
     * @param caller 作用域
     * @param args [可选] 默认值=null 附带的参数
     */
    Callback.CallLaterBeforeRender = function (func, caller, args) {
        if (args === void 0) { args = null; }
        // 初始化字典
        var map = caller["____clks2"];
        if (!map)
            map = caller["____clks2"] = new Dictionary();
        // 查询是否存在
        var keyInfo = map.get(func);
        if (keyInfo) {
            var key = keyInfo.key;
            var cb = keyInfo.cb;
            cb.args = args;
        }
        else {
            key = ObjectUtils.getInstanceID();
            cb = Callback.New(func, caller, args);
            map.set(func, { key: key, cb: cb });
            Callback.beforeRenderFuncs[key] = cb;
        }
    };
    var _a;
    _a = Callback;
    /**
     * 空的单一实例
     */
    Callback.EMPTY = new Callback(function () { }, _a);
    /**
     * 记录渲染前函数
     */
    Callback.beforeRenderFuncs = [];
    return Callback;
}());
/**
 * 通用事件管理器
 * Created by 黑暗之神KDS on 2017-08-22 20:52:51.
 */
var EventUtils = /** @class */ (function () {
    function EventUtils() {
    }
    /**
     * 注册事件
     * @param obj 事件对象
     * @param type 类型
     * @param callBack 回调
     * @param isOnce 是否执行一次 默认 false
     */
    EventUtils.addEventListener = function (obj, type, callBack, isOnce) {
        if (isOnce === void 0) { isOnce = false; }
        if (!obj)
            return;
        // 获取指定的对象中的事件数据
        var evIdx = obj["__evIdx"];
        var evTypes;
        if (evIdx != null) {
            evTypes = EventUtils.evList[evIdx];
        }
        else {
            evTypes = {};
            evIdx = ArrayUtils.insertToNullPosition(EventUtils.evList, evTypes);
            obj["__evIdx"] = evIdx;
        }
        // 获取指定事件数据中的对应的类型事件
        var evArrs = evTypes[type];
        if (!evArrs)
            evTypes[type] = evArrs = [];
        // 添加数据
        var evArr = [callBack, isOnce];
        evArrs.push(evArr);
    };
    /**
     * 注册事件-函数和作用域版
     * @param obj 事件对象
     * @param type 类型
     * @param onHappen 回调方法
     * @param thisPtr 回调时作用域
     * @param args [可选] 默认值=null 回调时参数
     * @param isOnce [可选] 默认值=false 是否执行一次
     */
    EventUtils.addEventListenerFunction = function (obj, type, onHappen, thisPtr, args, isOnce) {
        if (args === void 0) { args = null; }
        if (isOnce === void 0) { isOnce = false; }
        if (!obj)
            return;
        // 获取指定的对象中的事件数据
        var evIdx = obj["__evIdx2"];
        var evTypes;
        if (evIdx != null) {
            evTypes = EventUtils.evList2[evIdx];
        }
        else {
            evTypes = {};
            evIdx = ArrayUtils.insertToNullPosition(EventUtils.evList2, evTypes);
            obj["__evIdx2"] = evIdx;
        }
        // 获取指定事件数据中的对应的类型事件
        var evArrs = evTypes[type];
        if (!evArrs)
            evTypes[type] = evArrs = [];
        // 添加数据
        var evArr = [onHappen, thisPtr, args, isOnce];
        evArrs.push(evArr);
    };
    /**
     * 移除事件
     * @param obj 事件对象
     * @param type 类型
     * @param callBack 回调
     */
    EventUtils.removeEventListener = function (obj, type, callBack) {
        if (!obj)
            return;
        var evIdx = obj["__evIdx"];
        if (evIdx != null) {
            var evTypes = EventUtils.evList[evIdx];
            var evArrs = evTypes[type];
            for (var i in evArrs) {
                var evArr = evArrs[i];
                if (evArr[0] == callBack) {
                    evArrs.splice(parseInt(i), 1);
                    break;
                }
            }
        }
    };
    /**
     * 移除事件-函数和作用域版
     * @param obj 事件对象
     * @param type 类型
     * @param onHappen 回调方法
     * @param thisPtr 回调时作用域
     */
    EventUtils.removeEventListenerFunction = function (obj, type, onHappen, thisPtr) {
        if (!obj)
            return;
        var evIdx = obj["__evIdx2"];
        if (evIdx != null) {
            var evTypes = EventUtils.evList2[evIdx];
            var evArrs = evTypes[type];
            for (var i in evArrs) {
                var evArr = evArrs[i];
                if (evArr[0] == onHappen && evArr[1] == thisPtr) {
                    evArrs.splice(parseInt(i), 1);
                    break;
                }
            }
        }
    };
    /**
     * 派发事件，若注册时存在参数的话参数优先为注册的参数，再追加这里派发的参数args
     * @param obj 事件对象
     * @param type 类型
     */
    EventUtils.happen = function (obj, type, args) {
        if (args === void 0) { args = null; }
        if (!obj)
            return;
        // callback
        var evIdx = obj["__evIdx"];
        var happenFuncs = [];
        if (evIdx != null) {
            var evTypes = EventUtils.evList[evIdx];
            var evArrs = evTypes[type];
            if (evArrs) {
                for (var i = 0; i < evArrs.length; i++) {
                    var evArr = evArrs[i];
                    var callback = evArr[0];
                    var isOnce = evArr[1];
                    if (isOnce) {
                        evArrs.splice(i, 1);
                        i--;
                    }
                    happenFuncs.push(callback);
                }
                happenFuncs.forEach(function (callback, index, array) {
                    args ? callback.runWith(args) : callback.run();
                });
            }
        }
        // func
        var evIdx2 = obj["__evIdx2"];
        var happenFuncs2 = [];
        if (evIdx2 != null) {
            var evTypes2 = EventUtils.evList2[evIdx2];
            var evArrs2 = evTypes2[type];
            if (evArrs2) {
                for (var i = 0; i < evArrs2.length; i++) {
                    var evArr2 = evArrs2[i];
                    var func = evArr2[0];
                    var thisPtr = evArr2[1];
                    var funcArgs = evArr2[2];
                    var isOnce = evArr2[3];
                    if (isOnce) {
                        evArrs2.splice(i, 1);
                        i--;
                    }
                    happenFuncs2.push([func, thisPtr, funcArgs]);
                }
                happenFuncs2.forEach(function (funcArr, index, array) {
                    var func = funcArr[0];
                    var thisPtr = funcArr[1];
                    var funcArgs = funcArr[2];
                    if (args) {
                        func.apply(thisPtr, funcArgs ? funcArgs.concat(args) : args);
                    }
                    else {
                        func.apply(thisPtr, funcArgs);
                    }
                });
            }
        }
    };
    /**
     * 清空事件
     * @param obj 事件对象
     * @param type 类型，如果为null表示全部
     */
    EventUtils.clear = function (obj, type) {
        if (type === void 0) { type = null; }
        if (!obj)
            return;
        // callback
        var evIdx = obj["__evIdx"];
        if (evIdx != null) {
            if (type == null) {
                EventUtils.evList[evIdx] = null;
                delete obj["__evIdx"];
            }
            else {
                var evTypes = EventUtils.evList[evIdx];
                delete evTypes[type];
                var hasEv = false;
                for (var i in evTypes) {
                    hasEv = true;
                    break;
                }
                if (!hasEv) {
                    EventUtils.evList[evIdx] = null;
                    delete obj["__evIdx"];
                }
            }
        }
        // func
        var evIdx2 = obj["__evIdx2"];
        if (evIdx2 != null) {
            if (type == null) {
                EventUtils.evList2[evIdx2] = null;
                delete obj["__evIdx2"];
            }
            else {
                var evTypes2 = EventUtils.evList2[evIdx2];
                delete evTypes2[type];
                var hasEv = false;
                for (var i in evTypes2) {
                    hasEv = true;
                    break;
                }
                if (!hasEv) {
                    EventUtils.evList2[evIdx2] = null;
                    delete obj["__evIdx2"];
                }
            }
        }
    };
    /**
     * [obj][type][[func,thisPtr]]
     */
    EventUtils.evList = [];
    /**
     * [obj][type][[func,thisPtr]]
     */
    EventUtils.evList2 = [];
    return EventUtils;
}());
/**
 * 常用的数学工具类
 * Created by 黑暗之神KDS on 2017-08-22 20:52:51.
 */
var MathUtils = /** @class */ (function () {
    function MathUtils() {
    }
    /**
      * 角度转弧度。
      * @param	angle 角度值。
      * @return	返回弧度值。
      */
    MathUtils.angle2Radian = function (angle) { return angle * Math.PI / 180; };
    ;
    /**
     * 弧度转换为角度。
     * @param	radian 弧度值。
     * @return	返回角度值。
     */
    MathUtils.radian2Angle = function (radian) { return 180 * radian / Math.PI; };
    ;
    /**
     * 返回0~n-1的正整数
     * @param n
     * @return [number]
     */
    MathUtils.rand = function (n) {
        return Math.floor(Math.random() * n);
    };
    /**
     * 获取两点之间的角度 0-360
     * @param x1 起点x
     * @param y1 起点y
     * @param x2 终点x
     * @param y2 终点y
     * @return [number] 终点相对于起点的角度
     */
    MathUtils.direction360 = function (x1, y1, x2, y2) {
        var n_r = Math.PI / 2;
        if (x1 != x2) {
            n_r = Math.atan((y1 - y2) / (x1 - x2));
        }
        var angle = n_r * 180 / Math.PI;
        if (x2 > x1) {
            if (y2 > y1) {
                angle = Math.abs(angle) + 90;
            }
            else {
                angle = 90 - Math.abs(angle);
            }
        }
        else {
            if (y2 > y1) {
                angle = 90 - Math.abs(angle) + 180;
            }
            else {
                angle = Math.abs(angle) + 270;
            }
        }
        if (angle == 360) {
            angle = 0;
        }
        return angle;
    };
    /**
     * 获取顺时针/逆时针旋转的角度
     * @param x1 起点x
     * @param y1 起点y
     * @param x2 终点x
     * @param y2 终点y
     * @param lastAngle 上一次角度
     * @return [number]
     */
    MathUtils.directionCircle = function (x1, y1, x2, y2, lastAngle) {
        var angle = MathUtils.direction360(x1, y1, x2, y2);
        if (angle == lastAngle)
            return angle;
        var circle = Math.floor(lastAngle / 360);
        var last = lastAngle - circle * 360;
        if (last < 0)
            last += 360;
        if (angle > last) {
            //顺时针
            if (angle > 270 && angle <= 360 && last >= 0 && last < 90) {
                circle--;
            }
        }
        else {
            //逆时针
            if (angle >= 0 && angle < 90 && last > 270 && last <= 360) {
                circle++;
            }
        }
        return (angle + circle * 360);
    };
    /**
     * 固定整数位，未满则补充0
     * 如 fixIntDigit(2,3)  -->  003
     * @param s 数值
     * @param fixDigit [可选] 默认值=4 固定的位数
     * @return [string]
     */
    MathUtils.fixIntDigit = function (s, fixDigit) {
        if (fixDigit === void 0) { fixDigit = 4; }
        var ss = s.toString();
        while (ss.length < fixDigit) {
            ss = "0" + ss;
        }
        return ss;
    };
    /**
     * 强制转化为整数
     * @param v 对于不符合要求的参数则转为0
     */
    MathUtils.int = function (v) {
        var a = parseInt(v);
        if (isNaN(a))
            return 0;
        return a;
    };
    /**
     * 转化为浮点数
     * @param v 对于不符合要求的参数则转为0
     */
    MathUtils.float = function (v) {
        var a = parseFloat(v);
        if (isNaN(a))
            return 0;
        return a;
    };
    /**
     * 判断是否在度数范围内
     * @param limitMax 上限 -360~360
     * @param limitMin 下线 -360~360
     * @param angle 指定的角度
     * @return [boolean]
     */
    MathUtils.inAngleRange = function (limitMax, limitMin, angle) {
        limitMax = limitMax + 360;
        limitMin = limitMin + 360;
        var angles = [angle, angle - 360, angle + 360];
        for (var i in angles) {
            var angle = angles[i];
            if (angle > limitMin && angle < limitMax) {
                return true;
            }
        }
        return false;
    };
    /**
     * 判断一个数是否是2的n次幂
     * @return [boolean]
     */
    MathUtils.isPowerOfTwo = function (x) {
        return (x & (x - 1)) == 0;
    };
    /**
     * 获取离x最近的一个2的次幂数
     * @param x
     * @return [number]
     */
    MathUtils.nextHighestPowerOfTwo = function (x) {
        --x;
        for (var i = 1; i < 32; i <<= 1) {
            x = x | x >> i;
        }
        return x + 1;
    };
    /**
     * 计算获取二次贝塞尔曲线上的某个点具体位置
     * @param startX 起点x
     * @param startY 起点y
     * @param CtrlX 控制点x
     * @param CtrlY 控制点y
     * @param endX 终点x
     * @param endY 终点y
     * @param t 0~1 表示起点到终点间某个点的位置信息 0表示起点，1表示终点，0.5则表示起点-终点的一半
     * @param resultPoint [可选] 如存在则将数据装入到该点中
     * @return 计算点的具体位置
     */
    MathUtils.getBezierPoint2 = function (startX, startY, CtrlX, CtrlY, endX, endY, t, resultPoint) {
        if (resultPoint === void 0) { resultPoint = null; }
        if (!resultPoint)
            resultPoint = new Point();
        resultPoint.x = Math.pow((1 - t), 2) * startX + 2 * t * (1 - t) * CtrlX + Math.pow(t, 2) * endX;
        resultPoint.y = Math.pow((1 - t), 2) * startY + 2 * t * (1 - t) * CtrlY + Math.pow(t, 2) * endY;
        return resultPoint;
    };
    /**
     * 根据角度获得坐标的相对偏移比例
     * @param rotation 角度
     * @return [Point]
     */
    MathUtils.getOffsetByRotation = function (rotation) {
        var offset = new Point(0, 0);
        if (rotation > 0) {
            //360
            var per = Math.floor(rotation / 360);
            var angle360 = rotation - 360 * per;
            if (angle360 < 0)
                angle360 += 360;
            //180
            if (angle360 > 0 && angle360 <= 90) {
                offset.x = angle360 / 90;
                var angle45 = Math.abs(angle360 - 45);
                offset.y = (angle45 - 45) / 180;
            }
            else if (angle360 > 90 && angle360 <= 180) {
                var angle135 = Math.abs(angle360 - 135);
                offset.x = (225 - angle135) / 180;
                offset.y = (angle360 - 90) / 90;
            }
            else if (angle360 > 180 && angle360 <= 270) {
                offset.x = (270 - angle360) / 90;
                var angle225 = Math.abs(angle360 - 225);
                offset.y = (225 - angle225) / 180;
            }
            else if (angle360 > 270 && angle360 <= 360) {
                var angle315 = Math.abs(angle360 - 315);
                offset.x = (angle315 - 45) / 180;
                offset.y = (360 - angle360) / 90;
            }
        }
        return offset;
    };
    return MathUtils;
}());
/**
 * 对象工具
 * Created by 黑暗之神KDS on 2018-07-24 02:09:40.
 */
var ObjectUtils = /** @class */ (function () {
    function ObjectUtils() {
    }
    /**
     * 获取唯一ID
     */
    ObjectUtils.getInstanceID = function () {
        return ObjectUtils.idCount++;
    };
    /**
     * 获取随机唯一ID
     */
    ObjectUtils.getRandID = function () {
        return (new Date().getTime() - 1557554040401) + "_" + Math.random();
    };
    /**
     * 将A的属性克隆给B
     * @param a
     * @param b
     */
    ObjectUtils.clone = function (form, to) {
        for (var i in form) {
            to[i] = form[i];
        }
    };
    /**
     * 将A的属性克隆给B，仅对于B存在的属性才克隆
     * @param a
     * @param b
     */
    ObjectUtils.cloneExcludeNonExistentAttribute = function (form, to) {
        for (var i in to) {
            to[i] = form[i];
        }
    };
    /**
     * 深度克隆属性
     * @param 对象
     */
    ObjectUtils.depthClone = function (o) {
        if (o == null)
            return null;
        return JSON.parse(JSON.stringify(o));
    };
    /**
     * 判断两个对象是否不同 遍历a的属性是否与b相同
     * @param a 对象A
     * @param b 对象B
     * @return [boolean]
     */
    ObjectUtils.same = function (a, b) {
        if ((a == null && b != null) || (a != null && b == null))
            return false;
        for (var i in a) {
            if (a[i] != b[i]) {
                return false;
            }
        }
        return true;
    };
    /**
     * 判断两个对象是否不同 遍历a的属性是否与b相同 深度对比
     * 根据最终的基本属性对比，而复杂的属性则会进一步深入到基本属性中后进行对比
     * @param a 对象A
     * @param b 对象B
     * @return 是否相同
     */
    ObjectUtils.depthSame = function (a, b) {
        if ((a == null && b != null) || (a != null && b == null))
            return false;
        var aLen = 0, bLen = 0;
        for (var i in a) {
            if (i == "constructor")
                continue;
            aLen++;
        }
        for (var i in b) {
            if (i == "constructor")
                continue;
            bLen++;
        }
        if (bLen != aLen)
            return false;
        for (var i in a) {
            // 忽略构造函数
            if (i == "constructor")
                continue;
            var aValue = a[i];
            if (typeof aValue == "boolean" || typeof aValue == "number" || typeof aValue == "string") {
                if (aValue != b[i]) {
                    return false;
                }
            }
            else {
                if (!ObjectUtils.depthSame(aValue, b[i])) {
                    return false;
                }
            }
        }
        return true;
    };
    /**
     * 赋值，将B的值赋值给A，不变更类型
     * -- B中存在的属性才会被赋值
     * -- 保持A的类型不变（这样可保留该类型下的方法）
     * @param a对象
     * @param b对象
     */
    ObjectUtils.assignment = function (a, b) {
        for (var i in b) {
            var value = b[i];
            var attrType = typeof value;
            if (attrType == "number" || attrType == "string" || attrType == "boolean") {
                a[i] = value;
            }
            else if (typeof a[i] == "function") {
                continue;
            }
            else {
                if (a[i]) {
                    this.assignment(a[i], value);
                }
            }
        }
    };
    /**
     * 重定义get/set
     * @param target 目标对象
     * @param defineContent {x:function(v){code}}
     */
    ObjectUtils.reDefineGetSet = function (target, defineContent) {
        for (var i in defineContent) {
            var str = "\n            Object.defineProperty(" + target + ", \"" + i + "\", {\n                set: function (v) {\n                    this._" + i + " = v;\n                    defineContent." + i + ".apply(this,[v]);\n                },\n                get: function () {\n                    return this._" + i + "\n                }\n            });\n            ";
            eval(str);
        }
        var arr = target.split(".");
        if (arr.pop() == "prototype") {
            eval("setTimeout(function(){new " + arr.join(".") + "()},0);");
        }
    };
    /**
     * 代理方法，指定对象A的方法执行以B的该方法执行
     * @param target 目标对象
     * @param agentTargetName 目标对象的子对象属性
     * @param defineContent {x:function(v){code}}
     */
    ObjectUtils.agentFunction = function (target, agentTargetName, funcs, logic) {
        if (logic === void 0) { logic = ""; }
        for (var i in funcs) {
            var funcName = funcs[i];
            eval("\n                target." + funcName + " = function () {\n                   " + logic + "\n                   return this." + agentTargetName + "." + funcName + ".apply(this." + agentTargetName + ",arguments);\n                }\n            ");
        }
    };
    ObjectUtils.idCount = 0;
    return ObjectUtils;
}());
/**
 * 对象池工具
 * Created by 黑暗之神KDS on 2017-10-25 17:36:38.
 */
var PoolUtils = /** @class */ (function () {
    /**
     * 构造函数
     * @param 类对象
     */
    function PoolUtils(cls) {
        /**
         * 池子
         */
        this.pools = [];
        this.cls = cls;
    }
    /**
     * 归还
     * @param obj
     */
    PoolUtils.prototype.free = function (obj) {
        this.pools.push(obj);
    };
    /**
     * 取出
     * @param desc 倒序取出
     */
    PoolUtils.prototype.takeout = function (asc) {
        if (asc === void 0) { asc = true; }
        if (this.pools.length > 0) {
            return asc ? this.pools.shift() : this.pools.pop();
        }
        return new this.cls();
    };
    return PoolUtils;
}());
/**
 * 字符串工具
 * Created by 黑暗之神KDS on 2019-01-02 20:23:15.
 */
var StringUtils = /** @class */ (function () {
    function StringUtils() {
    }
    /**
     * 获取字符真实长度
     * @param str
     */
    StringUtils.getRealLength = function (str) {
        var realLength = 0, len = str.length, charCode = -1;
        for (var i = 0; i < len; i++) {
            charCode = str.charCodeAt(i);
            if (charCode >= 0 && charCode <= 128)
                realLength += 1;
            else
                realLength += 2;
        }
        return realLength;
    };
    /**
     * 清除HTML格式
     * -- 目前为SuperText的Span
     * @param str
     * @return [string]
     */
    StringUtils.clearHtmlTag = function (str) {
        if (!str)
            return "";
        return str.replace(/<(s|\/s)pa[^>]+>/g, "");
    };
    /**
     * 清除HTML格式
     * -- 包含 span、img 标签，并且把多个空白转换为一个空格
     * @param str
     * @return [string]
     */
    StringUtils.clearHtmlTag1 = function (str) {
        if (!str)
            return "";
        var space = " ";
        str = str.replace(/<img[^>]+\/>|<(s|\/s)pa[^>]+>/g, "");
        str = str.replace(/\<br\>/g, "");
        str = str.replace(/&nbsp;/g, space);
        str = str.replace(/[\s]+/g, space); // 把多个空白转换为一个空格
        str = str.replace(space, ""); // 出去第一个空格
        return str;
    };
    /**
     * 解析自定义文本信息
     * @param info
     * @returns
     */
    StringUtils.paraseCustomMessage = function (info) {
        var title = "", content = "";
        try {
            var arr = info.title.split("<span></span>");
            if (arr[1])
                title = StringUtils.clearHtmlTag1(arr[1]);
            if (arr[2])
                content = StringUtils.clearHtmlTag1(arr[2]);
        }
        catch (e) {
            title = StringUtils.clearHtmlTag1(info.title);
        }
        return { title: title, content: content };
    };
    /**
     * HTML转义
     * @param t
     * @return [string]
     */
    StringUtils.toHtmlEscape = function (t) {
        if (!t || typeof t != "string")
            return t;
        t = t.replace(/\</g, "〈");
        t = t.replace(/\>/g, "〉");
        t = t.replace(/&/g, "&amp;");
        t = t.replace(/ /g, "&nbsp;");
        return t;
    };
    StringUtils.htmlEscapeToText = function (t) {
        if (!t || typeof t != "string")
            return t;
        t = t.replace(/〈/g, "<");
        t = t.replace(/〉/g, ">");
        t = t.replace(/&amp;/g, "&");
        t = t.replace(/&nbsp;/g, " ");
        return t;
    };
    /**
     * 获取两个字符串中间不相同的地方的信息
     * @param str1 字符串1
     * @param str2 字符串2
     * @return [头串相同的字符数目,尾串相同的字符数目]
     */
    StringUtils.getMiddleDiff = function (str1, str2) {
        var oldFirstEndIndex = 0;
        var newSccondStartIndex = 0;
        var shortLen = Math.min(str1.length, str2.length);
        for (var i = 0; i < shortLen; i++) {
            if (str1[i] == str2[i]) {
                oldFirstEndIndex = i + 1;
            }
            else {
                break;
            }
        }
        var nStr1 = str1.substr(oldFirstEndIndex);
        var nStr2 = str2.substr(oldFirstEndIndex);
        shortLen -= oldFirstEndIndex;
        for (var i = 0; i < shortLen; i++) {
            var oldIndex = nStr1.length - 1 - i;
            var newIndex = nStr2.length - 1 - i;
            if (nStr1[oldIndex] == nStr2[newIndex]) {
                newSccondStartIndex = i + 1;
            }
            else {
                break;
            }
        }
        return [oldFirstEndIndex, newSccondStartIndex];
    };
    ;
    return StringUtils;
}());
//@cannot search
// domain
var gcTop = top;
var gcParent = parent;
try {
    top.document.domain;
}
catch (e) {
    gcTop = gcParent = window;
}
var top_kdsrpg;
if (gcTop.gcide_common && gcTop.gcide_common.kdsrpg) {
    top_kdsrpg = gcTop.gcide_common.kdsrpg;
}
if (typeof gcTop.gcide_common != "undefined" && typeof top_kdsrpg != "undefined") {
    gcTop.gcide_core.frameRef(1);
}
var console_warn = function () { };
var console_log = function () { };
var console_error = function () { };
var console_debug = function () { };
//------------------------------------------------------------------------------------------------------
// 第三方渲染引擎，API对接完成后替换底层渲染引擎
// 目前做了一些微略修改
//------------------------------------------------------------------------------------------------------
var Laya = window.Laya = (function (window, document) {
    var Laya = {
        __internals: [],
        __packages: {},
        __classmap: { 'Object': Object, 'Function': Function, 'Array': Array, 'String': String },
        __sysClass: { 'object': 'Object', 'array': 'Array', 'string': 'String', 'dictionary': 'Dictionary' },
        __propun: { writable: true, enumerable: false, configurable: true },
        __presubstr: String.prototype.substr,
        __substr: function (ofs, sz) { return arguments.length == 1 ? Laya.__presubstr.call(this, ofs) : Laya.__presubstr.call(this, ofs, sz > 0 ? sz : (this.length + sz)); },
        __init: function (_classs) { _classs.forEach(function (o) { o.__init$ && o.__init$(); }); },
        __isClass: function (o) { return o && (o.__isclass || o == Object || o == String || o == Array); },
        __newvec: function (sz, value) {
            var d = [];
            d.length = sz;
            for (var i = 0; i < sz; i++)
                d[i] = value;
            return d;
        },
        __extend: function (d, b) {
            for (var p in b) {
                if (!b.hasOwnProperty(p))
                    continue;
                var gs = Object.getOwnPropertyDescriptor(b, p);
                var g = gs.get, s = gs.set;
                if (g || s) {
                    if (g && s)
                        Object.defineProperty(d, p, gs);
                    else {
                        g && Object.defineProperty(d, p, g);
                        s && Object.defineProperty(d, p, s);
                    }
                }
                else
                    d[p] = b[p];
            }
            function __() { Laya.un(this, 'constructor', d); }
            __.prototype = b.prototype;
            d.prototype = new __();
            Laya.un(d.prototype, '__imps', Laya.__copy({}, b.prototype.__imps));
        },
        __copy: function (dec, src) {
            if (!src)
                return null;
            dec = dec || {};
            for (var i in src)
                dec[i] = src[i];
            return dec;
        },
        __package: function (name, o) {
            if (Laya.__packages[name])
                return;
            Laya.__packages[name] = true;
            var p = window, strs = name.split('.');
            if (strs.length > 1) {
                for (var i = 0, sz = strs.length - 1; i < sz; i++) {
                    var c = p[strs[i]];
                    p = c ? c : (p[strs[i]] = {});
                }
            }
            p[strs[strs.length - 1]] || (p[strs[strs.length - 1]] = o || {});
        },
        __hasOwnProperty: function (name, o) {
            o = o || this;
            function classHas(name, o) {
                if (Object.hasOwnProperty.call(o.prototype, name))
                    return true;
                var s = o.prototype.__super;
                return s == null ? null : classHas(name, s);
            }
            return (Object.hasOwnProperty.call(o, name)) || classHas(name, o.__class);
        },
        __typeof: function (o, value) {
            if (!o || !value)
                return false;
            if (value === String)
                return (typeof o === 'string');
            if (value === Number)
                return (typeof o === 'number');
            if (value.__interface__)
                value = value.__interface__;
            else if (typeof value != 'string')
                return (o instanceof value);
            return (o.__imps && o.__imps[value]) || (o.__class == value);
        },
        __as: function (value, type) {
            return (this.__typeof(value, type)) ? value : null;
        },
        __int: function (value) {
            return value ? parseInt(value) : 0;
        },
        interface: function (name, _super) {
            Laya.__package(name, {});
            var ins = Laya.__internals;
            var a = ins[name] = ins[name] || { self: name };
            if (_super) {
                var supers = _super.split(',');
                a.extend = [];
                for (var i = 0; i < supers.length; i++) {
                    var nm = supers[i];
                    ins[nm] = ins[nm] || { self: nm };
                    a.extend.push(ins[nm]);
                }
            }
            var o = window, words = name.split('.');
            for (var i = 0; i < words.length - 1; i++)
                o = o[words[i]];
            o[words[words.length - 1]] = { __interface__: name };
        },
        class: function (o, fullName, _super, miniName) {
            _super && Laya.__extend(o, _super);
            if (fullName) {
                Laya.__package(fullName, o);
                Laya.__classmap[fullName] = o;
                if (fullName.indexOf('.') > 0) {
                    if (fullName.indexOf('laya.') == 0) {
                        var paths = fullName.split('.');
                        miniName = miniName || paths[paths.length - 1];
                        if (Laya[miniName])
                            console_log("Warning!,this class[" + miniName + "] already exist:", Laya[miniName]);
                        Laya[miniName] = o;
                    }
                }
                else {
                    if (fullName == "Main")
                        window.Main = o;
                    else {
                        if (Laya[fullName]) {
                            console_log("Error!,this class[" + fullName + "] already exist:", Laya[fullName]);
                        }
                        Laya[fullName] = o;
                    }
                }
            }
            var un = Laya.un, p = o.prototype;
            un(p, 'hasOwnProperty', Laya.__hasOwnProperty);
            un(p, '__class', o);
            un(p, '__super', _super);
            un(p, '__className', fullName);
            un(o, '__super', _super);
            un(o, '__className', fullName);
            un(o, '__isclass', true);
            un(o, 'super', function (o) { this.__super.call(o); });
        },
        imps: function (dec, src) {
            if (!src)
                return null;
            var d = dec.__imps || Laya.un(dec, '__imps', {});
            function __(name) {
                var c, exs;
                if (!(c = Laya.__internals[name]))
                    return;
                d[name] = true;
                if (!(exs = c.extend))
                    return;
                for (var i = 0; i < exs.length; i++) {
                    __(exs[i].self);
                }
            }
            for (var i in src)
                __(i);
        },
        superSet: function (clas, o, prop, value) {
            var fun = clas.prototype["_$set_" + prop];
            fun && fun.call(o, value);
        },
        superGet: function (clas, o, prop) {
            var fun = clas.prototype["_$get_" + prop];
            return fun ? fun.call(o) : null;
        },
        getset: function (isStatic, o, name, getfn, setfn) {
            if (!isStatic) {
                getfn && Laya.un(o, '_$get_' + name, getfn);
                setfn && Laya.un(o, '_$set_' + name, setfn);
            }
            else {
                getfn && (o['_$GET_' + name] = getfn);
                setfn && (o['_$SET_' + name] = setfn);
            }
            if (getfn && setfn)
                Object.defineProperty(o, name, { get: getfn, set: setfn, enumerable: false, configurable: true });
            else {
                getfn && Object.defineProperty(o, name, { get: getfn, enumerable: false, configurable: true });
                setfn && Object.defineProperty(o, name, { set: setfn, enumerable: false, configurable: true });
            }
        },
        static: function (_class, def) {
            for (var i = 0, sz = def.length; i < sz; i += 2) {
                if (def[i] == 'length')
                    _class.length = def[i + 1].call(_class);
                else {
                    function tmp() {
                        var name = def[i];
                        var getfn = def[i + 1];
                        Object.defineProperty(_class, name, {
                            get: function () { delete this[name]; return this[name] = getfn.call(this); },
                            set: function (v) { delete this[name]; this[name] = v; }, enumerable: true, configurable: true
                        });
                    }
                    tmp();
                }
            }
        },
        un: function (obj, name, value) {
            value || (value = obj[name]);
            Laya.__propun.value = value;
            Object.defineProperty(obj, name, Laya.__propun);
            return value;
        },
        uns: function (obj, names) {
            names.forEach(function (o) { Laya.un(obj, o); });
        }
    };
    window.console = window.console || ({ log: function () { } });
    window.trace = window.console.log;
    Error.prototype.throwError = function () { throw arguments; };
    Object.defineProperty(Array.prototype, 'fixed', { enumerable: false });
    return Laya;
})(window, document);
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
})(window, document, Laya);
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    Laya.interface('laya.runtime.IMarket');
    Laya.interface('laya.filters.IFilter');
    Laya.interface('laya.display.ILayout');
    Laya.interface('laya.resource.IDispose');
    Laya.interface('laya.runtime.IPlatform');
    Laya.interface('laya.resource.IDestroy');
    Laya.interface('laya.runtime.IConchNode');
    Laya.interface('laya.filters.IFilterAction');
    Laya.interface('laya.runtime.ICPlatformClass');
    Laya.interface('laya.resource.ICreateResource');
    Laya.interface('laya.runtime.IConchRenderObject');
    Laya.interface('laya.runtime.IPlatformClass', 'laya.runtime.IPlatform');
    var RunDriver = (function () {
        function RunDriver() { }
        __class(RunDriver, 'laya.utils.RunDriver');
        RunDriver.FILTER_ACTIONS = [];
        RunDriver.pixelRatio = -1;
        RunDriver._charSizeTestDiv = null;
        RunDriver.now = function () {
            return Date.now();
        };
        RunDriver.getWindow = function () {
            return window;
        };
        RunDriver.getPixelRatio = function () {
            if (RunDriver.pixelRatio < 0) {
                var ctx = Browser.context;
                var backingStore = ctx.backingStorePixelRatio || ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
                RunDriver.pixelRatio = (Browser.window.devicePixelRatio || 1) / backingStore;
                if (RunDriver.pixelRatio < 1)
                    RunDriver.pixelRatio = 1;
            }
            return RunDriver.pixelRatio;
        };
        RunDriver.getIncludeStr = function (name) {
            return null;
        };
        RunDriver.createShaderCondition = function (conditionScript) {
            var fn = "(function() {return " + conditionScript + ";})";
            return Browser.window.eval(fn);
        };
        RunDriver.fontMap = [];
        RunDriver.measureText = function (txt, font) {
            var isChinese = RunDriver.hanzi.test(txt);
            if (isChinese && RunDriver.fontMap[font]) {
                return RunDriver.fontMap[font];
            }
            ;
            var ctx = Browser.context;
            ctx.font = font;
            var r = ctx.measureText(txt);
            if (isChinese)
                RunDriver.fontMap[font] = r;
            return r;
        };
        RunDriver.getWebGLContext = function (canvas) {
        };
        RunDriver.beginFlush = function () {
        };
        RunDriver.endFinish = function () {
        };
        RunDriver.addToAtlas = null;
        RunDriver.flashFlushImage = function (atlasWebGLCanvas) {
        };
        RunDriver.drawToCanvas = function (sprite, _renderType, canvasWidth, canvasHeight, offsetX, offsetY) {
            var canvas = HTMLCanvas.create("2D");
            var context = new RenderContext(canvasWidth, canvasHeight, canvas);
            RenderSprite.renders[_renderType]._fun(sprite, context, offsetX, offsetY);
            return canvas;
        };
        RunDriver.createParticleTemplate2D = null;
        RunDriver.createGLTextur = null;
        RunDriver.createWebGLContext2D = null;
        RunDriver.changeWebGLSize = function (w, h) {
        };
        RunDriver.createRenderSprite = function (type, next) {
            return new RenderSprite(type, next);
        };
        RunDriver.createFilterAction = function (type) {
            return new ColorFilterAction();
        };
        RunDriver.createGraphics = function () {
            return new Graphics();
        };
        RunDriver.clear = function (value) {
            Render._context.ctx.clear();
        };
        RunDriver.cancelLoadByUrl = function (url) {
        };
        RunDriver.clearAtlas = function (value) {
        };
        RunDriver.isAtlas = function (bitmap) {
            return false;
        };
        RunDriver.addTextureToAtlas = function (value) {
        };
        RunDriver.getTexturePixels = function (value, x, y, width, height) {
            return null;
        };
        RunDriver.skinAniSprite = function () {
            return null;
        };
        RunDriver.update3DLoop = function () {
        };
        __static(RunDriver, ['hanzi', function () { return this.hanzi = new RegExp("^[\u4E00-\u9FA5]$"); }
        ]);
        return RunDriver;
    })();
    var ___The3 = (function () {
        __getset(1, Laya, 'alertGlobalError', null, function (value) {
            var erralert = 0;
            if (value) {
                Browser.window.onerror = function (msg, url, line, column, detail) {
                    if (erralert++ < 5 && detail)
                        alert("出错啦，请把此信息截图给研发商\n" + msg + "\n" + detail.stack || detail);
                };
            }
            else {
                Browser.window.onerror = null;
            }
        });
        Laya.init = function (width, height, __plugins) {
            var plugins = [];
            for (var i = 2, sz = arguments.length; i < sz; i++)
                plugins.push(arguments[i]);
            if (Laya._isinit)
                return;
            ArrayBuffer.prototype.slice || (ArrayBuffer.prototype.slice = Laya._arrayBufferSlice);
            Laya._isinit = true;
            Browser.__init__();
            Context.__init__();
            Graphics.__init__();
            Laya.timer = new Timer();
            Laya.scaleTimer = new Timer();
            Laya.loader = new LoaderManager();
            WeakObject.__init__();
            for (var i = 0, n = plugins.length; i < n; i++) {
                if (plugins[i].enable)
                    plugins[i].enable();
            }
            Font.__init__();
            Style.__init__();
            ResourceManager.__init__();
            CacheManager.beginCheck();
            Laya._currentStage = Laya.stage = new Stage();
            Laya.stage.conchModel && Laya.stage.conchModel.setRootNode();
            Laya.getUrlPath();
            Laya.render = new Render(0, 0);
            Laya.stage.size(width, height);
            RenderSprite.__init__();
            KeyBoardManager.__init__();
            MouseManager.instance.__init__(Laya.stage, Render.canvas);
            Input.__init__();
            SoundManager.autoStopMusic = true;
            LocalStorage.__init__();
            return Render.canvas;
        };
        Laya.getUrlPath = function () {
            var location = Browser.window.location;
            var pathName = location.pathname;
            pathName = pathName.charAt(2) == ':' ? pathName.substring(1) : pathName;
            URL.rootPath = URL.basePath = URL.getPath(location.protocol == "file:" ? pathName : location.protocol + "//" + location.host + location.pathname);
        };
        Laya._arrayBufferSlice = function (start, end) {
            var arr = this;
            var arrU8List = new Uint8Array(arr, start, end - start);
            var newU8List = new Uint8Array(arrU8List.length);
            newU8List.set(arrU8List);
            return newU8List.buffer;
        };
        Laya.stage = null;
        Laya.timer = null;
        Laya.scaleTimer = null;
        Laya.loader = null;
        Laya.version = "1.7.17beta";
        Laya.render = null;
        Laya._currentStage = null;
        Laya._isinit = false;
        Laya.MiniAdpter = {
            init: function () {
                if (window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf("MiniGame") > -1)
                    console_error("请先引用小游戏适配库laya.wxmini.js,详细教程：https://ldc.the3box.com/doc/?nav=zh-ts-5-0-0");
            }
        };
        __static(Laya, ['conchMarket', function () { return this.conchMarket = window.conch ? conchMarket : null; }, 'PlatformClass', function () { return this.PlatformClass = window.PlatformClass; }
        ]);
        return Laya;
    })();
    var Config = (function () {
        function Config() { }
        __class(Config, 'Config');
        Config.WebGLTextCacheCount = 500;
        Config.atlasEnable = false;
        Config.showCanvasMark = false;
        Config.animationInterval = 50;
        Config.isAntialias = false;
        Config.isAlpha = false;
        Config.premultipliedAlpha = true;
        Config.isStencil = true;
        Config.preserveDrawingBuffer = false;
        return Config;
    })();
    var EventDispatcher = (function () {
        var EventHandler;
        function EventDispatcher() {
            this._events = null;
        }
        __class(EventDispatcher, 'laya.events.EventDispatcher');
        var __proto = EventDispatcher.prototype;
        __proto.hasListener = function (type) {
            var listener = this._events && this._events[type];
            var allnone = true;
            for (var i in listener) {
                if (listener[i]) {
                    allnone = false;
                    break;
                }
            }
            if (allnone)
                return false;
            return !!listener;
        };
        __proto.event = function (type, data) {
            if (!this._events || !this._events[type])
                return false;
            var listeners = this._events[type];
            if (listeners.run) {
                if (listeners.once)
                    delete this._events[type];
                data != null ? listeners.runWith(data) : listeners.run();
            }
            else {
                for (var i = 0, n = listeners.length; i < n; i++) {
                    var listener = listeners[i];
                    if (listener) {
                        (data != null) ? listener.runWith(data) : listener.run();
                    }
                    if (!listener || listener.once) {
                        listeners.splice(i, 1);
                        i--;
                        n--;
                    }
                }
                if (listeners.length === 0 && this._events)
                    delete this._events[type];
            }
            return true;
        };
        __proto.on = function (type, caller, listener, args) {
            return this._createListener(type, caller, listener, args, false);
        };
        __proto.once = function (type, caller, listener, args) {
            return this._createListener(type, caller, listener, args, true);
        };
        __proto._createListener = function (type, caller, listener, args, once, offBefore) {
            (offBefore === void 0) && (offBefore = true);
            offBefore && this.off(type, caller, listener, once);
            var handler = EventHandler.create(caller || this, listener, args, once);
            this._events || (this._events = {});
            var events = this._events;
            if (!events[type])
                events[type] = handler;
            else {
                if (!events[type].run)
                    events[type].push(handler);
                else
                    events[type] = [events[type], handler];
            }
            return this;
        };
        __proto.off = function (type, caller, listener, onceOnly) {
            (onceOnly === void 0) && (onceOnly = false);
            if (!this._events || !this._events[type])
                return this;
            var listeners = this._events[type];
            if (listener != null) {
                if (listeners.run) {
                    if ((!caller || listeners.caller === caller) && listeners.method === listener && (!onceOnly || listeners.once)) {
                        delete this._events[type];
                        listeners.recover();
                    }
                }
                else {
                    var count = 0;
                    for (var i = 0, n = listeners.length; i < n; i++) {
                        var item = listeners[i];
                        if (item && (!caller || item.caller === caller) && item.method === listener && (!onceOnly || item.once)) {
                            count++;
                            listeners[i] = null;
                            item.recover();
                        }
                    }
                    if (count === n)
                        delete this._events[type];
                }
            }
            return this;
        };
        __proto.offAll = function (type) {
            var events = this._events;
            if (!events)
                return this;
            if (type) {
                this._recoverHandlers(events[type]);
                delete events[type];
            }
            else {
                for (var name in events) {
                    this._recoverHandlers(events[name]);
                }
                this._events = null;
            }
            return this;
        };
        __proto._recoverHandlers = function (arr) {
            if (!arr)
                return;
            if (arr.run) {
                arr.recover();
            }
            else {
                for (var i = arr.length - 1; i > -1; i--) {
                    if (arr[i]) {
                        arr[i].recover();
                        arr[i] = null;
                    }
                }
            }
        };
        __proto.isMouseEvent = function (type) {
            return EventDispatcher.MOUSE_EVENTS[type];
        };
        EventDispatcher.MOUSE_EVENTS = { "rightmousedown": true, "rightmouseup": true, "rightclick": true, "mousedown": true, "mouseup": true, "mousemove": true, "mouseover": true, "mouseout": true, "click": true, "doubleclick": true };
        EventDispatcher.__init$ = function () {
            Object.defineProperty(laya.events.EventDispatcher.prototype, "_events", { enumerable: false, writable: true });
            EventHandler = (function (_super) {
                function EventHandler(caller, method, args, once) {
                    EventHandler.__super.call(this, caller, method, args, once);
                }
                __class(EventHandler, '', _super);
                var __proto = EventHandler.prototype;
                __proto.recover = function () {
                    if (this._id > 0) {
                        this._id = 0;
                        EventHandler._pool.push(this.clear());
                    }
                };
                EventHandler.create = function (caller, method, args, once) {
                    (once === void 0) && (once = true);
                    if (EventHandler._pool.length)
                        return EventHandler._pool.pop().setTo(caller, method, args, once);
                    return new EventHandler(caller, method, args, once);
                };
                EventHandler._pool = [];
                return EventHandler;
            })(Handler);
        };
        return EventDispatcher;
    })();
    var Handler = (function () {
        function Handler(caller, method, args, once) {
            this.once = false;
            this._id = 0;
            (once === void 0) && (once = false);
            this.setTo(caller, method, args, once);
        }
        __class(Handler, 'laya.utils.Handler');
        var __proto = Handler.prototype;
        __proto.setTo = function (caller, method, args, once) {
            this._id = Handler._gid++;
            this.caller = caller;
            this.method = method;
            this.args = args;
            this.once = once;
            return this;
        };
        __proto.run = function () {
            if (this.method == null)
                return null;
            var id = this._id;
            var result = this.method.apply(this.caller, this.args);
            this._id === id && this.once && this.recover();
            return result;
        };
        __proto.runWith = function (data) {
            if (this.method == null)
                return null;
            var id = this._id;
            if (data == null)
                var result = this.method.apply(this.caller, this.args);
            else if (!this.args && !data.unshift)
                result = this.method.call(this.caller, data);
            else if (this.args)
                result = this.method.apply(this.caller, this.args.concat(data));
            else
                result = this.method.apply(this.caller, data);
            this._id === id && this.once && this.recover();
            return result;
        };
        __proto.clear = function () {
            this.caller = null;
            this.method = null;
            this.args = null;
            return this;
        };
        __proto.recover = function () {
            if (this._id > 0) {
                this._id = 0;
                Handler._pool.push(this.clear());
            }
        };
        Handler.create = function (caller, method, args, once) {
            (once === void 0) && (once = true);
            if (Handler._pool.length)
                return Handler._pool.pop().setTo(caller, method, args, once);
            return new Handler(caller, method, args, once);
        };
        Handler._pool = [];
        Handler._gid = 1;
        return Handler;
    })();
    var BitmapFont = (function () {
        function BitmapFont() {
            this._texture = null;
            this._fontCharDic = {};
            this._fontWidthMap = {};
            this._complete = null;
            this._path = null;
            this._maxWidth = 0;
            this._spaceWidth = 10;
            this._padding = null;
            this.fontSize = 12;
            this.autoScaleSize = false;
            this.letterSpacing = 0;
        }
        __class(BitmapFont, 'laya.display.BitmapFont');
        var __proto = BitmapFont.prototype;
        __proto.loadFont = function (path, complete) {
            this._path = path;
            this._complete = complete;
            Laya.loader.load([{ url: this._path, type: "xml" }, { url: this._path.replace(".fnt", ".png"), type: "image" }], Handler.create(this, this.onLoaded));
        };
        __proto.onLoaded = function () {
            this.parseFont(Loader.getRes(this._path), Loader.getRes(this._path.replace(".fnt", ".png")));
            this._complete && this._complete.runWith(this._texture ? this : null);
        };
        __proto.parseFont = function (xml, texture) {
            if (xml == null || texture == null)
                return;
            this._texture = texture;
            var tX = 0;
            var tScale = 1;
            var tInfo = xml.getElementsByTagName("info");
            if (!tInfo[0].getAttributeNode) {
                return this.parseFont2(xml, texture);
            }
            this.fontSize = parseInt(tInfo[0].getAttributeNode("size").nodeValue);
            var tPadding = tInfo[0].getAttributeNode("padding").nodeValue;
            var tPaddingArray = tPadding.split(",");
            this._padding = [parseInt(tPaddingArray[0]), parseInt(tPaddingArray[1]), parseInt(tPaddingArray[2]), parseInt(tPaddingArray[3])];
            var chars;
            chars = xml.getElementsByTagName("char");
            var i = 0;
            for (i = 0; i < chars.length; i++) {
                var tAttribute = chars[i];
                var tId = parseInt(tAttribute.getAttributeNode("id").nodeValue);
                var xOffset = parseInt(tAttribute.getAttributeNode("xoffset").nodeValue) / tScale;
                var yOffset = parseInt(tAttribute.getAttributeNode("yoffset").nodeValue) / tScale;
                var xAdvance = parseInt(tAttribute.getAttributeNode("xadvance").nodeValue) / tScale;
                var region = new Rectangle();
                region.x = parseInt(tAttribute.getAttributeNode("x").nodeValue);
                region.y = parseInt(tAttribute.getAttributeNode("y").nodeValue);
                region.width = parseInt(tAttribute.getAttributeNode("width").nodeValue);
                region.height = parseInt(tAttribute.getAttributeNode("height").nodeValue);
                var tTexture = Texture.create(texture, region.x, region.y, region.width, region.height, xOffset, yOffset);
                this._maxWidth = Math.max(this._maxWidth, xAdvance + this.letterSpacing);
                this._fontCharDic[tId] = tTexture;
                this._fontWidthMap[tId] = xAdvance;
            }
        };
        __proto.parseFont2 = function (xml, texture) {
            if (xml == null || texture == null)
                return;
            this._texture = texture;
            var tX = 0;
            var tScale = 1;
            var tInfo = xml.getElementsByTagName("info");
            this.fontSize = parseInt(tInfo[0].attributes["size"].nodeValue);
            var tPadding = tInfo[0].attributes["padding"].nodeValue;
            var tPaddingArray = tPadding.split(",");
            this._padding = [parseInt(tPaddingArray[0]), parseInt(tPaddingArray[1]), parseInt(tPaddingArray[2]), parseInt(tPaddingArray[3])];
            var chars = xml.getElementsByTagName("char");
            var i = 0;
            for (i = 0; i < chars.length; i++) {
                var tAttribute = chars[i].attributes;
                var tId = parseInt(tAttribute["id"].nodeValue);
                var xOffset = parseInt(tAttribute["xoffset"].nodeValue) / tScale;
                var yOffset = parseInt(tAttribute["yoffset"].nodeValue) / tScale;
                var xAdvance = parseInt(tAttribute["xadvance"].nodeValue) / tScale;
                var region = new Rectangle();
                region.x = parseInt(tAttribute["x"].nodeValue);
                region.y = parseInt(tAttribute["y"].nodeValue);
                region.width = parseInt(tAttribute["width"].nodeValue);
                region.height = parseInt(tAttribute["height"].nodeValue);
                var tTexture = Texture.create(texture, region.x, region.y, region.width, region.height, xOffset, yOffset);
                this._maxWidth = Math.max(this._maxWidth, xAdvance + this.letterSpacing);
                this._fontCharDic[tId] = tTexture;
                this._fontWidthMap[tId] = xAdvance;
            }
        };
        __proto.getCharTexture = function (char) {
            return this._fontCharDic[char.charCodeAt(0)];
        };
        __proto.destroy = function () {
            if (this._texture) {
                for (var p in this._fontCharDic) {
                    var tTexture = this._fontCharDic[p];
                    if (tTexture)
                        tTexture.destroy();
                }
                this._texture.destroy();
                this._fontCharDic = null;
                this._fontWidthMap = null;
                this._texture = null;
            }
        };
        __proto.setSpaceWidth = function (spaceWidth) {
            this._spaceWidth = spaceWidth;
        };
        __proto.getCharWidth = function (char) {
            var code = char.charCodeAt(0);
            if (this._fontWidthMap[code])
                return this._fontWidthMap[code] + this.letterSpacing;
            if (char == " ")
                return this._spaceWidth + this.letterSpacing;
            return 0;
        };
        __proto.getTextWidth = function (text) {
            var tWidth = 0;
            for (var i = 0, n = text.length; i < n; i++) {
                tWidth += this.getCharWidth(text.charAt(i));
            }
            return tWidth;
        };
        __proto.getMaxWidth = function () {
            return this._maxWidth;
        };
        __proto.getMaxHeight = function () {
            return this.fontSize;
        };
        __proto.drawText = function (text, sprite, drawX, drawY, align, width) {
            var tWidth = this.getTextWidth(text);
            var tTexture;
            var dx = 0;
            align === "center" && (dx = (width - tWidth) / 2);
            align === "right" && (dx = (width - tWidth));
            var tX = 0;
            for (var i = 0, n = text.length; i < n; i++) {
                tTexture = this.getCharTexture(text.charAt(i));
                if (tTexture) {
                    sprite.graphics.drawTexture(tTexture, drawX + tX + dx + this.letterSpacing, drawY);
                    tX += this.getCharWidth(text.charAt(i));
                }
            }
        };
        return BitmapFont;
    })();
    var Style = (function () {
        function Style() {
            this.alpha = 1;
            this.visible = true;
            this.scrollRect = null;
            this.blendMode = null;
            this._type = 0;
            this._tf = Style._TF_EMPTY;
        }
        __class(Style, 'laya.display.css.Style');
        var __proto = Style.prototype;
        __proto.getTransform = function () {
            return this._tf;
        };
        __proto.setTransform = function (value) {
            this._tf = value === 'none' || !value ? Style._TF_EMPTY : value;
        };
        __proto.setTranslateX = function (value) {
            this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
            this._tf.translateX = value;
        };
        __proto.setTranslateY = function (value) {
            this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
            this._tf.translateY = value;
        };
        __proto.setScaleX = function (value) {
            this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
            this._tf.scaleX = value;
        };
        __proto.setScale = function (x, y) {
            this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
            this._tf.scaleX = x;
            this._tf.scaleY = y;
        };
        __proto.setScaleY = function (value) {
            this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
            this._tf.scaleY = value;
        };
        __proto.setRotate = function (value) {
            this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
            this._tf.rotate = value;
        };
        __proto.setSkewX = function (value) {
            this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
            this._tf.skewX = value;
        };
        __proto.setSkewY = function (value) {
            this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
            this._tf.skewY = value;
        };
        __proto.destroy = function () {
            this.scrollRect = null;
        };
        __proto.render = function (sprite, context, x, y) { };
        __proto.getCSSStyle = function () {
            return CSSStyle.EMPTY;
        };
        __proto._enableLayout = function () {
            return false;
        };
        __getset(0, __proto, 'scaleX', function () {
            return this._tf.scaleX;
        }, function (value) {
            this.setScaleX(value);
        });
        __getset(0, __proto, 'transform', function () {
            return this.getTransform();
        }, function (value) {
            this.setTransform(value);
        });
        __getset(0, __proto, 'translateX', function () {
            return this._tf.translateX;
        }, function (value) {
            this.setTranslateX(value);
        });
        __getset(0, __proto, 'translateY', function () {
            return this._tf.translateY;
        }, function (value) {
            this.setTranslateY(value);
        });
        __getset(0, __proto, 'scaleY', function () {
            return this._tf.scaleY;
        }, function (value) {
            this.setScaleY(value);
        });
        __getset(0, __proto, 'block', function () {
            return (this._type & 0x1) != 0;
        });
        __getset(0, __proto, 'skewY', function () {
            return this._tf.skewY;
        }, function (value) {
            this.setSkewY(value);
        });
        __getset(0, __proto, 'rotate', function () {
            return this._tf.rotate;
        }, function (value) {
            this.setRotate(value);
        });
        __getset(0, __proto, 'skewX', function () {
            return this._tf.skewX;
        }, function (value) {
            this.setSkewX(value);
        });
        __getset(0, __proto, 'paddingLeft', function () {
            return 0;
        });
        __getset(0, __proto, 'paddingTop', function () {
            return 0;
        });
        __getset(0, __proto, 'absolute', function () {
            return true;
        });
        Style.__init__ = function () {
            Style._TF_EMPTY = new TransformInfo();
            Style.EMPTY = new Style();
        };
        Style.EMPTY = null;
        Style._TF_EMPTY = null;
        return Style;
    })();
    var Font = (function () {
        function Font(src) {
            this._type = 0;
            this._weight = 0;
            this._decoration = null;
            this._text = null;
            this.indent = 0;
            this._color = Color.create(Font.defaultColor);
            this.family = Font.defaultFamily;
            this.stroke = Font._STROKE;
            this.size = Font.defaultSize;
            src && src !== Font.EMPTY && src.copyTo(this);
        }
        __class(Font, 'laya.display.css.Font');
        var __proto = Font.prototype;
        __proto.set = function (value) {
            this._text = null;
            var strs = value.split(' ');
            for (var i = 0, n = strs.length; i < n; i++) {
                var str = strs[i];
                switch (str) {
                    case 'italic':
                        this.italic = true;
                        continue;
                    case 'bold':
                        this.bold = true;
                        continue;
                }
                if (str.indexOf('px') > 0) {
                    this.size = parseInt(str);
                    this.family = strs[i + 1];
                    i++;
                    continue;
                }
            }
        };
        __proto.toString = function () {
            this._text = "";
            this.italic && (this._text += "italic ");
            this.bold && (this._text += "bold ");
            return this._text += this.size + "px " + this.family;
        };
        __proto.copyTo = function (dec) {
            dec._type = this._type;
            dec._text = this._text;
            dec._weight = this._weight;
            dec._color = this._color;
            dec.family = this.family;
            dec.stroke = this.stroke != Font._STROKE ? this.stroke.slice() : Font._STROKE;
            dec.indent = this.indent;
            dec.size = this.size;
        };
        __getset(0, __proto, 'password', function () {
            return (this._type & 0x400) !== 0;
        }, function (value) {
            value ? (this._type |= 0x400) : (this._type &= ~0x400);
        });
        __getset(0, __proto, 'color', function () {
            return this._color.strColor;
        }, function (value) {
            this._color = Color.create(value);
        });
        __getset(0, __proto, 'italic', function () {
            return (this._type & 0x200) !== 0;
        }, function (value) {
            value ? (this._type |= 0x200) : (this._type &= ~0x200);
        });
        __getset(0, __proto, 'bold', function () {
            return (this._type & 0x800) !== 0;
        }, function (value) {
            value ? (this._type |= 0x800) : (this._type &= ~0x800);
        });
        __getset(0, __proto, 'weight', function () {
            return "" + this._weight;
        }, function (value) {
            var weight = 0;
            switch (value) {
                case 'normal':
                    break;
                case 'bold':
                    this.bold = true;
                    weight = 700;
                    break;
                case 'bolder':
                    weight = 800;
                    break;
                case 'lighter':
                    weight = 100;
                    break;
                default:
                    weight = parseInt(value);
            }
            this._weight = weight;
            this._text = null;
        });
        __getset(0, __proto, 'decoration', function () {
            return this._decoration ? this._decoration.value : "none";
        }, function (value) {
            var strs = value.split(' ');
            this._decoration || (this._decoration = {});
            switch (strs[0]) {
                case '_':
                    this._decoration.type = 'underline';
                    break;
                case '-':
                    this._decoration.type = 'line-through';
                    break;
                case 'overline':
                    this._decoration.type = 'overline';
                    break;
                default:
                    this._decoration.type = strs[0];
            }
            strs[1] && (this._decoration.color = Color.create(strs));
            this._decoration.value = value;
        });
        Font.__init__ = function () {
            Font.EMPTY = new Font(null);
        };
        Font.EMPTY = null;
        Font.defaultColor = "#000000";
        Font.defaultSize = 12;
        Font.defaultFamily = "Arial";
        Font.defaultFont = "12px Arial";
        Font._STROKE = [0, "#000000"];
        Font._ITALIC = 0x200;
        Font._PASSWORD = 0x400;
        Font._BOLD = 0x800;
        return Font;
    })();
    var TransformInfo = (function () {
        function TransformInfo() {
            this.translateX = 0;
            this.translateY = 0;
            this.scaleX = 1;
            this.scaleY = 1;
            this.rotate = 0;
            this.skewX = 0;
            this.skewY = 0;
        }
        __class(TransformInfo, 'laya.display.css.TransformInfo');
        return TransformInfo;
    })();
    var Graphics = (function () {
        function Graphics() {
            this._one = null;
            this._cmds = null;
            this._render = this._renderEmpty;
            if (Render.isConchNode) {
                var _this_ = this;
                _this_._nativeObj = new (window)._conchGraphics();
                _this_.id = _this_._nativeObj.conchID;
            }
        }
        __class(Graphics, 'laya.display.Graphics');
        var __proto = Graphics.prototype;
        __proto.destroy = function () {
            this.clear();
            if (this._graphicBounds)
                this._graphicBounds.destroy();
            this._graphicBounds = null;
            this._vectorgraphArray = null;
            this._sp && (this._sp._renderType = 0);
            this._sp = null;
        };
        __proto.clear = function (recoverCmds) {
            (recoverCmds === void 0) && (recoverCmds = false);
            var i = 0, len = 0;
            if (recoverCmds) {
                var tCmd = this._one;
                if (this._cmds) {
                    len = this._cmds.length;
                    for (i = 0; i < len; i++) {
                        tCmd = this._cmds[i];
                        if (tCmd && (tCmd.callee === Render._context._drawTexture || tCmd.callee === Render._context._drawTextureWithTransform)) {
                            tCmd[0] = null;
                            Graphics._cache.push(tCmd);
                        }
                    }
                    this._cmds.length = 0;
                }
                else if (tCmd) {
                    if (tCmd && (tCmd.callee === Render._context._drawTexture || tCmd.callee === Render._context._drawTextureWithTransform)) {
                        tCmd[0] = null;
                        Graphics._cache.push(tCmd);
                    }
                }
            }
            else {
                this._cmds = null;
            }
            this._one = null;
            this._render = this._renderEmpty;
            this._sp && (this._sp._renderType &= ~0x01 & ~0x200);
            this._repaint();
            if (this._vectorgraphArray) {
                for (i = 0, len = this._vectorgraphArray.length; i < len; i++) {
                    VectorGraphManager.getInstance().deleteShape(this._vectorgraphArray[i]);
                }
                this._vectorgraphArray.length = 0;
            }
        };
        __proto._clearBoundsCache = function () {
            if (this._graphicBounds)
                this._graphicBounds.reset();
        };
        __proto._initGraphicBounds = function () {
            if (!this._graphicBounds) {
                this._graphicBounds = new GraphicsBounds();
                this._graphicBounds._graphics = this;
            }
        };
        __proto._repaint = function () {
            this._clearBoundsCache();
            this._sp && this._sp.repaint();
        };
        __proto._isOnlyOne = function () {
            return !this._cmds || this._cmds.length === 0;
        };
        __proto.getBounds = function (realSize) {
            (realSize === void 0) && (realSize = false);
            this._initGraphicBounds();
            return this._graphicBounds.getBounds(realSize);
        };
        __proto.getBoundPoints = function (realSize) {
            (realSize === void 0) && (realSize = false);
            this._initGraphicBounds();
            return this._graphicBounds.getBoundPoints(realSize);
        };
        __proto._addCmd = function (a) {
            this._cmds = this._cmds || [];
            a.callee = a.shift();
            this._cmds.push(a);
        };
        __proto.setFilters = function (fs) {
            this._saveToCmd(Render._context._setFilters, fs);
        };
        __proto.drawTexture = function (tex, x, y, width, height, m, alpha) {
            (x === void 0) && (x = 0);
            (y === void 0) && (y = 0);
            (width === void 0) && (width = 0);
            (height === void 0) && (height = 0);
            (alpha === void 0) && (alpha = 1);
            if (!tex || alpha < 0.01)
                return null;
            if (!width)
                width = tex.sourceWidth;
            if (!height)
                height = tex.sourceHeight;
            alpha = alpha < 0 ? 0 : (alpha > 1 ? 1 : alpha);
            var offset = (!Render.isWebGL && (Browser.onFirefox || Browser.onEdge || Browser.onIE)) ? 0.5 : 0;
            var wRate = width / tex.sourceWidth;
            var hRate = height / tex.sourceHeight;
            width = tex.width * wRate;
            height = tex.height * hRate;
            if (tex.loaded && (width <= 0 || height <= 0))
                return null;
            x += tex.offsetX * wRate;
            y += tex.offsetY * hRate;
            this._sp && (this._sp._renderType |= 0x200);
            var args;
            x -= offset;
            y -= offset;
            width += 2 * offset;
            height += 2 * offset;
            if (Graphics._cache.length) {
                args = Graphics._cache.pop();
                args[0] = tex;
                args[1] = x;
                args[2] = y;
                args[3] = width;
                args[4] = height;
                args[5] = m;
                args[6] = alpha;
            }
            else {
                args = [tex, x, y, width, height, m, alpha];
            }
            args.callee = (m || alpha != 1) ? Render._context._drawTextureWithTransform : Render._context._drawTexture;
            if (this._one == null && !m && alpha == 1) {
                this._one = args;
                this._render = this._renderOneImg;
            }
            else {
                this._saveToCmd(args.callee, args);
            }
            if (!tex.loaded) {
                tex.once("loaded", this, this._textureLoaded, [tex, args]);
            }
            this._repaint();
            return args;
        };
        __proto.cleanByTexture = function (tex, x, y, width, height) {
            (width === void 0) && (width = 0);
            (height === void 0) && (height = 0);
            if (!tex)
                return this.clear();
            if (this._one && this._render === this._renderOneImg) {
                if (!width)
                    width = tex.sourceWidth;
                if (!height)
                    height = tex.sourceHeight;
                var wRate = width / tex.sourceWidth;
                var hRate = height / tex.sourceHeight;
                width = tex.width * wRate;
                height = tex.height * hRate;
                x += tex.offsetX * wRate;
                y += tex.offsetY * hRate;
                this._one[0] = tex;
                this._one[1] = x;
                this._one[2] = y;
                this._one[3] = width;
                this._one[4] = height;
            }
            else {
                this.clear();
                tex && this.drawTexture(tex, x, y, width, height);
            }
        };
        __proto.drawTextures = function (tex, pos) {
            if (!tex)
                return;
            this._saveToCmd(Render._context._drawTextures, [tex, pos]);
        };
        __proto.fillTexture = function (tex, x, y, width, height, type, offset) {
            (width === void 0) && (width = 0);
            (height === void 0) && (height = 0);
            (type === void 0) && (type = "repeat");
            if (!tex)
                return;
            var args = [tex, x, y, width, height, type, offset || Point.EMPTY, {}];
            if (!tex.loaded) {
                tex.once("loaded", this, this._textureLoaded, [tex, args]);
            }
            this._saveToCmd(Render._context._fillTexture, args);
        };
        __proto._textureLoaded = function (tex, param) {
            param[3] = param[3] || tex.width;
            param[4] = param[4] || tex.height;
            this._repaint();
        };
        __proto.fillCircle = function (x, y, tex, cx, cy, radius, segNum) {
            tex.bitmap.enableMerageInAtlas = false;
            var verts = new Float32Array((segNum + 1) * 2);
            var uvs = new Float32Array((segNum + 1) * 2);
            var indices = new Uint16Array(segNum * 3);
            var dang = 2 * Math.PI / segNum;
            var cang = 0;
            verts[0] = cx;
            verts[1] = cy;
            uvs[0] = cx / tex.width;
            uvs[1] = cy / tex.height;
            var idx = 2;
            for (var i = 0; i < segNum; i++) {
                var px = radius * Math.cos(cang) + cx;
                var py = radius * Math.sin(cang) + cy;
                verts[idx] = px;
                verts[idx + 1] = py;
                uvs[idx] = px / tex.width;
                uvs[idx + 1] = py / tex.height;
                cang += dang;
                idx += 2;
            }
            idx = 0;
            for (i = 0; i < segNum; i++) {
                indices[idx++] = 0;
                indices[idx++] = i + 1;
                indices[idx++] = (i + 2 >= segNum + 1) ? 1 : (i + 2);
            }
            this.drawTriangles(tex, x, y, verts, uvs, indices);
        };
        __proto.drawTriangles = function (texture, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode) {
            (alpha === void 0) && (alpha = 1);
            this._saveToCmd(Render._context.drawTriangles, [texture, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode]);
        };
        __proto._saveToCmd = function (fun, args) {
            this._sp && (this._sp._renderType |= 0x200);
            if (this._one == null) {
                this._one = args;
                this._render = this._renderOne;
            }
            else {
                this._sp && (this._sp._renderType &= ~0x01);
                this._render = this._renderAll;
                (this._cmds || (this._cmds = [])).length === 0 && this._cmds.push(this._one);
                this._cmds.push(args);
            }
            args.callee = fun;
            this._repaint();
            return args;
        };
        __proto.clipRect = function (x, y, width, height) {
            this._saveToCmd(Render._context._clipRect, [x, y, width, height]);
        };
        __proto.fillText = function (text, x, y, font, color, textAlign, underLine) {
            (underLine === void 0) && (underLine = 0);
            this._saveToCmd(Render._context._fillText, [text, x, y, font || Font.defaultFont, color, textAlign]);
        };
        __proto.fillBorderText = function (text, x, y, font, fillColor, borderColor, lineWidth, textAlign) {
            this._saveToCmd(Render._context._fillBorderText, [text, x, y, font || Font.defaultFont, fillColor, borderColor, lineWidth, textAlign]);
        };
        __proto.strokeText = function (text, x, y, font, color, lineWidth, textAlign) {
            this._saveToCmd(Render._context._strokeText, [text, x, y, font || Font.defaultFont, color, lineWidth, textAlign]);
        };
        __proto.alpha = function (value) {
            value = value < 0 ? 0 : (value > 1 ? 1 : value);
            this._saveToCmd(Render._context._alpha, [value]);
        };
        __proto.setAlpha = function (value) {
            value = value < 0 ? 0 : (value > 1 ? 1 : value);
            this._saveToCmd(Render._context._setAlpha, [value]);
        };
        __proto.transform = function (matrix, pivotX, pivotY) {
            (pivotX === void 0) && (pivotX = 0);
            (pivotY === void 0) && (pivotY = 0);
            this._saveToCmd(Render._context._transform, [matrix, pivotX, pivotY]);
        };
        __proto.rotate = function (angle, pivotX, pivotY) {
            (pivotX === void 0) && (pivotX = 0);
            (pivotY === void 0) && (pivotY = 0);
            this._saveToCmd(Render._context._rotate, [angle, pivotX, pivotY]);
        };
        __proto.scale = function (scaleX, scaleY, pivotX, pivotY) {
            (pivotX === void 0) && (pivotX = 0);
            (pivotY === void 0) && (pivotY = 0);
            this._saveToCmd(Render._context._scale, [scaleX, scaleY, pivotX, pivotY]);
        };
        __proto.translate = function (x, y) {
            this._saveToCmd(Render._context._translate, [x, y]);
        };
        __proto.save = function () {
            this._saveToCmd(Render._context._save, []);
        };
        __proto.restore = function () {
            this._saveToCmd(Render._context._restore, []);
        };
        __proto.replaceText = function (text) {
            this._repaint();
            var cmds = this._cmds;
            if (!cmds) {
                if (this._one && this._isTextCmd(this._one.callee)) {
                    if (this._one[0].toUpperCase)
                        this._one[0] = text;
                    else
                        this._one[0].setText(text);
                    return true;
                }
            }
            else {
                for (var i = cmds.length - 1; i > -1; i--) {
                    if (this._isTextCmd(cmds[i].callee)) {
                        if (cmds[i][0].toUpperCase)
                            cmds[i][0] = text;
                        else
                            cmds[i][0].setText(text);
                        return true;
                    }
                }
            }
            return false;
        };
        __proto._isTextCmd = function (fun) {
            return fun === Render._context._fillText || fun === Render._context._fillBorderText || fun === Render._context._strokeText;
        };
        __proto.replaceTextColor = function (color) {
            this._repaint();
            var cmds = this._cmds;
            if (!cmds) {
                if (this._one && this._isTextCmd(this._one.callee)) {
                    this._one[4] = color;
                    if (!this._one[0].toUpperCase)
                        this._one[0].changed = true;
                }
            }
            else {
                for (var i = cmds.length - 1; i > -1; i--) {
                    if (this._isTextCmd(cmds[i].callee)) {
                        cmds[i][4] = color;
                        if (!cmds[i][0].toUpperCase)
                            cmds[i][0].changed = true;
                    }
                }
            }
        };
        __proto.loadImage = function (url, x, y, width, height, complete) {
            var _$this = this;
            (x === void 0) && (x = 0);
            (y === void 0) && (y = 0);
            (width === void 0) && (width = 0);
            (height === void 0) && (height = 0);
            var tex = Loader.getRes(url);
            if (tex)
                onloaded(tex);
            else
                Laya.loader.load(url, Handler.create(null, onloaded), null, "image");
            function onloaded(tex) {
                if (tex) {
                    _$this.drawTexture(tex, x, y, width, height);
                    if (complete != null)
                        complete.call(_$this._sp, tex);
                }
            }
        };
        __proto._renderEmpty = function (sprite, context, x, y) { };
        __proto._renderAll = function (sprite, context, x, y) {
            var cmds = this._cmds, cmd;
            for (var i = 0, n = cmds.length; i < n; i++) {
                (cmd = cmds[i]).callee.call(context, x, y, cmd);
            }
        };
        __proto._renderOne = function (sprite, context, x, y) {
            this._one.callee.call(context, x, y, this._one);
        };
        __proto._renderOneImg = function (sprite, context, x, y) {
            this._one.callee.call(context, x, y, this._one);
            if (sprite._renderType !== 2305) {
                sprite._renderType |= 0x01;
            }
        };
        __proto.drawLine = function (fromX, fromY, toX, toY, lineColor, lineWidth) {
            (lineWidth === void 0) && (lineWidth = 1);
            var tId = 0;
            if (Render.isWebGL) {
                tId = VectorGraphManager.getInstance().getId();
                if (this._vectorgraphArray == null)
                    this._vectorgraphArray = [];
                this._vectorgraphArray.push(tId);
            }
            ;
            var offset = lineWidth % 2 === 0 ? 0 : 0.5;
            var arr = [fromX + offset, fromY + offset, toX + offset, toY + offset, lineColor, lineWidth, tId];
            // var arr = [fromX, fromY, toX, toY, lineColor, lineWidth, tId];
            this._saveToCmd(Render._context._drawLine, arr);
        };
        __proto.drawLines = function (x, y, points, lineColor, lineWidth) {
            (lineWidth === void 0) && (lineWidth = 1);
            var tId = 0;
            if (!points || points.length < 4)
                return;
            if (Render.isWebGL) {
                tId = VectorGraphManager.getInstance().getId();
                if (this._vectorgraphArray == null)
                    this._vectorgraphArray = [];
                this._vectorgraphArray.push(tId);
            }
            // var offset = lineWidth % 2 === 0 ? 0 : 0.5;
            // var __scaleX = this._sp ? this._sp.scaleX : 1;
            // var __scaleY = this._sp ? this._sp.scaleY : 1;
            // var arr = [x + (offset / __scaleX), y + (offset / __scaleY), points, lineColor, lineWidth, tId];
            var arr = [x, y, points, lineColor, lineWidth, tId];
            this._saveToCmd(Render._context._drawLines, arr);
        };
        __proto.drawCurves = function (x, y, points, lineColor, lineWidth) {
            (lineWidth === void 0) && (lineWidth = 1);
            var arr = [x, y, points, lineColor, lineWidth];
            this._saveToCmd(Render._context._drawCurves, arr);
        };
        __proto.drawRect = function (x, y, width, height, fillColor, lineColor, lineWidth) {
            (lineWidth === void 0) && (lineWidth = 1);
            var offset = lineColor ? lineWidth / 2 : 0;
            var lineOffset = lineColor ? lineWidth : 0;
            var arr = [x + offset, y + offset, width - lineOffset, height - lineOffset, fillColor, lineColor, lineWidth];
            this._saveToCmd(Render._context._drawRect, arr);
        };
        __proto.drawCircle = function (x, y, radius, fillColor, lineColor, lineWidth) {
            (lineWidth === void 0) && (lineWidth = 1);
            var offset = lineColor ? lineWidth / 2 : 0;
            var tId = 0;
            if (Render.isWebGL) {
                tId = VectorGraphManager.getInstance().getId();
                if (this._vectorgraphArray == null)
                    this._vectorgraphArray = [];
                this._vectorgraphArray.push(tId);
            }
            ;
            var arr = [x, y, radius - offset, fillColor, lineColor, lineWidth, tId];
            this._saveToCmd(Render._context._drawCircle, arr);
        };
        __proto.drawPie = function (x, y, radius, startAngle, endAngle, fillColor, lineColor, lineWidth) {
            (lineWidth === void 0) && (lineWidth = 1);
            var offset = lineColor ? lineWidth / 2 : 0;
            var lineOffset = lineColor ? lineWidth : 0;
            var tId = 0;
            if (Render.isWebGL) {
                tId = VectorGraphManager.getInstance().getId();
                if (this._vectorgraphArray == null)
                    this._vectorgraphArray = [];
                this._vectorgraphArray.push(tId);
            }
            ;
            var arr = [x + offset, y + offset, radius - lineOffset, startAngle, endAngle, fillColor, lineColor, lineWidth, tId];
            arr[3] = Utils.toRadian(startAngle);
            arr[4] = Utils.toRadian(endAngle);
            this._saveToCmd(Render._context._drawPie, arr);
        };
        __proto.drawPoly = function (x, y, points, fillColor, lineColor, lineWidth) {
            (lineWidth === void 0) && (lineWidth = 1);
            var tId = 0;
            var tIsConvexPolygon = false;
            if (Render.isWebGL) {
                tId = VectorGraphManager.getInstance().getId();
                if (this._vectorgraphArray == null)
                    this._vectorgraphArray = [];
                this._vectorgraphArray.push(tId);
                if (points.length > 6) {
                    tIsConvexPolygon = false;
                }
                else {
                    tIsConvexPolygon = true;
                }
            }
            ;
            var offset = lineColor ? (lineWidth % 2 === 0 ? 0 : 0.5) : 0;
            var arr = [x + offset, y + offset, points, fillColor, lineColor, lineWidth, tId, tIsConvexPolygon];
            this._saveToCmd(Render._context._drawPoly, arr);
        };
        __proto.drawPath = function (x, y, paths, brush, pen) {
            var arr = [x, y, paths, brush, pen];
            this._saveToCmd(Render._context._drawPath, arr);
        };
        __getset(0, __proto, 'cmds', function () {
            return this._cmds;
        }, function (value) {
            this._sp && (this._sp._renderType |= 0x200);
            this._cmds = value;
            this._render = this._renderAll;
            this._repaint();
        });
        Graphics.__init__ = function () {
            if (Render.isConchNode) {
                var from = laya.display.Graphics.prototype;
                var to = Browser.window.ConchGraphics.prototype;
                var list = ["clear", "destroy", "alpha", "rotate", "transform", "scale", "translate", "save", "restore", "clipRect", "blendMode", "fillText", "fillBorderText", "_fands", "drawRect", "drawCircle", "drawPie", "drawPoly", "drawPath", "drawImageM", "drawLine", "drawLines", "_drawPs", "drawCurves", "replaceText", "replaceTextColor", "_fillImage", "fillTexture", "setSkinMesh", "drawParticle", "drawImageS"];
                for (var i = 0, len = list.length; i <= len; i++) {
                    var temp = list[i];
                    from[temp] = to[temp];
                }
                from._saveToCmd = null;
                if (to.drawImageS) {
                    from.drawTextures = function (tex, pos) {
                        if (!tex)
                            return;
                        if (!(tex.loaded && tex.bitmap && tex.source)) {
                            return;
                        }
                        ;
                        var uv = tex.uv, w = tex.bitmap.width, h = tex.bitmap.height;
                        this.drawImageS(tex.bitmap.source, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h, tex.offsetX, tex.offsetY, tex.width, tex.height, pos);
                    };
                }
                from.drawTexture = function (tex, x, y, width, height, m, alpha) {
                    (x === void 0) && (x = 0);
                    (y === void 0) && (y = 0);
                    (width === void 0) && (width = 0);
                    (height === void 0) && (height = 0);
                    (alpha === void 0) && (alpha = 1);
                    if (!tex)
                        return;
                    if (!tex.loaded) {
                        tex.once("loaded", this, function () {
                            this.drawTexture(tex, x, y, width, height, m);
                        });
                        return;
                    }
                    if (!(tex.loaded && tex.bitmap && tex.source)) {
                        return;
                    }
                    if (!width)
                        width = tex.sourceWidth;
                    if (!height)
                        height = tex.sourceHeight;
                    alpha = alpha < 0 ? 0 : (alpha > 1 ? 1 : alpha);
                    width = width - tex.sourceWidth + tex.width;
                    height = height - tex.sourceHeight + tex.height;
                    if (width <= 0 || height <= 0)
                        return;
                    x += tex.offsetX;
                    y += tex.offsetY;
                    var uv = tex.uv, w = tex.bitmap.width, h = tex.bitmap.height;
                    this.drawImageM(tex.bitmap.source, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h, x, y, width, height, m, alpha);
                    this._repaint();
                };
                from.fillTexture = function (tex, x, y, width, height, type, offset) {
                    (width === void 0) && (width = 0);
                    (height === void 0) && (height = 0);
                    (type === void 0) && (type = "repeat");
                    if (!tex)
                        return;
                    if (tex.loaded) {
                        var ctxi = Render._context.ctx;
                        var w = tex.bitmap.width, h = tex.bitmap.height, uv = tex.uv;
                        var pat;
                        if (tex.uv != Texture.DEF_UV) {
                            pat = ctxi.createPattern(tex.bitmap.source, type, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h);
                        }
                        else {
                            pat = ctxi.createPattern(tex.bitmap.source, type);
                        }
                        ;
                        var sX = 0, sY = 0;
                        if (offset) {
                            x += offset.x % tex.width;
                            y += offset.y % tex.height;
                            sX -= offset.x % tex.width;
                            sY -= offset.y % tex.height;
                        }
                        this._fillImage(pat, x, y, sX, sY, width, height);
                    }
                };
            }
        };
        Graphics._cache = [];
        return Graphics;
    })();
    var GraphicsBounds = (function () {
        function GraphicsBounds() {
            this._cacheBoundsType = false;
        }
        __class(GraphicsBounds, 'laya.display.GraphicsBounds');
        var __proto = GraphicsBounds.prototype;
        __proto.destroy = function () {
            this._graphics = null;
            this._temp = null;
            this._rstBoundPoints = null;
            this._bounds = null;
        };
        __proto.reset = function () {
            this._temp && (this._temp.length = 0);
        };
        __proto.getBounds = function (realSize) {
            (realSize === void 0) && (realSize = false);
            if (!this._bounds || !this._temp || this._temp.length < 1 || realSize != this._cacheBoundsType) {
                this._bounds = Rectangle._getWrapRec(this.getBoundPoints(realSize), this._bounds);
            }
            this._cacheBoundsType = realSize;
            return this._bounds;
        };
        __proto.getBoundPoints = function (realSize) {
            (realSize === void 0) && (realSize = false);
            if (!this._temp || this._temp.length < 1 || realSize != this._cacheBoundsType)
                this._temp = this._getCmdPoints(realSize);
            this._cacheBoundsType = realSize;
            return this._rstBoundPoints = Utils.copyArray(this._rstBoundPoints, this._temp);
        };
        __proto._getCmdPoints = function (realSize) {
            (realSize === void 0) && (realSize = false);
            var context = Render._context;
            var cmds = this._graphics.cmds;
            var rst;
            rst = this._temp || (this._temp = []);
            rst.length = 0;
            if (!cmds && this._graphics._one != null) {
                GraphicsBounds._tempCmds.length = 0;
                GraphicsBounds._tempCmds.push(this._graphics._one);
                cmds = GraphicsBounds._tempCmds;
            }
            if (!cmds)
                return rst;
            var matrixs;
            matrixs = GraphicsBounds._tempMatrixArrays;
            matrixs.length = 0;
            var tMatrix = GraphicsBounds._initMatrix;
            tMatrix.identity();
            var tempMatrix = GraphicsBounds._tempMatrix;
            var cmd;
            var tex;
            var wRate = NaN;
            var hRate = NaN;
            var oWidth = NaN;
            var oHeight = NaN;
            var offX = NaN;
            var offY = NaN;
            for (var i = 0, n = cmds.length; i < n; i++) {
                cmd = cmds[i];
                if (!cmd.callee)
                    continue;
                switch (cmd.callee) {
                    case context._save:
                    case 7:
                        matrixs.push(tMatrix);
                        tMatrix = tMatrix.clone();
                        break;
                    case context._restore:
                    case 8:
                        tMatrix = matrixs.pop();
                        break;
                    case context._scale:
                    case 5:
                        tempMatrix.identity();
                        tempMatrix.translate(-cmd[2], -cmd[3]);
                        tempMatrix.scale(cmd[0], cmd[1]);
                        tempMatrix.translate(cmd[2], cmd[3]);
                        this._switchMatrix(tMatrix, tempMatrix);
                        break;
                    case context._rotate:
                    case 3:
                        tempMatrix.identity();
                        tempMatrix.translate(-cmd[1], -cmd[2]);
                        tempMatrix.rotate(cmd[0]);
                        tempMatrix.translate(cmd[1], cmd[2]);
                        this._switchMatrix(tMatrix, tempMatrix);
                        break;
                    case context._translate:
                    case 6:
                        tempMatrix.identity();
                        tempMatrix.translate(cmd[0], cmd[1]);
                        this._switchMatrix(tMatrix, tempMatrix);
                        break;
                    case context._transform:
                    case 4:
                        tempMatrix.identity();
                        tempMatrix.translate(-cmd[1], -cmd[2]);
                        tempMatrix.concat(cmd[0]);
                        tempMatrix.translate(cmd[1], cmd[2]);
                        this._switchMatrix(tMatrix, tempMatrix);
                        break;
                    case 16:
                    case 24:
                        GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[0], cmd[1], cmd[2], cmd[3]), tMatrix);
                        break;
                    case 17:
                        tMatrix.copyTo(tempMatrix);
                        tempMatrix.concat(cmd[4]);
                        GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[0], cmd[1], cmd[2], cmd[3]), tempMatrix);
                        break;
                    case context._drawTexture:
                        tex = cmd[0];
                        if (realSize) {
                            if (cmd[3] && cmd[4]) {
                                GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1], cmd[2], cmd[3], cmd[4]), tMatrix);
                            }
                            else {
                                tex = cmd[0];
                                GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1], cmd[2], tex.width, tex.height), tMatrix);
                            }
                        }
                        else {
                            wRate = (cmd[3] || tex.sourceWidth) / tex.width;
                            hRate = (cmd[4] || tex.sourceHeight) / tex.height;
                            oWidth = wRate * tex.sourceWidth;
                            oHeight = hRate * tex.sourceHeight;
                            offX = tex.offsetX > 0 ? tex.offsetX : 0;
                            offY = tex.offsetY > 0 ? tex.offsetY : 0;
                            offX *= wRate;
                            offY *= hRate;
                            GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1] - offX, cmd[2] - offY, oWidth, oHeight), tMatrix);
                        }
                        break;
                    case context._fillTexture:
                        if (cmd[3] && cmd[4]) {
                            GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1], cmd[2], cmd[3], cmd[4]), tMatrix);
                        }
                        else {
                            tex = cmd[0];
                            GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1], cmd[2], tex.width, tex.height), tMatrix);
                        }
                        break;
                    case context._drawTextureWithTransform:
                        ;
                        var drawMatrix;
                        if (cmd[5]) {
                            tMatrix.copyTo(tempMatrix);
                            tempMatrix.concat(cmd[5]);
                            drawMatrix = tempMatrix;
                        }
                        else {
                            drawMatrix = tMatrix;
                        }
                        if (realSize) {
                            if (cmd[3] && cmd[4]) {
                                GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1], cmd[2], cmd[3], cmd[4]), drawMatrix);
                            }
                            else {
                                tex = cmd[0];
                                GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1], cmd[2], tex.width, tex.height), drawMatrix);
                            }
                        }
                        else {
                            tex = cmd[0];
                            wRate = (cmd[3] || tex.sourceWidth) / tex.width;
                            hRate = (cmd[4] || tex.sourceHeight) / tex.height;
                            oWidth = wRate * tex.sourceWidth;
                            oHeight = hRate * tex.sourceHeight;
                            offX = tex.offsetX > 0 ? tex.offsetX : 0;
                            offY = tex.offsetY > 0 ? tex.offsetY : 0;
                            offX *= wRate;
                            offY *= hRate;
                            GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1] - offX, cmd[2] - offY, oWidth, oHeight), drawMatrix);
                        }
                        break;
                    case context._drawRect:
                    case 13:
                        GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[0], cmd[1], cmd[2], cmd[3]), tMatrix);
                        break;
                    case context._drawCircle:
                    case context._fillCircle:
                    case 14:
                        GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[0] - cmd[2], cmd[1] - cmd[2], cmd[2] + cmd[2], cmd[2] + cmd[2]), tMatrix);
                        break;
                    case context._drawLine:
                    case 20:
                        GraphicsBounds._tempPoints.length = 0;
                        var lineWidth = NaN;
                        lineWidth = cmd[5] * 0.5;
                        if (cmd[0] == cmd[2]) {
                            GraphicsBounds._tempPoints.push(cmd[0] + lineWidth, cmd[1], cmd[2] + lineWidth, cmd[3], cmd[0] - lineWidth, cmd[1], cmd[2] - lineWidth, cmd[3]);
                        }
                        else if (cmd[1] == cmd[3]) {
                            GraphicsBounds._tempPoints.push(cmd[0], cmd[1] + lineWidth, cmd[2], cmd[3] + lineWidth, cmd[0], cmd[1] - lineWidth, cmd[2], cmd[3] - lineWidth);
                        }
                        else {
                            GraphicsBounds._tempPoints.push(cmd[0], cmd[1], cmd[2], cmd[3]);
                        }
                        GraphicsBounds._addPointArrToRst(rst, GraphicsBounds._tempPoints, tMatrix);
                        break;
                    case context._drawCurves:
                    case 22:
                        GraphicsBounds._addPointArrToRst(rst, Bezier.I.getBezierPoints(cmd[2]), tMatrix, cmd[0], cmd[1]);
                        break;
                    case context._drawPoly:
                    case context._drawLines:
                    case 18:
                        GraphicsBounds._addPointArrToRst(rst, cmd[2], tMatrix, cmd[0], cmd[1]);
                        break;
                    case context._drawPath:
                    case 19:
                        GraphicsBounds._addPointArrToRst(rst, this._getPathPoints(cmd[2]), tMatrix, cmd[0], cmd[1]);
                        break;
                    case context._drawPie:
                    case 15:
                        GraphicsBounds._addPointArrToRst(rst, this._getPiePoints(cmd[0], cmd[1], cmd[2], cmd[3], cmd[4]), tMatrix);
                        break;
                }
            }
            if (rst.length > 200) {
                rst = Utils.copyArray(rst, Rectangle._getWrapRec(rst)._getBoundPoints());
            }
            else if (rst.length > 8)
                rst = GrahamScan.scanPList(rst);
            return rst;
        };
        __proto._switchMatrix = function (tMatix, tempMatrix) {
            tempMatrix.concat(tMatix);
            tempMatrix.copyTo(tMatix);
        };
        __proto._getPiePoints = function (x, y, radius, startAngle, endAngle) {
            var rst = GraphicsBounds._tempPoints;
            GraphicsBounds._tempPoints.length = 0;
            rst.push(x, y);
            var delta = (endAngle - startAngle) % (2 * Math.PI);
            var segnum = 10;
            var step = delta / segnum;
            var i = NaN;
            var angle = startAngle;
            for (i = 0; i <= segnum; i++) {
                rst.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle));
                angle += step;
            }
            return rst;
        };
        __proto._getPathPoints = function (paths) {
            var i = 0, len = 0;
            var rst = GraphicsBounds._tempPoints;
            rst.length = 0;
            len = paths.length;
            var tCMD;
            for (i = 0; i < len; i++) {
                tCMD = paths[i];
                if (tCMD.length > 1) {
                    rst.push(tCMD[1], tCMD[2]);
                    if (tCMD.length > 3) {
                        rst.push(tCMD[3], tCMD[4]);
                    }
                }
            }
            return rst;
        };
        GraphicsBounds._addPointArrToRst = function (rst, points, matrix, dx, dy) {
            (dx === void 0) && (dx = 0);
            (dy === void 0) && (dy = 0);
            var i = 0, len = 0;
            len = points.length;
            for (i = 0; i < len; i += 2) {
                GraphicsBounds._addPointToRst(rst, points[i] + dx, points[i + 1] + dy, matrix);
            }
        };
        GraphicsBounds._addPointToRst = function (rst, x, y, matrix) {
            var _tempPoint = Point.TEMP;
            _tempPoint.setTo(x ? x : 0, y ? y : 0);
            matrix.transformPoint(_tempPoint);
            rst.push(_tempPoint.x, _tempPoint.y);
        };
        GraphicsBounds._tempPoints = [];
        GraphicsBounds._tempMatrixArrays = [];
        GraphicsBounds._tempCmds = [];
        __static(GraphicsBounds, ['_tempMatrix', function () { return this._tempMatrix = new Matrix(); }, '_initMatrix', function () { return this._initMatrix = new Matrix(); }
        ]);
        return GraphicsBounds;
    })();
    var Event = (function () {
        function Event() {
        }
        __class(Event, 'laya.events.Event');
        var __proto = Event.prototype;
        __proto.setTo = function (type, currentTarget, target) {
            this.type = type;
            this.currentTarget = currentTarget;
            this.target = target;
            return this;
        };
        __proto.stopPropagation = function () {
            this._stoped = true;
        };
        __getset(0, __proto, 'stageY', function () {
            return Laya.stage.mouseY;
        });
        __getset(0, __proto, 'charCode', function () {
            return this.nativeEvent.charCode;
        });
        __getset(0, __proto, 'touches', function () {
            var arr = this.nativeEvent.touches;
            if (arr) {
                var stage = Laya.stage;
                for (var i = 0, n = arr.length; i < n; i++) {
                    var e = arr[i];
                    var point = Point.TEMP;
                    point.setTo(e.clientX, e.clientY);
                    stage._canvasTransform.invertTransformPoint(point);
                    stage.transform.invertTransformPoint(point);
                    e.stageX = point.x;
                    e.stageY = point.y;
                }
            }
            return arr;
        });
        __getset(0, __proto, 'keyLocation', function () {
            return this.nativeEvent.keyLocation;
        });
        __getset(0, __proto, 'ctrlKey', function () {
            return this.nativeEvent.ctrlKey;
        });
        __getset(0, __proto, 'altKey', function () {
            return this.nativeEvent.altKey;
        });
        __getset(0, __proto, 'shiftKey', function () {
            return this.nativeEvent.shiftKey;
        });
        __getset(0, __proto, 'stageX', function () {
            return Laya.stage.mouseX;
        });
        Event.EMPTY = new Event();
        Event.MOUSE_DOWN = "mousedown";
        Event.MOUSE_UP = "mouseup";
        Event.CLICK = "click";
        Event.RIGHT_MOUSE_DOWN = "rightmousedown";
        Event.RIGHT_MOUSE_UP = "rightmouseup";
        Event.RIGHT_CLICK = "rightclick";
        Event.MOUSE_MOVE = "mousemove";
        Event.MOUSE_OVER = "mouseover";
        Event.MOUSE_OUT = "mouseout";
        Event.MOUSE_WHEEL = "mousewheel";
        Event.ROLL_OVER = "mouseover";
        Event.ROLL_OUT = "mouseout";
        Event.DOUBLE_CLICK = "doubleclick";
        Event.CHANGE = "change";
        Event.CHANGED = "changed";
        Event.RESIZE = "resize";
        Event.ADDED = "added";
        Event.REMOVED = "removed";
        Event.DISPLAY = "display";
        Event.UNDISPLAY = "undisplay";
        Event.ERROR = "error";
        Event.COMPLETE = "complete";
        Event.LOADED = "loaded";
        Event.PROGRESS = "progress";
        Event.INPUT = "input";
        Event.RENDER = "render";
        Event.OPEN = "open";
        Event.MESSAGE = "message";
        Event.CLOSE = "close";
        Event.KEY_DOWN = "keydown";
        Event.KEY_PRESS = "keypress";
        Event.KEY_UP = "keyup";
        Event.FRAME = "enterframe";
        Event.DRAG_START = "dragstart";
        Event.DRAG_MOVE = "dragmove";
        Event.DRAG_END = "dragend";
        Event.ENTER = "enter";
        Event.SELECT = "select";
        Event.BLUR = "blur";
        Event.FOCUS = "focus";
        Event.VISIBILITY_CHANGE = "visibilitychange";
        Event.FOCUS_CHANGE = "focuschange";
        Event.PLAYED = "played";
        Event.PAUSED = "paused";
        Event.STOPPED = "stopped";
        Event.START = "start";
        Event.END = "end";
        Event.ENABLE_CHANGED = "enablechanged";
        Event.ACTIVE_IN_HIERARCHY_CHANGED = "activeinhierarchychanged";
        Event.COMPONENT_ADDED = "componentadded";
        Event.COMPONENT_REMOVED = "componentremoved";
        Event.LAYER_CHANGED = "layerchanged";
        Event.HIERARCHY_LOADED = "hierarchyloaded";
        Event.RECOVERED = "recovered";
        Event.RELEASED = "released";
        Event.LINK = "link";
        Event.LABEL = "label";
        Event.FULL_SCREEN_CHANGE = "fullscreenchange";
        Event.DEVICE_LOST = "devicelost";
        Event.MESH_CHANGED = "meshchanged";
        Event.MATERIAL_CHANGED = "materialchanged";
        Event.WORLDMATRIX_NEEDCHANGE = "worldmatrixneedchanged";
        Event.ANIMATION_CHANGED = "animationchanged";
        Event.TRIGGER_ENTER = "triggerenter";
        Event.TRIGGER_STAY = "triggerstay";
        Event.TRIGGER_EXIT = "triggerexit";
        Event.TRAIL_FILTER_CHANGE = "trailfilterchange";
        Event.DOMINO_FILTER_CHANGE = "dominofilterchange";
        return Event;
    })();
    var Keyboard = (function () {
        function Keyboard() { }
        __class(Keyboard, 'laya.events.Keyboard');
        Keyboard.NUMBER_0 = 48;
        Keyboard.NUMBER_1 = 49;
        Keyboard.NUMBER_2 = 50;
        Keyboard.NUMBER_3 = 51;
        Keyboard.NUMBER_4 = 52;
        Keyboard.NUMBER_5 = 53;
        Keyboard.NUMBER_6 = 54;
        Keyboard.NUMBER_7 = 55;
        Keyboard.NUMBER_8 = 56;
        Keyboard.NUMBER_9 = 57;
        Keyboard.A = 65;
        Keyboard.B = 66;
        Keyboard.C = 67;
        Keyboard.D = 68;
        Keyboard.E = 69;
        Keyboard.F = 70;
        Keyboard.G = 71;
        Keyboard.H = 72;
        Keyboard.I = 73;
        Keyboard.J = 74;
        Keyboard.K = 75;
        Keyboard.L = 76;
        Keyboard.M = 77;
        Keyboard.N = 78;
        Keyboard.O = 79;
        Keyboard.P = 80;
        Keyboard.Q = 81;
        Keyboard.R = 82;
        Keyboard.S = 83;
        Keyboard.T = 84;
        Keyboard.U = 85;
        Keyboard.V = 86;
        Keyboard.W = 87;
        Keyboard.X = 88;
        Keyboard.Y = 89;
        Keyboard.Z = 90;
        Keyboard.F1 = 112;
        Keyboard.F2 = 113;
        Keyboard.F3 = 114;
        Keyboard.F4 = 115;
        Keyboard.F5 = 116;
        Keyboard.F6 = 117;
        Keyboard.F7 = 118;
        Keyboard.F8 = 119;
        Keyboard.F9 = 120;
        Keyboard.F10 = 121;
        Keyboard.F11 = 122;
        Keyboard.F12 = 123;
        Keyboard.F13 = 124;
        Keyboard.F14 = 125;
        Keyboard.F15 = 126;
        Keyboard.NUMPAD = 21;
        Keyboard.NUMPAD_0 = 96;
        Keyboard.NUMPAD_1 = 97;
        Keyboard.NUMPAD_2 = 98;
        Keyboard.NUMPAD_3 = 99;
        Keyboard.NUMPAD_4 = 100;
        Keyboard.NUMPAD_5 = 101;
        Keyboard.NUMPAD_6 = 102;
        Keyboard.NUMPAD_7 = 103;
        Keyboard.NUMPAD_8 = 104;
        Keyboard.NUMPAD_9 = 105;
        Keyboard.NUMPAD_ADD = 107;
        Keyboard.NUMPAD_DECIMAL = 110;
        Keyboard.NUMPAD_DIVIDE = 111;
        Keyboard.NUMPAD_ENTER = 108;
        Keyboard.NUMPAD_MULTIPLY = 106;
        Keyboard.NUMPAD_SUBTRACT = 109;
        Keyboard.SEMICOLON = 186;
        Keyboard.EQUAL = 187;
        Keyboard.COMMA = 188;
        Keyboard.MINUS = 189;
        Keyboard.PERIOD = 190;
        Keyboard.SLASH = 191;
        Keyboard.BACKQUOTE = 192;
        Keyboard.LEFTBRACKET = 219;
        Keyboard.BACKSLASH = 220;
        Keyboard.RIGHTBRACKET = 221;
        Keyboard.QUOTE = 222;
        Keyboard.ALTERNATE = 18;
        Keyboard.BACKSPACE = 8;
        Keyboard.CAPS_LOCK = 20;
        Keyboard.COMMAND = 15;
        Keyboard.CONTROL = 17;
        Keyboard.DELETE = 46;
        Keyboard.ENTER = 13;
        Keyboard.ESCAPE = 27;
        Keyboard.PAGE_UP = 33;
        Keyboard.PAGE_DOWN = 34;
        Keyboard.END = 35;
        Keyboard.HOME = 36;
        Keyboard.LEFT = 37;
        Keyboard.UP = 38;
        Keyboard.RIGHT = 39;
        Keyboard.DOWN = 40;
        Keyboard.SHIFT = 16;
        Keyboard.SPACE = 32;
        Keyboard.TAB = 9;
        Keyboard.INSERT = 45;
        return Keyboard;
    })();
    var KeyBoardManager = (function () {
        function KeyBoardManager() { }
        __class(KeyBoardManager, 'laya.events.KeyBoardManager');
        KeyBoardManager.__init__ = function () {
            KeyBoardManager._addEvent("keydown");
            KeyBoardManager._addEvent("keypress");
            KeyBoardManager._addEvent("keyup");
        };
        KeyBoardManager._addEvent = function (type) {
            Browser.document.addEventListener(type, function (e) {
                laya.events.KeyBoardManager._dispatch(e, type);
            }, true);
        };
        KeyBoardManager._dispatch = function (e, type) {
            if (!KeyBoardManager.enabled)
                return;
            KeyBoardManager._event._stoped = false;
            KeyBoardManager._event.nativeEvent = e;
            KeyBoardManager._event.keyCode = e.keyCode || e.which || e.charCode;
            if (type === "keydown")
                KeyBoardManager._pressKeys[KeyBoardManager._event.keyCode] = true;
            else if (type === "keyup")
                KeyBoardManager._pressKeys[KeyBoardManager._event.keyCode] = null;
            var target = (Laya.stage.focus && (Laya.stage.focus.event != null) && Laya.stage.focus.displayedInStage) ? Laya.stage.focus : Laya.stage;
            var ct = target;
            while (ct) {
                ct.event(type, KeyBoardManager._event.setTo(type, ct, target));
                ct = ct.parent;
            }
        };
        KeyBoardManager.hasKeyDown = function (key) {
            return KeyBoardManager._pressKeys[key];
        };
        KeyBoardManager._pressKeys = {};
        KeyBoardManager.enabled = true;
        __static(KeyBoardManager, ['_event', function () { return this._event = new Event(); }
        ]);
        return KeyBoardManager;
    })();
    var KeyLocation = (function () {
        function KeyLocation() { }
        __class(KeyLocation, 'laya.events.KeyLocation');
        KeyLocation.STANDARD = 0;
        KeyLocation.LEFT = 1;
        KeyLocation.RIGHT = 2;
        KeyLocation.NUM_PAD = 3;
        return KeyLocation;
    })();
    var MouseManager = (function () {
        function MouseManager() {
            this.mouseX = 0;
            this.mouseY = 0;
            this.disableMouseEvent = false;
            this.mouseDownTime = 0;
            this.mouseMoveAccuracy = 2;
            this._stage = null;
            this._target = null;
            this._lastMoveTimer = 0;
            this._isLeftMouse = false;
            this._eventList = [];
            this._touchIDs = {};
            this._id = 1;
            this._tTouchID = 0;
            this._event = new Event();
            this._matrix = new Matrix();
            this._point = new Point();
            this._rect = new Rectangle();
            this._prePoint = new Point();
            this._curTouchID = NaN;
        }
        __class(MouseManager, 'laya.events.MouseManager');
        var __proto = MouseManager.prototype;
        __proto.__init__ = function (stage, canvas) {
            var _$this = this;
            this._stage = stage;
            var _this = this;
            var list = this._eventList;
            canvas.oncontextmenu = function (e) {
                if (MouseManager.enabled)
                    return false;
            };
            canvas.addEventListener('mousedown', function (e) {
                if (MouseManager.enabled) {
                    if (!Browser.onIE)
                        e.preventDefault();
                    list.push(e);
                    _this.mouseDownTime = Browser.now();
                }
            });
            canvas.addEventListener('mouseup', function (e) {
                if (MouseManager.enabled) {
                    e.preventDefault();
                    list.push(e);
                    _this.mouseDownTime = -Browser.now();
                }
            }, true);
            canvas.addEventListener('mousemove', function (e) {
                if (MouseManager.enabled) {
                    e.preventDefault();
                    var now = Browser.now();
                    if (now - _this._lastMoveTimer < 10)
                        return;
                    _this._lastMoveTimer = now;
                    list.push(e);
                }
            }, true);
            canvas.addEventListener("mouseout", function (e) {
                if (MouseManager.enabled)
                    list.push(e);
            });
            canvas.addEventListener("mouseover", function (e) {
                if (MouseManager.enabled)
                    list.push(e);
            });
            canvas.addEventListener("touchstart", function (e) {
                if (MouseManager.enabled) {
                    list.push(e);
                    if (!MouseManager._isFirstTouch && !Input.isInputting)
                        e.preventDefault();
                    _this.mouseDownTime = Browser.now();
                }
            });
            canvas.addEventListener("touchend", function (e) {
                if (MouseManager.enabled) {
                    if (!MouseManager._isFirstTouch && !Input.isInputting)
                        e.preventDefault();
                    MouseManager._isFirstTouch = false;
                    list.push(e);
                    _this.mouseDownTime = -Browser.now();
                }
                else {
                    _$this._curTouchID = NaN;
                }
            }, true);
            canvas.addEventListener("touchmove", function (e) {
                if (MouseManager.enabled) {
                    e.preventDefault();
                    list.push(e);
                }
            }, true);
            canvas.addEventListener("touchcancel", function (e) {
                if (MouseManager.enabled) {
                    e.preventDefault();
                    list.push(e);
                }
                else {
                    _$this._curTouchID = NaN;
                }
            }, true);
            canvas.addEventListener('mousewheel', function (e) {
                if (MouseManager.enabled)
                    list.push(e);
            });
            canvas.addEventListener('DOMMouseScroll', function (e) {
                if (MouseManager.enabled)
                    list.push(e);
            });
        };
        __proto.initEvent = function (e, nativeEvent) {
            var _this = this;
            _this._event._stoped = false;
            _this._event.nativeEvent = nativeEvent || e;
            _this._target = null;
            this._point.setTo(e.pageX || e.clientX, e.pageY || e.clientY);
            this._stage._canvasTransform.invertTransformPoint(this._point);
            _this.mouseX = this._point.x;
            _this.mouseY = this._point.y;
            _this._event.touchId = e.identifier || 0;
            this._tTouchID = _this._event.touchId;
            var evt;
            evt = TouchManager.I._event;
            evt._stoped = false;
            evt.nativeEvent = _this._event.nativeEvent;
            evt.touchId = _this._event.touchId;
        };
        __proto.checkMouseWheel = function (e) {
            var _lastOvers = TouchManager.I.getLastOvers();
            for (var i = 0, n = _lastOvers.length; i < n; i++) {
                var ele = _lastOvers[i];
                if (!ele) {
                    continue;
                }
                if (!ele.stage) {
                    var lastEvent = this._event;
                    this._prePoint.x = e.clientX;
                    this._prePoint.y = e.clientY;
                    this.initEvent(e);
                    var hit = this.check(this._stage, this.mouseX, this.mouseY, this.onMouseWheelAndMove);
                    if (hit)
                        this.onMouseWheel(lastEvent, e);
                }
                else {
                    this._event.delta = e.wheelDelta ? e.wheelDelta * 0.025 : -e.detail;
                    ele.event("mousewheel", this._event.setTo("mousewheel", ele, this._target));
                }
            }
        };
        __proto.onMouseWheelAndMove = function (ele) {
            TouchManager.I.onMouseMove(ele, this._tTouchID, true);
        };
        __proto.onMouseWheel = function (lastEvt, evt) {
            this._prePoint.x = this._prePoint.y = -1000000;
            this._event = lastEvt;
            this.checkMouseWheel(evt);
        };
        __proto.onMouseMove = function (ele) {
            TouchManager.I.onMouseMove(ele, this._tTouchID);
        };
        __proto.onMouseDown = function (ele) {
            if (Input.isInputting && Laya.stage.focus && Laya.stage.focus["focus"] && !Laya.stage.focus.contains(this._target)) {
                var pre_input = Laya.stage.focus['_tf'] || Laya.stage.focus;
                var new_input = ele['_tf'] || ele;
                if ((new_input instanceof laya.display.Input) && new_input.multiline == pre_input.multiline)
                    pre_input['_focusOut']();
                else
                    pre_input.focus = false;
            }
            TouchManager.I.onMouseDown(ele, this._tTouchID, this._isLeftMouse);
        };
        __proto.onMouseUp = function (ele) {
            TouchManager.I.onMouseUp(ele, this._tTouchID, this._isLeftMouse);
        };
        __proto.check = function (sp, mouseX, mouseY, callBack) {
            this._point.setTo(mouseX, mouseY);
            sp.fromParentPoint(this._point);
            mouseX = this._point.x;
            mouseY = this._point.y;
            var scrollRect = sp.scrollRect;
            if (scrollRect) {
                this._rect.setTo(scrollRect.x, scrollRect.y, scrollRect.width, scrollRect.height);
                if (!this._rect.contains(mouseX, mouseY))
                    return false;
            }
            if (!this.disableMouseEvent) {
                if (sp.hitTestPrior && !sp.mouseThrough && !this.hitTest(sp, mouseX, mouseY)) {
                    return false;
                }
                for (var i = sp._childs.length - 1; i > -1; i--) {
                    var child = sp._childs[i];
                    if (!child.destroyed && child.mouseEnabled && child.visible) {
                        if (this.check(child, mouseX, mouseY, callBack))
                            return true;
                    }
                }
            }
            var isHit = (sp.hitTestPrior && !sp.mouseThrough && !this.disableMouseEvent) ? true : this.hitTest(sp, mouseX, mouseY);
            if (isHit) {
                this._target = sp;
                if (callBack)
                    callBack.call(this, sp);
            }
            else if (callBack === this.onMouseUp && sp === this._stage) {
                this._target = this._stage;
                if (callBack)
                    callBack.call(this, this._target);
            }
            return isHit;
        };
        __proto.hitTest = function (sp, mouseX, mouseY) {
            var isHit = false;
            if (sp.scrollRect) {
                mouseX -= sp.scrollRect.x;
                mouseY -= sp.scrollRect.y;
            }
            if ((sp.hitArea instanceof laya.utils.HitArea)) {
                return sp.hitArea.isHit(mouseX, mouseY);
            }
            if (!sp.mouseThrough) {
                var hitRect = this._rect;
                if (sp.hitArea)
                    hitRect = sp.hitArea;
                else {
                    if (sp.width < 0 || sp.height < 0) {
                        var __x = sp.width < 0 ? -Math.abs(sp.width) : 0;
                        var __y = sp.height < 0 ? -Math.abs(sp.height) : 0;
                        hitRect.setTo(__x, __y, Math.abs(sp.width), Math.abs(sp.height));
                    }
                    else {
                        hitRect.setTo(0, 0, sp.width, sp.height);
                    }
                }
                isHit = hitRect.contains(mouseX, mouseY);
            }
            else {
                isHit = sp.getGraphicBounds().contains(mouseX, mouseY);
            }
            return isHit;
        };
        __proto.runEvent = function () {
            var len = this._eventList.length;
            if (!len)
                return;
            var _this = this;
            var i = 0, j = 0, n = 0, touch;
            while (i < len) {
                var evt = this._eventList[i];
                if (evt.type !== 'mousemove')
                    this._prePoint.x = this._prePoint.y = -1000000;
                switch (evt.type) {
                    case 'mousedown':
                        this._touchIDs[0] = this._id++;
                        if (!MouseManager._isTouchRespond) {
                            _this._isLeftMouse = evt.button === 0;
                            _this.initEvent(evt);
                            _this.check(_this._stage, _this.mouseX, _this.mouseY, _this.onMouseDown);
                        }
                        else
                            MouseManager._isTouchRespond = false;
                        break;
                    case 'mouseup':
                        _this._isLeftMouse = evt.button === 0;
                        _this.initEvent(evt);
                        _this.check(_this._stage, _this.mouseX, _this.mouseY, _this.onMouseUp);
                        break;
                    case 'mousemove':
                        if ((Math.abs(this._prePoint.x - evt.clientX) + Math.abs(this._prePoint.y - evt.clientY)) >= this.mouseMoveAccuracy) {
                            this._prePoint.x = evt.clientX;
                            this._prePoint.y = evt.clientY;
                            _this.initEvent(evt);
                            _this.check(_this._stage, _this.mouseX, _this.mouseY, _this.onMouseMove);
                        }
                        break;
                    case "touchstart":
                        MouseManager._isTouchRespond = true;
                        _this._isLeftMouse = true;
                        var touches = evt.changedTouches;
                        for (j = 0, n = touches.length; j < n; j++) {
                            touch = touches[j];
                            if (MouseManager.multiTouchEnabled || isNaN(this._curTouchID)) {
                                this._curTouchID = touch.identifier;
                                if (this._id % 200 === 0)
                                    this._touchIDs = {};
                                this._touchIDs[touch.identifier] = this._id++;
                                _this.initEvent(touch, evt);
                                _this.check(_this._stage, _this.mouseX, _this.mouseY, _this.onMouseDown);
                            }
                        }
                        break;
                    case "touchend":
                    case "touchcancel":
                        MouseManager._isTouchRespond = true;
                        _this._isLeftMouse = true;
                        var touchends = evt.changedTouches;
                        for (j = 0, n = touchends.length; j < n; j++) {
                            touch = touchends[j];
                            if (MouseManager.multiTouchEnabled || touch.identifier == this._curTouchID) {
                                this._curTouchID = NaN;
                                _this.initEvent(touch, evt);
                                var isChecked = false;
                                isChecked = _this.check(_this._stage, _this.mouseX, _this.mouseY, _this.onMouseUp);
                                if (!isChecked) {
                                    _this.onMouseUp(null);
                                }
                            }
                        }
                        break;
                    case "touchmove":
                        ;
                        var touchemoves = evt.changedTouches;
                        for (j = 0, n = touchemoves.length; j < n; j++) {
                            touch = touchemoves[j];
                            if (MouseManager.multiTouchEnabled || touch.identifier == this._curTouchID) {
                                _this.initEvent(touch, evt);
                                _this.check(_this._stage, _this.mouseX, _this.mouseY, _this.onMouseMove);
                            }
                        }
                        break;
                    case "wheel":
                    case "mousewheel":
                    case "DOMMouseScroll":
                        _this.checkMouseWheel(evt);
                        break;
                    case "mouseout":
                        TouchManager.I.stageMouseOut();
                        break;
                    case "mouseover":
                        _this._stage.event("mouseover", _this._event.setTo("mouseover", _this._stage, _this._stage));
                        break;
                }
                i++;
            }
            this._eventList.length = 0;
        };
        MouseManager.enabled = true;
        MouseManager.multiTouchEnabled = true;
        MouseManager._isTouchRespond = false;
        MouseManager._isFirstTouch = true;
        __static(MouseManager, ['instance', function () { return this.instance = new MouseManager(); }
        ]);
        return MouseManager;
    })();
    var TouchManager = (function () {
        function TouchManager() {
            this.preOvers = [];
            this.preDowns = [];
            this.preRightDowns = [];
            this.enable = true;
            this._lastClickTime = 0;
            this._event = new Event();
        }
        __class(TouchManager, 'laya.events.TouchManager');
        var __proto = TouchManager.prototype;
        __proto._clearTempArrs = function () {
            TouchManager._oldArr.length = 0;
            TouchManager._newArr.length = 0;
            TouchManager._tEleArr.length = 0;
        };
        __proto.getTouchFromArr = function (touchID, arr) {
            var i = 0, len = 0;
            len = arr.length;
            var tTouchO;
            for (i = 0; i < len; i++) {
                tTouchO = arr[i];
                if (tTouchO.id == touchID) {
                    return tTouchO;
                }
            }
            return null;
        };
        __proto.removeTouchFromArr = function (touchID, arr) {
            var i = 0;
            for (i = arr.length - 1; i >= 0; i--) {
                if (arr[i].id == touchID) {
                    arr.splice(i, 1);
                }
            }
        };
        __proto.createTouchO = function (ele, touchID) {
            var rst;
            rst = Pool.getItem("TouchData") || {};
            rst.id = touchID;
            rst.tar = ele;
            return rst;
        };
        __proto.onMouseDown = function (ele, touchID, isLeft) {
            (isLeft === void 0) && (isLeft = false);
            if (!this.enable)
                return;
            var preO;
            var tO;
            var arrs;
            preO = this.getTouchFromArr(touchID, this.preOvers);
            arrs = this.getEles(ele, null, TouchManager._tEleArr);
            if (!preO) {
                tO = this.createTouchO(ele, touchID);
                this.preOvers.push(tO);
            }
            else {
                preO.tar = ele;
            }
            if (Browser.onMobile)
                this.sendEvents(arrs, "mouseover", touchID);
            var preDowns;
            preDowns = isLeft ? this.preDowns : this.preRightDowns;
            preO = this.getTouchFromArr(touchID, preDowns);
            if (!preO) {
                tO = this.createTouchO(ele, touchID);
                preDowns.push(tO);
            }
            else {
                preO.tar = ele;
            }
            this.sendEvents(arrs, isLeft ? "mousedown" : "rightmousedown", touchID);
            this._clearTempArrs();
        };
        __proto.sendEvents = function (eles, type, touchID) {
            (touchID === void 0) && (touchID = 0);
            var i = 0, len = 0;
            len = eles.length;
            this._event._stoped = false;
            var _target;
            _target = eles[0];
            var tE;
            for (i = 0; i < len; i++) {
                tE = eles[i];
                if (tE.destroyed)
                    return;
                tE.event(type, this._event.setTo(type, tE, _target));
                if (this._event._stoped)
                    break;
            }
        };
        __proto.getEles = function (start, end, rst) {
            if (!rst) {
                rst = [];
            }
            else {
                rst.length = 0;
            }
            while (start && start != end) {
                rst.push(start);
                start = start.parent;
            }
            return rst;
        };
        __proto.checkMouseOutAndOverOfMove = function (eleNew, elePre, touchID, limit) {
            (touchID === void 0) && (touchID = 0);
            (limit === void 0) && (limit = false);
            if (elePre == eleNew)
                return;
            var tar;
            var arrs;
            var i = 0, len = 0;
            if (elePre.contains(eleNew)) {
                arrs = this.getEles(eleNew, elePre, TouchManager._tEleArr);
                if (!limit)
                    this.sendEvents(arrs, "mouseover", touchID);
            }
            else if (eleNew.contains(elePre)) {
                arrs = this.getEles(elePre, eleNew, TouchManager._tEleArr);
                if (!limit)
                    this.sendEvents(arrs, "mouseout", touchID);
            }
            else {
                arrs = TouchManager._tEleArr;
                arrs.length = 0;
                var oldArr;
                oldArr = this.getEles(elePre, null, TouchManager._oldArr);
                var newArr;
                newArr = this.getEles(eleNew, null, TouchManager._newArr);
                len = oldArr.length;
                var tIndex = 0;
                for (i = 0; i < len; i++) {
                    tar = oldArr[i];
                    tIndex = newArr.indexOf(tar);
                    if (tIndex >= 0) {
                        newArr.splice(tIndex, newArr.length - tIndex);
                        break;
                    }
                    else {
                        arrs.push(tar);
                    }
                }
                if (arrs.length > 0) {
                    if (!limit)
                        this.sendEvents(arrs, "mouseout", touchID);
                }
                if (newArr.length > 0) {
                    if (!limit)
                        this.sendEvents(newArr, "mouseover", touchID);
                }
            }
        };
        __proto.onMouseMove = function (ele, touchID, limit) {
            (limit === void 0) && (limit = false);
            if (!this.enable)
                return;
            var preO;
            preO = this.getTouchFromArr(touchID, this.preOvers);
            var arrs;
            var tO;
            if (!preO) {
                arrs = this.getEles(ele, null, TouchManager._tEleArr);
                if (!limit)
                    this.sendEvents(arrs, "mouseover", touchID);
                this.preOvers.push(this.createTouchO(ele, touchID));
            }
            else {
                this.checkMouseOutAndOverOfMove(ele, preO.tar, 0, limit);
                preO.tar = ele;
                arrs = this.getEles(ele, null, TouchManager._tEleArr);
            }
            if (!limit)
                this.sendEvents(arrs, "mousemove", touchID);
            this._clearTempArrs();
        };
        __proto.getLastOvers = function () {
            TouchManager._tEleArr.length = 0;
            if (this.preOvers.length > 0 && this.preOvers[0].tar) {
                return this.getEles(this.preOvers[0].tar, null, TouchManager._tEleArr);
            }
            TouchManager._tEleArr.push(Laya.stage);
            return TouchManager._tEleArr;
        };
        __proto.stageMouseOut = function () {
            var lastOvers;
            lastOvers = this.getLastOvers();
            this.preOvers.length = 0;
            this.sendEvents(lastOvers, "mouseout", 0);
        };
        __proto.onMouseUp = function (ele, touchID, isLeft) {
            (isLeft === void 0) && (isLeft = false);
            if (!this.enable)
                return;
            var preO;
            var tO;
            var arrs;
            var oldArr;
            var i = 0, len = 0;
            var tar;
            var sendArr;
            var onMobile = Browser.onMobile;
            arrs = this.getEles(ele, null, TouchManager._tEleArr);
            this.sendEvents(arrs, isLeft ? "mouseup" : "rightmouseup", touchID);
            var preDowns;
            preDowns = isLeft ? this.preDowns : this.preRightDowns;
            preO = this.getTouchFromArr(touchID, preDowns);
            if (!preO) {
            }
            else {
                var isDouble = false;
                var now = Browser.now();
                isDouble = now - this._lastClickTime < 300;
                this._lastClickTime = now;
                if (ele == preO.tar) {
                    sendArr = arrs;
                }
                else {
                    oldArr = this.getEles(preO.tar, null, TouchManager._oldArr);
                    sendArr = TouchManager._newArr;
                    sendArr.length = 0;
                    len = oldArr.length;
                    for (i = 0; i < len; i++) {
                        tar = oldArr[i];
                        if (arrs.indexOf(tar) >= 0) {
                            sendArr.push(tar);
                        }
                    }
                }
                if (sendArr.length > 0) {
                    this.sendEvents(sendArr, isLeft ? "click" : "rightclick", touchID);
                }
                if (isLeft && isDouble) {
                    this.sendEvents(sendArr, "doubleclick", touchID);
                }
                this.removeTouchFromArr(touchID, preDowns);
                preO.tar = null;
                Pool.recover("TouchData", preO);
            }
            preO = this.getTouchFromArr(touchID, this.preOvers);
            if (!preO) {
            }
            else {
                if (onMobile) {
                    sendArr = this.getEles(preO.tar, null, sendArr);
                    if (sendArr && sendArr.length > 0) {
                        this.sendEvents(sendArr, "mouseout", touchID);
                    }
                    this.removeTouchFromArr(touchID, this.preOvers);
                    preO.tar = null;
                    Pool.recover("TouchData", preO);
                }
            }
            this._clearTempArrs();
        };
        TouchManager._oldArr = [];
        TouchManager._newArr = [];
        TouchManager._tEleArr = [];
        __static(TouchManager, ['I', function () { return this.I = new TouchManager(); }
        ]);
        return TouchManager;
    })();
    var Filter = (function () {
        function Filter() {
            this._action = null;
        }
        __class(Filter, 'laya.filters.Filter');
        var __proto = Filter.prototype;
        Laya.imps(__proto, { "laya.filters.IFilter": true });
        __proto.callNative = function (sp) { };
        __getset(0, __proto, 'type', function () { return -1; });
        __getset(0, __proto, 'action', function () { return this._action; });
        Filter.BLUR = 0x10;
        Filter.COLOR = 0x20;
        Filter.GLOW = 0x08;
        // Filter.KDS = 0x800;
        Filter._filterStart = null;
        Filter._filterEnd = null;
        Filter._EndTarget = null;
        Filter._recycleScope = null;
        Filter._filter = null;
        Filter._useSrc = null;
        Filter._endSrc = null;
        Filter._useOut = null;
        Filter._endOut = null;
        return Filter;
    })();
    var ColorFilterAction = (function () {
        function ColorFilterAction() {
            this.data = null;
        }
        __class(ColorFilterAction, 'laya.filters.ColorFilterAction');
        var __proto = ColorFilterAction.prototype;
        Laya.imps(__proto, { "laya.filters.IFilterAction": true });
        __proto.apply = function (srcCanvas) {
            var ctx = srcCanvas.ctx.ctx;
            var canvas = srcCanvas.ctx.ctx.canvas;
            if (canvas.width == 0 || canvas.height == 0)
                return canvas;
            var imgdata = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imgdata.data;
            var nData;
            for (var i = 0, n = data.length; i < n; i += 4) {
                nData = this.getColor(data[i], data[i + 1], data[i + 2], data[i + 3]);
                if (data[i + 3] == 0)
                    continue;
                data[i] = nData[0];
                data[i + 1] = nData[1];
                data[i + 2] = nData[2];
                data[i + 3] = nData[3];
            }
            ctx.putImageData(imgdata, 0, 0);
            return srcCanvas;
        };
        __proto.getColor = function (red, green, blue, alpha) {
            var rst = [];
            if (this.data._mat && this.data._alpha) {
                var mat = this.data._mat;
                var tempAlpha = this.data._alpha;
                rst[0] = mat[0] * red + mat[1] * green + mat[2] * blue + mat[3] * alpha + tempAlpha[0];
                rst[1] = mat[4] * red + mat[5] * green + mat[6] * blue + mat[7] * alpha + tempAlpha[1];
                rst[2] = mat[8] * red + mat[9] * green + mat[10] * blue + mat[11] * alpha + tempAlpha[2];
                rst[3] = mat[12] * red + mat[13] * green + mat[14] * blue + mat[15] * alpha + tempAlpha[3];
            }
            return rst;
        };
        return ColorFilterAction;
    })();
    var Arith = (function () {
        function Arith() { }
        __class(Arith, 'laya.maths.Arith');
        Arith.formatR = function (r) {
            if (r > Math.PI)
                r -= Math.PI * 2;
            if (r < -Math.PI)
                r += Math.PI * 2;
            return r;
        };
        Arith.isPOT = function (w, h) {
            return (w > 0 && (w & (w - 1)) === 0 && h > 0 && (h & (h - 1)) === 0);
        };
        Arith.setMatToArray = function (mat, array) {
            mat.a, mat.b, 0, 0, mat.c, mat.d, 0, 0, 0, 0, 1, 0, mat.tx + 20, mat.ty + 20, 0, 1;
            array[0] = mat.a;
            array[1] = mat.b;
            array[4] = mat.c;
            array[5] = mat.d;
            array[12] = mat.tx;
            array[13] = mat.ty;
        };
        return Arith;
    })();
    var Bezier = (function () {
        function Bezier() {
            this._controlPoints = [new Point(), new Point(), new Point()];
            this._calFun = this.getPoint2;
        }
        __class(Bezier, 'laya.maths.Bezier');
        var __proto = Bezier.prototype;
        __proto._switchPoint = function (x, y) {
            var tPoint = this._controlPoints.shift();
            tPoint.setTo(x, y);
            this._controlPoints.push(tPoint);
        };
        __proto.getPoint2 = function (t, rst) {
            var p1 = this._controlPoints[0];
            var p2 = this._controlPoints[1];
            var p3 = this._controlPoints[2];
            var lineX = Math.pow((1 - t), 2) * p1.x + 2 * t * (1 - t) * p2.x + Math.pow(t, 2) * p3.x;
            var lineY = Math.pow((1 - t), 2) * p1.y + 2 * t * (1 - t) * p2.y + Math.pow(t, 2) * p3.y;
            rst.push(lineX, lineY);
        };
        __proto.getPoint3 = function (t, rst) {
            var p1 = this._controlPoints[0];
            var p2 = this._controlPoints[1];
            var p3 = this._controlPoints[2];
            var p4 = this._controlPoints[3];
            var lineX = Math.pow((1 - t), 3) * p1.x + 3 * p2.x * t * (1 - t) * (1 - t) + 3 * p3.x * t * t * (1 - t) + p4.x * Math.pow(t, 3);
            var lineY = Math.pow((1 - t), 3) * p1.y + 3 * p2.y * t * (1 - t) * (1 - t) + 3 * p3.y * t * t * (1 - t) + p4.y * Math.pow(t, 3);
            rst.push(lineX, lineY);
        };
        __proto.insertPoints = function (count, rst) {
            var i = NaN;
            count = count > 0 ? count : 5;
            var dLen = NaN;
            dLen = 1 / count;
            for (i = 0; i <= 1; i += dLen) {
                this._calFun(i, rst);
            }
        };
        __proto.getBezierPoints = function (pList, inSertCount, count) {
            (inSertCount === void 0) && (inSertCount = 5);
            (count === void 0) && (count = 2);
            var i = 0, len = 0;
            len = pList.length;
            if (len < (count + 1) * 2)
                return [];
            var rst;
            rst = [];
            switch (count) {
                case 2:
                    this._calFun = this.getPoint2;
                    break;
                case 3:
                    this._calFun = this.getPoint3;
                    break;
                default:
                    return [];
            }
            while (this._controlPoints.length <= count) {
                this._controlPoints.push(new Point());
            }
            for (i = 0; i < count * 2; i += 2) {
                this._switchPoint(pList[i], pList[i + 1]);
            }
            for (i = count * 2; i < len; i += 2) {
                this._switchPoint(pList[i], pList[i + 1]);
                if ((i / 2) % count == 0)
                    this.insertPoints(inSertCount, rst);
            }
            return rst;
        };
        __static(Bezier, ['I', function () { return this.I = new Bezier(); }
        ]);
        return Bezier;
    })();
    var GrahamScan = (function () {
        function GrahamScan() { }
        __class(GrahamScan, 'laya.maths.GrahamScan');
        GrahamScan.multiply = function (p1, p2, p0) {
            return ((p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y));
        };
        GrahamScan.dis = function (p1, p2) {
            return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
        };
        GrahamScan._getPoints = function (count, tempUse, rst) {
            (tempUse === void 0) && (tempUse = false);
            if (!GrahamScan._mPointList)
                GrahamScan._mPointList = [];
            while (GrahamScan._mPointList.length < count)
                GrahamScan._mPointList.push(new Point());
            if (!rst)
                rst = [];
            rst.length = 0;
            if (tempUse) {
                GrahamScan.getFrom(rst, GrahamScan._mPointList, count);
            }
            else {
                GrahamScan.getFromR(rst, GrahamScan._mPointList, count);
            }
            return rst;
        };
        GrahamScan.getFrom = function (rst, src, count) {
            var i = 0;
            for (i = 0; i < count; i++) {
                rst.push(src[i]);
            }
            return rst;
        };
        GrahamScan.getFromR = function (rst, src, count) {
            var i = 0;
            for (i = 0; i < count; i++) {
                rst.push(src.pop());
            }
            return rst;
        };
        GrahamScan.pListToPointList = function (pList, tempUse) {
            (tempUse === void 0) && (tempUse = false);
            var i = 0, len = pList.length / 2, rst = GrahamScan._getPoints(len, tempUse, GrahamScan._tempPointList);
            for (i = 0; i < len; i++) {
                rst[i].setTo(pList[i + i], pList[i + i + 1]);
            }
            return rst;
        };
        GrahamScan.pointListToPlist = function (pointList) {
            var i = 0, len = pointList.length, rst = GrahamScan._temPList, tPoint;
            rst.length = 0;
            for (i = 0; i < len; i++) {
                tPoint = pointList[i];
                rst.push(tPoint.x, tPoint.y);
            }
            return rst;
        };
        GrahamScan.scanPList = function (pList) {
            return Utils.copyArray(pList, GrahamScan.pointListToPlist(GrahamScan.scan(GrahamScan.pListToPointList(pList, true))));
        };
        GrahamScan.scan = function (PointSet) {
            var i = 0, j = 0, k = 0, top = 2, tmp, n = PointSet.length, ch;
            var _tmpDic = {};
            var key;
            ch = GrahamScan._temArr;
            ch.length = 0;
            n = PointSet.length;
            for (i = n - 1; i >= 0; i--) {
                tmp = PointSet[i];
                key = tmp.x + "_" + tmp.y;
                if (!_tmpDic.hasOwnProperty(key)) {
                    _tmpDic[key] = true;
                    ch.push(tmp);
                }
            }
            n = ch.length;
            Utils.copyArray(PointSet, ch);
            for (i = 1; i < n; i++)
                if ((PointSet[i].y < PointSet[k].y) || ((PointSet[i].y == PointSet[k].y) && (PointSet[i].x < PointSet[k].x)))
                    k = i;
            tmp = PointSet[0];
            PointSet[0] = PointSet[k];
            PointSet[k] = tmp;
            for (i = 1; i < n - 1; i++) {
                k = i;
                for (j = i + 1; j < n; j++)
                    if ((GrahamScan.multiply(PointSet[j], PointSet[k], PointSet[0]) > 0) || ((GrahamScan.multiply(PointSet[j], PointSet[k], PointSet[0]) == 0) && (GrahamScan.dis(PointSet[0], PointSet[j]) < GrahamScan.dis(PointSet[0], PointSet[k]))))
                        k = j;
                tmp = PointSet[i];
                PointSet[i] = PointSet[k];
                PointSet[k] = tmp;
            }
            ch = GrahamScan._temArr;
            ch.length = 0;
            if (PointSet.length < 3) {
                return Utils.copyArray(ch, PointSet);
            }
            ch.push(PointSet[0], PointSet[1], PointSet[2]);
            for (i = 3; i < n; i++) {
                while (ch.length >= 2 && GrahamScan.multiply(PointSet[i], ch[ch.length - 1], ch[ch.length - 2]) >= 0)
                    ch.pop();
                PointSet[i] && ch.push(PointSet[i]);
            }
            return ch;
        };
        GrahamScan._mPointList = null;
        GrahamScan._tempPointList = [];
        GrahamScan._temPList = [];
        GrahamScan._temArr = [];
        return GrahamScan;
    })();
    var MathUtil = (function () {
        function MathUtil() { }
        __class(MathUtil, 'laya.maths.MathUtil');
        MathUtil.subtractVector3 = function (l, r, o) {
            o[0] = l[0] - r[0];
            o[1] = l[1] - r[1];
            o[2] = l[2] - r[2];
        };
        MathUtil.lerp = function (left, right, amount) {
            return left * (1 - amount) + right * amount;
        };
        MathUtil.scaleVector3 = function (f, b, e) {
            e[0] = f[0] * b;
            e[1] = f[1] * b;
            e[2] = f[2] * b;
        };
        MathUtil.lerpVector3 = function (l, r, t, o) {
            var ax = l[0], ay = l[1], az = l[2];
            o[0] = ax + t * (r[0] - ax);
            o[1] = ay + t * (r[1] - ay);
            o[2] = az + t * (r[2] - az);
        };
        MathUtil.lerpVector4 = function (l, r, t, o) {
            var ax = l[0], ay = l[1], az = l[2], aw = l[3];
            o[0] = ax + t * (r[0] - ax);
            o[1] = ay + t * (r[1] - ay);
            o[2] = az + t * (r[2] - az);
            o[3] = aw + t * (r[3] - aw);
        };
        MathUtil.slerpQuaternionArray = function (a, Offset1, b, Offset2, t, out, Offset3) {
            var ax = a[Offset1 + 0], ay = a[Offset1 + 1], az = a[Offset1 + 2], aw = a[Offset1 + 3], bx = b[Offset2 + 0], by = b[Offset2 + 1], bz = b[Offset2 + 2], bw = b[Offset2 + 3];
            var omega, cosom, sinom, scale0, scale1;
            cosom = ax * bx + ay * by + az * bz + aw * bw;
            if (cosom < 0.0) {
                cosom = -cosom;
                bx = -bx;
                by = -by;
                bz = -bz;
                bw = -bw;
            }
            if ((1.0 - cosom) > 0.000001) {
                omega = Math.acos(cosom);
                sinom = Math.sin(omega);
                scale0 = Math.sin((1.0 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
            }
            else {
                scale0 = 1.0 - t;
                scale1 = t;
            }
            out[Offset3 + 0] = scale0 * ax + scale1 * bx;
            out[Offset3 + 1] = scale0 * ay + scale1 * by;
            out[Offset3 + 2] = scale0 * az + scale1 * bz;
            out[Offset3 + 3] = scale0 * aw + scale1 * bw;
            return out;
        };
        MathUtil.getRotation = function (x0, y0, x1, y1) {
            return Math.atan2(y1 - y0, x1 - x0) / Math.PI * 180;
        };
        MathUtil.sortBigFirst = function (a, b) {
            if (a == b)
                return 0;
            return b > a ? 1 : -1;
        };
        MathUtil.sortSmallFirst = function (a, b) {
            if (a == b)
                return 0;
            return b > a ? -1 : 1;
        };
        MathUtil.sortNumBigFirst = function (a, b) {
            return parseFloat(b) - parseFloat(a);
        };
        MathUtil.sortNumSmallFirst = function (a, b) {
            return parseFloat(a) - parseFloat(b);
        };
        MathUtil.sortByKey = function (key, bigFirst, forceNum) {
            (bigFirst === void 0) && (bigFirst = false);
            (forceNum === void 0) && (forceNum = true);
            var _sortFun;
            if (bigFirst) {
                _sortFun = forceNum ? MathUtil.sortNumBigFirst : MathUtil.sortBigFirst;
            }
            else {
                _sortFun = forceNum ? MathUtil.sortNumSmallFirst : MathUtil.sortSmallFirst;
            }
            return function (a, b) {
                return _sortFun(a[key], b[key]);
            };
        };
        return MathUtil;
    })();
    var Matrix = (function () {
        function Matrix(a, b, c, d, tx, ty) {
            this.inPool = false;
            this.bTransform = false;
            (a === void 0) && (a = 1);
            (b === void 0) && (b = 0);
            (c === void 0) && (c = 0);
            (d === void 0) && (d = 1);
            (tx === void 0) && (tx = 0);
            (ty === void 0) && (ty = 0);
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            this.tx = tx;
            this.ty = ty;
            this._checkTransform();
        }
        __class(Matrix, 'laya.maths.Matrix');
        var __proto = Matrix.prototype;
        __proto.identity = function () {
            this.a = this.d = 1;
            this.b = this.tx = this.ty = this.c = 0;
            this.bTransform = false;
            return this;
        };
        __proto._checkTransform = function () {
            return this.bTransform = (this.a !== 1 || this.b !== 0 || this.c !== 0 || this.d !== 1);
        };
        __proto.setTranslate = function (x, y) {
            this.tx = x;
            this.ty = y;
            return this;
        };
        __proto.translate = function (x, y) {
            this.tx += x;
            this.ty += y;
            return this;
        };
        __proto.scale = function (x, y) {
            this.a *= x;
            this.d *= y;
            this.c *= x;
            this.b *= y;
            this.tx *= x;
            this.ty *= y;
            this.bTransform = true;
        };
        __proto.rotate = function (angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var a1 = this.a;
            var c1 = this.c;
            var tx1 = this.tx;
            this.a = a1 * cos - this.b * sin;
            this.b = a1 * sin + this.b * cos;
            this.c = c1 * cos - this.d * sin;
            this.d = c1 * sin + this.d * cos;
            this.tx = tx1 * cos - this.ty * sin;
            this.ty = tx1 * sin + this.ty * cos;
            this.bTransform = true;
        };
        __proto.skew = function (x, y) {
            var tanX = Math.tan(x);
            var tanY = Math.tan(y);
            var a1 = this.a;
            var b1 = this.b;
            this.a += tanY * this.c;
            this.b += tanY * this.d;
            this.c += tanX * a1;
            this.d += tanX * b1;
            return this;
        };
        __proto.invertTransformPoint = function (out) {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;
            var tx1 = this.tx;
            var n = a1 * d1 - b1 * c1;
            var a2 = d1 / n;
            var b2 = -b1 / n;
            var c2 = -c1 / n;
            var d2 = a1 / n;
            var tx2 = (c1 * this.ty - d1 * tx1) / n;
            var ty2 = -(a1 * this.ty - b1 * tx1) / n;
            return out.setTo(a2 * out.x + c2 * out.y + tx2, b2 * out.x + d2 * out.y + ty2);
        };
        __proto.transformPoint = function (out) {
            return out.setTo(this.a * out.x + this.c * out.y + this.tx, this.b * out.x + this.d * out.y + this.ty);
        };
        __proto.transformPointN = function (out) {
            return out.setTo(this.a * out.x + this.c * out.y, this.b * out.x + this.d * out.y);
        };
        __proto.transformPointArray = function (data, out) {
            var len = data.length;
            for (var i = 0; i < len; i += 2) {
                var x = data[i], y = data[i + 1];
                out[i] = this.a * x + this.c * y + this.tx;
                out[i + 1] = this.b * x + this.d * y + this.ty;
            }
            return out;
        };
        __proto.transformPointArrayScale = function (data, out) {
            var len = data.length;
            for (var i = 0; i < len; i += 2) {
                var x = data[i], y = data[i + 1];
                out[i] = this.a * x + this.c * y;
                out[i + 1] = this.b * x + this.d * y;
            }
            return out;
        };
        __proto.getScaleX = function () {
            return this.b === 0 ? this.a : Math.sqrt(this.a * this.a + this.b * this.b);
        };
        __proto.getScaleY = function () {
            return this.c === 0 ? this.d : Math.sqrt(this.c * this.c + this.d * this.d);
        };
        __proto.invert = function () {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;
            var tx1 = this.tx;
            var n = a1 * d1 - b1 * c1;
            this.a = d1 / n;
            this.b = -b1 / n;
            this.c = -c1 / n;
            this.d = a1 / n;
            this.tx = (c1 * this.ty - d1 * tx1) / n;
            this.ty = -(a1 * this.ty - b1 * tx1) / n;
            return this;
        };
        __proto.setTo = function (a, b, c, d, tx, ty) {
            this.a = a, this.b = b, this.c = c, this.d = d, this.tx = tx, this.ty = ty;
            return this;
        };
        __proto.concat = function (matrix) {
            var a = this.a;
            var c = this.c;
            var tx = this.tx;
            this.a = a * matrix.a + this.b * matrix.c;
            this.b = a * matrix.b + this.b * matrix.d;
            this.c = c * matrix.a + this.d * matrix.c;
            this.d = c * matrix.b + this.d * matrix.d;
            this.tx = tx * matrix.a + this.ty * matrix.c + matrix.tx;
            this.ty = tx * matrix.b + this.ty * matrix.d + matrix.ty;
            return this;
        };
        __proto.scaleEx = function (x, y) {
            var ba = this.a, bb = this.b, bc = this.c, bd = this.d;
            if (bb !== 0 || bc !== 0) {
                this.a = x * ba;
                this.b = x * bb;
                this.c = y * bc;
                this.d = y * bd;
            }
            else {
                this.a = x * ba;
                this.b = 0 * bd;
                this.c = 0 * ba;
                this.d = y * bd;
            }
            this.bTransform = true;
        };
        __proto.rotateEx = function (angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var ba = this.a, bb = this.b, bc = this.c, bd = this.d;
            if (bb !== 0 || bc !== 0) {
                this.a = cos * ba + sin * bc;
                this.b = cos * bb + sin * bd;
                this.c = -sin * ba + cos * bc;
                this.d = -sin * bb + cos * bd;
            }
            else {
                this.a = cos * ba;
                this.b = sin * bd;
                this.c = -sin * ba;
                this.d = cos * bd;
            }
            this.bTransform = true;
        };
        __proto.clone = function () {
            var dec = Matrix.create();
            dec.a = this.a;
            dec.b = this.b;
            dec.c = this.c;
            dec.d = this.d;
            dec.tx = this.tx;
            dec.ty = this.ty;
            dec.bTransform = this.bTransform;
            return dec;
        };
        __proto.copyTo = function (dec) {
            dec.a = this.a;
            dec.b = this.b;
            dec.c = this.c;
            dec.d = this.d;
            dec.tx = this.tx;
            dec.ty = this.ty;
            dec.bTransform = this.bTransform;
            return dec;
        };
        __proto.toString = function () {
            return this.a + "," + this.b + "," + this.c + "," + this.d + "," + this.tx + "," + this.ty;
        };
        __proto.destroy = function () {
            if (this.inPool)
                return;
            var cache = Matrix._cache;
            this.inPool = true;
            cache._length || (cache._length = 0);
            cache[cache._length++] = this;
            this.a = this.d = 1;
            this.b = this.c = this.tx = this.ty = 0;
            this.bTransform = false;
        };
        Matrix.mul = function (m1, m2, out) {
            var aa = m1.a, ab = m1.b, ac = m1.c, ad = m1.d, atx = m1.tx, aty = m1.ty;
            var ba = m2.a, bb = m2.b, bc = m2.c, bd = m2.d, btx = m2.tx, bty = m2.ty;
            if (bb !== 0 || bc !== 0) {
                out.a = aa * ba + ab * bc;
                out.b = aa * bb + ab * bd;
                out.c = ac * ba + ad * bc;
                out.d = ac * bb + ad * bd;
                out.tx = ba * atx + bc * aty + btx;
                out.ty = bb * atx + bd * aty + bty;
            }
            else {
                out.a = aa * ba;
                out.b = ab * bd;
                out.c = ac * ba;
                out.d = ad * bd;
                out.tx = ba * atx + btx;
                out.ty = bd * aty + bty;
            }
            return out;
        };
        Matrix.mul16 = function (m1, m2, out) {
            var aa = m1.a, ab = m1.b, ac = m1.c, ad = m1.d, atx = m1.tx, aty = m1.ty;
            var ba = m2.a, bb = m2.b, bc = m2.c, bd = m2.d, btx = m2.tx, bty = m2.ty;
            if (bb !== 0 || bc !== 0) {
                out[0] = aa * ba + ab * bc;
                out[1] = aa * bb + ab * bd;
                out[4] = ac * ba + ad * bc;
                out[5] = ac * bb + ad * bd;
                out[12] = ba * atx + bc * aty + btx;
                out[13] = bb * atx + bd * aty + bty;
            }
            else {
                out[0] = aa * ba;
                out[1] = ab * bd;
                out[4] = ac * ba;
                out[5] = ad * bd;
                out[12] = ba * atx + btx;
                out[13] = bd * aty + bty;
            }
            return out;
        };
        Matrix.mulPre = function (m1, ba, bb, bc, bd, btx, bty, out) {
            var aa = m1.a, ab = m1.b, ac = m1.c, ad = m1.d, atx = m1.tx, aty = m1.ty;
            if (bb !== 0 || bc !== 0) {
                out.a = aa * ba + ab * bc;
                out.b = aa * bb + ab * bd;
                out.c = ac * ba + ad * bc;
                out.d = ac * bb + ad * bd;
                out.tx = ba * atx + bc * aty + btx;
                out.ty = bb * atx + bd * aty + bty;
            }
            else {
                out.a = aa * ba;
                out.b = ab * bd;
                out.c = ac * ba;
                out.d = ad * bd;
                out.tx = ba * atx + btx;
                out.ty = bd * aty + bty;
            }
            return out;
        };
        Matrix.mulPos = function (m1, aa, ab, ac, ad, atx, aty, out) {
            var ba = m1.a, bb = m1.b, bc = m1.c, bd = m1.d, btx = m1.tx, bty = m1.ty;
            if (bb !== 0 || bc !== 0) {
                out.a = aa * ba + ab * bc;
                out.b = aa * bb + ab * bd;
                out.c = ac * ba + ad * bc;
                out.d = ac * bb + ad * bd;
                out.tx = ba * atx + bc * aty + btx;
                out.ty = bb * atx + bd * aty + bty;
            }
            else {
                out.a = aa * ba;
                out.b = ab * bd;
                out.c = ac * ba;
                out.d = ad * bd;
                out.tx = ba * atx + btx;
                out.ty = bd * aty + bty;
            }
            return out;
        };
        Matrix.preMul = function (parent, self, out) {
            var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
            var na = self.a, nb = self.b, nc = self.c, nd = self.d, ntx = self.tx, nty = self.ty;
            out.a = na * pa;
            out.b = out.c = 0;
            out.d = nd * pd;
            out.tx = ntx * pa + parent.tx;
            out.ty = nty * pd + parent.ty;
            if (nb !== 0 || nc !== 0 || pb !== 0 || pc !== 0) {
                out.a += nb * pc;
                out.d += nc * pb;
                out.b += na * pb + nb * pd;
                out.c += nc * pa + nd * pc;
                out.tx += nty * pc;
                out.ty += ntx * pb;
            }
            return out;
        };
        Matrix.preMulXY = function (parent, x, y, out) {
            var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
            out.a = pa;
            out.b = pb;
            out.c = pc;
            out.d = pd;
            out.tx = x * pa + parent.tx + y * pc;
            out.ty = y * pd + parent.ty + x * pb;
            return out;
        };
        Matrix.create = function () {
            var cache = Matrix._cache;
            var mat = !cache._length ? (new Matrix()) : cache[--cache._length];
            mat.inPool = false;
            return mat;
        };
        Matrix.EMPTY = new Matrix();
        Matrix.TEMP = new Matrix();
        Matrix._cache = [];
        return Matrix;
    })();
    var Point = (function () {
        function Point(x, y) {
            (x === void 0) && (x = 0);
            (y === void 0) && (y = 0);
            this.x = x;
            this.y = y;
        }
        __class(Point, 'laya.maths.Point');
        var __proto = Point.prototype;
        __proto.setTo = function (x, y) {
            this.x = x;
            this.y = y;
            return this;
        };
        __proto.distance = function (x, y) {
            return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y) * (this.y - y));
        };
        __proto.toString = function () {
            return this.x + "," + this.y;
        };
        __proto.normalize = function () {
            var d = Math.sqrt(this.x * this.x + this.y * this.y);
            if (d > 0) {
                var id = 1.0 / d;
                this.x *= id;
                this.y *= id;
            }
        };
        Point.TEMP = new Point();
        Point.EMPTY = new Point();
        return Point;
    })();
    var Rectangle = (function () {
        function Rectangle(x, y, width, height) {
            (x === void 0) && (x = 0);
            (y === void 0) && (y = 0);
            (width === void 0) && (width = 0);
            (height === void 0) && (height = 0);
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        __class(Rectangle, 'laya.maths.Rectangle');
        var __proto = Rectangle.prototype;
        __proto.setTo = function (x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            return this;
        };
        __proto.copyFrom = function (source) {
            this.x = source.x;
            this.y = source.y;
            this.width = source.width;
            this.height = source.height;
            return this;
        };
        __proto.contains = function (x, y) {
            if (this.width <= 0 || this.height <= 0)
                return false;
            if (x >= this.x && x < this.right) {
                if (y >= this.y && y < this.bottom) {
                    return true;
                }
            }
            return false;
        };
        __proto.intersects = function (rect) {
            return !(rect.x > (this.x + this.width) || (rect.x + rect.width) < this.x || rect.y > (this.y + this.height) || (rect.y + rect.height) < this.y);
        };
        __proto.intersection = function (rect, out) {
            if (!this.intersects(rect))
                return null;
            out || (out = new Rectangle());
            out.x = Math.max(this.x, rect.x);
            out.y = Math.max(this.y, rect.y);
            out.width = Math.min(this.right, rect.right) - out.x;
            out.height = Math.min(this.bottom, rect.bottom) - out.y;
            return out;
        };
        __proto.union = function (source, out) {
            out || (out = new Rectangle());
            this.clone(out);
            if (source.width <= 0 || source.height <= 0)
                return out;
            out.addPoint(source.x, source.y);
            out.addPoint(source.right, source.bottom);
            return this;
        };
        __proto.clone = function (out) {
            out || (out = new Rectangle());
            out.x = this.x;
            out.y = this.y;
            out.width = this.width;
            out.height = this.height;
            return out;
        };
        __proto.toString = function () {
            return this.x + "," + this.y + "," + this.width + "," + this.height;
        };
        __proto.equals = function (rect) {
            if (!rect || rect.x !== this.x || rect.y !== this.y || rect.width !== this.width || rect.height !== this.height)
                return false;
            return true;
        };
        __proto.addPoint = function (x, y) {
            this.x > x && (this.width += this.x - x, this.x = x);
            this.y > y && (this.height += this.y - y, this.y = y);
            if (this.width < x - this.x)
                this.width = x - this.x;
            if (this.height < y - this.y)
                this.height = y - this.y;
            return this;
        };
        __proto._getBoundPoints = function () {
            var rst = Rectangle._temB;
            rst.length = 0;
            if (this.width == 0 || this.height == 0)
                return rst;
            rst.push(this.x, this.y, this.x + this.width, this.y, this.x, this.y + this.height, this.x + this.width, this.y + this.height);
            return rst;
        };
        __proto.isEmpty = function () {
            if (this.width <= 0 || this.height <= 0)
                return true;
            return false;
        };
        __getset(0, __proto, 'right', function () {
            return this.x + this.width;
        });
        __getset(0, __proto, 'bottom', function () {
            return this.y + this.height;
        });
        Rectangle._getBoundPointS = function (x, y, width, height) {
            var rst = Rectangle._temA;
            rst.length = 0;
            if (width == 0 || height == 0)
                return rst;
            rst.push(x, y, x + width, y, x, y + height, x + width, y + height);
            return rst;
        };
        Rectangle._getWrapRec = function (pointList, rst) {
            if (!pointList || pointList.length < 1)
                return rst ? rst.setTo(0, 0, 0, 0) : Rectangle.TEMP.setTo(0, 0, 0, 0);
            rst = rst ? rst : new Rectangle();
            var i, len = pointList.length, minX, maxX, minY, maxY, tPoint = Point.TEMP;
            minX = minY = 99999;
            maxX = maxY = -minX;
            for (i = 0; i < len; i += 2) {
                tPoint.x = pointList[i];
                tPoint.y = pointList[i + 1];
                minX = minX < tPoint.x ? minX : tPoint.x;
                minY = minY < tPoint.y ? minY : tPoint.y;
                maxX = maxX > tPoint.x ? maxX : tPoint.x;
                maxY = maxY > tPoint.y ? maxY : tPoint.y;
            }
            return rst.setTo(minX, minY, maxX - minX, maxY - minY);
        };
        Rectangle.EMPTY = new Rectangle();
        Rectangle.TEMP = new Rectangle();
        Rectangle._temB = [];
        Rectangle._temA = [];
        return Rectangle;
    })();
    var SoundManager = (function () {
        function SoundManager() { }
        __class(SoundManager, 'laya.media.SoundManager');
        __getset(1, SoundManager, 'useAudioMusic', function () {
            return SoundManager._useAudioMusic;
        }, function (value) {
            SoundManager._useAudioMusic = value;
            if (value)
                SoundManager._musicClass = AudioSound;
        });
        __getset(1, SoundManager, 'autoStopMusic', function () {
            return SoundManager._autoStopMusic;
        }, function (v) {
            Laya.stage.off("blur", null, SoundManager._stageOnBlur);
            Laya.stage.off("focus", null, SoundManager._stageOnFocus);
            Laya.stage.off("visibilitychange", null, SoundManager._visibilityChange);
            SoundManager._autoStopMusic = v;
            if (v) {
                Laya.stage.on("blur", null, SoundManager._stageOnBlur);
                Laya.stage.on("focus", null, SoundManager._stageOnFocus);
                Laya.stage.on("visibilitychange", null, SoundManager._visibilityChange);
            }
        });
        __getset(1, SoundManager, 'muted', function () {
            return SoundManager._muted;
        }, function (value) {
            if (value == SoundManager._muted)
                return;
            if (value) {
                SoundManager.stopAllSound();
            }
            SoundManager.musicMuted = value;
            SoundManager._muted = value;
        });
        __getset(1, SoundManager, 'musicMuted', function () {
            return SoundManager._musicMuted;
        }, function (value) {
            if (value == SoundManager._musicMuted)
                return;
            if (value) {
                if (SoundManager._tMusic) {
                    if (SoundManager._musicChannel && !SoundManager._musicChannel.isStopped) {
                        SoundManager._musicChannel.pause();
                    }
                    else {
                        SoundManager._musicChannel = null;
                    }
                }
                else {
                    SoundManager._musicChannel = null;
                }
                SoundManager._musicMuted = value;
            }
            else {
                SoundManager._musicMuted = value;
                if (SoundManager._tMusic) {
                    if (SoundManager._musicChannel) {
                        SoundManager._musicChannel.resume();
                    }
                }
            }
        });
        __getset(1, SoundManager, 'soundMuted', function () {
            return SoundManager._soundMuted;
        }, function (value) {
            SoundManager._soundMuted = value;
        });
        SoundManager.addChannel = function (channel) {
            if (SoundManager._channels.indexOf(channel) >= 0)
                return;
            SoundManager._channels.push(channel);
        };
        SoundManager.removeChannel = function (channel) {
            var i = 0;
            for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                if (SoundManager._channels[i] == channel) {
                    SoundManager._channels.splice(i, 1);
                }
            }
        };
        SoundManager.disposeSoundIfNotUsed = function (url) {
            var i = 0;
            for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                if (SoundManager._channels[i].url == url) {
                    return;
                }
            }
            SoundManager.destroySound(url);
        };
        SoundManager._visibilityChange = function () {
            if (Laya.stage.isVisibility) {
                SoundManager._stageOnFocus();
            }
            else {
                SoundManager._stageOnBlur();
            }
        };
        SoundManager._stageOnBlur = function () {
            SoundManager._isActive = false;
            if (SoundManager._musicChannel) {
                if (!SoundManager._musicChannel.isStopped) {
                    SoundManager._blurPaused = true;
                    SoundManager._musicChannel.pause();
                    Laya.stage.once("mousedown", null, SoundManager._stageOnFocus);
                }
            }
            SoundManager.stopAllSound();
        };
        SoundManager._stageOnFocus = function () {
            SoundManager._isActive = true;
            Laya.stage.off("mousedown", null, SoundManager._stageOnFocus);
            if (SoundManager._blurPaused) {
                if (SoundManager._musicChannel && SoundManager._musicChannel.isStopped) {
                    SoundManager._blurPaused = false;
                    SoundManager._musicChannel.resume();
                }
            }
        };
        SoundManager.playSound = function (url, loops, playbackRate, complete, soundClass, startTime) {
            (loops === void 0) && (loops = 1);
            (startTime === void 0) && (startTime = 0);
            (playbackRate === void 0) && (playbackRate = 1);
            if (!SoundManager._isActive || !url)
                return null;
            if (SoundManager._muted)
                return null;
            url = URL.formatURL(url);
            if (url == SoundManager._tMusic) {
                if (SoundManager._musicMuted)
                    return null;
            }
            else {
                if (Render.isConchApp) {
                    var ext = Utils.getFileExtension(url);
                    if (ext != "wav" && ext != "ogg") {
                        alert("The sound only supports wav or ogg format,for optimal performance reason,please refer to the official website document.");
                        return null;
                    }
                }
                if (SoundManager._soundMuted)
                    return null;
            }
            ;
            var tSound;
            if (!Browser.onMiniGame) {
                tSound = Laya.loader.getRes(url);
            }
            if (!soundClass)
                soundClass = SoundManager._soundClass;
            if (!tSound) {
                tSound = new soundClass();
                tSound.load(url);
                Loader.cacheRes(url, tSound);
            }
            ;
            var channel;
            channel = tSound.play(startTime, loops, playbackRate);
            if (!channel)
                return null;
            tSound.once(EventObject.ERROR, this, function (channel) {
                channel.event(EventObject.ERROR);
            }, [channel]);
            channel.url = url;
            channel.volume = (url == SoundManager._tMusic) ? SoundManager.musicVolume : SoundManager.soundVolume;
            channel.completeHandler = complete;
            return channel;
        };
        SoundManager.destroySound = function (url) {
            var tSound = Laya.loader.getRes(url);
            if (tSound) {
                Loader.clearRes(url);
                tSound.dispose();
            }
        };
        SoundManager.playMusic = function (url, loops, complete, startTime) {
            (loops === void 0) && (loops = 0);
            (startTime === void 0) && (startTime = 0);
            url = URL.formatURL(url);
            SoundManager._tMusic = url;
            if (SoundManager._musicChannel)
                SoundManager._musicChannel.stop();
            return SoundManager._musicChannel = SoundManager.playSound(url, loops, complete, SoundManager._musicClass, startTime);
        };
        SoundManager.stopSound = function (url) {
            url = URL.formatURL(url);
            var i = 0;
            var channel;
            for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                channel = SoundManager._channels[i];
                if (channel.url == url) {
                    channel.stop();
                }
            }
        };
        SoundManager.stopAll = function () {
            SoundManager._tMusic = null;
            var i = 0;
            var channel;
            for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                channel = SoundManager._channels[i];
                channel.stop();
            }
        };
        SoundManager.stopAllSound = function () {
            var i = 0;
            var channel;
            for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                channel = SoundManager._channels[i];
                if (channel.url != SoundManager._tMusic) {
                    channel.stop();
                }
            }
        };
        SoundManager.stopMusic = function () {
            if (SoundManager._musicChannel)
                SoundManager._musicChannel.stop();
            SoundManager._tMusic = null;
        };
        SoundManager.setSoundVolume = function (volume, url) {
            if (url) {
                url = URL.formatURL(url);
                SoundManager._setVolume(url, volume);
            }
            else {
                SoundManager.soundVolume = volume;
                var i = 0;
                var channel;
                for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                    channel = SoundManager._channels[i];
                    if (channel.url != SoundManager._tMusic) {
                        channel.volume = volume;
                    }
                }
            }
        };
        SoundManager.setMusicVolume = function (volume) {
            SoundManager.musicVolume = volume;
            SoundManager._setVolume(SoundManager._tMusic, volume);
        };
        SoundManager._setVolume = function (url, volume) {
            url = URL.formatURL(url);
            var i = 0;
            var channel;
            for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                channel = SoundManager._channels[i];
                if (channel.url == url) {
                    channel.volume = volume;
                }
            }
        };
        SoundManager.musicVolume = 1;
        SoundManager.soundVolume = 1;
        SoundManager.playbackRate = 1;
        SoundManager._useAudioMusic = true;
        SoundManager._muted = false;
        SoundManager._soundMuted = false;
        SoundManager._musicMuted = false;
        SoundManager._tMusic = null;
        SoundManager._musicChannel = null;
        SoundManager._channels = [];
        SoundManager._autoStopMusic = false;
        SoundManager._blurPaused = false;
        SoundManager._isActive = true;
        SoundManager._soundClass = null;
        SoundManager._musicClass = null;
        SoundManager.autoReleaseSound = true;
        return SoundManager;
    })();
    var LocalStorage = (function () {
        var Storage;
        function LocalStorage() { }
        __class(LocalStorage, 'laya.net.LocalStorage');
        LocalStorage.__init__ = function () {
            if (!LocalStorage._baseClass) {
                LocalStorage._baseClass = Storage;
                Storage.init();
            }
            LocalStorage.items = LocalStorage._baseClass.items;
            LocalStorage.support = LocalStorage._baseClass.support;
        };
        LocalStorage.setItem = function (key, value) {
            LocalStorage._baseClass.setItem(key, value);
        };
        LocalStorage.getItem = function (key) {
            return LocalStorage._baseClass.getItem(key);
        };
        LocalStorage.setJSON = function (key, value) {
            LocalStorage._baseClass.setJSON(key, value);
        };
        LocalStorage.getJSON = function (key) {
            return LocalStorage._baseClass.getJSON(key);
        };
        LocalStorage.removeItem = function (key) {
            LocalStorage._baseClass.removeItem(key);
        };
        LocalStorage.clear = function () {
            LocalStorage._baseClass.clear();
        };
        LocalStorage._baseClass = null;
        LocalStorage.items = null;
        LocalStorage.support = false;
        LocalStorage.__init$ = function () {
            Storage = (function () {
                function Storage() { }
                __class(Storage, '');
                Storage.init = function () {
                    try {
                        Storage.items = window.localStorage;
                        Storage.setItem('laya', '1');
                        Storage.removeItem('laya');
                        Storage.support = true;
                    }
                    catch (e) { }
                    if (!Storage.support)
                        console_log('LocalStorage is not supprot or browser is private mode.');
                };
                Storage.setItem = function (key, value) {
                    try {
                        Storage.support && Storage.items.setItem(key, value);
                    }
                    catch (e) {
                        console_warn("set localStorage failed", e);
                    }
                };
                Storage.getItem = function (key) {
                    return Storage.support ? Storage.items.getItem(key) : null;
                };
                Storage.setJSON = function (key, value) {
                    try {
                        Storage.support && Storage.items.setItem(key, JSON.stringify(value));
                    }
                    catch (e) {
                        console_warn("set localStorage failed", e);
                    }
                };
                Storage.getJSON = function (key) {
                    return JSON.parse(Storage.support ? Storage.items.getItem(key) : null);
                };
                Storage.removeItem = function (key) {
                    Storage.support && Storage.items.removeItem(key);
                };
                Storage.clear = function () {
                    Storage.support && Storage.items.clear();
                };
                Storage.items = null;
                Storage.support = false;
                return Storage;
            })();
        };
        return LocalStorage;
    })();
    var ResourceVersion = (function () {
        function ResourceVersion() { }
        __class(ResourceVersion, 'laya.net.ResourceVersion');
        ResourceVersion.enable = function (manifestFile, callback, type) {
            (type === void 0) && (type = 2);
            laya.net.ResourceVersion.type = type;
            Laya.loader.load(manifestFile, Handler.create(null, ResourceVersion.onManifestLoaded, [callback]), null, "json");
            URL.customFormat = ResourceVersion.addVersionPrefix;
        };
        ResourceVersion.onManifestLoaded = function (callback, data) {
            ResourceVersion.manifest = data;
            callback.run();
            if (!data) {
                console_warn("资源版本清单文件不存在，不使用资源版本管理。忽略ERR_FILE_NOT_FOUND错误。");
            }
        };
        ResourceVersion.addVersionPrefix = function (originURL) {
            if (ResourceVersion.manifest && ResourceVersion.manifest[originURL]) {
                if (ResourceVersion.type == 2)
                    return ResourceVersion.manifest[originURL];
                return ResourceVersion.manifest[originURL] + "/" + originURL;
            }
            return originURL;
        };
        ResourceVersion.FOLDER_VERSION = 1;
        ResourceVersion.FILENAME_VERSION = 2;
        ResourceVersion.manifest = null;
        ResourceVersion.type = 1;
        return ResourceVersion;
    })();
    var TTFLoader = (function () {
        function TTFLoader() {
            this.fontName = null;
            this.complete = null;
            this.err = null;
            this._fontTxt = null;
            this._url = null;
            this._div = null;
            this._txtWidth = NaN;
            this._http = null;
        }
        __class(TTFLoader, 'laya.net.TTFLoader');
        var __proto = TTFLoader.prototype;
        __proto.load = function (fontPath) {
            this._url = fontPath;
            var tArr = fontPath.split(".ttf")[0].split("/");
            this.fontName = tArr[tArr.length - 1];
            if (Browser.window.conch) {
                this._loadConch();
            }
            else if (Browser.window.FontFace) {
                this._loadWithFontFace();
            }
            else {
                this._loadWithCSS();
            }
        };
        __proto._loadConch = function () {
            this._http = new HttpRequest();
            this._http.on("error", this, this._onErr);
            this._http.on("complete", this, this._onHttpLoaded);
            this._http.send(this._url, null, "get", "arraybuffer");
        };
        __proto._onHttpLoaded = function (data) {
            Browser.window.conch.setFontFaceFromBuffer(this.fontName, data);
            this._clearHttp();
            this._complete();
        };
        __proto._clearHttp = function () {
            if (this._http) {
                this._http.off("error", this, this._onErr);
                this._http.off("complete", this, this._onHttpLoaded);
                this._http = null;
            }
        };
        __proto._onErr = function () {
            this._clearHttp();
            if (this.err) {
                this.err.runWith("fail:" + this._url);
                this.err = null;
            }
        };
        __proto._complete = function () {
            Laya.timer.clear(this, this._complete);
            Laya.timer.clear(this, this._checkComplete);
            if (this._div && this._div.parentNode) {
                this._div.parentNode.removeChild(this._div);
                this._div = null;
            }
            if (this.complete) {
                this.complete.runWith(this);
                this.complete = null;
            }
        };
        __proto._checkComplete = function () {
            if (RunDriver.measureText("The3TTFFont", this._fontTxt).width != this._txtWidth) {
                this._complete();
            }
        };
        __proto._loadWithFontFace = function () {
            var fontFace = new Browser.window.FontFace(this.fontName, "url('" + this._url + "')");
            Browser.window.document.fonts.add(fontFace);
            var self = this;
            fontFace.loaded.then((function () {
                self._complete();
            }));
            fontFace.load();
        };
        __proto._createDiv = function () {
            this._div = Browser.createElement("div");
            this._div.innerHTML = "laya";
            var _style = this._div.style;
            _style.fontFamily = this.fontName;
            _style.position = "absolute";
            _style.left = "-100px";
            _style.top = "-100px";
            Browser.document.body.appendChild(this._div);
        };
        __proto._loadWithCSS = function () {
            var _$this = this;
            var fontStyle = Browser.createElement("style");
            fontStyle.type = "text/css";
            Browser.document.body.appendChild(fontStyle);
            fontStyle.textContent = "@font-face { font-family:'" + this.fontName + "'; src:url('" + this._url + "');}";
            this._fontTxt = "40px " + this.fontName;
            this._txtWidth = RunDriver.measureText("The3TTFFont", this._fontTxt).width;
            var self = this;
            fontStyle.onload = function () {
                Laya.timer.once(10000, self, _$this._complete);
            };
            Laya.timer.loop(20, this, this._checkComplete);
            this._createDiv();
        };
        TTFLoader._testString = "The3TTFFont";
        return TTFLoader;
    })();
    var URL = (function () {
        function URL(url) {
            this._url = null;
            this._path = null;
            this._url = URL.formatURL(url);
            this._path = URL.getPath(url);
        }
        __class(URL, 'laya.net.URL');
        var __proto = URL.prototype;
        __getset(0, __proto, 'path', function () {
            return this._path;
        });
        __getset(0, __proto, 'url', function () {
            return this._url;
        });
        URL.formatURL = function (url, base) {
            if (!url)
                return "null path";
            if (url.indexOf(":") > 0)
                return url;
            if (URL.customFormat != null)
                url = URL.customFormat(url, base);
            var char1 = url.charAt(0);
            if (char1 === ".") {
                return URL.formatRelativePath((base || URL.basePath) + url);
            }
            else if (char1 === '~') {
                return URL.rootPath + url.substring(1);
            }
            else if (char1 === "d") {
                if (url.indexOf("data:image") === 0)
                    return url;
            }
            else if (char1 === "/") {
                return url;
            }
            return (base || URL.basePath) + url;
        };
        URL.formatRelativePath = function (value) {
            var parts = value.split("/");
            for (var i = 0, len = parts.length; i < len; i++) {
                if (parts[i] == '..') {
                    parts.splice(i - 1, 2);
                    i -= 2;
                }
            }
            return parts.join('/');
        };
        URL.isAbsolute = function (url) {
            return url.indexOf(":") > 0 || url.charAt(0) == '/';
        };
        URL.getPath = function (url) {
            var ofs = url.lastIndexOf('/');
            return ofs > 0 ? url.substr(0, ofs + 1) : "";
        };
        URL.getFileName = function (url) {
            var ofs = url.lastIndexOf('/');
            return ofs > 0 ? url.substr(ofs + 1) : url;
        };
        URL.version = {};
        URL.basePath = "";
        URL.rootPath = "";
        URL.customFormat = function (url) {
            var newUrl = URL.version[url];
            if (!Render.isConchApp && newUrl)
                url += "?v=" + newUrl;
            return url;
        };
        return URL;
    })();
    var Render = (function () {
        function Render(width, height) {
            this._timeId = 0;
            var style = Render._mainCanvas.source.style;
            style.position = 'absolute';
            style.top = style.left = "0px";
            style.background = "#000000";
            Render._mainCanvas.source.id = "gcCanvas";
            var isWebGl = laya.renders.Render.isWebGL;
            Render._mainCanvas.source.width = width;
            Render._mainCanvas.source.height = height;
            isWebGl && Render.WebGL.init(Render._mainCanvas, width, height);
            Browser.container.appendChild(Render._mainCanvas.source);
            Render._context = new RenderContext(width, height, isWebGl ? null : Render._mainCanvas);
            Render._context.ctx.setIsMainContext();
            var callbackBeforeRenderFunc = null;
            if (typeof Callback != "undefined") {
                callbackBeforeRenderFunc = function () {
                    var beforeRenderFuncs = Callback.beforeRenderFuncs.concat();
                    Callback.beforeRenderFuncs.length = 0;
                    for (var i in beforeRenderFuncs) {
                        var cb = beforeRenderFuncs[i];
                        var caller = cb.caller;
                        caller.____clks2.clear();
                    }
                    for (var i in beforeRenderFuncs) {
                        beforeRenderFuncs[i].run();
                    }
                };
            }
            else {
                callbackBeforeRenderFunc = function () { };
            }
            window.___callbackBeforeRenderFunc = callbackBeforeRenderFunc;
            //记录初始时间
            var then = Date.now();
            Browser.window.requestAnimationFrame(loop);
            function loop() {
                var now = Date.now();
                if (Math.round(now * os.fps * 0.001) > Math.round(then * os.fps * 0.001)) {
                    Laya.stage._loop();
                    then = now;
                }
                Browser.window.requestAnimationFrame(loop);
            }
            Laya.stage.on("visibilitychange", this, this._onVisibilitychange);
        }
        __class(Render, 'laya.renders.Render');
        var __proto = Render.prototype;
        __proto._onVisibilitychange = function () {
            if (!Browser.window.setInterval)
                return;
            if (!Laya.stage.isVisibility) {
                this._timeId = Browser.window.setInterval(this._enterFrame, 1000);
            }
            else if (this._timeId != 0) {
                Browser.window.clearInterval(this._timeId);
            }
        };
        __proto._enterFrame = function (e) {
            Laya.stage._loop();
        };
        __getset(1, Render, 'context', function () {
            return Render._context;
        });
        __getset(1, Render, 'canvas', function () {
            return Render._mainCanvas.source;
        });
        Render._context = null;
        Render._mainCanvas = null;
        Render.WebGL = null;
        Render.isConchNode = false;
        Render.isConchApp = false;
        Render.isConchWebGL = false;
        Render.isWebGL = false;
        Render.is3DMode = false;
        Render.optimizeTextureMemory = function (url, texture) {
            return true;
        };
        Render.__init$ = function () {
            window.ConchRenderType = window.ConchRenderType || 1;
            window.ConchRenderType |= (!window.conch ? 0 : 0x04);
            ;
            {
                Render.isConchNode = (window.ConchRenderType & 5) == 5;
                Render.isConchApp = (window.ConchRenderType & 0x04) == 0x04;
                Render.isConchWebGL = window.ConchRenderType == 6;
            }
            ;
            ;
        };
        return Render;
    })();
    var RenderContext = (function () {
        function RenderContext(width, height, canvas) {
            this.x = 0;
            this.y = 0;
            this._drawTexture = function (x, y, args) {
                if (args[0].loaded)
                    this.ctx.drawTexture(args[0], args[1], args[2], args[3], args[4], x, y);
            };
            this._fillTexture = function (x, y, args) {
                if (args[0].loaded)
                    this.ctx.fillTexture(args[0], args[1] + x, args[2] + y, args[3], args[4], args[5], args[6], args[7]);
            };
            this._drawTextureWithTransform = function (x, y, args) {
                if (args[0].loaded)
                    this.ctx.drawTextureWithTransform(args[0], args[1], args[2], args[3], args[4], args[5], x, y, args[6]);
            };
            this._fillQuadrangle = function (x, y, args) {
                this.ctx.fillQuadrangle(args[0], args[1], args[2], args[3], args[4]);
            };
            this._drawRect = function (x, y, args) {
                var ctx = this.ctx;
                if (args[4] != null) {
                    ctx.fillStyle = args[4];
                    ctx.fillRect(x + args[0], y + args[1], args[2], args[3], null);
                }
                if (args[5] != null) {
                    ctx.strokeStyle = args[5];
                    ctx.lineWidth = args[6];
                    ctx.strokeRect(x + args[0], y + args[1], args[2], args[3], args[6]);
                }
            };
            this._drawPie = function (x, y, args) {
                var ctx = this.ctx;
                Render.isWebGL && ctx.setPathId(args[8]);
                ctx.beginPath();
                if (Render.isWebGL) {
                    ctx.movePath(args[0] + x, args[1] + y);
                    ctx.moveTo(0, 0);
                }
                else {
                    ctx.moveTo(x + args[0], y + args[1]);
                }
                ctx.arc(x + args[0], y + args[1], args[2], args[3], args[4]);
                ctx.closePath();
                this._fillAndStroke(args[5], args[6], args[7], true);
            };
            this._clipRect = function (x, y, args) {
                this.ctx.clipRect(x + args[0], y + args[1], args[2], args[3]);
            };
            this._fillRect = function (x, y, args) {
                this.ctx.fillRect(x + args[0], y + args[1], args[2], args[3], args[4]);
            };
            this._drawCircle = function (x, y, args) {
                var ctx = this.ctx;
                Render.isWebGL && ctx.setPathId(args[6]);
                Stat.drawCall++;
                ctx.beginPath();
                Render.isWebGL && ctx.movePath(args[0] + x, args[1] + y);
                ctx.arc(args[0] + x, args[1] + y, args[2], 0, RenderContext.PI2);
                ctx.closePath();
                this._fillAndStroke(args[3], args[4], args[5], true);
            };
            this._fillCircle = function (x, y, args) {
                Stat.drawCall++;
                var ctx = this.ctx;
                ctx.beginPath();
                ctx.fillStyle = args[3];
                ctx.arc(args[0] + x, args[1] + y, args[2], 0, RenderContext.PI2);
                ctx.fill();
            };
            this._setShader = function (x, y, args) {
                this.ctx.setShader(args[0]);
            };
            this._drawLine = function (x, y, args) {
                var ctx = this.ctx;
                Render.isWebGL && ctx.setPathId(args[6]);
                ctx.beginPath();
                ctx.strokeStyle = args[4];
                ctx.lineWidth = args[5];
                if (Render.isWebGL) {
                    ctx.movePath(x, y);
                    ctx.moveTo(args[0], args[1]);
                    ctx.lineTo(args[2], args[3]);
                }
                else {
                    ctx.moveTo(x + args[0], y + args[1]);
                    ctx.lineTo(x + args[2], y + args[3]);
                }
                ctx.stroke();
            };
            this._drawLines = function (x, y, args) {
                var ctx = this.ctx;
                Render.isWebGL && ctx.setPathId(args[5]);
                ctx.beginPath();
                x += args[0], y += args[1];
                Render.isWebGL && ctx.movePath(x, y);
                ctx.strokeStyle = args[3];
                ctx.lineWidth = args[4];
                var points = args[2];
                var i = 2, n = points.length;
                if (Render.isWebGL) {
                    ctx.moveTo(points[0], points[1]);
                    while (i < n) {
                        ctx.lineTo(points[i++], points[i++]);
                    }
                }
                else {
                    ctx.moveTo(x + points[0], y + points[1]);
                    while (i < n) {
                        ctx.lineTo(x + points[i++], y + points[i++]);
                    }
                }
                ctx.stroke();
            };
            this._drawLinesWebGL = function (x, y, args) {
                this.ctx.drawLines(x + this.x + args[0], y + this.y + args[1], args[2], args[3], args[4]);
            };
            this._drawCurves = function (x, y, args) {
                this.ctx.drawCurves(x, y, args);
            };
            this._draw = function (x, y, args) {
                args[0].call(null, this, x, y);
            };
            this._transformByMatrix = function (x, y, args) {
                this.ctx.transformByMatrix(args[0]);
            };
            this._setTransform = function (x, y, args) {
                this.ctx.setTransform(args[0], args[1], args[2], args[3], args[4], args[5]);
            };
            this._setTransformByMatrix = function (x, y, args) {
                this.ctx.setTransformByMatrix(args[0]);
            };
            this._save = function (x, y, args) {
                this.ctx.save();
            };
            this._restore = function (x, y, args) {
                this.ctx.restore();
            };
            this._translate = function (x, y, args) {
                this.ctx.translate(args[0], args[1]);
            };
            this._transform = function (x, y, args) {
                this.ctx.translate(args[1] + x, args[2] + y);
                var mat = args[0];
                this.ctx.transform(mat.a, mat.b, mat.c, mat.d, mat.tx, mat.ty);
                this.ctx.translate(-x - args[1], -y - args[2]);
            };
            this._rotate = function (x, y, args) {
                this.ctx.translate(args[1] + x, args[2] + y);
                this.ctx.rotate(args[0]);
                this.ctx.translate(-x - args[1], -y - args[2]);
            };
            this._scale = function (x, y, args) {
                this.ctx.translate(args[2] + x, args[3] + y);
                this.ctx.scale(args[0], args[1]);
                this.ctx.translate(-x - args[2], -y - args[3]);
            };
            this._alpha = function (x, y, args) {
                this.ctx.globalAlpha *= args[0];
            };
            this._setAlpha = function (x, y, args) {
                this.ctx.globalAlpha = args[0];
            };
            this._fillText = function (x, y, args) {
                this.ctx.fillText(args[0], args[1] + x, args[2] + y, args[3], args[4], args[5]);
            };
            this._strokeText = function (x, y, args) {
                this.ctx.strokeText(args[0], args[1] + x, args[2] + y, args[3], args[4], args[5], args[6]);
            };
            this._fillBorderText = function (x, y, args) {
                this.ctx.fillBorderText(args[0], args[1] + x, args[2] + y, args[3], args[4], args[5], args[6], args[7]);
            };
            this._blendMode = function (x, y, args) {
                this.ctx.globalCompositeOperation = args[0];
            };
            this._beginClip = function (x, y, args) {
                this.ctx.beginClip && this.ctx.beginClip(x + args[0], y + args[1], args[2], args[3]);
            };
            this._setIBVB = function (x, y, args) {
                this.ctx.setIBVB(args[0] + x, args[1] + y, args[2], args[3], args[4], args[5], args[6], args[7]);
            };
            this._fillTrangles = function (x, y, args) {
                this.ctx.fillTrangles(args[0], args[1] + x, args[2] + y, args[3], args[4]);
            };
            this._drawPath = function (x, y, args) {
                var ctx = this.ctx;
                Render.isWebGL && ctx.setPathId(-1);
                ctx.beginPath();
                x += args[0], y += args[1];
                Render.isWebGL && ctx.movePath(x, y);
                var paths = args[2];
                for (var i = 0, n = paths.length; i < n; i++) {
                    var path = paths[i];
                    switch (path[0]) {
                        case "moveTo":
                            Render.isWebGL ? ctx.moveTo(path[1], path[2]) : ctx.moveTo(x + path[1], y + path[2]);
                            break;
                        case "lineTo":
                            Render.isWebGL ? ctx.lineTo(path[1], path[2]) : ctx.lineTo(x + path[1], y + path[2]);
                            break;
                        case "arcTo":
                            Render.isWebGL ? ctx.arcTo(path[1], path[2], path[3], path[4], path[5]) : ctx.arcTo(x + path[1], y + path[2], x + path[3], y + path[4], path[5]);
                            break;
                        case "closePath":
                            ctx.closePath();
                            break;
                    }
                }
                ;
                var brush = args[3];
                if (brush != null) {
                    ctx.fillStyle = brush.fillStyle;
                    ctx.fill();
                }
                ;
                var pen = args[4];
                if (pen != null) {
                    ctx.strokeStyle = pen.strokeStyle;
                    ctx.lineWidth = pen.lineWidth || 1;
                    ctx.lineJoin = pen.lineJoin;
                    ctx.lineCap = pen.lineCap;
                    ctx.miterLimit = pen.miterLimit;
                    ctx.stroke();
                }
            };
            this.drawPoly = function (x, y, args) {
                this.ctx.drawPoly(x + this.x + args[0], y + this.y + args[1], args[2], args[3], args[4], args[5], args[6]);
            };
            this._drawPoly = function (x, y, args) {
                var ctx = this.ctx;
                var points = args[2];
                var i = 2, n = points.length;
                if (Render.isWebGL) {
                    ctx.setPathId(args[6]);
                    ctx.beginPath();
                    x += args[0], y += args[1];
                    ctx.movePath(x, y);
                    ctx.moveTo(points[0], points[1]);
                    while (i < n) {
                        ctx.lineTo(points[i++], points[i++]);
                    }
                }
                else {
                    ctx.beginPath();
                    x += args[0], y += args[1];
                    ctx.moveTo(x + points[0], y + points[1]);
                    while (i < n) {
                        ctx.lineTo(x + points[i++], y + points[i++]);
                    }
                }
                ctx.closePath();
                this._fillAndStroke(args[3], args[4], args[5], args[7]);
            };
            this._drawSkin = function (x, y, args) {
                var tSprite = args[0];
                if (tSprite) {
                    var ctx = this.ctx;
                    tSprite.render(ctx, x, y);
                }
            };
            this._drawParticle = function (x, y, args) {
                this.ctx.drawParticle(x + this.x, y + this.y, args[0]);
            };
            this._setFilters = function (x, y, args) {
                this.ctx.setFilters(args);
            };
            if (canvas) {
                this.ctx = canvas.getContext('2d');
            }
            else {
                canvas = HTMLCanvas.create("3D");
                this.ctx = RunDriver.createWebGLContext2D(canvas);
                canvas._setContext(this.ctx);
            }
            canvas.size(width, height);
            this.canvas = canvas;
        }
        __class(RenderContext, 'laya.renders.RenderContext');
        var __proto = RenderContext.prototype;
        __proto.destroy = function () {
            if (this.canvas) {
                this.canvas.destroy();
                this.canvas = null;
                this.ctx = null;
            }
            if (this.ctx) {
                this.ctx.destroy();
                this.ctx = null;
            }
        };
        __proto.drawTexture = function (tex, x, y, width, height) {
            if (tex.loaded)
                this.ctx.drawTexture(tex, x, y, width, height, this.x, this.y);
        };
        __proto._drawTextures = function (x, y, args) {
            if (args[0].loaded)
                this.ctx.drawTextures(args[0], args[1], x + this.x, y + this.y);
        };
        __proto.drawTextureWithTransform = function (tex, x, y, width, height, m, alpha) {
            if (tex.loaded)
                this.ctx.drawTextureWithTransform(tex, x, y, width, height, m, this.x, this.y, alpha);
        };
        __proto.fillQuadrangle = function (tex, x, y, point4, m) {
            this.ctx.fillQuadrangle(tex, x, y, point4, m);
        };
        __proto.drawCanvas = function (canvas, x, y, width, height) {
            this.ctx.drawCanvas(canvas, x + this.x, y + this.y, width, height);
        };
        __proto.drawRect = function (x, y, width, height, color, lineWidth) {
            (lineWidth === void 0) && (lineWidth = 1);
            var ctx = this.ctx;
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.strokeRect(x + this.x, y + this.y, width, height, lineWidth);
        };
        __proto._fillAndStroke = function (fillColor, strokeColor, lineWidth, isConvexPolygon) {
            (isConvexPolygon === void 0) && (isConvexPolygon = false);
            var ctx = this.ctx;
            if (fillColor != null) {
                ctx.fillStyle = fillColor;
                if (Render.isWebGL) {
                    ctx.fill(isConvexPolygon);
                }
                else {
                    ctx.fill();
                }
            }
            if (strokeColor != null && lineWidth > 0) {
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = lineWidth;
                ctx.stroke();
            }
        };
        __proto.clipRect = function (x, y, width, height) {
            this.ctx.clipRect(x + this.x, y + this.y, width, height);
        };
        __proto.fillRect = function (x, y, width, height, fillStyle) {
            this.ctx.fillRect(x + this.x, y + this.y, width, height, fillStyle);
        };
        __proto.drawCircle = function (x, y, radius, color, lineWidth) {
            (lineWidth === void 0) && (lineWidth = 1);
            Stat.drawCall++;
            var ctx = this.ctx;
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.arc(x + this.x, y + this.y, radius, 0, RenderContext.PI2);
            ctx.stroke();
        };
        __proto.drawTriangles = function (x, y, args) {
            if (Render.isWebGL) {
                this.ctx.drawTriangles(args[0], x + args[1], y + args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
            }
            else {
                var indices = args[5];
                var i = 0, len = indices.length;
                var ctx = this.ctx;
                for (i = 0; i < len; i += 3) {
                    var index0 = indices[i] * 2;
                    var index1 = indices[i + 1] * 2;
                    var index2 = indices[i + 2] * 2;
                    ctx.drawTriangle(args[0], args[3], args[4], index0, index1, index2, args[6], true);
                }
            }
        };
        __proto.fillCircle = function (x, y, radius, color) {
            Stat.drawCall++;
            var ctx = this.ctx;
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.arc(x + this.x, y + this.y, radius, 0, RenderContext.PI2);
            ctx.fill();
        };
        __proto.setShader = function (shader) {
            this.ctx.setShader(shader);
        };
        __proto.drawLine = function (fromX, fromY, toX, toY, color, lineWidth) {
            (lineWidth === void 0) && (lineWidth = 1);
            var ctx = this.ctx;
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.moveTo(this.x + fromX, this.y + fromY);
            ctx.lineTo(this.x + toX, this.y + toY);
            ctx.stroke();
        };
        __proto.clear = function () {
            this.ctx.clear();
        };
        __proto.transformByMatrix = function (value) {
            this.ctx.transformByMatrix(value);
        };
        __proto.setTransform = function (a, b, c, d, tx, ty) {
            this.ctx.setTransform(a, b, c, d, tx, ty);
        };
        __proto.setTransformByMatrix = function (value) {
            this.ctx.setTransformByMatrix(value);
        };
        __proto.save = function () {
            this.ctx.save();
        };
        __proto.restore = function () {
            this.ctx.restore();
        };
        __proto.translate = function (x, y) {
            this.ctx.translate(x, y);
        };
        __proto.transform = function (a, b, c, d, tx, ty) {
            this.ctx.transform(a, b, c, d, tx, ty);
        };
        __proto.rotate = function (angle) {
            this.ctx.rotate(angle);
        };
        __proto.scale = function (scaleX, scaleY) {
            this.ctx.scale(scaleX, scaleY);
        };
        __proto.alpha = function (value) {
            this.ctx.globalAlpha *= value;
        };
        __proto.setAlpha = function (value) {
            this.ctx.globalAlpha = value;
        };
        __proto.fillWords = function (words, x, y, font, color, underLine) {
            (underLine === void 0) && (underLine = 0);
            this.ctx.fillWords(words, x, y, font, color, underLine);
        };
        __proto.fillBorderWords = function (words, x, y, font, fillColor, borderColor, lineWidth) {
            this.ctx.fillBorderWords(words, x, y, font, fillColor, borderColor, lineWidth);
        };
        __proto.fillText = function (text, x, y, font, color, textAlign) {
            this.ctx.fillText(text, x + this.x, y + this.y, font, color, textAlign);
        };
        __proto.strokeText = function (text, x, y, font, color, lineWidth, textAlign) {
            this.ctx.strokeText(text, x + this.x, y + this.y, font, color, lineWidth, textAlign);
        };
        __proto.blendMode = function (type) {
            this.ctx.globalCompositeOperation = type;
        };
        __proto.flush = function () {
            this.ctx.flush && this.ctx.flush();
        };
        __proto.addRenderObject = function (o) {
            this.ctx.addRenderObject(o);
        };
        __proto.beginClip = function (x, y, w, h) {
            this.ctx.beginClip && this.ctx.beginClip(x, y, w, h);
        };
        __proto.endClip = function () {
            this.ctx.endClip && this.ctx.endClip();
        };
        __proto.fillTrangles = function (x, y, args) {
            this.ctx.fillTrangles(args[0], args[1], args[2], args[3], args.length > 4 ? args[4] : null);
        };
        RenderContext.PI2 = 2 * Math.PI;
        return RenderContext;
    })();
    var RenderSprite = (function () {
        function RenderSprite(type, next) {
            this._next = next || RenderSprite.NORENDER;
            switch (type) {
                case 0:
                    this._fun = this._no;
                    return;
                case 0x01:
                    this._fun = this._image;
                    return;
                case 0x02:
                    this._fun = this._alpha;
                    return;
                case 0x04:
                    this._fun = this._transform;
                    return;
                case 0x08:
                    this._fun = this._blend;
                    return;
                case 0x10:
                    this._fun = this._canvas;
                    return;
                case 0x40:
                    this._fun = this._mask;
                    return;
                case 0x80:
                    this._fun = this._clip;
                    return;
                case 0x100:
                    this._fun = this._style;
                    return;
                case 0x200:
                    this._fun = this._graphics;
                    return;
                case 0x800:
                    this._fun = this._childs;
                    return;
                case 0x400:
                    this._fun = this._custom;
                    return;
                case 0x01 | 0x200:
                    this._fun = this._image2;
                    return;
                case 0x01 | 0x04 | 0x200:
                    this._fun = this._image2;
                    return;
                case 0x20:
                    this._fun = Filter._filter;
                    return;
                case 0x11111:
                    this._fun = RenderSprite._initRenderFun;
                    return;
            }
            this.onCreate(type);
        }
        __class(RenderSprite, 'laya.renders.RenderSprite');
        var __proto = RenderSprite.prototype;
        __proto.onCreate = function (type) { };
        __proto._style = function (sprite, context, x, y) {
            sprite._style.render(sprite, context, x, y);
            var next = this._next;
            next._fun.call(next, sprite, context, x, y);
        };
        __proto._no = function (sprite, context, x, y) { };
        __proto._custom = function (sprite, context, x, y) {
            sprite.customRender(context, x, y);
            var tf = sprite._style._tf;
            this._next._fun.call(this._next, sprite, context, x - tf.translateX, y - tf.translateY);
        };
        __proto._clip = function (sprite, context, x, y) {
            var next = this._next;
            if (next == RenderSprite.NORENDER)
                return;
            var r = sprite._style.scrollRect;
            context.ctx.save();
            context.ctx.clipRect(x, y, r.width, r.height);
            next._fun.call(next, sprite, context, x - r.x, y - r.y);
            context.ctx.restore();
        };
        __proto._blend = function (sprite, context, x, y) {
            var style = sprite._style;
            if (style.blendMode) {
                context.ctx.globalCompositeOperation = style.blendMode;
            }
            ;
            var next = this._next;
            next._fun.call(next, sprite, context, x, y);
            context.ctx.globalCompositeOperation = "source-over";
        };
        __proto._mask = function (sprite, context, x, y) {
            var next = this._next;
            next._fun.call(next, sprite, context, x, y);
            var mask = sprite.mask;
            if (mask) {
                context.ctx.globalCompositeOperation = "destination-in";
                if (mask.numChildren > 0 || !mask.graphics._isOnlyOne()) {
                    mask.cacheAsBitmap = true;
                }
                mask.render(context, x - sprite.pivotX, y - sprite.pivotY);
            }
            context.ctx.globalCompositeOperation = "source-over";
        };
        __proto._graphics = function (sprite, context, x, y) {
            var tf = sprite._style._tf;
            sprite._graphics && sprite._graphics._render(sprite, context, x - tf.translateX, y - tf.translateY);
            var next = this._next;
            next._fun.call(next, sprite, context, x, y);
        };
        __proto._image = function (sprite, context, x, y) {
            var style = sprite._style;
            context.ctx.drawTexture2(x, y, style._tf.translateX, style._tf.translateY, sprite.transform, style.alpha, style.blendMode, sprite._graphics._one);
        };
        __proto._image2 = function (sprite, context, x, y) {
            var tf = sprite._style._tf;
            context.ctx.drawTexture2(x, y, tf.translateX, tf.translateY, sprite.transform, 1, null, sprite._graphics._one);
        };
        __proto._alpha = function (sprite, context, x, y) {
            var style = sprite._style;
            var alpha;
            if ((alpha = style.alpha) > 0.01 || sprite._needRepaint()) {
                var temp = context.ctx.globalAlpha;
                context.ctx.globalAlpha *= alpha;
                var next = this._next;
                next._fun.call(next, sprite, context, x, y);
                context.ctx.globalAlpha = temp;
            }
        };
        __proto._transform = function (sprite, context, x, y) {
            var transform = sprite.transform, _next = this._next;
            if (transform && _next != RenderSprite.NORENDER) {
                context.save();
                context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx + x, transform.ty + y);
                _next._fun.call(_next, sprite, context, 0, 0);
                context.restore();
            }
            else
                _next._fun.call(_next, sprite, context, x, y);
        };
        __proto._childs = function (sprite, context, x, y) {
            var style = sprite._style;
            var tf = style._tf;
            x = x - tf.translateX + style.paddingLeft;
            y = y - tf.translateY + style.paddingTop;
            if (style._calculation) {
                var words = sprite._getWords();
                if (words) {
                    var tStyle = style;
                    if (tStyle) {
                        if (tStyle.stroke) {
                            context.fillBorderWords(words, x, y, tStyle.font, tStyle.color, tStyle.strokeColor, tStyle.stroke);
                        }
                        else {
                            context.fillWords(words, x, y, tStyle.font, tStyle.color, tStyle.underLine);
                        }
                    }
                }
            }
            ;
            var childs = sprite._childs, n = childs.length, ele;
            if (sprite.viewport || (sprite.optimizeScrollRect && sprite._style.scrollRect)) {
                var rect = sprite.viewport || sprite._style.scrollRect;
                var left = rect.x;
                var top = rect.y;
                var right = rect.right;
                var bottom = rect.bottom;
                var _x = NaN, _y = NaN;
                for (i = 0; i < n; ++i) {
                    if ((ele = childs[i]).visible && ((_x = ele._x) < right && (_x + ele.width) > left && (_y = ele._y) < bottom && (_y + ele.height) > top)) {
                        ele.render(context, x, y);
                    }
                }
            }
            else {
                for (var i = 0; i < n; ++i)
                    (ele = (childs[i]))._style.visible && ele.render(context, x, y);
            }
        };
        __proto._canvas = function (sprite, context, x, y) {
            var _cacheCanvas = sprite._$P.cacheCanvas;
            if (!_cacheCanvas) {
                this._next._fun.call(this._next, sprite, context, x, y);
                return;
            }
            _cacheCanvas.type === 'bitmap' ? (Stat.canvasBitmap++) : (Stat.canvasNormal++);
            var tx = _cacheCanvas.ctx;
            if (sprite._needRepaint() || !tx) {
                this._canvas_repaint(sprite, context, x, y);
            }
            else {
                var tRec = _cacheCanvas._cacheRec;
                context.drawCanvas(tx.canvas, x + tRec.x, y + tRec.y, tRec.width, tRec.height);
            }
        };
        __proto._canvas_repaint = function (sprite, context, x, y) {
            var _cacheCanvas = sprite._$P.cacheCanvas;
            var _next = this._next;
            if (!_cacheCanvas) {
                _next._fun.call(_next, sprite, tx, x, y);
                return;
            }
            ;
            var tx = _cacheCanvas.ctx;
            var _repaint = sprite._needRepaint() || (!tx);
            var canvas;
            var left;
            var top;
            var tRec;
            var tCacheType = _cacheCanvas.type;
            tCacheType === 'bitmap' ? (Stat.canvasBitmap++) : (Stat.canvasNormal++);
            if (_repaint) {
                if (!_cacheCanvas._cacheRec)
                    _cacheCanvas._cacheRec = new Rectangle();
                var w, h;
                if (!Render.isWebGL || tCacheType === "bitmap") {
                    tRec = sprite.getSelfBounds();
                    tRec.x = tRec.x - sprite.pivotX;
                    tRec.y = tRec.y - sprite.pivotY;
                    tRec.x = tRec.x - 16;
                    tRec.y = tRec.y - 16;
                    tRec.width = tRec.width + 32;
                    tRec.height = tRec.height + 32;
                    tRec.x = Math.floor(tRec.x + x) - x;
                    tRec.y = Math.floor(tRec.y + y) - y;
                    tRec.width = Math.floor(tRec.width);
                    tRec.height = Math.floor(tRec.height);
                    _cacheCanvas._cacheRec.copyFrom(tRec);
                }
                else {
                    _cacheCanvas._cacheRec.setTo(-sprite.pivotX, -sprite.pivotY, 1, 1);
                }
                tRec = _cacheCanvas._cacheRec;
                var scaleX = Render.isWebGL ? 1 : Browser.pixelRatio * Laya.stage.clientScaleX;
                var scaleY = Render.isWebGL ? 1 : Browser.pixelRatio * Laya.stage.clientScaleY;
                if (!Render.isWebGL) {
                    var chainScaleX = 1;
                    var chainScaleY = 1;
                    var tar;
                    tar = sprite;
                    while (tar && tar != Laya.stage) {
                        chainScaleX *= tar.scaleX;
                        chainScaleY *= tar.scaleY;
                        tar = tar.parent;
                    }
                    if (Render.isWebGL) {
                        if (chainScaleX < 1)
                            scaleX *= chainScaleX;
                        if (chainScaleY < 1)
                            scaleY *= chainScaleY;
                    }
                    else {
                        if (chainScaleX > 1)
                            scaleX *= chainScaleX;
                        if (chainScaleY > 1)
                            scaleY *= chainScaleY;
                    }
                }
                if (sprite.scrollRect) {
                    var scrollRect = sprite.scrollRect;
                    tRec.x -= scrollRect.x;
                    tRec.y -= scrollRect.y;
                }
                w = tRec.width * scaleX;
                h = tRec.height * scaleY;
                left = tRec.x;
                top = tRec.y;
                if (Render.isWebGL && tCacheType === 'bitmap' && (w > 4096 || h > 4096)) {
                    console_warn("cache bitmap size larger than 2048,cache ignored");
                    if (_cacheCanvas.ctx) {
                        Pool.recover("RenderContext", _cacheCanvas.ctx);
                        _cacheCanvas.ctx.canvas.size(0, 0);
                        _cacheCanvas.ctx = null;
                    }
                    _next._fun.call(_next, sprite, context, x, y);
                    return;
                }
                if (!tx) {
                    tx = _cacheCanvas.ctx = Pool.getItem("RenderContext") || new RenderContext(w, h, HTMLCanvas.create("AUTO"));
                }
                tx.ctx.sprite = sprite;
                canvas = tx.canvas;
                canvas.clear();
                (canvas.width != w || canvas.height != h) && canvas.size(w, h);
                if (tCacheType === 'bitmap')
                    canvas.context.asBitmap = true;
                else if (tCacheType === 'normal')
                    canvas.context.asBitmap = false;
                var t;
                if (scaleX != 1 || scaleY != 1) {
                    var ctx = (tx).ctx;
                    ctx.save();
                    ctx.scale(scaleX, scaleY);
                    if (!Render.isConchWebGL && Render.isConchApp) {
                        t = sprite._$P.cf;
                        t && ctx.setFilterMatrix && ctx.setFilterMatrix(t._mat, t._alpha);
                    }
                    _next._fun.call(_next, sprite, tx, -left, -top);
                    ctx.restore();
                    if (!Render.isConchApp || Render.isConchWebGL)
                        sprite._applyFilters();
                }
                else {
                    ctx = (tx).ctx;
                    if (!Render.isConchWebGL && Render.isConchApp) {
                        t = sprite._$P.cf;
                        t && ctx.setFilterMatrix && ctx.setFilterMatrix(t._mat, t._alpha);
                    }
                    _next._fun.call(_next, sprite, tx, -left, -top);
                    if (!Render.isConchApp || Render.isConchWebGL)
                        sprite._applyFilters();
                }
                if (sprite._$P.staticCache)
                    _cacheCanvas.reCache = false;
                Stat.canvasReCache++;
            }
            else {
                tRec = _cacheCanvas._cacheRec;
                left = tRec.x;
                top = tRec.y;
                canvas = tx.canvas;
            }
            context.drawCanvas(canvas, x + left, y + top, tRec.width, tRec.height);
        };
        RenderSprite.__init__ = function () {
            var i = 0, len = 0;
            var initRender;
            initRender = RunDriver.createRenderSprite(0x11111, null);
            len = RenderSprite.renders.length = 0x800 * 2;
            for (i = 0; i < len; i++)
                RenderSprite.renders[i] = initRender;
            RenderSprite.renders[0] = RunDriver.createRenderSprite(0, null);
            function _initSame(value, o) {
                var n = 0;
                for (var i = 0; i < value.length; i++) {
                    n |= value[i];
                    RenderSprite.renders[n] = o;
                }
            }
            _initSame([0x01, 0x200, 0x04, 0x02], new RenderSprite(0x01, null));
            RenderSprite.renders[0x01 | 0x200] = RunDriver.createRenderSprite(0x01 | 0x200, null);
            RenderSprite.renders[0x01 | 0x04 | 0x200] = new RenderSprite(0x01 | 0x04 | 0x200, null);
        };
        RenderSprite._initRenderFun = function (sprite, context, x, y) {
            var type = sprite._renderType;
            var r = RenderSprite.renders[type] = RenderSprite._getTypeRender(type);
            r._fun(sprite, context, x, y);
        };
        RenderSprite._getTypeRender = function (type) {
            var rst = null;
            var tType = 0x800;
            while (tType > 1) {
                if (tType & type)
                    rst = RunDriver.createRenderSprite(tType, rst);
                tType = tType >> 1;
            }
            return rst;
        };
        RenderSprite.IMAGE = 0x01;
        RenderSprite.ALPHA = 0x02;
        RenderSprite.TRANSFORM = 0x04;
        RenderSprite.BLEND = 0x08;
        RenderSprite.CANVAS = 0x10;
        RenderSprite.FILTERS = 0x20;
        RenderSprite.MASK = 0x40;
        RenderSprite.CLIP = 0x80;
        RenderSprite.STYLE = 0x100;
        RenderSprite.GRAPHICS = 0x200;
        RenderSprite.CUSTOM = 0x400;
        RenderSprite.CHILDS = 0x800;
        RenderSprite.INIT = 0x11111;
        RenderSprite.renders = [];
        RenderSprite.NORENDER = new RenderSprite(0, null);
        return RenderSprite;
    })();
    var Context = (function () {
        function Context() {
            this._repaint = false;
        }
        __class(Context, 'laya.resource.Context');
        var __proto = Context.prototype;
        __proto.replaceReset = function () {
            var i = 0, len = 0;
            len = Context.replaceKeys.length;
            var key;
            for (i = 0; i < len; i++) {
                key = Context.replaceKeys[i];
                this[Context.newKeys[i]] = this[key];
            }
        };
        __proto.replaceResotre = function () {
            this.__restore();
            this.__reset();
        };
        __proto.setIsMainContext = function () { };
        __proto.drawTextures = function (tex, pos, tx, ty) {
            Stat.drawCall += pos.length / 2;
            var w = tex.width;
            var h = tex.height;
            for (var i = 0, sz = pos.length; i < sz; i += 2) {
                this.drawTexture(tex, pos[i], pos[i + 1], w, h, tx, ty);
            }
        };
        __proto.drawCanvas = function (canvas, x, y, width, height) {
            Stat.drawCall++;
            this.drawImage(canvas.source, x, y, width, height);
        };
        __proto.fillRect = function (x, y, width, height, style) {
            Stat.drawCall++;
            style && (this.fillStyle = style);
            this.__fillRect(x, y, width, height);
        };
        __proto.fillText = function (text, x, y, font, color, textAlign) {
            Stat.drawCall++;
            if (arguments.length > 3 && font != null) {
                this.font = font;
                this.fillStyle = color;
                this.textAlign = textAlign;
                this.textBaseline = "top";
            }
            this.__fillText(text, x, y);
        };
        __proto.fillBorderText = function (text, x, y, font, fillColor, borderColor, lineWidth, textAlign) {
            Stat.drawCall++;
            this.font = font;
            this.fillStyle = fillColor;
            this.textBaseline = "top";
            this.strokeStyle = borderColor;
            this.lineWidth = lineWidth;
            this.textAlign = textAlign;
            this.__strokeText(text, x, y);
            this.__fillText(text, x, y);
        };
        __proto.strokeText = function (text, x, y, font, color, lineWidth, textAlign) {
            Stat.drawCall++;
            if (arguments.length > 3 && font != null) {
                this.font = font;
                this.strokeStyle = color;
                this.lineWidth = lineWidth;
                this.textAlign = textAlign;
                this.textBaseline = "top";
            }
            this.__strokeText(text, x, y);
        };
        __proto.transformByMatrix = function (value) {
            this.transform(value.a, value.b, value.c, value.d, value.tx, value.ty);
        };
        __proto.setTransformByMatrix = function (value) {
            this.setTransform(value.a, value.b, value.c, value.d, value.tx, value.ty);
        };
        __proto.clipRect = function (x, y, width, height) {
            Stat.drawCall++;
            this.beginPath();
            this.rect(x, y, width, height);
            this.clip();
        };
        __proto.drawTexture = function (tex, x, y, width, height, tx, ty) {
            Stat.drawCall++;
            var uv = tex.uv, w = tex.bitmap.width, h = tex.bitmap.height;
            this.drawImage(tex.source, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h, x + tx, y + ty, width, height);
        };
        __proto.drawTextureWithTransform = function (tex, x, y, width, height, m, tx, ty, alpha) {
            Stat.drawCall++;
            var uv = tex.uv, w = tex.bitmap.width, h = tex.bitmap.height;
            this.save();
            alpha != 1 && (this.globalAlpha *= alpha);
            if (m) {
                this.transform(m.a, m.b, m.c, m.d, m.tx + tx, m.ty + ty);
                this.drawImage(tex.source, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h, x, y, width, height);
            }
            else {
                this.drawImage(tex.source, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h, x + tx, y + ty, width, height);
            }
            this.restore();
        };
        __proto.drawTexture2 = function (x, y, pivotX, pivotY, m, alpha, blendMode, args2) {
            'use strict';
            var tex = args2[0];
            if (!(tex.loaded && tex.bitmap && tex.source)) {
                return;
            }
            Stat.drawCall++;
            var alphaChanged = alpha !== 1;
            if (alphaChanged) {
                var temp = this.globalAlpha;
                this.globalAlpha *= alpha;
            }
            ;
            var uv = tex.uv, w = tex.bitmap.width, h = tex.bitmap.height;
            if (m) {
                this.save();
                this.transform(m.a, m.b, m.c, m.d, m.tx + x, m.ty + y);
                this.drawImage(tex.source, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h, args2[1] - pivotX, args2[2] - pivotY, args2[3], args2[4]);
                this.restore();
            }
            else {
                this.drawImage(tex.source, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h, args2[1] - pivotX + x, args2[2] - pivotY + y, args2[3], args2[4]);
            }
            if (alphaChanged)
                this.globalAlpha = temp;
        };
        __proto.fillTexture = function (texture, x, y, width, height, type, offset, other) {
            if (!other.pat) {
                if (texture.uv != Texture.DEF_UV) {
                    var canvas = new HTMLCanvas("2D");
                    canvas.getContext('2d');
                    canvas.size(texture.width, texture.height);
                    canvas.context.drawTexture(texture, 0, 0, texture.width, texture.height, 0, 0);
                    texture = new Texture(canvas);
                }
                other.pat = this.createPattern(texture.bitmap.source, type);
            }
            ;
            var oX = x, oY = y;
            var sX = 0, sY = 0;
            if (offset) {
                oX += offset.x % texture.width;
                oY += offset.y % texture.height;
                sX -= offset.x % texture.width;
                sY -= offset.y % texture.height;
            }
            this.translate(oX, oY);
            this.fillRect(sX, sY, width, height, other.pat);
            this.translate(-oX, -oY);
        };
        __proto.drawTriangle = function (texture, vertices, uvs, index0, index1, index2, matrix, canvasPadding) {
            var source = texture.bitmap;
            var textureSource = source.source;
            var textureWidth = texture.width;
            var textureHeight = texture.height;
            var sourceWidth = source.width;
            var sourceHeight = source.height;
            var u0 = uvs[index0] * sourceWidth;
            var u1 = uvs[index1] * sourceWidth;
            var u2 = uvs[index2] * sourceWidth;
            var v0 = uvs[index0 + 1] * sourceHeight;
            var v1 = uvs[index1 + 1] * sourceHeight;
            var v2 = uvs[index2 + 1] * sourceHeight;
            var x0 = vertices[index0];
            var x1 = vertices[index1];
            var x2 = vertices[index2];
            var y0 = vertices[index0 + 1];
            var y1 = vertices[index1 + 1];
            var y2 = vertices[index2 + 1];
            if (canvasPadding) {
                var paddingX = 1;
                var paddingY = 1;
                var centerX = (x0 + x1 + x2) / 3;
                var centerY = (y0 + y1 + y2) / 3;
                var normX = x0 - centerX;
                var normY = y0 - centerY;
                var dist = Math.sqrt((normX * normX) + (normY * normY));
                x0 = centerX + ((normX / dist) * (dist + paddingX));
                y0 = centerY + ((normY / dist) * (dist + paddingY));
                normX = x1 - centerX;
                normY = y1 - centerY;
                dist = Math.sqrt((normX * normX) + (normY * normY));
                x1 = centerX + ((normX / dist) * (dist + paddingX));
                y1 = centerY + ((normY / dist) * (dist + paddingY));
                normX = x2 - centerX;
                normY = y2 - centerY;
                dist = Math.sqrt((normX * normX) + (normY * normY));
                x2 = centerX + ((normX / dist) * (dist + paddingX));
                y2 = centerY + ((normY / dist) * (dist + paddingY));
            }
            this.save();
            if (matrix)
                this.transform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
            this.beginPath();
            this.moveTo(x0, y0);
            this.lineTo(x1, y1);
            this.lineTo(x2, y2);
            this.closePath();
            this.clip();
            var delta = (u0 * v1) + (v0 * u2) + (u1 * v2) - (v1 * u2) - (v0 * u1) - (u0 * v2);
            var dDelta = 1 / delta;
            var deltaA = (x0 * v1) + (v0 * x2) + (x1 * v2) - (v1 * x2) - (v0 * x1) - (x0 * v2);
            var deltaB = (u0 * x1) + (x0 * u2) + (u1 * x2) - (x1 * u2) - (x0 * u1) - (u0 * x2);
            var deltaC = (u0 * v1 * x2) + (v0 * x1 * u2) + (x0 * u1 * v2) - (x0 * v1 * u2) - (v0 * u1 * x2) - (u0 * x1 * v2);
            var deltaD = (y0 * v1) + (v0 * y2) + (y1 * v2) - (v1 * y2) - (v0 * y1) - (y0 * v2);
            var deltaE = (u0 * y1) + (y0 * u2) + (u1 * y2) - (y1 * u2) - (y0 * u1) - (u0 * y2);
            var deltaF = (u0 * v1 * y2) + (v0 * y1 * u2) + (y0 * u1 * v2) - (y0 * v1 * u2) - (v0 * u1 * y2) - (u0 * y1 * v2);
            this.transform(deltaA * dDelta, deltaD * dDelta, deltaB * dDelta, deltaE * dDelta, deltaC * dDelta, deltaF * dDelta);
            this.drawImage(textureSource, texture.uv[0] * sourceWidth, texture.uv[1] * sourceHeight, textureWidth, textureHeight, texture.uv[0] * sourceWidth, texture.uv[1] * sourceHeight, textureWidth, textureHeight);
            this.restore();
        };
        __proto.flush = function () {
            return 0;
        };
        __proto.fillWords = function (words, x, y, font, color, underLine) {
            font && (this.font = font);
            color && (this.fillStyle = color);
            var _this = this;
            this.textBaseline = "top";
            this.textAlign = 'left';
            for (var i = 0, n = words.length; i < n; i++) {
                var a = words[i];
                this.__fillText(a.char, a.x + x, a.y + y);
                if (underLine === 1) {
                    var tHeight = a.height;
                    var dX = a.style.letterSpacing * 0.5;
                    if (!dX)
                        dX = 0;
                    this.beginPath();
                    this.strokeStyle = color;
                    this.lineWidth = 1;
                    this.moveTo(x + a.x - dX + 0.5, y + a.y + tHeight + 0.5);
                    this.lineTo(x + a.x + a.width + dX + 0.5, y + a.y + tHeight + 0.5);
                    this.stroke();
                }
            }
        };
        __proto.fillBorderWords = function (words, x, y, font, color, borderColor, lineWidth) {
            font && (this.font = font);
            color && (this.fillStyle = color);
            this.textBaseline = "top";
            this.lineWidth = lineWidth;
            this.textAlign = 'left';
            this.strokeStyle = borderColor;
            for (var i = 0, n = words.length; i < n; i++) {
                var a = words[i];
                this.__strokeText(a.char, a.x + x, a.y + y);
                this.__fillText(a.char, a.x + x, a.y + y);
            }
        };
        __proto.destroy = function () {
            this.canvas.width = this.canvas.height = 0;
        };
        __proto.clear = function () {
            this.clearRect(0, 0, this._canvas.width, this._canvas.height);
            this._repaint = false;
        };
        __proto.drawCurves = function (x, y, args) {
            this.beginPath();
            this.strokeStyle = args[3];
            this.lineWidth = args[4];
            var points = args[2];
            x += args[0], y += args[1];
            this.moveTo(x + points[0], y + points[1]);
            var i = 2, n = points.length;
            while (i < n) {
                this.quadraticCurveTo(x + points[i++], y + points[i++], x + points[i++], y + points[i++]);
            }
            this.stroke();
        };
        Context.__init__ = function (to) {
            var from = laya.resource.Context.prototype;
            to = to || CanvasRenderingContext2D.prototype;
            if (to.inited)
                return;
            to.inited = true;
            to.__fillText = to.fillText;
            to.__fillRect = to.fillRect;
            to.__strokeText = to.strokeText;
            var funs = ['drawTextures', "drawTriangle", 'fillWords', 'fillBorderWords', 'setIsMainContext', 'fillRect', 'strokeText', 'fillTexture', 'fillText', 'transformByMatrix', 'setTransformByMatrix', 'clipRect', 'drawTexture', 'drawTexture2', 'drawTextureWithTransform', 'flush', 'clear', 'destroy', 'drawCanvas', 'fillBorderText', 'drawCurves'];
            funs.forEach(function (i) {
                to[i] = from[i];
            });
        };
        Context.replaceCanvasGetSet = function (tar, key) {
            var oldO = Object.getOwnPropertyDescriptor(tar, key);
            if (!oldO || !oldO.configurable)
                return false;
            var newO = {};
            var tkey;
            for (tkey in oldO) {
                if (tkey != "set") {
                    newO[tkey] = oldO[tkey];
                }
            }
            ;
            var preFun = oldO["set"];
            newO["set"] = function (v) {
                var _self = this;
                preFun.call(_self, v);
                var _ct = _self.getContext("2d");
                if (_ct && "__reset" in _ct) {
                    _ct.__reset();
                }
            };
            Object.defineProperty(tar, key, newO);
            return true;
        };
        Context.replaceGetSet = function (tar, key) {
            var oldO = Object.getOwnPropertyDescriptor(tar, key);
            if (!oldO || !oldO.configurable)
                return false;
            var newO = {};
            var tkey;
            for (tkey in oldO) {
                if (tkey != "set") {
                    newO[tkey] = oldO[tkey];
                }
            }
            ;
            var preFun = oldO["set"];
            var dataKey = "___" + key + "__";
            Context.newKeys.push(dataKey);
            newO["set"] = function (v) {
                var _self = this;
                if (v != _self[dataKey]) {
                    _self[dataKey] = v;
                    preFun.call(_self, v);
                }
            };
            Object.defineProperty(tar, key, newO);
            return true;
        };
        Context._default = new Context();
        Context.newKeys = [];
        __static(Context, ['replaceKeys', function () { return this.replaceKeys = ["font", "fillStyle", "textBaseline"]; }
        ]);
        return Context;
    })();
    var ResourceManager = (function () {
        function ResourceManager(name) {
            this._id = 0;
            this._name = null;
            this._resources = null;
            this._memorySize = 0;
            this._garbageCollectionRate = NaN;
            this._isOverflow = false;
            this.autoRelease = false;
            this.autoReleaseMaxSize = 0;
            this._id = ++ResourceManager._uniqueIDCounter;
            this._name = name ? name : "Content Manager";
            ResourceManager._isResourceManagersSorted = false;
            this._memorySize = 0;
            this._isOverflow = false;
            this.autoRelease = false;
            this.autoReleaseMaxSize = 1024 * 1024 * 512;
            this._garbageCollectionRate = 0.2;
            ResourceManager._resourceManagers.push(this);
            this._resources = [];
        }
        __class(ResourceManager, 'laya.resource.ResourceManager');
        var __proto = ResourceManager.prototype;
        Laya.imps(__proto, { "laya.resource.IDispose": true });
        __proto.getResourceByIndex = function (index) {
            return this._resources[index];
        };
        __proto.getResourcesLength = function () {
            return this._resources.length;
        };
        __proto.addResource = function (resource) {
            if (resource.resourceManager)
                resource.resourceManager.removeResource(resource);
            var index = this._resources.indexOf(resource);
            if (index === -1) {
                resource._resourceManager = this;
                this._resources.push(resource);
                this.addSize(resource.memorySize);
                return true;
            }
            return false;
        };
        __proto.removeResource = function (resource) {
            var index = this._resources.indexOf(resource);
            if (index !== -1) {
                this._resources.splice(index, 1);
                resource._resourceManager = null;
                this._memorySize -= resource.memorySize;
                return true;
            }
            return false;
        };
        __proto.unload = function () {
            var tempResources = this._resources.slice(0, this._resources.length);
            for (var i = 0; i < tempResources.length; i++) {
                var resource = tempResources[i];
                resource.destroy();
            }
            tempResources.length = 0;
        };
        __proto.dispose = function () {
            if (this === ResourceManager._systemResourceManager)
                throw new Error("systemResourceManager不能被释放！");
            ResourceManager._resourceManagers.splice(ResourceManager._resourceManagers.indexOf(this), 1);
            ResourceManager._isResourceManagersSorted = false;
            var tempResources = this._resources.slice(0, this._resources.length);
            for (var i = 0; i < tempResources.length; i++) {
                var resource = tempResources[i];
                resource.resourceManager.removeResource(resource);
                resource.destroy();
            }
            tempResources.length = 0;
        };
        __proto.addSize = function (add) {
            if (add) {
                if (this.autoRelease && add > 0)
                    ((this._memorySize + add) > this.autoReleaseMaxSize) && (this.garbageCollection((1 - this._garbageCollectionRate) * this.autoReleaseMaxSize));
                this._memorySize += add;
            }
        };
        __proto.garbageCollection = function (reserveSize) {
            var all = this._resources;
            all = all.slice();
            all.sort(function (a, b) {
                if (!a || !b)
                    throw new Error("a或b不能为空！");
                if (a.released && b.released)
                    return 0;
                else if (a.released)
                    return 1;
                else if (b.released)
                    return -1;
                return a._lastUseFrameCount - b._lastUseFrameCount;
            });
            var currentFrameCount = Stat.loopCount;
            for (var i = 0, n = all.length; i < n; i++) {
                var resou = all[i];
                if (currentFrameCount - resou._lastUseFrameCount > 1) {
                    resou.releaseResource();
                }
                else {
                    if (this._memorySize >= reserveSize)
                        this._isOverflow = true;
                    return;
                }
                if (this._memorySize < reserveSize) {
                    this._isOverflow = false;
                    return;
                }
            }
        };
        __getset(0, __proto, 'id', function () {
            return this._id;
        });
        __getset(0, __proto, 'name', function () {
            return this._name;
        }, function (value) {
            if ((value || value !== "") && this._name !== value) {
                this._name = value;
                ResourceManager._isResourceManagersSorted = false;
            }
        });
        __getset(0, __proto, 'memorySize', function () {
            return this._memorySize;
        });
        __getset(1, ResourceManager, 'systemResourceManager', function () {
            return ResourceManager._systemResourceManager;
        });
        ResourceManager.__init__ = function () {
            ResourceManager.currentResourceManager = ResourceManager.systemResourceManager;
        };
        ResourceManager.getLoadedResourceManagerByIndex = function (index) {
            return ResourceManager._resourceManagers[index];
        };
        ResourceManager.getLoadedResourceManagersCount = function () {
            return ResourceManager._resourceManagers.length;
        };
        ResourceManager.recreateContentManagers = function (force) {
            (force === void 0) && (force = false);
            var temp = ResourceManager.currentResourceManager;
            for (var i = 0; i < ResourceManager._resourceManagers.length; i++) {
                ResourceManager.currentResourceManager = ResourceManager._resourceManagers[i];
                for (var j = 0; j < ResourceManager.currentResourceManager._resources.length; j++) {
                    ResourceManager.currentResourceManager._resources[j].releaseResource(force);
                    ResourceManager.currentResourceManager._resources[j].activeResource(force);
                }
            }
            ResourceManager.currentResourceManager = temp;
        };
        ResourceManager.releaseContentManagers = function (force) {
            (force === void 0) && (force = false);
            var temp = ResourceManager.currentResourceManager;
            for (var i = 0; i < ResourceManager._resourceManagers.length; i++) {
                ResourceManager.currentResourceManager = ResourceManager._resourceManagers[i];
                for (var j = 0; j < ResourceManager.currentResourceManager._resources.length; j++) {
                    var resource = ResourceManager.currentResourceManager._resources[j];
                    (!resource.released) && (resource.releaseResource(force));
                }
            }
            ResourceManager.currentResourceManager = temp;
        };
        ResourceManager._uniqueIDCounter = 0;
        ResourceManager._isResourceManagersSorted = false;
        ResourceManager._resourceManagers = [];
        __static(ResourceManager, ['_systemResourceManager', function () { return this._systemResourceManager = new ResourceManager("System Resource Manager"); }, 'currentResourceManager', function () { return this.currentResourceManager = ResourceManager._systemResourceManager; }
        ]);
        return ResourceManager;
    })();
    var System = (function () {
        function System() { }
        __class(System, 'laya.system.System');
        System.changeDefinition = function (name, classObj) {
            Laya[name] = classObj;
            var str = name + "=classObj";
            eval(str);
        };
        System.__init__ = function () {
            if (Render.isConchApp) {
                conch.disableConchResManager();
                conch.disableConchAutoRestoreLostedDevice();
            }
        };
        return System;
    })();
    SoundManager;
    var Browser = (function () {
        function Browser() { }
        __class(Browser, 'laya.utils.Browser');
        __getset(1, Browser, 'pixelRatio', function () {
            Browser.__init__();
            if (Browser.userAgent.indexOf("Mozilla/6.0(Linux; Android 6.0; HUAWEI NXT-AL10 Build/HUAWEINXT-AL10)") > -1)
                return 2;
            return RunDriver.getPixelRatio();
        });
        __getset(1, Browser, 'height', function () {
            Browser.__init__();
            return ((Laya.stage && Laya.stage.canvasRotation) ? Browser.clientWidth : Browser.clientHeight) * Browser.pixelRatio;
        });
        __getset(1, Browser, 'clientWidth', function () {
            Browser.__init__();
            return Browser.window.innerWidth || Browser.document.body.clientWidth;
        });
        __getset(1, Browser, 'window', function () {
            Browser.__init__();
            return Browser._window;
        });
        __getset(1, Browser, 'clientHeight', function () {
            Browser.__init__();
            return Browser.window.innerHeight || Browser.document.body.clientHeight || Browser.document.documentElement.clientHeight;
        });
        __getset(1, Browser, 'width', function () {
            Browser.__init__();
            return ((Laya.stage && Laya.stage.canvasRotation) ? Browser.clientHeight : Browser.clientWidth) * Browser.pixelRatio;
        });
        __getset(1, Browser, 'container', function () {
            Browser.__init__();
            if (!Browser._container) {
                Browser._container = Browser.createElement("div");
                Browser._container.id = "the3Container";
                Browser.document.body.appendChild(Browser._container);
            }
            return Browser._container;
        }, function (value) {
            Browser._container = value;
        });
        __getset(1, Browser, 'document', function () {
            Browser.__init__();
            return Browser._document;
        });
        Browser.__init__ = function () {
            SoundManager;
            if (Browser._window)
                return;
            Browser._window = RunDriver.getWindow();
            Browser._document = Browser.window.document;
            Browser._window.addEventListener('message', function (e) {
                laya.utils.Browser._onMessage(e);
            }, false);
            Browser.document.__createElement = Browser.document.createElement;
            window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (c) { return window.setTimeout(c, 1000 / 60); };
            ;
            Browser.userAgent = Browser.window.navigator.userAgent;
            Browser.u = Browser.userAgent;
            Browser.onIOS = !!Browser.u.match(/\(i[^;]+;(U;)? CPU.+Mac OS X/);
            Browser.onMobile = Browser.u.indexOf("Mobile") > -1;
            Browser.onIPhone = Browser.u.indexOf("iPhone") > -1;
            Browser.onMac = Browser.u.indexOf("Mac OS X") > -1;
            Browser.onIPad = Browser.u.indexOf("iPad") > -1;
            Browser.onAndriod = Browser.u.indexOf('Android') > -1 || Browser.u.indexOf('Adr') > -1;
            Browser.onWP = Browser.u.indexOf("Windows Phone") > -1;
            Browser.onQQBrowser = Browser.u.indexOf("QQBrowser") > -1;
            Browser.onMQQBrowser = Browser.u.indexOf("MQQBrowser") > -1 || (Browser.u.indexOf("Mobile") > -1 && Browser.u.indexOf("QQ") > -1);
            Browser.onIE = !!Browser.window.ActiveXObject || "ActiveXObject" in Browser.window;
            Browser.onWeiXin = Browser.u.indexOf('MicroMessenger') > -1;
            Browser.onPC = !Browser.onMobile;
            Browser.onSafari = !!Browser.u.match(/Version\/\d+\.\d\x20Mobile\/\S+\x20Safari/);
            Browser.onFirefox = Browser.u.indexOf('Firefox') > -1;
            Browser.onEdge = Browser.u.indexOf('Edge') > -1;
            Browser.onMiniGame = Browser.u.indexOf('MiniGame') > -1;
            Browser.onLimixiu = Browser.u.indexOf('limixiu') > -1;
            Browser.httpProtocol = Browser.window.location.protocol == "http:";
            if (Browser.onMiniGame && Browser.window.focus == null) {
                console_error("请先初始化小游戏适配库，详细教程https://ldc.the3box.com/doc/?nav=zh-ts-5-0-0");
            }
            Browser.webAudioEnabled = Browser.window["AudioContext"] || Browser.window["webkitAudioContext"] || Browser.window["mozAudioContext"] ? true : false;
            Browser.soundType = Browser.webAudioEnabled ? "WEBAUDIOSOUND" : "AUDIOSOUND";
            Sound = Browser.webAudioEnabled ? WebAudioSound : AudioSound;
            ;
            if (Browser.webAudioEnabled)
                WebAudioSound.initWebAudio();
            ;
            AudioSound._initMusicAudio();
            Browser.enableTouch = (('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch);
            window.focus();
            SoundManager._soundClass = Sound;
            ;
            Render._mainCanvas = Render._mainCanvas || HTMLCanvas.create('2D');
            if (Browser.canvas)
                return;
            Browser.canvas = HTMLCanvas.create('2D');
            Browser.context = Browser.canvas.getContext('2d');
            Browser.document.body.style.overflow = "hidden";
        };
        Browser._onMessage = function (e) {
            if (!e.data)
                return;
            if (e.data.name == "size") {
                Browser.window.innerWidth = e.data.width;
                Browser.window.innerHeight = e.data.height;
                Browser.window.__innerHeight = e.data.clientHeight;
                if (!Browser.document.createEvent) {
                    console_warn("no document.createEvent");
                    return;
                }
                ;
                var evt = Browser.document.createEvent("HTMLEvents");
                evt.initEvent("resize", false, false);
                Browser.window.dispatchEvent(evt);
                return;
            }
        };
        Browser.createElement = function (type) {
            Browser.__init__();
            return Browser.document.__createElement(type);
        };
        Browser.getElementById = function (type) {
            Browser.__init__();
            return Browser.document.getElementById(type);
        };
        Browser.removeElement = function (ele) {
            if (ele && ele.parentNode)
                ele.parentNode.removeChild(ele);
        };
        Browser.now = function () {
            return RunDriver.now();
        };
        Browser._window = null;
        Browser._document = null;
        Browser._container = null;
        Browser.userAgent = null;
        Browser.u = null;
        Browser.onIOS = false;
        Browser.onMac = false;
        Browser.onMobile = false;
        Browser.onIPhone = false;
        Browser.onIPad = false;
        Browser.onAndriod = false;
        Browser.onAndroid = false;
        Browser.onWP = false;
        Browser.onQQBrowser = false;
        Browser.onMQQBrowser = false;
        Browser.onSafari = false;
        Browser.onFirefox = false;
        Browser.onEdge = false;
        Browser.onIE = false;
        Browser.onWeiXin = false;
        Browser.onMiniGame = false;
        Browser.onLimixiu = false;
        Browser.onPC = false;
        Browser.httpProtocol = false;
        Browser.webAudioEnabled = false;
        Browser.soundType = null;
        Browser.enableTouch = false;
        Browser.canvas = null;
        Browser.context = null;
        Browser.__init$ = function () {
            AudioSound;
            WebAudioSound;
        };
        return Browser;
    })();
    var Byte = (function () {
        function Byte(data) {
            this._xd_ = true;
            this._allocated_ = 8;
            this._pos_ = 0;
            this._length = 0;
            if (data) {
                this._u8d_ = new Uint8Array(data);
                this._d_ = new DataView(this._u8d_.buffer);
                this._length = this._d_.byteLength;
            }
            else {
                this.___resizeBuffer(this._allocated_);
            }
        }
        __class(Byte, 'laya.utils.Byte');
        var __proto = Byte.prototype;
        __proto.___resizeBuffer = function (len) {
            try {
                var newByteView = new Uint8Array(len);
                if (this._u8d_ != null) {
                    if (this._u8d_.length <= len)
                        newByteView.set(this._u8d_);
                    else
                        newByteView.set(this._u8d_.subarray(0, len));
                }
                this._u8d_ = newByteView;
                this._d_ = new DataView(newByteView.buffer);
            }
            catch (err) {
                throw "___resizeBuffer err:" + len;
            }
        };
        __proto.getString = function () {
            return this.rUTF(this.getUint16());
        };
        __proto.getFloat32Array = function (start, len) {
            var end = start + len;
            end = (end > this._length) ? this._length : end;
            var v = new Float32Array(this._d_.buffer.slice(start, end));
            this._pos_ = end;
            return v;
        };
        __proto.getUint8Array = function (start, len) {
            var end = start + len;
            end = (end > this._length) ? this._length : end;
            var v = new Uint8Array(this._d_.buffer.slice(start, end));
            this._pos_ = end;
            return v;
        };
        __proto.getInt16Array = function (start, len) {
            var end = start + len;
            end = (end > this._length) ? this._length : end;
            var v = new Int16Array(this._d_.buffer.slice(start, end));
            this._pos_ = end;
            return v;
        };
        __proto.getFloat32 = function () {
            if (this._pos_ + 4 > this._length)
                throw "getFloat32 error - Out of bounds";
            var v = this._d_.getFloat32(this._pos_, this._xd_);
            this._pos_ += 4;
            return v;
        };
        __proto.getFloat64 = function () {
            if (this._pos_ + 8 > this._length)
                throw "getFloat64 error - Out of bounds";
            var v = this._d_.getFloat64(this._pos_, this._xd_);
            this._pos_ += 8;
            return v;
        };
        __proto.writeFloat32 = function (value) {
            this.ensureWrite(this._pos_ + 4);
            this._d_.setFloat32(this._pos_, value, this._xd_);
            this._pos_ += 4;
        };
        __proto.writeFloat64 = function (value) {
            this.ensureWrite(this._pos_ + 8);
            this._d_.setFloat64(this._pos_, value, this._xd_);
            this._pos_ += 8;
        };
        __proto.getInt32 = function () {
            if (this._pos_ + 4 > this._length)
                throw "getInt32 error - Out of bounds";
            var float = this._d_.getInt32(this._pos_, this._xd_);
            this._pos_ += 4;
            return float;
        };
        __proto.getUint32 = function () {
            if (this._pos_ + 4 > this._length)
                throw "getUint32 error - Out of bounds";
            var v = this._d_.getUint32(this._pos_, this._xd_);
            this._pos_ += 4;
            return v;
        };
        __proto.writeInt32 = function (value) {
            this.ensureWrite(this._pos_ + 4);
            this._d_.setInt32(this._pos_, value, this._xd_);
            this._pos_ += 4;
        };
        __proto.writeUint32 = function (value) {
            this.ensureWrite(this._pos_ + 4);
            this._d_.setUint32(this._pos_, value, this._xd_);
            this._pos_ += 4;
        };
        __proto.getInt16 = function () {
            if (this._pos_ + 2 > this._length)
                throw "getInt16 error - Out of bounds";
            var us = this._d_.getInt16(this._pos_, this._xd_);
            this._pos_ += 2;
            return us;
        };
        __proto.getUint16 = function () {
            if (this._pos_ + 2 > this._length)
                throw "getUint16 error - Out of bounds";
            var us = this._d_.getUint16(this._pos_, this._xd_);
            this._pos_ += 2;
            return us;
        };
        __proto.writeUint16 = function (value) {
            this.ensureWrite(this._pos_ + 2);
            this._d_.setUint16(this._pos_, value, this._xd_);
            this._pos_ += 2;
        };
        __proto.writeInt16 = function (value) {
            this.ensureWrite(this._pos_ + 2);
            this._d_.setInt16(this._pos_, value, this._xd_);
            this._pos_ += 2;
        };
        __proto.getUint8 = function () {
            if (this._pos_ + 1 > this._length)
                throw "getUint8 error - Out of bounds";
            return this._d_.getUint8(this._pos_++);
        };
        __proto.writeUint8 = function (value) {
            this.ensureWrite(this._pos_ + 1);
            this._d_.setUint8(this._pos_, value);
            this._pos_++;
        };
        __proto._getUInt8 = function (pos) {
            return this._d_.getUint8(pos);
        };
        __proto._getUint16 = function (pos) {
            return this._d_.getUint16(pos, this._xd_);
        };
        __proto._getMatrix = function () {
            var rst = new Matrix(this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32());
            return rst;
        };
        __proto.rUTF = function (len) {
            var v = "", max = this._pos_ + len, c = 0, c2 = 0, c3 = 0, f = String.fromCharCode;
            var u = this._u8d_, i = 0;
            while (this._pos_ < max) {
                c = u[this._pos_++];
                if (c < 0x80) {
                    if (c != 0) {
                        v += f(c);
                    }
                }
                else if (c < 0xE0) {
                    v += f(((c & 0x3F) << 6) | (u[this._pos_++] & 0x7F));
                }
                else if (c < 0xF0) {
                    c2 = u[this._pos_++];
                    v += f(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (u[this._pos_++] & 0x7F));
                }
                else {
                    c2 = u[this._pos_++];
                    c3 = u[this._pos_++];
                    v += f(((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 << 6) & 0x7F) | (u[this._pos_++] & 0x7F));
                }
                i++;
            }
            return v;
        };
        __proto.getCustomString = function (len) {
            var v = "", ulen = 0, c = 0, c2 = 0, f = String.fromCharCode;
            var u = this._u8d_, i = 0;
            while (len > 0) {
                c = u[this._pos_];
                if (c < 0x80) {
                    v += f(c);
                    this._pos_++;
                    len--;
                }
                else {
                    ulen = c - 0x80;
                    this._pos_++;
                    len -= ulen;
                    while (ulen > 0) {
                        c = u[this._pos_++];
                        c2 = u[this._pos_++];
                        v += f((c2 << 8) | c);
                        ulen--;
                    }
                }
            }
            return v;
        };
        __proto.clear = function () {
            this._pos_ = 0;
            this.length = 0;
        };
        __proto.__getBuffer = function () {
            return this._d_.buffer;
        };
        __proto.writeUTFBytes = function (value) {
            value = value + "";
            for (var i = 0, sz = value.length; i < sz; i++) {
                var c = value.charCodeAt(i);
                if (c <= 0x7F) {
                    this.writeByte(c);
                }
                else if (c <= 0x7FF) {
                    this.ensureWrite(this._pos_ + 2);
                    this._u8d_.set([0xC0 | (c >> 6), 0x80 | (c & 0x3F)], this._pos_);
                    this._pos_ += 2;
                }
                else if (c <= 0xFFFF) {
                    this.ensureWrite(this._pos_ + 3);
                    this._u8d_.set([0xE0 | (c >> 12), 0x80 | ((c >> 6) & 0x3F), 0x80 | (c & 0x3F)], this._pos_);
                    this._pos_ += 3;
                }
                else {
                    this.ensureWrite(this._pos_ + 4);
                    this._u8d_.set([0xF0 | (c >> 18), 0x80 | ((c >> 12) & 0x3F), 0x80 | ((c >> 6) & 0x3F), 0x80 | (c & 0x3F)], this._pos_);
                    this._pos_ += 4;
                }
            }
        };
        __proto.writeUTFString = function (value) {
            var tPos = this.pos;
            this.writeUint16(1);
            this.writeUTFBytes(value);
            var dPos = this.pos - tPos - 2;
            if (dPos >= 65536) {
                throw "writeUTFString byte len more than 65536";
            }
            this._d_.setUint16(tPos, dPos, this._xd_);
        };
        __proto.readUTFString = function () {
            return this.readUTFBytes(this.getUint16());
        };
        __proto.getUTFString = function () {
            return this.readUTFString();
        };
        __proto.readUTFBytes = function (len) {
            (len === void 0) && (len = -1);
            if (len == 0)
                return "";
            var lastBytes = this.bytesAvailable;
            if (len > lastBytes)
                throw "readUTFBytes error - Out of bounds";
            len = len > 0 ? len : lastBytes;
            return this.rUTF(len);
        };
        __proto.getUTFBytes = function (len) {
            (len === void 0) && (len = -1);
            return this.readUTFBytes(len);
        };
        __proto.writeByte = function (value) {
            this.ensureWrite(this._pos_ + 1);
            this._d_.setInt8(this._pos_, value);
            this._pos_ += 1;
        };
        __proto.readByte = function () {
            if (this._pos_ + 1 > this._length)
                throw "readByte error - Out of bounds";
            return this._d_.getInt8(this._pos_++);
        };
        __proto.getByte = function () {
            return this.readByte();
        };
        __proto.ensureWrite = function (lengthToEnsure) {
            if (this._length < lengthToEnsure)
                this._length = lengthToEnsure;
            if (this._allocated_ < lengthToEnsure)
                this.length = lengthToEnsure;
        };
        __proto.writeArrayBuffer = function (arraybuffer, offset, length) {
            (offset === void 0) && (offset = 0);
            (length === void 0) && (length = 0);
            if (offset < 0 || length < 0)
                throw "writeArrayBuffer error - Out of bounds";
            if (length == 0)
                length = arraybuffer.byteLength - offset;
            this.ensureWrite(this._pos_ + length);
            var uint8array = new Uint8Array(arraybuffer);
            this._u8d_.set(uint8array.subarray(offset, offset + length), this._pos_);
            this._pos_ += length;
        };
        __getset(0, __proto, 'buffer', function () {
            var rstBuffer = this._d_.buffer;
            if (rstBuffer.byteLength == this.length)
                return rstBuffer;
            return rstBuffer.slice(0, this.length);
        });
        __getset(0, __proto, 'endian', function () {
            return this._xd_ ? "littleEndian" : "bigEndian";
        }, function (endianStr) {
            this._xd_ = (endianStr == "littleEndian");
        });
        __getset(0, __proto, 'length', function () {
            return this._length;
        }, function (value) {
            if (this._allocated_ < value)
                this.___resizeBuffer(this._allocated_ = Math.floor(Math.max(value, this._allocated_ * 2)));
            else if (this._allocated_ > value)
                this.___resizeBuffer(this._allocated_ = value);
            this._length = value;
        });
        __getset(0, __proto, 'pos', function () {
            return this._pos_;
        }, function (value) {
            this._pos_ = value;
        });
        __getset(0, __proto, 'bytesAvailable', function () {
            return this._length - this._pos_;
        });
        Byte.getSystemEndian = function () {
            if (!Byte._sysEndian) {
                var buffer = new ArrayBuffer(2);
                new DataView(buffer).setInt16(0, 256, true);
                Byte._sysEndian = (new Int16Array(buffer))[0] === 256 ? "littleEndian" : "bigEndian";
            }
            return Byte._sysEndian;
        };
        Byte.BIG_ENDIAN = "bigEndian";
        Byte.LITTLE_ENDIAN = "littleEndian";
        Byte._sysEndian = null;
        return Byte;
    })();
    var CacheManager = (function () {
        function CacheManager() { }
        __class(CacheManager, 'laya.utils.CacheManager');
        CacheManager.regCacheByFunction = function (disposeFunction, getCacheListFunction) {
            CacheManager.unRegCacheByFunction(disposeFunction, getCacheListFunction);
            var cache;
            cache = { tryDispose: disposeFunction, getCacheList: getCacheListFunction };
            CacheManager._cacheList.push(cache);
        };
        CacheManager.unRegCacheByFunction = function (disposeFunction, getCacheListFunction) {
            var i = 0, len = 0;
            len = CacheManager._cacheList.length;
            for (i = 0; i < len; i++) {
                if (CacheManager._cacheList[i].tryDispose == disposeFunction && CacheManager._cacheList[i].getCacheList == getCacheListFunction) {
                    CacheManager._cacheList.splice(i, 1);
                    return;
                }
            }
        };
        CacheManager.forceDispose = function () {
            var i = 0, len = CacheManager._cacheList.length;
            for (i = 0; i < len; i++) {
                CacheManager._cacheList[i].tryDispose(true);
            }
        };
        CacheManager.beginCheck = function (waitTime) {
            (waitTime === void 0) && (waitTime = 15000);
            Laya.timer.loop(waitTime, null, CacheManager._checkLoop);
        };
        CacheManager.stopCheck = function () {
            Laya.timer.clear(null, CacheManager._checkLoop);
        };
        CacheManager._checkLoop = function () {
            var cacheList = CacheManager._cacheList;
            if (cacheList.length < 1)
                return;
            var tTime = Browser.now();
            var count = 0;
            var len = 0;
            len = count = cacheList.length;
            while (count > 0) {
                CacheManager._index++;
                CacheManager._index = CacheManager._index % len;
                cacheList[CacheManager._index].tryDispose(false);
                if (Browser.now() - tTime > CacheManager.loopTimeLimit)
                    break;
                count--;
            }
        };
        CacheManager.loopTimeLimit = 2;
        CacheManager._cacheList = [];
        CacheManager._index = 0;
        return CacheManager;
    })();
    var ClassUtils = (function () {
        function ClassUtils() { }
        __class(ClassUtils, 'laya.utils.ClassUtils');
        ClassUtils.regClass = function (className, classDef) {
            ClassUtils._classMap[className] = classDef;
        };
        ClassUtils.getRegClass = function (className) {
            return ClassUtils._classMap[className];
        };
        ClassUtils.getInstance = function (className) {
            var compClass = ClassUtils.getClass(className);
            if (compClass)
                return new compClass();
            else
                console_warn("[error] Undefined class:", className);
            return null;
        };
        ClassUtils.createByJson = function (json, node, root, customHandler, instanceHandler) {
            if ((typeof json == 'string'))
                json = JSON.parse(json);
            var props = json.props;
            if (!node) {
                node = instanceHandler ? instanceHandler.runWith(json) : ClassUtils.getInstance(props.runtime || json.type);
                if (!node)
                    return null;
            }
            ;
            var child = json.child;
            if (child) {
                for (var i = 0, n = child.length; i < n; i++) {
                    var data = child[i];
                    if ((data.props.name === "render" || data.props.renderType === "render") && node["_$set_itemRender"])
                        node.itemRender = data;
                    else {
                        if (data.type == "Graphic") {
                            ClassUtils.addGraphicsToSprite(data, node);
                        }
                        else if (ClassUtils.isDrawType(data.type)) {
                            ClassUtils.addGraphicToSprite(data, node, true);
                        }
                        else {
                            var tChild = ClassUtils.createByJson(data, null, root, customHandler, instanceHandler);
                            if (data.type == "Script") {
                                if (tChild.hasOwnProperty("owner")) {
                                    tChild["owner"] = node;
                                }
                                else if (tChild.hasOwnProperty("target")) {
                                    tChild["target"] = node;
                                }
                            }
                            else if (data.props.renderType == "mask") {
                                node.mask = tChild;
                            }
                            else {
                                node.addChild(tChild);
                            }
                        }
                    }
                }
            }
            if (props) {
                for (var prop in props) {
                    var value = props[prop];
                    if (prop === "var" && root) {
                        root[value] = node;
                    }
                    else if ((value instanceof Array) && (typeof (node[prop]) == 'function')) {
                        node[prop].apply(node, value);
                    }
                    else {
                        node[prop] = value;
                    }
                }
            }
            if (customHandler && json.customProps) {
                customHandler.runWith([node, json]);
            }
            if (node["created"])
                node.created();
            return node;
        };
        ClassUtils.addGraphicsToSprite = function (graphicO, sprite) {
            var graphics;
            graphics = graphicO.child;
            if (!graphics || graphics.length < 1)
                return;
            var g;
            g = ClassUtils._getGraphicsFromSprite(graphicO, sprite);
            var ox = 0;
            var oy = 0;
            if (graphicO.props) {
                ox = ClassUtils._getObjVar(graphicO.props, "x", 0);
                oy = ClassUtils._getObjVar(graphicO.props, "y", 0);
            }
            if (ox != 0 && oy != 0) {
                g.translate(ox, oy);
            }
            ;
            var i = 0, len = 0;
            len = graphics.length;
            for (i = 0; i < len; i++) {
                ClassUtils._addGraphicToGraphics(graphics[i], g);
            }
            if (ox != 0 && oy != 0) {
                g.translate(-ox, -oy);
            }
        };
        ClassUtils.addGraphicToSprite = function (graphicO, sprite, isChild) {
            (isChild === void 0) && (isChild = false);
            var g;
            g = isChild ? ClassUtils._getGraphicsFromSprite(graphicO, sprite) : sprite.graphics;
            ClassUtils._addGraphicToGraphics(graphicO, g);
        };
        ClassUtils._getGraphicsFromSprite = function (dataO, sprite) {
            var g;
            if (!dataO || !dataO.props)
                return sprite.graphics;
            var propsName;
            propsName = dataO.props.renderType;
            switch (propsName) {
                case "hit":
                case "unHit":
                    ;
                    var hitArea;
                    if (!sprite.hitArea) {
                        sprite.hitArea = new HitArea();
                    }
                    hitArea = sprite.hitArea;
                    if (!hitArea[propsName]) {
                        hitArea[propsName] = new Graphics();
                    }
                    g = hitArea[propsName];
                    break;
                default:
            }
            if (!g)
                g = sprite.graphics;
            return g;
        };
        ClassUtils._getTransformData = function (propsO) {
            var m;
            if (propsO.hasOwnProperty("pivotX") || propsO.hasOwnProperty("pivotY")) {
                m = m || new Matrix();
                m.translate(-ClassUtils._getObjVar(propsO, "pivotX", 0), -ClassUtils._getObjVar(propsO, "pivotY", 0));
            }
            ;
            var sx = ClassUtils._getObjVar(propsO, "scaleX", 1), sy = ClassUtils._getObjVar(propsO, "scaleY", 1);
            var rotate = ClassUtils._getObjVar(propsO, "rotation", 0);
            var skewX = ClassUtils._getObjVar(propsO, "skewX", 0);
            var skewY = ClassUtils._getObjVar(propsO, "skewY", 0);
            if (sx != 1 || sy != 1 || rotate != 0) {
                m = m || new Matrix();
                m.scale(sx, sy);
                m.rotate(rotate * 0.0174532922222222);
            }
            return m;
        };
        ClassUtils._addGraphicToGraphics = function (graphicO, graphic) {
            var propsO;
            propsO = graphicO.props;
            if (!propsO)
                return;
            var drawConfig;
            drawConfig = ClassUtils.DrawTypeDic[graphicO.type];
            if (!drawConfig)
                return;
            var g;
            g = graphic;
            var m;
            var params = ClassUtils._getParams(propsO, drawConfig[1], drawConfig[2], drawConfig[3]);
            m = ClassUtils._tM;
            if (m || ClassUtils._alpha != 1) {
                g.save();
                if (m)
                    g.transform(m);
                if (ClassUtils._alpha != 1)
                    g.alpha(ClassUtils._alpha);
            }
            g[drawConfig[0]].apply(g, params);
            if (m || ClassUtils._alpha != 1) {
                g.restore();
            }
        };
        ClassUtils._adptLineData = function (params) {
            params[2] = parseFloat(params[0]) + parseFloat(params[2]);
            params[3] = parseFloat(params[1]) + parseFloat(params[3]);
            return params;
        };
        ClassUtils._adptTextureData = function (params) {
            params[0] = Loader.getRes(params[0]);
            return params;
        };
        ClassUtils._adptLinesData = function (params) {
            params[2] = ClassUtils._getPointListByStr(params[2]);
            return params;
        };
        ClassUtils.isDrawType = function (type) {
            if (type == "Image")
                return false;
            return ClassUtils.DrawTypeDic.hasOwnProperty(type);
        };
        ClassUtils._getParams = function (obj, params, xPos, adptFun) {
            (xPos === void 0) && (xPos = 0);
            var rst;
            rst = ClassUtils._temParam;
            rst.length = params.length;
            var i = 0, len = 0;
            len = params.length;
            for (i = 0; i < len; i++) {
                rst[i] = ClassUtils._getObjVar(obj, params[i][0], params[i][1]);
            }
            ClassUtils._alpha = ClassUtils._getObjVar(obj, "alpha", 1);
            var m;
            m = ClassUtils._getTransformData(obj);
            if (m) {
                if (!xPos)
                    xPos = 0;
                m.translate(rst[xPos], rst[xPos + 1]);
                rst[xPos] = rst[xPos + 1] = 0;
                ClassUtils._tM = m;
            }
            else {
                ClassUtils._tM = null;
            }
            if (adptFun && ClassUtils[adptFun]) {
                rst = ClassUtils[adptFun](rst);
            }
            return rst;
        };
        ClassUtils._getPointListByStr = function (str) {
            var pointArr;
            pointArr = str.split(",");
            var i = 0, len = 0;
            len = pointArr.length;
            for (i = 0; i < len; i++) {
                pointArr[i] = parseFloat(pointArr[i]);
            }
            return pointArr;
        };
        ClassUtils._getObjVar = function (obj, key, noValue) {
            if (obj.hasOwnProperty(key)) {
                return obj[key];
            }
            return noValue;
        };
        ClassUtils._temParam = [];
        ClassUtils._classMap = { 'Sprite': 'laya.display.Sprite', 'Text': 'laya.display.Text', 'Animation': 'laya.display.Animation', 'Skeleton': 'laya.ani.bone.Skeleton', 'Particle2D': 'laya.particle.Particle2D', 'div': 'laya.html.dom.HTMLDivElement', 'p': 'laya.html.dom.HTMLElement', 'img': 'laya.html.dom.HTMLImageElement', 'span': 'laya.html.dom.HTMLElement', 'br': 'laya.html.dom.HTMLBrElement', 'style': 'laya.html.dom.HTMLStyleElement', 'font': 'laya.html.dom.HTMLElement', 'a': 'laya.html.dom.HTMLElement', '#text': 'laya.html.dom.HTMLElement' };
        ClassUtils.getClass = function (className) {
            var classObject = ClassUtils._classMap[className] || className;
            if ((typeof classObject == 'string'))
                return Laya["__classmap"][classObject];
            return classObject;
        };
        ClassUtils._tM = null;
        ClassUtils._alpha = NaN;
        __static(ClassUtils, ['DrawTypeDic', function () { return this.DrawTypeDic = { "Rect": ["drawRect", [["x", 0], ["y", 0], ["width", 0], ["height", 0], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]]], "Circle": ["drawCircle", [["x", 0], ["y", 0], ["radius", 0], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]]], "Pie": ["drawPie", [["x", 0], ["y", 0], ["radius", 0], ["startAngle", 0], ["endAngle", 0], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]]], "Image": ["drawTexture", [["x", 0], ["y", 0], ["width", 0], ["height", 0]]], "Texture": ["drawTexture", [["skin", null], ["x", 0], ["y", 0], ["width", 0], ["height", 0]], 1, "_adptTextureData"], "FillTexture": ["fillTexture", [["skin", null], ["x", 0], ["y", 0], ["width", 0], ["height", 0], ["repeat", null]], 1, "_adptTextureData"], "FillText": ["fillText", [["text", ""], ["x", 0], ["y", 0], ["font", null], ["color", null], ["textAlign", null]], 1], "Line": ["drawLine", [["x", 0], ["y", 0], ["toX", 0], ["toY", 0], ["lineColor", null], ["lineWidth", 0]], 0, "_adptLineData"], "Lines": ["drawLines", [["x", 0], ["y", 0], ["points", ""], ["lineColor", null], ["lineWidth", 0]], 0, "_adptLinesData"], "Curves": ["drawCurves", [["x", 0], ["y", 0], ["points", ""], ["lineColor", null], ["lineWidth", 0]], 0, "_adptLinesData"], "Poly": ["drawPoly", [["x", 0], ["y", 0], ["points", ""], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]], 0, "_adptLinesData"] }; }
        ]);
        return ClassUtils;
    })();
    var Color = (function () {
        function Color(str) {
            this._color = [];
            if ((typeof str == 'string')) {
                this.strColor = str;
                if (str === null)
                    str = "#000000";
                str.charAt(0) == '#' && (str = str.substr(1));
                var len = str.length;
                if (len == 3 || len == 4) {
                    var temp = "";
                    for (var i = 0; i < len; i++) {
                        temp += (str[i] + str[i]);
                    }
                    str = temp;
                }
                ;
                var color = this.numColor = parseInt(str, 16);
                var flag = (str.length == 8);
                if (flag) {
                    this._color = [parseInt(str.substr(0, 2), 16) / 255, ((0x00FF0000 & color) >> 16) / 255, ((0x0000FF00 & color) >> 8) / 255, (0x000000FF & color) / 255];
                    return;
                }
            }
            else {
                color = this.numColor = str;
                this.strColor = Utils.toHexColor(color);
            }
            this._color = [((0xFF0000 & color) >> 16) / 255, ((0xFF00 & color) >> 8) / 255, (0xFF & color) / 255, 1];
            (this._color).__id = ++Color._COLODID;
        }
        __class(Color, 'laya.utils.Color');
        Color._initDefault = function () {
            Color._DEFAULT = {};
            for (var i in Color._COLOR_MAP)
                Color._SAVE[i] = Color._DEFAULT[i] = new Color(Color._COLOR_MAP[i]);
            return Color._DEFAULT;
        };
        Color._initSaveMap = function () {
            Color._SAVE_SIZE = 0;
            Color._SAVE = {};
            for (var i in Color._DEFAULT)
                Color._SAVE[i] = Color._DEFAULT[i];
        };
        Color.create = function (str) {
            var color = Color._SAVE[str + ""];
            if (color != null)
                return color;
            (Color._SAVE_SIZE < 1000) || Color._initSaveMap();
            return Color._SAVE[str + ""] = new Color(str);
        };
        Color._SAVE = {};
        Color._SAVE_SIZE = 0;
        Color._COLOR_MAP = { "white": '#FFFFFF', "red": '#FF0000', "green": '#00FF00', "blue": '#0000FF', "black": '#000000', "yellow": '#FFFF00', 'gray': '#AAAAAA' };
        Color._DEFAULT = Color._initDefault();
        Color._COLODID = 1;
        return Color;
    })();
    var Dictionary = (function () {
        function Dictionary() {
            this._values = [];
            this._keys = [];
        }
        __class(Dictionary, 'laya.utils.Dictionary');
        var __proto = Dictionary.prototype;
        __proto.set = function (key, value) {
            var index = this.indexOf(key);
            if (index >= 0) {
                this._values[index] = value;
                return;
            }
            this._keys.push(key);
            this._values.push(value);
        };
        __proto.indexOf = function (key) {
            var index = this._keys.indexOf(key);
            if (index >= 0)
                return index;
            key = ((typeof key == 'string')) ? Number(key) : (((typeof key == 'number')) ? key.toString() : key);
            return this._keys.indexOf(key);
        };
        __proto.get = function (key) {
            var index = this.indexOf(key);
            return index < 0 ? null : this._values[index];
        };
        __proto.remove = function (key) {
            var index = this.indexOf(key);
            if (index >= 0) {
                this._keys.splice(index, 1);
                this._values.splice(index, 1);
                return true;
            }
            return false;
        };
        __proto.clear = function () {
            this._values.length = 0;
            this._keys.length = 0;
        };
        __getset(0, __proto, 'values', function () {
            return this._values;
        });
        __getset(0, __proto, 'keys', function () {
            return this._keys;
        });
        return Dictionary;
    })();
    var Dragging = (function () {
        function Dragging() {
            this.ratio = 0.92;
            this.maxOffset = 60;
            this._dragging = false;
            this._clickOnly = true;
        }
        __class(Dragging, 'laya.utils.Dragging');
        var __proto = Dragging.prototype;
        __proto.start = function (target, area, hasInertia, elasticDistance, elasticBackTime, data, disableMouseEvent, ratio) {
            (ratio === void 0) && (ratio = 0.92);
            this.clearTimer();
            this.target = target;
            this.area = area;
            this.hasInertia = hasInertia;
            this.elasticDistance = area ? elasticDistance : 0;
            this.elasticBackTime = elasticBackTime;
            this.data = data;
            this._disableMouseEvent = disableMouseEvent;
            this.ratio = ratio;
            if (target.globalScaleX != 1 || target.globalScaleY != 1) {
                this._parent = target.parent;
            }
            else {
                this._parent = Laya.stage;
            }
            this._clickOnly = true;
            this._dragging = true;
            this._elasticRateX = this._elasticRateY = 1;
            this._lastX = this._parent.mouseX;
            this._lastY = this._parent.mouseY;
            Laya.stage.on("mouseup", this, this.onStageMouseUp);
            Laya.stage.on("mouseout", this, this.onStageMouseUp);
            Laya.timer.frameLoop(1, this, this.loop);
        };
        __proto.clearTimer = function () {
            Laya.timer.clear(this, this.loop);
            Laya.timer.clear(this, this.tweenMove);
            if (this._tween) {
                this._tween.recover();
                this._tween = null;
            }
        };
        __proto.stop = function () {
            if (this._dragging) {
                MouseManager.instance.disableMouseEvent = false;
                Laya.stage.off("mouseup", this, this.onStageMouseUp);
                Laya.stage.off("mouseout", this, this.onStageMouseUp);
                this._dragging = false;
                this.target && this.area && this.backToArea();
                this.clear();
            }
        };
        __proto.loop = function () {
            var point = this._parent.getMousePoint();
            var mouseX = point.x;
            var mouseY = point.y;
            var offsetX = mouseX - this._lastX;
            var offsetY = mouseY - this._lastY;
            if (this._clickOnly) {
                if (Math.abs(offsetX * Laya.stage._canvasTransform.getScaleX()) > 1 || Math.abs(offsetY * Laya.stage._canvasTransform.getScaleY()) > 1) {
                    this._clickOnly = false;
                    this._offsets || (this._offsets = []);
                    this._offsets.length = 0;
                    this.target.event("dragstart", this.data);
                    MouseManager.instance.disableMouseEvent = this._disableMouseEvent;
                    this.target._set$P("$_MOUSEDOWN", false);
                }
                else
                    return;
            }
            else {
                this._offsets.push(offsetX, offsetY);
            }
            if (offsetX === 0 && offsetY === 0)
                return;
            this._lastX = mouseX;
            this._lastY = mouseY;
            this.target.x += offsetX * this._elasticRateX;
            this.target.y += offsetY * this._elasticRateY;
            this.area && this.checkArea();
            this.target.event("dragmove", this.data);
        };
        __proto.checkArea = function () {
            if (this.elasticDistance <= 0) {
                this.backToArea();
            }
            else {
                if (this.target.x < this.area.x) {
                    var offsetX = this.area.x - this.target.x;
                }
                else if (this.target.x > this.area.x + this.area.width) {
                    offsetX = this.target.x - this.area.x - this.area.width;
                }
                else {
                    offsetX = 0;
                }
                this._elasticRateX = Math.max(0, 1 - (offsetX / this.elasticDistance));
                if (this.target.y < this.area.y) {
                    var offsetY = this.area.y - this.target.y;
                }
                else if (this.target.y > this.area.y + this.area.height) {
                    offsetY = this.target.y - this.area.y - this.area.height;
                }
                else {
                    offsetY = 0;
                }
                this._elasticRateY = Math.max(0, 1 - (offsetY / this.elasticDistance));
            }
        };
        __proto.backToArea = function () {
            this.target.x = Math.min(Math.max(this.target.x, this.area.x), this.area.x + this.area.width);
            this.target.y = Math.min(Math.max(this.target.y, this.area.y), this.area.y + this.area.height);
        };
        __proto.onStageMouseUp = function (e) {
            MouseManager.instance.disableMouseEvent = false;
            Laya.stage.off("mouseup", this, this.onStageMouseUp);
            Laya.stage.off("mouseout", this, this.onStageMouseUp);
            Laya.timer.clear(this, this.loop);
            if (this._clickOnly || !this.target)
                return;
            if (this.hasInertia) {
                if (this._offsets.length < 1) {
                    this._offsets.push(this._parent.mouseX - this._lastX, this._parent.mouseY - this._lastY);
                }
                this._offsetX = this._offsetY = 0;
                var len = this._offsets.length;
                var n = Math.min(len, 6);
                var m = this._offsets.length - n;
                for (var i = len - 1; i > m; i--) {
                    this._offsetY += this._offsets[i--];
                    this._offsetX += this._offsets[i];
                }
                this._offsetX = this._offsetX / n * 2;
                this._offsetY = this._offsetY / n * 2;
                if (Math.abs(this._offsetX) > this.maxOffset)
                    this._offsetX = this._offsetX > 0 ? this.maxOffset : -this.maxOffset;
                if (Math.abs(this._offsetY) > this.maxOffset)
                    this._offsetY = this._offsetY > 0 ? this.maxOffset : -this.maxOffset;
                Laya.timer.frameLoop(1, this, this.tweenMove);
            }
            else if (this.elasticDistance > 0) {
                this.checkElastic();
            }
            else {
                this.clear();
            }
        };
        __proto.checkElastic = function () {
            var tx = NaN;
            var ty = NaN;
            if (this.target.x < this.area.x)
                tx = this.area.x;
            else if (this.target.x > this.area.x + this.area.width)
                tx = this.area.x + this.area.width;
            if (this.target.y < this.area.y)
                ty = this.area.y;
            else if (this.target.y > this.area.y + this.area.height)
                ty = this.area.y + this.area.height;
            if (!isNaN(tx) || !isNaN(ty)) {
                var obj = {};
                if (!isNaN(tx))
                    obj.x = tx;
                if (!isNaN(ty))
                    obj.y = ty;
                this._tween = Tween.to(this.target, obj, this.elasticBackTime, Ease.sineOut, Handler.create(this, this.clear), 0, false);
            }
            else {
                this.clear();
            }
        };
        __proto.tweenMove = function () {
            this._offsetX *= this.ratio * this._elasticRateX;
            this._offsetY *= this.ratio * this._elasticRateY;
            this.target.x += this._offsetX;
            this.target.y += this._offsetY;
            this.area && this.checkArea();
            this.target.event("dragmove", this.data);
            if ((Math.abs(this._offsetX) < 1 && Math.abs(this._offsetY) < 1) || this._elasticRateX < 0.5 || this._elasticRateY < 0.5) {
                Laya.timer.clear(this, this.tweenMove);
                if (this.elasticDistance > 0)
                    this.checkElastic();
                else
                    this.clear();
            }
        };
        __proto.clear = function () {
            if (this.target) {
                this.clearTimer();
                var sp = this.target;
                this.target = null;
                this._parent = null;
                sp.event("dragend", this.data);
            }
        };
        return Dragging;
    })();
    var Ease = (function () {
        function Ease() { }
        __class(Ease, 'laya.utils.Ease');
        Ease.linearNone = function (t, b, c, d) {
            return c * t / d + b;
        };
        Ease.linearIn = function (t, b, c, d) {
            return c * t / d + b;
        };
        Ease.linearInOut = function (t, b, c, d) {
            return c * t / d + b;
        };
        Ease.linearOut = function (t, b, c, d) {
            return c * t / d + b;
        };
        Ease.bounceIn = function (t, b, c, d) {
            return c - Ease.bounceOut(d - t, 0, c, d) + b;
        };
        Ease.bounceInOut = function (t, b, c, d) {
            if (t < d * 0.5)
                return Ease.bounceIn(t * 2, 0, c, d) * .5 + b;
            else
                return Ease.bounceOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b;
        };
        Ease.bounceOut = function (t, b, c, d) {
            if ((t /= d) < (1 / 2.75))
                return c * (7.5625 * t * t) + b;
            else if (t < (2 / 2.75))
                return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
            else if (t < (2.5 / 2.75))
                return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
            else
                return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
        };
        Ease.backIn = function (t, b, c, d, s) {
            (s === void 0) && (s = 1.70158);
            return c * (t /= d) * t * ((s + 1) * t - s) + b;
        };
        Ease.backInOut = function (t, b, c, d, s) {
            (s === void 0) && (s = 1.70158);
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
            return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
        };
        Ease.backOut = function (t, b, c, d, s) {
            (s === void 0) && (s = 1.70158);
            return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
        };
        Ease.elasticIn = function (t, b, c, d, a, p) {
            (a === void 0) && (a = 0);
            (p === void 0) && (p = 0);
            var s;
            if (t == 0)
                return b;
            if ((t /= d) == 1)
                return b + c;
            if (!p)
                p = d * .3;
            if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
                a = c;
                s = p / 4;
            }
            else
                s = p / Ease.PI2 * Math.asin(c / a);
            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * Ease.PI2 / p)) + b;
        };
        Ease.elasticInOut = function (t, b, c, d, a, p) {
            (a === void 0) && (a = 0);
            (p === void 0) && (p = 0);
            var s;
            if (t == 0)
                return b;
            if ((t /= d * 0.5) == 2)
                return b + c;
            if (!p)
                p = d * (.3 * 1.5);
            if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
                a = c;
                s = p / 4;
            }
            else
                s = p / Ease.PI2 * Math.asin(c / a);
            if (t < 1)
                return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * Ease.PI2 / p)) + b;
            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * Ease.PI2 / p) * .5 + c + b;
        };
        Ease.elasticOut = function (t, b, c, d, a, p) {
            (a === void 0) && (a = 0);
            (p === void 0) && (p = 0);
            var s;
            if (t == 0)
                return b;
            if ((t /= d) == 1)
                return b + c;
            if (!p)
                p = d * .3;
            if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
                a = c;
                s = p / 4;
            }
            else
                s = p / Ease.PI2 * Math.asin(c / a);
            return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * Ease.PI2 / p) + c + b);
        };
        Ease.strongIn = function (t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        };
        Ease.strongInOut = function (t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * t * t * t * t * t + b;
            return c * 0.5 * ((t -= 2) * t * t * t * t + 2) + b;
        };
        Ease.strongOut = function (t, b, c, d) {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        };
        Ease.sineInOut = function (t, b, c, d) {
            return -c * 0.5 * (Math.cos(Math.PI * t / d) - 1) + b;
        };
        Ease.sineIn = function (t, b, c, d) {
            return -c * Math.cos(t / d * Ease.HALF_PI) + c + b;
        };
        Ease.sineOut = function (t, b, c, d) {
            return c * Math.sin(t / d * Ease.HALF_PI) + b;
        };
        Ease.quintIn = function (t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        };
        Ease.quintInOut = function (t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * t * t * t * t * t + b;
            return c * 0.5 * ((t -= 2) * t * t * t * t + 2) + b;
        };
        Ease.quintOut = function (t, b, c, d) {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        };
        Ease.quartIn = function (t, b, c, d) {
            return c * (t /= d) * t * t * t + b;
        };
        Ease.quartInOut = function (t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * t * t * t * t + b;
            return -c * 0.5 * ((t -= 2) * t * t * t - 2) + b;
        };
        Ease.quartOut = function (t, b, c, d) {
            return -c * ((t = t / d - 1) * t * t * t - 1) + b;
        };
        Ease.cubicIn = function (t, b, c, d) {
            return c * (t /= d) * t * t + b;
        };
        Ease.cubicInOut = function (t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * t * t * t + b;
            return c * 0.5 * ((t -= 2) * t * t + 2) + b;
        };
        Ease.cubicOut = function (t, b, c, d) {
            return c * ((t = t / d - 1) * t * t + 1) + b;
        };
        Ease.quadIn = function (t, b, c, d) {
            return c * (t /= d) * t + b;
        };
        Ease.quadInOut = function (t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * t * t + b;
            return -c * 0.5 * ((--t) * (t - 2) - 1) + b;
        };
        Ease.quadOut = function (t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        };
        Ease.expoIn = function (t, b, c, d) {
            return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b - c * 0.001;
        };
        Ease.expoInOut = function (t, b, c, d) {
            if (t == 0)
                return b;
            if (t == d)
                return b + c;
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * Math.pow(2, 10 * (t - 1)) + b;
            return c * 0.5 * (-Math.pow(2, -10 * --t) + 2) + b;
        };
        Ease.expoOut = function (t, b, c, d) {
            return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
        };
        Ease.circIn = function (t, b, c, d) {
            return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
        };
        Ease.circInOut = function (t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return -c * 0.5 * (Math.sqrt(1 - t * t) - 1) + b;
            return c * 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
        };
        Ease.circOut = function (t, b, c, d) {
            return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
        };
        Ease.HALF_PI = Math.PI * 0.5;
        Ease.PI2 = Math.PI * 2;
        return Ease;
    })();
    var HitArea = (function () {
        function HitArea() {
            this._hit = null;
            this._unHit = null;
        }
        __class(HitArea, 'laya.utils.HitArea');
        var __proto = HitArea.prototype;
        __proto.isHit = function (x, y) {
            if (!HitArea.isHitGraphic(x, y, this.hit))
                return false;
            return !HitArea.isHitGraphic(x, y, this.unHit);
        };
        __proto.contains = function (x, y) {
            return this.isHit(x, y);
        };
        __getset(0, __proto, 'hit', function () {
            if (!this._hit)
                this._hit = new Graphics();
            return this._hit;
        }, function (value) {
            this._hit = value;
        });
        __getset(0, __proto, 'unHit', function () {
            if (!this._unHit)
                this._unHit = new Graphics();
            return this._unHit;
        }, function (value) {
            this._unHit = value;
        });
        HitArea.isHitGraphic = function (x, y, graphic) {
            if (!graphic)
                return false;
            var cmds;
            cmds = graphic.cmds;
            if (!cmds && graphic._one) {
                cmds = HitArea._cmds;
                cmds.length = 1;
                cmds[0] = graphic._one;
            }
            if (!cmds)
                return false;
            var i = 0, len = 0;
            len = cmds.length;
            var cmd;
            for (i = 0; i < len; i++) {
                cmd = cmds[i];
                if (!cmd)
                    continue;
                var context = Render._context;
                switch (cmd.callee) {
                    case context._translate:
                    case 6:
                        x -= cmd[0];
                        y -= cmd[1];
                    default:
                }
                if (HitArea.isHitCmd(x, y, cmd))
                    return true;
            }
            return false;
        };
        HitArea.isHitCmd = function (x, y, cmd) {
            if (!cmd)
                return false;
            var context = Render._context;
            var rst = false;
            switch (cmd["callee"]) {
                case context._drawRect:
                case 13:
                    HitArea._rec.setTo(cmd[0], cmd[1], cmd[2], cmd[3]);
                    rst = HitArea._rec.contains(x, y);
                    break;
                case context._drawCircle:
                case context._fillCircle:
                case 14:
                    ;
                    var d = NaN;
                    x -= cmd[0];
                    y -= cmd[1];
                    d = x * x + y * y;
                    rst = d < cmd[2] * cmd[2];
                    break;
                case context._drawPoly:
                case 18:
                    x -= cmd[0];
                    y -= cmd[1];
                    rst = HitArea.ptInPolygon(x, y, cmd[2]);
                    break;
                default:
                    break;
            }
            return rst;
        };
        HitArea.ptInPolygon = function (x, y, areaPoints) {
            var p;
            p = HitArea._ptPoint;
            p.setTo(x, y);
            var nCross = 0;
            var p1x = NaN, p1y = NaN, p2x = NaN, p2y = NaN;
            var len = 0;
            len = areaPoints.length;
            for (var i = 0; i < len; i += 2) {
                p1x = areaPoints[i];
                p1y = areaPoints[i + 1];
                p2x = areaPoints[(i + 2) % len];
                p2y = areaPoints[(i + 3) % len];
                if (p1y == p2y)
                    continue;
                if (p.y < Math.min(p1y, p2y))
                    continue;
                if (p.y >= Math.max(p1y, p2y))
                    continue;
                var tx = (p.y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x;
                if (tx > p.x) {
                    nCross++;
                }
            }
            return (nCross % 2 == 1);
        };
        HitArea._cmds = [];
        __static(HitArea, ['_rec', function () { return this._rec = new Rectangle(); }, '_ptPoint', function () { return this._ptPoint = new Point(); }
        ]);
        return HitArea;
    })();
    var HTMLChar = (function () {
        function HTMLChar(char, w, h, style) {
            this.char = char;
            this.charNum = char.charCodeAt(0);
            this._x = this._y = 0;
            this.width = w;
            this.height = h;
            this.style = style;
            this.isWord = !HTMLChar._isWordRegExp.test(char);
        }
        __class(HTMLChar, 'laya.utils.HTMLChar');
        var __proto = HTMLChar.prototype;
        Laya.imps(__proto, { "laya.display.ILayout": true });
        __proto.setSprite = function (sprite) {
            this._sprite = sprite;
        };
        __proto.getSprite = function () {
            return this._sprite;
        };
        __proto._isChar = function () {
            return true;
        };
        __proto._getCSSStyle = function () {
            return this.style;
        };
        __getset(0, __proto, 'width', function () {
            return this._w;
        }, function (value) {
            this._w = value;
        });
        __getset(0, __proto, 'x', function () {
            return this._x;
        }, function (value) {
            if (this._sprite) {
                this._sprite.x = value;
            }
            this._x = value;
        });
        __getset(0, __proto, 'y', function () {
            return this._y;
        }, function (value) {
            if (this._sprite) {
                this._sprite.y = value;
            }
            this._y = value;
        });
        __getset(0, __proto, 'height', function () {
            return this._h;
        }, function (value) {
            this._h = value;
        });
        HTMLChar._isWordRegExp = new RegExp("[\\w\.]", "");
        return HTMLChar;
    })();
    var Log = (function () {
        function Log() { }
        __class(Log, 'laya.utils.Log');
        Log.enable = function () {
            if (!Log._logdiv) {
                Log._logdiv = Browser.window.document.createElement('div');
                Browser.window.document.body.appendChild(Log._logdiv);
                Log._logdiv.style.cssText = "pointer-events:none;border:white;overflow:hidden;z-index:1000000;background:rgba(100,100,100,0.6);color:white;position: absolute;left:0px;top:0px;width:50%;height:50%;";
            }
        };
        Log.toggle = function () {
            var style = Log._logdiv.style;
            if (style.width == "1px") {
                style.width = style.height = "50%";
            }
            else {
                style.width = style.height = "1px";
            }
        };
        Log.print = function (value) {
            if (Log._logdiv) {
                if (Log._count >= Log.maxCount)
                    Log.clear();
                Log._count++;
                Log._logdiv.innerText += value + "\n";
                Log._logdiv.scrollTop = Log._logdiv.scrollHeight;
            }
        };
        Log.clear = function () {
            Log._logdiv.innerText = "";
            Log._count = 0;
        };
        Log._logdiv = null;
        Log._count = 0;
        Log.maxCount = 20;
        return Log;
    })();
    var Mouse = (function () {
        function Mouse() { }
        __class(Mouse, 'laya.utils.Mouse');
        __getset(1, Mouse, 'cursor', function () {
            return Mouse._style.cursor;
        }, function (cursorStr) {
            Mouse._style.cursor = cursorStr;
        });
        Mouse.hide = function () {
            if (Mouse.cursor != "none") {
                Mouse._preCursor = Mouse.cursor;
                Mouse.cursor = "none";
            }
        };
        Mouse.show = function () {
            if (Mouse.cursor == "none") {
                if (Mouse._preCursor) {
                    Mouse.cursor = Mouse._preCursor;
                }
                else {
                    Mouse.cursor = "auto";
                }
            }
        };
        Mouse._preCursor = null;
        __static(Mouse, ['_style', function () { return this._style = Browser.document.body.style; }
        ]);
        return Mouse;
    })();
    var Pool = (function () {
        function Pool() { }
        __class(Pool, 'laya.utils.Pool');
        Pool.getPoolBySign = function (sign) {
            return Pool._poolDic[sign] || (Pool._poolDic[sign] = []);
        };
        Pool.clearBySign = function (sign) {
            if (Pool._poolDic[sign])
                Pool._poolDic[sign].length = 0;
        };
        Pool.recover = function (sign, item) {
            if (item["__InPool"])
                return;
            item["__InPool"] = true;
            Pool.getPoolBySign(sign).push(item);
        };
        Pool.getItemByClass = function (sign, cls) {
            var pool = Pool.getPoolBySign(sign);
            var rst = pool.length ? pool.pop() : new cls();
            rst["__InPool"] = false;
            return rst;
        };
        Pool.getItemByCreateFun = function (sign, createFun) {
            var pool = Pool.getPoolBySign(sign);
            var rst = pool.length ? pool.pop() : createFun();
            rst["__InPool"] = false;
            return rst;
        };
        Pool.getItem = function (sign) {
            var pool = Pool.getPoolBySign(sign);
            var rst = pool.length ? pool.pop() : null;
            if (rst) {
                rst["__InPool"] = false;
            }
            return rst;
        };
        Pool._poolDic = {};
        Pool.InPoolSign = "__InPool";
        return Pool;
    })();
    var PoolCache = (function () {
        function PoolCache() {
            this.sign = null;
            this.maxCount = 1000;
        }
        __class(PoolCache, 'laya.utils.PoolCache');
        var __proto = PoolCache.prototype;
        __proto.getCacheList = function () {
            return Pool.getPoolBySign(this.sign);
        };
        __proto.tryDispose = function (force) {
            var list;
            list = Pool.getPoolBySign(this.sign);
            if (list.length > this.maxCount) {
                list.splice(this.maxCount, list.length - this.maxCount);
            }
        };
        PoolCache.addPoolCacheManager = function (sign, maxCount) {
            (maxCount === void 0) && (maxCount = 100);
            var cache;
            cache = new PoolCache();
            cache.sign = sign;
            cache.maxCount = maxCount;
            CacheManager.regCacheByFunction(Utils.bind(cache.tryDispose, cache), Utils.bind(cache.getCacheList, cache));
        };
        return PoolCache;
    })();
    var Stat = (function () {
        function Stat() { }
        __class(Stat, 'laya.utils.Stat');
        __getset(1, Stat, 'onclick', null, function (fn) {
            if (Stat._sp) {
                Stat._sp.on("click", Stat._sp, fn);
            }
            if (Stat._canvas) {
                Stat._canvas.source.onclick = fn;
                Stat._canvas.source.style.pointerEvents = '';
            }
        });
        Stat.show = function (x, y) {
            (x === void 0) && (x = 0);
            (y === void 0) && (y = 0);
            if (Render.isConchApp) {
                Browser.window.conch.showFPS && Browser.window.conch.showFPS(x, y);
                return;
            }
            if (!Browser.onMiniGame && !Browser.onLimixiu)
                Stat._useCanvas = true;
            Stat._show = true;
            Stat._fpsData.length = 60;
            Stat._view[0] = { title: "FPS(Canvas)", value: "_fpsStr", color: "yellow", units: "int" };
            Stat._view[1] = { title: "Sprite", value: "_spriteStr", color: "white", units: "int" };
            Stat._view[2] = { title: "DrawCall", value: "drawCall", color: "white", units: "int" };
            Stat._view[3] = { title: "CurMem", value: "currentMemorySize", color: "yellow", units: "M" };
            if (Render.isWebGL) {
                Stat._view[4] = { title: "Shader", value: "shaderCall", color: "white", units: "int" };
                if (!Render.is3DMode) {
                    Stat._view[0].title = "FPS";
                    Stat._view[5] = { title: "Canvas", value: "_canvasStr", color: "white", units: "int" };
                }
                else {
                    Stat._view[0].title = "FPS(3D)";
                    Stat._view[5] = { title: "TriFaces", value: "trianglesFaces", color: "white", units: "int" };
                    Stat._view[6] = { title: "treeNodeColl", value: "treeNodeCollision", color: "white", units: "int" };
                    Stat._view[7] = { title: "treeSpriteColl", value: "treeSpriteCollision", color: "white", units: "int" };
                }
            }
            else {
                Stat._view[4] = { title: "Canvas", value: "_canvasStr", color: "white", units: "int" };
            }
            if (Stat._useCanvas) {
                Stat.createUIPre(x, y);
            }
            else
                Stat.createUI(x, y);
            Stat.enable();
        };
        Stat.createUIPre = function (x, y) {
            var pixel = Browser.pixelRatio;
            Stat._width = pixel * 130;
            Stat._vx = pixel * 75;
            Stat._height = pixel * (Stat._view.length * 12 + 3 * pixel) + 4;
            Stat._fontSize = 12 * pixel;
            var d = 0;
            for (var i = 0; i < Stat._view.length; i++) {
                if (i == 3 || i == 5) {
                    continue;
                }
                Stat._view[i].x = 4;
                Stat._view[i].y = d * Stat._fontSize + 2 * pixel + d * 5 + 6;
                d++;
            }
            if (!Stat._canvas) {
                Stat._canvas = new HTMLCanvas('2D');
                Stat._canvas.size(Stat._width, Stat._height);
                Stat._ctx = Stat._canvas.getContext('2d');
                Stat._ctx.textBaseline = "top";
                Stat._ctx.font = Stat._fontSize + "px Sans-serif";
                Stat._canvas.source.style.cssText = "pointer-events:none;background:rgba(0,0,0,0.8);z-index:100000;position: absolute;direction:ltr;left:" + x + "px;top:" + y + "px;width:" + (Stat._width / pixel) + "px;height:" + (Stat._height / pixel) + "px;";
            }
            Stat._first = true;
            Stat.loop();
            Stat._first = false;
            Browser.container.appendChild(Stat._canvas.source);
        };
        Stat.createUI = function (x, y) {
            var stat = Stat._sp;
            var pixel = Browser.pixelRatio;
            if (!stat) {
                stat = new Sprite();
                Stat._leftText = new Text();
                Stat._leftText.pos(5, 5);
                Stat._leftText.color = "#ffffff";
                stat.addChild(Stat._leftText);
                Stat._txt = new Text();
                Stat._txt.pos(80 * pixel, 5);
                Stat._txt.color = "#ffffff";
                stat.addChild(Stat._txt);
                Stat._sp = stat;
            }
            stat.pos(x, y);
            var text = "";
            for (var i = 0; i < Stat._view.length; i++) {
                var one = Stat._view[i];
                text += one.title + "\n";
            }
            Stat._leftText.text = text;
            var width = pixel * 138;
            var height = pixel * (Stat._view.length * 12 + 3 * pixel) + 4;
            Stat._txt.fontSize = Stat._fontSize * pixel;
            Stat._leftText.fontSize = Stat._fontSize * pixel;
            stat.size(width, height);
            stat.graphics.clear();
            stat.graphics.setAlpha(0.5);
            stat.graphics.drawRect(0, 0, width, height, "#999999");
            stat.graphics.setAlpha(1);
            Stat.loop();
        };
        Stat.enable = function () {
            Laya.timer.frameLoop(1, Stat, Stat.loop);
        };
        Stat.hide = function () {
            Stat._show = false;
            Laya.timer.clear(Stat, Stat.loop);
            if (Stat._canvas) {
                Browser.removeElement(Stat._canvas.source);
            }
        };
        Stat.clear = function () {
            Stat.trianglesFaces = Stat.drawCall = Stat.shaderCall = Stat.spriteCount = Stat.spriteRenderUseCacheCount = Stat.treeNodeCollision = Stat.treeSpriteCollision = Stat.canvasNormal = Stat.canvasBitmap = Stat.canvasReCache = 0;
        };
        Stat.loop = function () {
            Stat._count++;
            var timer = Browser.now();
            if (timer - Stat._timer < 1000)
                return;
            var count = Stat._count;
            Stat.FPS = Math.round((count * 1000) / (timer - Stat._timer));
            if (Stat._show) {
                Stat.trianglesFaces = Math.round(Stat.trianglesFaces / count);
                if (!Stat._useCanvas) {
                    Stat.drawCall = Math.round(Stat.drawCall / count) - 2;
                    Stat.shaderCall = Math.round(Stat.shaderCall / count) - 4;
                    Stat.spriteCount = Math.round(Stat.spriteCount / count) - 4;
                }
                else {
                    Stat.drawCall = Math.round(Stat.drawCall / count) - 2;
                    Stat.shaderCall = Math.round(Stat.shaderCall / count);
                    Stat.spriteCount = Math.round(Stat.spriteCount / count) - 1;
                }
                Stat.spriteRenderUseCacheCount = Math.round(Stat.spriteRenderUseCacheCount / count);
                Stat.canvasNormal = Math.round(Stat.canvasNormal / count);
                Stat.canvasBitmap = Math.round(Stat.canvasBitmap / count);
                Stat.canvasReCache = Math.ceil(Stat.canvasReCache / count);
                Stat.treeNodeCollision = Math.round(Stat.treeNodeCollision / count);
                Stat.treeSpriteCollision = Math.round(Stat.treeSpriteCollision / count);
                var delay = Stat.FPS > 0 ? Math.floor(1000 / Stat.FPS).toString() : " ";
                Stat._fpsStr = Stat.FPS + (Stat.renderSlow ? " slow" : "") + " " + delay;
                Stat._spriteStr = Stat.spriteCount + (Stat.spriteRenderUseCacheCount ? ("/" + Stat.spriteRenderUseCacheCount) : '');
                Stat._canvasStr = Stat.canvasReCache + "/" + Stat.canvasNormal + "/" + Stat.canvasBitmap;
                Stat.currentMemorySize = ResourceManager.systemResourceManager.memorySize;
                if (Stat._useCanvas) {
                    Stat.renderInfoPre();
                }
                else
                    Stat.renderInfo();
                Stat.clear();
            }
            Stat._count = 0;
            Stat._timer = timer;
        };
        Stat.renderInfoPre = function () {
            if (Stat._canvas) {
                var ctx = Stat._ctx;
                ctx.clearRect(Stat._first ? 0 : Stat._vx, 0, Stat._width, Stat._height);
                for (var i = 0; i < Stat._view.length; i++) {
                    var one = Stat._view[i];
                    if (Stat._first) {
                        ctx.fillStyle = "white";
                        ctx.fillText(one.title, one.x, one.y, null, null, null);
                    }
                    ctx.fillStyle = one.color;
                    var value = Stat[one.value];
                    (one.units == "M") && (value = Math.floor(value / (1024 * 1024) * 100) / 100 + " M");
                    ctx.fillText(value + "", one.x + Stat._vx, one.y, null, null, null);
                }
            }
        };
        Stat.renderInfo = function () {
            var text = "";
            for (var i = 0; i < Stat._view.length; i++) {
                var one = Stat._view[i];
                var value = Stat[one.value];
                (one.units == "M") && (value = Math.floor(value / (1024 * 1024) * 100) / 100 + " M");
                (one.units == "K") && (value = Math.floor(value / (1024) * 100) / 100 + " K");
                text += value + "\n";
            }
            Stat._txt.text = text;
        };
        Stat.FPS = 0;
        Stat.loopCount = 0;
        Stat.shaderCall = 0;
        Stat.drawCall = 0;
        Stat.trianglesFaces = 0;
        Stat.spriteCount = 0;
        Stat.spriteRenderUseCacheCount = 0;
        Stat.treeNodeCollision = 0;
        Stat.treeSpriteCollision = 0;
        Stat.canvasNormal = 0;
        Stat.canvasBitmap = 0;
        Stat.canvasReCache = 0;
        Stat.renderSlow = false;
        Stat.currentMemorySize = 0;
        Stat._fpsStr = null;
        Stat._canvasStr = null;
        Stat._spriteStr = null;
        Stat._fpsData = [];
        Stat._timer = 0;
        Stat._count = 0;
        Stat._view = [];
        Stat._fontSize = 12;
        Stat._txt = null;
        Stat._leftText = null;
        Stat._sp = null;
        Stat._show = false;
        Stat._useCanvas = false;
        Stat._canvas = null;
        Stat._ctx = null;
        Stat._first = false;
        Stat._vx = NaN;
        Stat._width = 0;
        Stat._height = 100;
        return Stat;
    })();
    var StringKey = (function () {
        function StringKey() {
            this._strsToID = {};
            this._idToStrs = [];
            this._length = 0;
        }
        __class(StringKey, 'laya.utils.StringKey');
        var __proto = StringKey.prototype;
        __proto.add = function (str) {
            var index = this._strsToID[str];
            if (index != null)
                return index;
            this._idToStrs[this._length] = str;
            return this._strsToID[str] = this._length++;
        };
        __proto.getID = function (str) {
            var index = this._strsToID[str];
            return index == null ? -1 : index;
        };
        __proto.getName = function (id) {
            var str = this._idToStrs[id];
            return str == null ? undefined : str;
        };
        return StringKey;
    })();
    var Timer = (function () {
        var TimerHandler;
        function Timer() {
            this._delta = 0;
            this.scale = 1;
            this.currFrame = 0;
            this._mid = 1;
            this._map = [];
            this._laters = [];
            this._handlers = [];
            this._temp = [];
            this._count = 0;
            this.currTimer = this._now();
            this._lastTimer = this._now();
            this._init();
        }
        __class(Timer, 'laya.utils.Timer');
        var __proto = Timer.prototype;
        __proto._init = function () {
            Laya.timer && Laya.timer.frameLoop(1, this, this._update);
        };
        __proto._now = function () {
            return Date.now();
        };
        __proto._update = function () {
            if (this.scale <= 0) {
                this._lastTimer = this._now();
                return;
            }
            ;
            var frame = this.currFrame = this.currFrame + this.scale;
            var now = this._now();
            this._delta = (now - this._lastTimer) * this.scale;
            var timer = this.currTimer = this.currTimer + this._delta;
            this._lastTimer = now;
            var handlers = this._handlers;
            this._count = 0;
            for (i = 0, n = handlers.length; i < n; i++) {
                handler = handlers[i];
                if (handler == null)
                    continue;
                if (handler.method !== null) {
                    var t = handler.userFrame ? frame : timer;
                    if (t >= handler.exeTime) {
                        if (handler.repeat) {
                            if (!handler.jumpFrame) {
                                handler.exeTime += handler.delay;
                                handler.run(false);
                                if (t > handler.exeTime) {
                                    handler.exeTime += Math.ceil((t - handler.exeTime) / handler.delay) * handler.delay;
                                }
                            }
                            else {
                                while (t >= handler.exeTime) {
                                    handler.exeTime += handler.delay;
                                    handler.run(false);
                                }
                            }
                        }
                        else {
                            handler.run(true);
                        }
                    }
                }
                else {
                    this._count++;
                }
            }
            if (this._count > 30 || frame % 200 === 0)
                this._clearHandlers();
            var laters = this._laters;
            for (var i = 0, n = laters.length - 1; i <= n; i++) {
                var handler = laters[i];
                if (handler.method !== null) {
                    this._map[handler.key] = null;
                    handler.run(false);
                }
                this._recoverHandler(handler);
                i === n && (n = laters.length - 1);
            }
            laters.length = 0;
        };
        __proto._clearHandlers = function () {
            var handlers = this._handlers;
            for (var i = 0, n = handlers.length; i < n; i++) {
                var handler = handlers[i];
                if (handler.method !== null)
                    this._temp.push(handler);
                else
                    this._recoverHandler(handler);
            }
            this._handlers = this._temp;
            this._temp = handlers;
            this._temp.length = 0;
        };
        __proto._recoverHandler = function (handler) {
            if (this._map[handler.key] == handler)
                this._map[handler.key] = null;
            handler.clear();
            Timer._pool.push(handler);
        };
        __proto._create = function (useFrame, repeat, delay, caller, method, args, coverBefore) {
            if (!delay) {
                method.apply(caller, args);
                return null;
            }
            if (coverBefore) {
                var handler = this._getHandler(caller, method);
                if (handler) {
                    handler.repeat = repeat;
                    handler.userFrame = useFrame;
                    handler.delay = delay;
                    handler.caller = caller;
                    handler.method = method;
                    handler.args = args;
                    handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + this._now() - this._lastTimer);
                    return handler;
                }
            }
            handler = Timer._pool.length > 0 ? Timer._pool.pop() : new TimerHandler();
            handler.repeat = repeat;
            handler.userFrame = useFrame;
            handler.delay = delay;
            handler.caller = caller;
            handler.method = method;
            handler.args = args;
            handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + this._now() - this._lastTimer) + 1;
            this._indexHandler(handler);
            this._handlers.push(handler);
            return handler;
        };
        __proto._indexHandler = function (handler) {
            var caller = handler.caller;
            var method = handler.method;
            var cid = caller ? caller.$_GID || (caller.$_GID = Utils.getGID()) : 0;
            var mid = method.$_TID || (method.$_TID = (this._mid++) * 100000);
            handler.key = cid + mid;
            this._map[handler.key] = handler;
        };
        __proto.once = function (delay, caller, method, args, coverBefore) {
            (coverBefore === void 0) && (coverBefore = true);
            this._create(false, false, delay, caller, method, args, coverBefore);
        };
        __proto.loop = function (delay, caller, method, args, coverBefore, jumpFrame) {
            (coverBefore === void 0) && (coverBefore = true);
            (jumpFrame === void 0) && (jumpFrame = false);
            var handler = this._create(false, true, delay, caller, method, args, coverBefore);
            if (handler)
                handler.jumpFrame = jumpFrame;
        };
        __proto.frameOnce = function (delay, caller, method, args, coverBefore) {
            (coverBefore === void 0) && (coverBefore = true);
            this._create(true, false, delay, caller, method, args, coverBefore);
        };
        __proto.frameLoop = function (delay, caller, method, args, coverBefore) {
            (coverBefore === void 0) && (coverBefore = true);
            this._create(true, true, delay, caller, method, args, coverBefore);
        };
        __proto.toString = function () {
            return "callLater:" + this._laters.length + " handlers:" + this._handlers.length + " pool:" + Timer._pool.length;
        };
        __proto.clear = function (caller, method) {
            var handler = this._getHandler(caller, method);
            if (handler) {
                this._map[handler.key] = null;
                handler.key = 0;
                handler.clear();
            }
        };
        __proto.clearAll = function (caller) {
            if (!caller)
                return;
            for (var i = 0, n = this._handlers.length; i < n; i++) {
                var handler = this._handlers[i];
                if (handler.caller === caller) {
                    this._map[handler.key] = null;
                    handler.key = 0;
                    handler.clear();
                }
            }
        };
        __proto._getHandler = function (caller, method) {
            var cid = caller ? caller.$_GID || (caller.$_GID = Utils.getGID()) : 0;
            var mid = method.$_TID || (method.$_TID = (this._mid++) * 100000);
            return this._map[cid + mid];
        };
        __proto.callLater = function (caller, method, args) {
            if (this._getHandler(caller, method) == null) {
                if (Timer._pool.length)
                    var handler = Timer._pool.pop();
                else
                    handler = new TimerHandler();
                handler.caller = caller;
                handler.method = method;
                handler.args = args;
                this._indexHandler(handler);
                this._laters.push(handler);
            }
        };
        __proto.runCallLater = function (caller, method) {
            var handler = this._getHandler(caller, method);
            if (handler && handler.method != null) {
                this._map[handler.key] = null;
                handler.run(true);
            }
        };
        __proto.runTimer = function (caller, method) {
            this.runCallLater(caller, method);
        };
        __getset(0, __proto, 'delta', function () {
            return this._delta;
        });
        Timer._pool = [];
        Timer.__init$ = function () {
            TimerHandler = (function () {
                function TimerHandler() {
                    this.key = 0;
                    this.repeat = false;
                    this.delay = 0;
                    this.userFrame = false;
                    this.exeTime = 0;
                    this.caller = null;
                    this.method = null;
                    this.args = null;
                    this.jumpFrame = false;
                }
                __class(TimerHandler, '');
                var __proto = TimerHandler.prototype;
                __proto.clear = function () {
                    this.caller = null;
                    this.method = null;
                    this.args = null;
                };
                __proto.run = function (withClear) {
                    var caller = this.caller;
                    if (caller && caller.destroyed)
                        return this.clear();
                    var method = this.method;
                    var args = this.args;
                    withClear && this.clear();
                    if (method == null)
                        return;
                    args ? method.apply(caller, args) : method.call(caller);
                };
                return TimerHandler;
            })();
        };
        return Timer;
    })();
    var Tween = (function () {
        function Tween() {
            this.gid = 0;
        }
        __class(Tween, 'laya.utils.Tween');
        var __proto = Tween.prototype;
        __proto.to = function (target, props, duration, ease, complete, delay, coverBefore) {
            (delay === void 0) && (delay = 0);
            (coverBefore === void 0) && (coverBefore = false);
            return this._create(target, props, duration, ease, complete, delay, coverBefore, true, false, true);
        };
        __proto.from = function (target, props, duration, ease, complete, delay, coverBefore) {
            (delay === void 0) && (delay = 0);
            (coverBefore === void 0) && (coverBefore = false);
            return this._create(target, props, duration, ease, complete, delay, coverBefore, false, false, true);
        };
        __proto._create = function (target, props, duration, ease, complete, delay, coverBefore, isTo, usePool, runNow) {
            if (!target)
                throw new Error("Tween:target is null");
            this._target = target;
            this._duration = duration;
            this._ease = ease || props.ease || Tween.easeNone;
            this._complete = complete || props.complete;
            this._delay = delay;
            this._props = [];
            this._usedTimer = 0;
            this._startTimer = Browser.now();
            this._usedPool = usePool;
            this._delayParam = null;
            this.update = props.update;
            var gid = (target.$_GID || (target.$_GID = Utils.getGID()));
            if (!Tween.tweenMap[gid]) {
                Tween.tweenMap[gid] = [this];
            }
            else {
                if (coverBefore)
                    Tween.clearTween(target);
                Tween.tweenMap[gid].push(this);
            }
            if (runNow) {
                if (delay <= 0)
                    this.firstStart(target, props, isTo);
                else {
                    this._delayParam = [target, props, isTo];
                    Laya.scaleTimer.once(delay, this, this.firstStart, this._delayParam);
                }
            }
            else {
                this._initProps(target, props, isTo);
            }
            return this;
        };
        __proto.firstStart = function (target, props, isTo) {
            this._delayParam = null;
            if (target.destroyed) {
                this.clear();
                return;
            }
            this._initProps(target, props, isTo);
            this._beginLoop();
        };
        __proto._initProps = function (target, props, isTo) {
            for (var p in props) {
                if ((typeof (target[p]) == 'number')) {
                    var start = isTo ? target[p] : props[p];
                    var end = isTo ? props[p] : target[p];
                    this._props.push([p, start, end - start]);
                    if (!isTo)
                        target[p] = start;
                }
            }
        };
        __proto._beginLoop = function () {
            Laya.scaleTimer.frameLoop(1, this, this._doEase);
        };
        __proto._doEase = function () {
            this._updateEase(Browser.now());
        };
        __proto._updateEase = function (time) {
            var target = this._target;
            if (!target)
                return;
            if (target.destroyed)
                return Tween.clearTween(target);
            var usedTimer = this._usedTimer = time - this._startTimer - this._delay;
            if (usedTimer < 0)
                return;
            if (usedTimer >= this._duration)
                return this.complete();
            var ratio = usedTimer > 0 ? this._ease(usedTimer, 0, 1, this._duration) : 0;
            var props = this._props;
            for (var i = 0, n = props.length; i < n; i++) {
                var prop = props[i];
                target[prop[0]] = prop[1] + (ratio * prop[2]);
            }
            if (this.update)
                this.update.run();
        };
        __proto.complete = function () {
            if (!this._target)
                return;
            Laya.scaleTimer.runTimer(this, this.firstStart);
            var target = this._target;
            var props = this._props;
            var handler = this._complete;
            for (var i = 0, n = props.length; i < n; i++) {
                var prop = props[i];
                target[prop[0]] = prop[1] + prop[2];
            }
            if (this.update)
                this.update.run();
            this.clear();
            handler && handler.run();
        };
        __proto.pause = function () {
            Laya.scaleTimer.clear(this, this._beginLoop);
            Laya.scaleTimer.clear(this, this._doEase);
            Laya.scaleTimer.clear(this, this.firstStart);
            var time = Browser.now();
            var dTime = NaN;
            dTime = time - this._startTimer - this._delay;
            if (dTime < 0) {
                this._usedTimer = dTime;
            }
        };
        __proto.setStartTime = function (startTime) {
            this._startTimer = startTime;
        };
        __proto.clear = function () {
            if (this._target) {
                this._remove();
                this._clear();
            }
        };
        __proto._clear = function () {
            this.pause();
            Laya.scaleTimer.clear(this, this.firstStart);
            this._complete = null;
            this._target = null;
            this._ease = null;
            this._props = null;
            this._delayParam = null;
            // if (this._usedPool) {
            //     this.update = null;
            //     Pool.recover("tween", this);
            // }
        };
        __proto.recover = function () {
            // this._usedPool = true;
            this._clear();
        };
        __proto._remove = function () {
            var tweens = Tween.tweenMap[this._target.$_GID];
            if (tweens) {
                for (var i = 0, n = tweens.length; i < n; i++) {
                    if (tweens[i] === this) {
                        tweens.splice(i, 1);
                        break;
                    }
                }
            }
        };
        __proto.restart = function () {
            this.pause();
            this._usedTimer = 0;
            this._startTimer = Browser.now();
            if (this._delayParam) {
                Laya.scaleTimer.once(this._delay, this, this.firstStart, this._delayParam);
                return;
            }
            ;
            var props = this._props;
            for (var i = 0, n = props.length; i < n; i++) {
                var prop = props[i];
                this._target[prop[0]] = prop[1];
            }
            Laya.scaleTimer.once(this._delay, this, this._beginLoop);
        };
        __proto.resume = function () {
            if (this._usedTimer >= this._duration)
                return;
            this._startTimer = Browser.now() - this._usedTimer - this._delay;
            if (this._delayParam) {
                if (this._usedTimer < 0) {
                    Laya.scaleTimer.once(-this._usedTimer, this, this.firstStart, this._delayParam);
                }
                else {
                    this.firstStart.apply(this, this._delayParam);
                }
            }
            else {
                this._beginLoop();
            }
        };
        __getset(0, __proto, 'progress', function () {
            return Math.min(Math.max((Browser.now() - this._startTimer) / this._duration, 0), 1);
        }, function (v) {
            var uTime = v * this._duration;
            this._startTimer = Browser.now() - this._delay - uTime;
        });
        Tween.to = function (target, props, duration, ease, complete, delay, coverBefore) {
            (delay === void 0) && (delay = 0);
            (coverBefore === void 0) && (coverBefore = false);
            return new Tween()._create(target, props, duration, ease, complete, delay, coverBefore, true, false, true);
        };
        Tween.from = function (target, props, duration, ease, complete, delay, coverBefore) {
            (delay === void 0) && (delay = 0);
            (coverBefore === void 0) && (coverBefore = false);
            return new Tween()._create(target, props, duration, ease, complete, delay, coverBefore, false, false, true);
        };
        Tween.clearAll = function (target) {
            if (!target || !target.$_GID)
                return;
            var tweens = Tween.tweenMap[target.$_GID];
            if (tweens) {
                for (var i = 0, n = tweens.length; i < n; i++) {
                    tweens[i]._clear();
                }
                tweens.length = 0;
            }
        };
        Tween.clear = function (tween) {
            tween.clear();
        };
        Tween.clearTween = function (target) {
            Tween.clearAll(target);
        };
        Tween.easeNone = function (t, b, c, d) {
            return c * t / d + b;
        };
        Tween.tweenMap = {};
        return Tween;
    })();
    var Utils = (function () {
        function Utils() { }
        __class(Utils, 'laya.utils.Utils');
        Utils.toRadian = function (angle) {
            return angle * Utils._pi2;
        };
        Utils.toAngle = function (radian) {
            return radian * Utils._pi;
        };
        Utils.toHexColor = function (color) {
            if (color < 0 || isNaN(color))
                return null;
            var str = color.toString(16);
            while (str.length < 6)
                str = "0" + str;
            return "#" + str;
        };
        Utils.getGID = function () {
            return Utils._gid++;
        };
        Utils.concatArray = function (source, array) {
            if (!array)
                return source;
            if (!source)
                return array;
            var i = 0, len = array.length;
            for (i = 0; i < len; i++) {
                source.push(array[i]);
            }
            return source;
        };
        Utils.clearArray = function (array) {
            if (!array)
                return array;
            array.length = 0;
            return array;
        };
        Utils.copyArray = function (source, array) {
            source || (source = []);
            if (!array)
                return source;
            source.length = array.length;
            var i = 0, len = array.length;
            for (i = 0; i < len; i++) {
                source[i] = array[i];
            }
            return source;
        };
        Utils.getGlobalRecByPoints = function (sprite, x0, y0, x1, y1) {
            var newLTPoint;
            newLTPoint = new Point(x0, y0);
            newLTPoint = sprite.localToGlobal(newLTPoint);
            var newRBPoint;
            newRBPoint = new Point(x1, y1);
            newRBPoint = sprite.localToGlobal(newRBPoint);
            return Rectangle._getWrapRec([newLTPoint.x, newLTPoint.y, newRBPoint.x, newRBPoint.y]);
        };
        Utils.getGlobalPosAndScale = function (sprite) {
            return Utils.getGlobalRecByPoints(sprite, 0, 0, 1, 1);
        };
        Utils.bind = function (fun, scope) {
            var rst = fun;
            rst = fun.bind(scope);
            ;
            return rst;
        };
        Utils.measureText = function (txt, font) {
            return RunDriver.measureText(txt, font);
        };
        Utils.updateOrder = function (array) {
            if (!array || array.length < 2)
                return false;
            var i = 1, j = 0, len = array.length, key = NaN, c;
            while (i < len) {
                j = i;
                c = array[j];
                key = array[j]._zOrder;
                while (--j > -1) {
                    if (array[j]._zOrder > key)
                        array[j + 1] = array[j];
                    else
                        break;
                }
                array[j + 1] = c;
                i++;
            }
            ;
            var model = c.parent.conchModel;
            if (model) {
                if (model.updateZOrder != null) {
                    model.updateZOrder();
                }
                else {
                    for (i = 0; i < len; i++) {
                        model.removeChild(array[i].conchModel);
                    }
                    for (i = 0; i < len; i++) {
                        model.addChildAt(array[i].conchModel, i);
                    }
                }
            }
            return true;
        };
        Utils.transPointList = function (points, x, y) {
            var i = 0, len = points.length;
            for (i = 0; i < len; i += 2) {
                points[i] += x;
                points[i + 1] += y;
            }
        };
        Utils.parseInt = function (str, radix) {
            (radix === void 0) && (radix = 0);
            var result = Browser.window.parseInt(str, radix);
            if (isNaN(result))
                return 0;
            return result;
        };
        Utils.getFileExtension = function (path) {
            Utils._extReg.lastIndex = path.lastIndexOf(".");
            var result = Utils._extReg.exec(path);
            if (result && result.length > 1) {
                return result[1].toLowerCase();
            }
            return null;
        };
        Utils.getTransformRelativeToWindow = function (coordinateSpace, x, y) {
            var stage = Laya.stage;
            var globalTransform = laya.utils.Utils.getGlobalPosAndScale(coordinateSpace);
            var canvasMatrix = stage._canvasTransform.clone();
            var canvasLeft = canvasMatrix.tx;
            var canvasTop = canvasMatrix.ty;
            canvasMatrix.rotate(-Math.PI / 180 * Laya.stage.canvasDegree);
            canvasMatrix.scale(Laya.stage.clientScaleX, Laya.stage.clientScaleY);
            var perpendicular = (Laya.stage.canvasDegree % 180 != 0);
            var tx = NaN, ty = NaN;
            if (perpendicular) {
                tx = y + globalTransform.y;
                ty = x + globalTransform.x;
                tx *= canvasMatrix.d;
                ty *= canvasMatrix.a;
                if (Laya.stage.canvasDegree == 90) {
                    tx = canvasLeft - tx;
                    ty += canvasTop;
                }
                else {
                    tx += canvasLeft;
                    ty = canvasTop - ty;
                }
            }
            else {
                tx = x + globalTransform.x;
                ty = y + globalTransform.y;
                tx *= canvasMatrix.a;
                ty *= canvasMatrix.d;
                tx += canvasLeft;
                ty += canvasTop;
            }
            ;
            var domScaleX = NaN, domScaleY = NaN;
            if (perpendicular) {
                domScaleX = canvasMatrix.d * globalTransform.height;
                domScaleY = canvasMatrix.a * globalTransform.width;
            }
            else {
                domScaleX = canvasMatrix.a * globalTransform.width;
                domScaleY = canvasMatrix.d * globalTransform.height;
            }
            return { x: tx, y: ty, scaleX: domScaleX, scaleY: domScaleY };
        };
        Utils.fitDOMElementInArea = function (dom, coordinateSpace, x, y, width, height) {
            if (!dom._fitThe3AirInitialized) {
                dom._fitThe3AirInitialized = true;
                dom.style.transformOrigin = dom.style.webKittransformOrigin = "left top";
                dom.style.position = "absolute";
            }
            ;
            var transform = Utils.getTransformRelativeToWindow(coordinateSpace, x, y);
            dom.style.transform = dom.style.webkitTransform = "scale(" + transform.scaleX + "," + transform.scaleY + ") rotate(" + (Laya.stage.canvasDegree) + "deg)";
            dom.style.width = width + 'px';
            dom.style.height = height + 'px';
            dom.style.left = transform.x + 'px';
            dom.style.top = transform.y + 'px';
        };
        Utils.isOkTextureList = function (textureList) {
            if (!textureList)
                return false;
            var i = 0, len = textureList.length;
            var tTexture;
            for (i = 0; i < len; i++) {
                tTexture = textureList[i];
                if (!tTexture || !tTexture.source)
                    return false;
            }
            return true;
        };
        Utils.isOKCmdList = function (cmds) {
            if (!cmds)
                return false;
            var i = 0, len = cmds.length;
            var context = Render._context;
            var cmd;
            var tex;
            for (i = 0; i < len; i++) {
                cmd = cmds[i];
                switch (cmd.callee) {
                    case context._drawTexture:
                    case context._fillTexture:
                    case context._drawTextureWithTransform:
                        tex = cmd[0];
                        if (!tex || !tex.source)
                            return false;
                }
            }
            return true;
        };
        Utils._gid = 1;
        Utils._pi = 180 / Math.PI;
        Utils._pi2 = Math.PI / 180;
        Utils._extReg = /\.(\w+)\??/g;
        Utils.parseXMLFromString = function (value) {
            var rst;
            value = value.replace(/>\s+</g, '><');
            rst = (new DOMParser()).parseFromString(value, 'text/xml');
            if (rst.firstChild.textContent.indexOf("This page contains the following errors") > -1) {
                throw new Error(rst.firstChild.firstChild.textContent);
            }
            return rst;
        };
        return Utils;
    })();
    var VectorGraphManager = (function () {
        function VectorGraphManager() {
            this.useDic = {};
            this.shapeDic = {};
            this.shapeLineDic = {};
            this._id = 0;
            this._checkKey = false;
            this._freeIdArray = [];
            if (Render.isWebGL) {
                CacheManager.regCacheByFunction(Utils.bind(this.startDispose, this), Utils.bind(this.getCacheList, this));
            }
        }
        __class(VectorGraphManager, 'laya.utils.VectorGraphManager');
        var __proto = VectorGraphManager.prototype;
        __proto.getId = function () {
            return this._id++;
        };
        __proto.addShape = function (id, shape) {
            this.shapeDic[id] = shape;
            if (!this.useDic[id]) {
                this.useDic[id] = true;
            }
        };
        __proto.addLine = function (id, Line) {
            this.shapeLineDic[id] = Line;
            if (!this.shapeLineDic[id]) {
                this.shapeLineDic[id] = true;
            }
        };
        __proto.getShape = function (id) {
            if (this._checkKey) {
                if (this.useDic[id] != null) {
                    this.useDic[id] = true;
                }
            }
        };
        __proto.deleteShape = function (id) {
            if (this.shapeDic[id]) {
                this.shapeDic[id] = null;
                delete this.shapeDic[id];
            }
            if (this.shapeLineDic[id]) {
                this.shapeLineDic[id] = null;
                delete this.shapeLineDic[id];
            }
            if (this.useDic[id] != null) {
                delete this.useDic[id];
            }
        };
        __proto.getCacheList = function () {
            var str;
            var list = [];
            for (str in this.shapeDic) {
                list.push(this.shapeDic[str]);
            }
            for (str in this.shapeLineDic) {
                list.push(this.shapeLineDic[str]);
            }
            return list;
        };
        __proto.startDispose = function (key) {
            var str;
            for (str in this.useDic) {
                this.useDic[str] = false;
            }
            this._checkKey = true;
        };
        __proto.endDispose = function () {
            if (this._checkKey) {
                var str;
                for (str in this.useDic) {
                    if (!this.useDic[str]) {
                        this.deleteShape(str);
                    }
                }
                this._checkKey = false;
            }
        };
        VectorGraphManager.getInstance = function () {
            return VectorGraphManager.instance = VectorGraphManager.instance || new VectorGraphManager();
        };
        VectorGraphManager.instance = null;
        return VectorGraphManager;
    })();
    var WeakObject = (function () {
        function WeakObject() {
            this._obj = null;
            this._obj = WeakObject.supportWeakMap ? new Browser.window.WeakMap() : {};
            if (!WeakObject.supportWeakMap)
                WeakObject._maps.push(this);
        }
        __class(WeakObject, 'laya.utils.WeakObject');
        var __proto = WeakObject.prototype;
        __proto.set = function (key, value) {
            if (key == null)
                return;
            if (WeakObject.supportWeakMap) {
                var objKey = key;
                if ((typeof key == 'string') || (typeof key == 'number')) {
                    objKey = WeakObject._keys[key];
                    if (!objKey)
                        objKey = WeakObject._keys[key] = { k: key };
                }
                this._obj.set(objKey, value);
            }
            else {
                if ((typeof key == 'string') || (typeof key == 'number')) {
                    this._obj[key] = value;
                }
                else {
                    key.$_GID || (key.$_GID = Utils.getGID());
                    this._obj[key.$_GID] = value;
                }
            }
        };
        __proto.get = function (key) {
            if (key == null)
                return null;
            if (WeakObject.supportWeakMap) {
                var objKey = ((typeof key == 'string') || (typeof key == 'number')) ? WeakObject._keys[key] : key;
                if (!objKey)
                    return null;
                return this._obj.get(objKey);
            }
            else {
                if ((typeof key == 'string') || (typeof key == 'number'))
                    return this._obj[key];
                return this._obj[key.$_GID];
            }
        };
        __proto.del = function (key) {
            if (key == null)
                return;
            if (WeakObject.supportWeakMap) {
                var objKey = ((typeof key == 'string') || (typeof key == 'number')) ? WeakObject._keys[key] : key;
                if (!objKey)
                    return;
                this._obj.delete(objKey);
            }
            else {
                if ((typeof key == 'string') || (typeof key == 'number'))
                    delete this._obj[key];
                else
                    delete this._obj[this._obj.$_GID];
            }
        };
        __proto.has = function (key) {
            if (key == null)
                return false;
            if (WeakObject.supportWeakMap) {
                var objKey = ((typeof key == 'string') || (typeof key == 'number')) ? WeakObject._keys[key] : key;
                return this._obj.has(objKey);
            }
            else {
                if ((typeof key == 'string') || (typeof key == 'number'))
                    return this._obj[key] != null;
                return this._obj[this._obj.$_GID] != null;
            }
        };
        WeakObject.__init__ = function () {
            WeakObject.supportWeakMap = Browser.window.WeakMap != null;
            if (!WeakObject.supportWeakMap)
                Laya.timer.loop(WeakObject.delInterval, null, WeakObject.clearCache);
        };
        WeakObject.clearCache = function () {
            for (var i = 0, n = WeakObject._maps.length; i < n; i++) {
                var obj = WeakObject._maps[i];
                obj._obj = {};
            }
        };
        WeakObject.supportWeakMap = false;
        WeakObject.delInterval = 5 * 60 * 1000;
        WeakObject._keys = {};
        WeakObject._maps = [];
        __static(WeakObject, ['I', function () { return this.I = new WeakObject(); }
        ]);
        return WeakObject;
    })();
    var WordText = (function () {
        function WordText() {
            this.id = NaN;
            this.save = [];
            this.toUpperCase = null;
            this.changed = false;
            this._text = null;
        }
        __class(WordText, 'laya.utils.WordText');
        var __proto = WordText.prototype;
        __proto.setText = function (txt, letterSpacing, stroke) {
            this.changed = true;
            this._text = txt;
            this._letterSpacing = letterSpacing ? letterSpacing * (stroke ? 2 : 1) : 0;
        };
        __proto.toString = function () {
            return this._text;
        };
        __proto.charCodeAt = function (i) {
            return this._text ? this._text.charCodeAt(i) : NaN;
        };
        __proto.charAt = function (i) {
            return this._text ? this._text.charAt(i) : null;
        };
        __getset(0, __proto, 'length', function () {
            return this._text ? this._text.length : 0;
        });
        return WordText;
    })();
    var Node = (function (_super) {
        function Node() {
            this._bits = 0;
            this._displayedInStage = false;
            this._parent = null;
            this.conchModel = null;
            this.name = "";
            this._destroyed = false;
            Node.__super.call(this);
            this._childs = Node.ARRAY_EMPTY;
            this._$P = Node.PROP_EMPTY;
            this.timer = Laya.scaleTimer;
            this.conchModel = Render.isConchNode ? this.createConchModel() : null;
        }
        __class(Node, 'laya.display.Node', _super);
        var __proto = Node.prototype;
        __proto._setBit = function (type, value) {
            if (type == 0x1) {
                var preValue = this._getBit(type);
                if (preValue != value) {
                    this._updateDisplayedInstage();
                }
            }
            if (value) {
                this._bits |= type;
            }
            else {
                this._bits &= ~type;
            }
        };
        __proto._getBit = function (type) {
            return (this._bits & type) != 0;
        };
        __proto._setUpNoticeChain = function () {
            if (this._getBit(0x1)) {
                this._setUpNoticeType(0x1);
            }
        };
        __proto._setUpNoticeType = function (type) {
            var ele = this;
            ele._setBit(type, true);
            ele = ele.parent;
            while (ele) {
                if (ele._getBit(type))
                    return;
                ele._setBit(type, true);
                ele = ele.parent;
            }
        };
        __proto.on = function (type, caller, listener, args) {
            if (type === "display" || type === "undisplay") {
                if (!this._getBit(0x1)) {
                    this._setUpNoticeType(0x1);
                }
            }
            return this._createListener(type, caller, listener, args, false);
        };
        __proto.once = function (type, caller, listener, args) {
            if (type === "display" || type === "undisplay") {
                if (!this._getBit(0x1)) {
                    this._setUpNoticeType(0x1);
                }
            }
            return this._createListener(type, caller, listener, args, true);
        };
        __proto.createConchModel = function () {
            return null;
        };
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            this._destroyed = true;
            this._parent && this._parent.removeChild(this);
            if (this._childs) {
                if (destroyChild)
                    this.destroyChildren();
                else
                    this.removeChildren();
            }
            this._childs = null;
            this._$P = null;
            this.offAll();
            this.timer.clearAll(this);
        };
        __proto.destroyChildren = function () {
            if (this._childs) {
                for (var i = this._childs.length - 1; i > -1; i--) {
                    this._childs[i].destroy(true);
                }
            }
        };
        __proto.addChild = function (node) {
            if (!node || this.destroyed || node === this)
                return node;
            if ((node).zOrder)
                this._set$P("hasZorder", true);
            if (node._parent === this) {
                var index = this.getChildIndex(node);
                if (index !== this._childs.length - 1) {
                    this._childs.splice(index, 1);
                    this._childs.push(node);
                    if (this.conchModel) {
                        this.conchModel.removeChild(node.conchModel);
                        this.conchModel.addChildAt(node.conchModel, this._childs.length - 1);
                    }
                    this._childChanged();
                }
            }
            else {
                node.parent && node.parent.removeChild(node);
                this._childs === Node.ARRAY_EMPTY && (this._childs = []);
                this._childs.push(node);
                this.conchModel && this.conchModel.addChildAt(node.conchModel, this._childs.length - 1);
                node.parent = this;
                this._childChanged();
            }
            return node;
        };
        __proto.addChildren = function (__args) {
            var args = arguments;
            var i = 0, n = args.length;
            while (i < n) {
                this.addChild(args[i++]);
            }
        };
        __proto.addChildAt = function (node, index) {
            if (!node || this.destroyed || node === this)
                return node;
            if ((node).zOrder)
                this._set$P("hasZorder", true);
            if (index >= 0 && index <= this._childs.length) {
                if (node._parent === this) {
                    var oldIndex = this.getChildIndex(node);
                    this._childs.splice(oldIndex, 1);
                    this._childs.splice(index, 0, node);
                    if (this.conchModel) {
                        this.conchModel.removeChild(node.conchModel);
                        this.conchModel.addChildAt(node.conchModel, index);
                    }
                    this._childChanged();
                }
                else {
                    node.parent && node.parent.removeChild(node);
                    this._childs === Node.ARRAY_EMPTY && (this._childs = []);
                    this._childs.splice(index, 0, node);
                    this.conchModel && this.conchModel.addChildAt(node.conchModel, index);
                    node.parent = this;
                }
                return node;
            }
            else {
                throw new Error("appendChildAt:The index is out of bounds");
            }
        };
        __proto.getChildIndex = function (node) {
            return this._childs.indexOf(node);
        };
        __proto.getChildByName = function (name) {
            var nodes = this._childs;
            if (nodes) {
                for (var i = 0, n = nodes.length; i < n; i++) {
                    var node = nodes[i];
                    if (node.name === name)
                        return node;
                }
            }
            return null;
        };
        __proto._get$P = function (key) {
            return this._$P[key];
        };
        __proto._set$P = function (key, value) {
            if (!this.destroyed) {
                this._$P === Node.PROP_EMPTY && (this._$P = {});
                this._$P[key] = value;
            }
            return value;
        };
        __proto.getChildAt = function (index) {
            return this._childs[index];
        };
        __proto.setChildIndex = function (node, index) {
            var childs = this._childs;
            if (index < 0 || index >= childs.length) {
                throw new Error("setChildIndex:The index is out of bounds.");
            }
            ;
            var oldIndex = this.getChildIndex(node);
            if (oldIndex < 0)
                throw new Error("setChildIndex:node is must child of this object.");
            childs.splice(oldIndex, 1);
            childs.splice(index, 0, node);
            if (this.conchModel) {
                this.conchModel.removeChild(node.conchModel);
                this.conchModel.addChildAt(node.conchModel, index);
            }
            this._childChanged();
            return node;
        };
        __proto._childChanged = function (child) { };
        __proto.removeChild = function (node) {
            if (!this._childs)
                return node;
            var index = this._childs.indexOf(node);
            return this.removeChildAt(index);
        };
        __proto.removeSelf = function () {
            this._parent && this._parent.removeChild(this);
            return this;
        };
        __proto.removeChildByName = function (name) {
            var node = this.getChildByName(name);
            node && this.removeChild(node);
            return node;
        };
        __proto.removeChildAt = function (index) {
            var node = this.getChildAt(index);
            if (node) {
                this._childs.splice(index, 1);
                this.conchModel && this.conchModel.removeChild(node.conchModel);
                node.parent = null;
            }
            return node;
        };
        __proto.removeChildren = function (beginIndex, endIndex) {
            (beginIndex === void 0) && (beginIndex = 0);
            (endIndex === void 0) && (endIndex = 0x7fffffff);
            if (this._childs && this._childs.length > 0) {
                var childs = this._childs;
                if (beginIndex === 0 && endIndex >= n) {
                    var arr = childs;
                    this._childs = Node.ARRAY_EMPTY;
                }
                else {
                    arr = childs.splice(beginIndex, endIndex - beginIndex);
                }
                for (var i = 0, n = arr.length; i < n; i++) {
                    arr[i].parent = null;
                    this.conchModel && this.conchModel.removeChild(arr[i].conchModel);
                }
            }
            return this;
        };
        __proto.replaceChild = function (newNode, oldNode) {
            var index = this._childs.indexOf(oldNode);
            if (index > -1) {
                this._childs.splice(index, 1, newNode);
                if (this.conchModel) {
                    this.conchModel.removeChild(oldNode.conchModel);
                    this.conchModel.addChildAt(newNode.conchModel, index);
                }
                oldNode.parent = null;
                newNode.parent = this;
                return newNode;
            }
            return null;
        };
        __proto._updateDisplayedInstage = function () {
            var ele;
            ele = this;
            var stage = Laya.stage;
            this._displayedInStage = false;
            while (ele) {
                if (ele._getBit(0x1)) {
                    this._displayedInStage = ele._displayedInStage;
                    break;
                }
                if (ele == stage || ele._displayedInStage) {
                    this._displayedInStage = true;
                    break;
                }
                ele = ele.parent;
            }
        };
        __proto._setDisplay = function (value) {
            if (this._displayedInStage !== value) {
                this._displayedInStage = value;
                if (value)
                    this.event("display");
                else
                    this.event("undisplay");
            }
        };
        __proto._displayChild = function (node, display) {
            var childs = node._childs;
            if (childs) {
                for (var i = 0, n = childs.length; i < n; i++) {
                    var child = childs[i];
                    if (!child._getBit(0x1))
                        continue;
                    if (child._childs.length > 0) {
                        this._displayChild(child, display);
                    }
                    else {
                        child._setDisplay(display);
                    }
                }
            }
            node._setDisplay(display);
        };
        __proto.contains = function (node) {
            if (node === this)
                return true;
            while (node) {
                if (node.parent === this)
                    return true;
                node = node.parent;
            }
            return false;
        };
        __proto.timerLoop = function (delay, caller, method, args, coverBefore, jumpFrame) {
            (coverBefore === void 0) && (coverBefore = true);
            (jumpFrame === void 0) && (jumpFrame = false);
            this.timer.loop(delay, caller, method, args, coverBefore, jumpFrame);
        };
        __proto.timerOnce = function (delay, caller, method, args, coverBefore) {
            (coverBefore === void 0) && (coverBefore = true);
            this.timer._create(false, false, delay, caller, method, args, coverBefore);
        };
        __proto.frameLoop = function (delay, caller, method, args, coverBefore) {
            (coverBefore === void 0) && (coverBefore = true);
            this.timer._create(true, true, delay, caller, method, args, coverBefore);
        };
        __proto.frameOnce = function (delay, caller, method, args, coverBefore) {
            (coverBefore === void 0) && (coverBefore = true);
            this.timer._create(true, false, delay, caller, method, args, coverBefore);
        };
        __proto.clearTimer = function (caller, method) {
            this.timer.clear(caller, method);
        };
        __getset(0, __proto, 'numChildren', function () {
            return this._childs.length;
        });
        __getset(0, __proto, 'destroyed', function () {
            return this._destroyed;
        });
        __getset(0, __proto, 'parent', function () {
            return this._parent;
        }, function (value) {
            if (this._parent !== value) {
                if (value) {
                    this._parent = value;
                    this.event("added");
                    if (this._getBit(0x1)) {
                        this._setUpNoticeChain();
                        value.displayedInStage && this._displayChild(this, true);
                    }
                    value._childChanged(this);
                }
                else {
                    this.event("removed");
                    this._parent._childChanged();
                    if (this._getBit(0x1))
                        this._displayChild(this, false);
                    this._parent = value;
                }
            }
        });
        __getset(0, __proto, 'displayedInStage', function () {
            if (this._getBit(0x1))
                return this._displayedInStage;
            this._setUpNoticeType(0x1);
            return this._displayedInStage;
        });
        Node.ARRAY_EMPTY = [];
        Node.PROP_EMPTY = {};
        Node.NOTICE_DISPLAY = 0x1;
        Node.MOUSEENABLE = 0x2;
        return Node;
    })(EventDispatcher);
    var CSSStyle = (function (_super) {
        function CSSStyle(ower) {
            this._bgground = null;
            this._border = null;
            this._rect = null;
            this.underLine = 0;
            this.lineHeight = 0;
            CSSStyle.__super.call(this);
            this._padding = CSSStyle._PADDING;
            this._spacing = CSSStyle._SPACING;
            this._aligns = CSSStyle._ALIGNS;
            this._font = Font.EMPTY;
            this._ower = ower;
        }
        __class(CSSStyle, 'laya.display.css.CSSStyle', _super);
        var __proto = CSSStyle.prototype;
        __proto.destroy = function () {
            this._ower = null;
            this._font = null;
            this._rect = null;
        };
        __proto.inherit = function (src) {
            this._font = src._font;
            this._spacing = src._spacing === CSSStyle._SPACING ? CSSStyle._SPACING : src._spacing.slice();
            this.lineHeight = src.lineHeight;
        };
        __proto._widthAuto = function () {
            return (this._type & 0x40000) !== 0;
        };
        __proto.widthed = function (sprite) {
            return (this._type & 0x8) != 0;
        };
        __proto._calculation = function (type, value) {
            if (value.indexOf('%') < 0)
                return false;
            var ower = this._ower;
            var parent = ower.parent;
            var rect = this._rect;
            function getValue(pw, w, nums) {
                return (pw * nums[0] + w * nums[1] + nums[2]);
            }
            function onParentResize(type) {
                var pw = parent.width, w = ower.width;
                rect.width && (ower.width = getValue(pw, w, rect.width));
                rect.height && (ower.height = getValue(pw, w, rect.height));
                rect.left && (ower.x = getValue(pw, w, rect.left));
                rect.top && (ower.y = getValue(pw, w, rect.top));
            }
            if (rect === null) {
                parent._getCSSStyle()._type |= 0x80000;
                parent.on("resize", this, onParentResize);
                this._rect = rect = { input: {} };
            }
            ;
            var nums = value.split(' ');
            nums[0] = parseFloat(nums[0]) / 100;
            if (nums.length == 1)
                nums[1] = nums[2] = 0;
            else {
                nums[1] = parseFloat(nums[1]) / 100;
                nums[2] = parseFloat(nums[2]);
            }
            rect[type] = nums;
            rect.input[type] = value;
            onParentResize(type);
            return true;
        };
        __proto.heighted = function (sprite) {
            return (this._type & 0x2000) != 0;
        };
        __proto.size = function (w, h) {
            var ower = this._ower;
            var resize = false;
            if (w !== -1 && w != this._ower.width) {
                this._type |= 0x8;
                this._ower.width = w;
                resize = true;
            }
            if (h !== -1 && h != this._ower.height) {
                this._type |= 0x2000;
                this._ower.height = h;
                resize = true;
            }
            if (resize) {
                ower._layoutLater();
                (this._type & 0x80000) && ower.event("resize", this);
            }
        };
        __proto._getAlign = function () {
            return this._aligns[0];
        };
        __proto._getValign = function () {
            return this._aligns[1];
        };
        __proto._getCssFloat = function () {
            return (this._type & 0x8000) != 0 ? 0x8000 : 0;
        };
        __proto._createFont = function () {
            return (this._type & 0x1000) ? this._font : (this._type |= 0x1000, this._font = new Font(this._font));
        };
        __proto.render = function (sprite, context, x, y) {
            var w = sprite.width;
            var h = sprite.height;
            x -= sprite.pivotX;
            y -= sprite.pivotY;
            this._bgground && this._bgground.color != null && context.ctx.fillRect(x, y, w, h, this._bgground.color);
            this._border && this._border.color && context.drawRect(x, y, w, h, this._border.color.strColor, this._border.size);
        };
        __proto.getCSSStyle = function () {
            return this;
        };
        __proto.cssText = function (text) {
            this.attrs(CSSStyle.parseOneCSS(text, ';'));
        };
        __proto.attrs = function (attrs) {
            if (attrs) {
                for (var i = 0, n = attrs.length; i < n; i++) {
                    var attr = attrs[i];
                    this[attr[0]] = attr[1];
                }
            }
        };
        __proto.setTransform = function (value) {
            (value === 'none') ? (this._tf = Style._TF_EMPTY) : this.attrs(CSSStyle.parseOneCSS(value, ','));
        };
        __proto.translate = function (x, y) {
            this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
            this._tf.translateX = x;
            this._tf.translateY = y;
        };
        __proto.scale = function (x, y) {
            this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
            this._tf.scaleX = x;
            this._tf.scaleY = y;
        };
        __proto._enableLayout = function () {
            return (this._type & 0x2) === 0 && (this._type & 0x4) === 0;
        };
        __getset(0, __proto, 'block', _super.prototype._$get_block, function (value) {
            value ? (this._type |= 0x1) : (this._type &= (~0x1));
        });
        __getset(0, __proto, 'valign', function () {
            return CSSStyle._valigndef[this._aligns[1]];
        }, function (value) {
            this._aligns === CSSStyle._ALIGNS && (this._aligns = [0, 0, 0]);
            this._aligns[1] = CSSStyle._valigndef[value];
        });
        __getset(0, __proto, 'height', null, function (h) {
            this._type |= 0x2000;
            if ((typeof h == 'string')) {
                if (this._calculation("height", h))
                    return;
                h = parseInt(h);
            }
            this.size(-1, h);
        });
        __getset(0, __proto, 'width', null, function (w) {
            this._type |= 0x8;
            if ((typeof w == 'string')) {
                var offset = w.indexOf('auto');
                if (offset >= 0) {
                    this._type |= 0x40000;
                    w = w.substr(0, offset);
                }
                if (this._calculation("width", w))
                    return;
                w = parseInt(w);
            }
            this.size(w, -1);
        });
        __getset(0, __proto, 'fontWeight', function () {
            return this._font.weight;
        }, function (value) {
            this._createFont().weight = value;
        });
        __getset(0, __proto, 'left', null, function (value) {
            var ower = this._ower;
            if (((typeof value == 'string'))) {
                if (value === "center")
                    value = "50% -50% 0";
                else if (value === "right")
                    value = "100% -100% 0";
                if (this._calculation("left", value))
                    return;
                value = parseInt(value);
            }
            ower.x = value;
        });
        __getset(0, __proto, '_translate', null, function (value) {
            this.translate(value[0], value[1]);
        });
        __getset(0, __proto, 'absolute', function () {
            return (this._type & 0x4) !== 0;
        });
        __getset(0, __proto, 'top', null, function (value) {
            var ower = this._ower;
            if (((typeof value == 'string'))) {
                if (value === "middle")
                    value = "50% -50% 0";
                else if (value === "bottom")
                    value = "100% -100% 0";
                if (this._calculation("top", value))
                    return;
                value = parseInt(value);
            }
            ower.y = value;
        });
        __getset(0, __proto, 'align', function () {
            return CSSStyle._aligndef[this._aligns[0]];
        }, function (value) {
            this._aligns === CSSStyle._ALIGNS && (this._aligns = [0, 0, 0]);
            this._aligns[0] = CSSStyle._aligndef[value];
        });
        __getset(0, __proto, 'bold', function () {
            return this._font.bold;
        }, function (value) {
            this._createFont().bold = value;
        });
        __getset(0, __proto, 'padding', function () {
            return this._padding;
        }, function (value) {
            this._padding = value;
        });
        __getset(0, __proto, 'leading', function () {
            return this._spacing[1];
        }, function (d) {
            ((typeof d == 'string')) && (d = parseInt(d + ""));
            this._spacing === CSSStyle._SPACING && (this._spacing = [0, 0]);
            this._spacing[1] = d;
        });
        __getset(0, __proto, 'lineElement', function () {
            return (this._type & 0x10000) != 0;
        }, function (value) {
            value ? (this._type |= 0x10000) : (this._type &= (~0x10000));
        });
        __getset(0, __proto, 'cssFloat', function () {
            return (this._type & 0x8000) != 0 ? "right" : "left";
        }, function (value) {
            this.lineElement = false;
            value === "right" ? (this._type |= 0x8000) : (this._type &= (~0x8000));
        });
        __getset(0, __proto, 'textDecoration', function () {
            return this._font.decoration;
        }, function (value) {
            this._createFont().decoration = value;
        });
        __getset(0, __proto, 'whiteSpace', function () {
            return (this._type & 0x20000) ? "nowrap" : "";
        }, function (type) {
            type === "nowrap" && (this._type |= 0x20000);
            type === "none" && (this._type &= ~0x20000);
        });
        __getset(0, __proto, 'background', null, function (value) {
            if (!value) {
                this._bgground = null;
                return;
            }
            this._bgground || (this._bgground = {});
            this._bgground.color = value;
            this._ower.conchModel && this._ower.conchModel.bgColor(value);
            this._type |= 0x4000;
            this._ower._renderType |= 0x100;
        });
        __getset(0, __proto, 'wordWrap', function () {
            return (this._type & 0x20000) === 0;
        }, function (value) {
            value ? (this._type &= ~0x20000) : (this._type |= 0x20000);
        });
        __getset(0, __proto, 'color', function () {
            return this._font.color;
        }, function (value) {
            this._createFont().color = value;
        });
        __getset(0, __proto, 'password', function () {
            return this._font.password;
        }, function (value) {
            this._createFont().password = value;
        });
        __getset(0, __proto, 'backgroundColor', function () {
            return this._bgground ? this._bgground.color : null;
        }, function (value) {
            if (value === 'none')
                this._bgground = null;
            else
                (this._bgground || (this._bgground = {}), this._bgground.color = value);
            this._ower.conchModel && this._ower.conchModel.bgColor(value);
            this._ower._renderType |= 0x100;
        });
        __getset(0, __proto, 'font', function () {
            return this._font.toString();
        }, function (value) {
            this._createFont().set(value);
        });
        __getset(0, __proto, 'weight', null, function (value) {
            this._createFont().weight = value;
        });
        __getset(0, __proto, 'letterSpacing', function () {
            return this._spacing[0];
        }, function (d) {
            ((typeof d == 'string')) && (d = parseInt(d + ""));
            this._spacing === CSSStyle._SPACING && (this._spacing = [0, 0]);
            this._spacing[0] = d;
        });
        __getset(0, __proto, 'fontSize', function () {
            return this._font.size;
        }, function (value) {
            this._createFont().size = value;
        });
        __getset(0, __proto, 'italic', function () {
            return this._font.italic;
        }, function (value) {
            this._createFont().italic = value;
        });
        __getset(0, __proto, 'fontFamily', function () {
            return this._font.family;
        }, function (value) {
            this._createFont().family = value;
        });
        __getset(0, __proto, 'stroke', function () {
            return this._font.stroke[0];
        }, function (value) {
            if (this._createFont().stroke === Font._STROKE)
                this._font.stroke = [0, "#000000"];
            this._font.stroke[0] = value;
        });
        __getset(0, __proto, 'strokeColor', function () {
            return this._font.stroke[1];
        }, function (value) {
            if (this._createFont().stroke === Font._STROKE)
                this._font.stroke = [0, "#000000"];
            this._font.stroke[1] = value;
        });
        __getset(0, __proto, 'border', function () {
            return this._border ? this._border.value : "";
        }, function (value) {
            if (value == 'none') {
                this._border = null;
                return;
            }
            this._border || (this._border = {});
            this._border.value = value;
            var values = value.split(' ');
            this._border.color = Color.create(values[values.length - 1]);
            if (values.length == 1) {
                this._border.size = 1;
                this._border.type = 'solid';
                return;
            }
            ;
            var i = 0;
            if (values[0].indexOf('px') > 0) {
                this._border.size = parseInt(values[0]);
                i++;
            }
            else
                this._border.size = 1;
            this._border.type = values[i];
            this._ower._renderType |= 0x100;
        });
        __getset(0, __proto, 'borderColor', function () {
            return (this._border && this._border.color) ? this._border.color.strColor : null;
        }, function (value) {
            if (!value) {
                this._border = null;
                return;
            }
            this._border || (this._border = { size: 1, type: 'solid' });
            this._border.color = (value == null) ? null : Color.create(value);
            this._ower.conchModel && this._ower.conchModel.border(this._border.color.strColor);
            this._ower._renderType |= 0x100;
        });
        __getset(0, __proto, 'position', function () {
            return (this._type & 0x4) ? "absolute" : "";
        }, function (value) {
            value == "absolute" ? (this._type |= 0x4) : (this._type &= ~0x4);
        });
        __getset(0, __proto, 'display', null, function (value) {
            switch (value) {
                case '':
                    this._type &= ~0x2;
                    this.visible = true;
                    break;
                case 'none':
                    this._type |= 0x2;
                    this.visible = false;
                    this._ower._layoutLater();
                    break;
            }
        });
        __getset(0, __proto, 'paddingLeft', function () {
            return this.padding[3];
        });
        __getset(0, __proto, 'paddingTop', function () {
            return this.padding[0];
        });
        __getset(0, __proto, '_scale', null, function (value) {
            this._ower.scale(value[0], value[1]);
        });
        __getset(0, __proto, '_rotate', null, function (value) {
            this._ower.rotation = value;
        });
        CSSStyle.parseOneCSS = function (text, clipWord) {
            var out = [];
            var attrs = text.split(clipWord);
            var valueArray;
            for (var i = 0, n = attrs.length; i < n; i++) {
                var attr = attrs[i];
                var ofs = attr.indexOf(':');
                var name = attr.substr(0, ofs).replace(/^\s+|\s+$/g, '');
                if (name.length == 0)
                    continue;
                var value = attr.substr(ofs + 1).replace(/^\s+|\s+$/g, '');
                var one = [name, value];
                switch (name) {
                    case 'italic':
                    case 'bold':
                        one[1] = value == "true";
                        break;
                    case 'line-height':
                        one[0] = 'lineHeight';
                        one[1] = parseInt(value);
                        break;
                    case 'font-size':
                        one[0] = 'fontSize';
                        one[1] = parseInt(value);
                        break;
                    case 'padding':
                        valueArray = value.split(' ');
                        valueArray.length > 1 || (valueArray[1] = valueArray[2] = valueArray[3] = valueArray[0]);
                        one[1] = [parseInt(valueArray[0]), parseInt(valueArray[1]), parseInt(valueArray[2]), parseInt(valueArray[3])];
                        break;
                    case 'rotate':
                        one[0] = "_rotate";
                        one[1] = parseFloat(value);
                        break;
                    case 'scale':
                        valueArray = value.split(' ');
                        one[0] = "_scale";
                        one[1] = [parseFloat(valueArray[0]), parseFloat(valueArray[1])];
                        break;
                    case 'translate':
                        valueArray = value.split(' ');
                        one[0] = "_translate";
                        one[1] = [parseInt(valueArray[0]), parseInt(valueArray[1])];
                        break;
                    default:
                        (one[0] = CSSStyle._CSSTOVALUE[name]) || (one[0] = name);
                }
                out.push(one);
            }
            return out;
        };
        CSSStyle.parseCSS = function (text, uri) {
            var one;
            while ((one = CSSStyle._parseCSSRegExp.exec(text)) != null) {
                CSSStyle.styleSheets[one[1]] = CSSStyle.parseOneCSS(one[2], ';');
            }
        };
        CSSStyle.EMPTY = new CSSStyle(null);
        CSSStyle._CSSTOVALUE = { 'letter-spacing': 'letterSpacing', 'line-spacing': 'lineSpacing', 'white-space': 'whiteSpace', 'line-height': 'lineHeight', 'scale-x': 'scaleX', 'scale-y': 'scaleY', 'translate-x': 'translateX', 'translate-y': 'translateY', 'font-family': 'fontFamily', 'font-weight': 'fontWeight', 'vertical-align': 'valign', 'text-decoration': 'textDecoration', 'background-color': 'backgroundColor', 'border-color': 'borderColor', 'float': 'cssFloat' };
        CSSStyle._parseCSSRegExp = new RegExp("([\.\#]\\w+)\\s*{([\\s\\S]*?)}", "g");
        CSSStyle._aligndef = { 'left': 0, 'center': 1, 'right': 2, 0: 'left', 1: 'center', 2: 'right' };
        CSSStyle._valigndef = { 'top': 0, 'middle': 1, 'bottom': 2, 0: 'top', 1: 'middle', 2: 'bottom' };
        CSSStyle.styleSheets = {};
        CSSStyle.ALIGN_CENTER = 1;
        CSSStyle.ALIGN_RIGHT = 2;
        CSSStyle.VALIGN_MIDDLE = 1;
        CSSStyle.VALIGN_BOTTOM = 2;
        CSSStyle._CSS_BLOCK = 0x1;
        CSSStyle._DISPLAY_NONE = 0x2;
        CSSStyle._ABSOLUTE = 0x4;
        CSSStyle._WIDTH_SET = 0x8;
        CSSStyle._PADDING = [0, 0, 0, 0];
        CSSStyle._RECT = [-1, -1, -1, -1];
        CSSStyle._SPACING = [0, 0];
        CSSStyle._ALIGNS = [0, 0, 0];
        CSSStyle.ADDLAYOUTED = 0x200;
        CSSStyle._NEWFONT = 0x1000;
        CSSStyle._HEIGHT_SET = 0x2000;
        CSSStyle._BACKGROUND_SET = 0x4000;
        CSSStyle._FLOAT_RIGHT = 0x8000;
        CSSStyle._LINE_ELEMENT = 0x10000;
        CSSStyle._NOWARP = 0x20000;
        CSSStyle._WIDTHAUTO = 0x40000;
        CSSStyle._LISTERRESZIE = 0x80000;
        return CSSStyle;
    })(Style);
    var AudioSound = (function (_super) {
        function AudioSound() {
            this.url = null;
            this.audio = null;
            this.loaded = false;
            AudioSound.__super.call(this);
        }
        __class(AudioSound, 'laya.media.h5audio.AudioSound', _super);
        var __proto = AudioSound.prototype;
        __proto.dispose = function () {
            var ad = AudioSound._audioCache[this.url];
            if (ad) {
                ad.src = "";
                delete AudioSound._audioCache[this.url];
            }
        };
        __proto.load = function (url) {
            url = URL.formatURL(url);
            this.url = url;
            var ad;
            if (url == SoundManager._tMusic) {
                AudioSound._initMusicAudio();
                ad = AudioSound._musicAudio;
                if (ad.src != url) {
                    AudioSound._audioCache[ad.src] = null;
                    ad = null;
                }
            }
            else {
                ad = AudioSound._audioCache[url];
            }
            if (ad && ad.readyState >= 2) {
                this.event("complete");
                return;
            }
            if (!ad) {
                if (url == SoundManager._tMusic) {
                    AudioSound._initMusicAudio();
                    ad = AudioSound._musicAudio;
                }
                else {
                    ad = Browser.createElement("audio");
                }
                AudioSound._audioCache[url] = ad;
                ad.src = url;
            }
            ad.addEventListener("canplaythrough", onLoaded);
            ad.addEventListener("error", onErr);
            var me = this;
            function onLoaded() {
                offs();
                me.loaded = true;
                me.event("complete");
            }
            function onErr() {
                ad.load = null;
                offs();
                me.event("error");
            }
            function offs() {
                ad.removeEventListener("canplaythrough", onLoaded);
                ad.removeEventListener("error", onErr);
            }
            this.audio = ad;
            if (ad.load) {
                ad.load();
            }
            else {
                onErr();
            }
        };
        __proto.play = function (startTime, loops, playbackRate) {
            (startTime === void 0) && (startTime = 0);
            (loops === void 0) && (loops = 0);
            (playbackRate === void 0) && (playbackRate = 1);
            if (!this.url)
                return null;
            var ad;
            if (this.url == SoundManager._tMusic) {
                ad = AudioSound._musicAudio;
            }
            else {
                ad = AudioSound._audioCache[this.url];
            }
            if (!ad)
                return null;
            var tAd;
            tAd = Pool.getItem("audio:" + this.url);
            if (Render.isConchApp) {
                if (!tAd) {
                    tAd = Browser.createElement("audio");
                    tAd.src = this.url;
                }
            }
            else {
                if (this.url == SoundManager._tMusic) {
                    AudioSound._initMusicAudio();
                    tAd = AudioSound._musicAudio;
                    tAd.src = this.url;
                }
                else {
                    tAd = tAd ? tAd : ad.cloneNode(true);
                }
            }
            ;
            var channel = new AudioSoundChannel(tAd);
            channel.url = this.url;
            channel.loops = loops;
            channel.startTime = startTime;
            channel.playbackRate = playbackRate;
            channel.play();
            SoundManager.addChannel(channel);
            return channel;
        };
        __getset(0, __proto, 'duration', function () {
            var ad;
            ad = AudioSound._audioCache[this.url];
            if (!ad)
                return 0;
            return ad.duration;
        });
        AudioSound._initMusicAudio = function () {
            if (AudioSound._musicAudio)
                return;
            if (!AudioSound._musicAudio)
                AudioSound._musicAudio = Browser.createElement("audio");
            if (!Render.isConchApp) {
                Browser.document.addEventListener("mousedown", AudioSound._makeMusicOK);
            }
        };
        AudioSound._makeMusicOK = function () {
            Browser.document.removeEventListener("mousedown", AudioSound._makeMusicOK);
            if (!AudioSound._musicAudio.src) {
                AudioSound._musicAudio.src = "";
                AudioSound._musicAudio.load();
            }
            else {
                AudioSound._musicAudio.play();
            }
        };
        AudioSound._audioCache = {};
        AudioSound._musicAudio = null;
        return AudioSound;
    })(EventDispatcher);
    var SoundChannel = (function (_super) {
        function SoundChannel() {
            this.url = null;
            this.loops = 0;
            this.startTime = NaN;
            this.isStopped = false;
            this.completeHandler = null;
            SoundChannel.__super.call(this);
        }
        __class(SoundChannel, 'laya.media.SoundChannel', _super);
        var __proto = SoundChannel.prototype;
        __proto.play = function () { };
        __proto.stop = function () { };
        __proto.pause = function () { };
        __proto.resume = function () { };
        __proto.__runComplete = function (handler) {
            if (handler) {
                handler.run();
            }
        };
        __getset(0, __proto, 'volume', function () {
            return 1;
        }, function (v) {
        });
        __getset(0, __proto, 'position', function () {
            return 0;
        });
        __getset(0, __proto, 'duration', function () {
            return 0;
        });
        return SoundChannel;
    })(EventDispatcher);
    var Sound = (function (_super) {
        function Sound() {
            Sound.__super.call(this);
            ;
        }
        __class(Sound, 'laya.media.Sound', _super);
        var __proto = Sound.prototype;
        __proto.load = function (url) { };
        __proto.play = function (startTime, loops) {
            (startTime === void 0) && (startTime = 0);
            (loops === void 0) && (loops = 0);
            return null;
        };
        __proto.dispose = function () { };
        __getset(0, __proto, 'duration', function () {
            return 0;
        });
        return Sound;
    })(EventDispatcher);
    var WebAudioSound = (function (_super) {
        function WebAudioSound() {
            this.url = null;
            this.loaded = false;
            this.data = null;
            this.audioBuffer = null;
            this.__toPlays = null;
            WebAudioSound.__super.call(this);
        }
        __class(WebAudioSound, 'laya.media.webaudio.WebAudioSound', _super);
        var __proto = WebAudioSound.prototype;
        __proto.load = function (url) {
            var me = this;
            url = URL.formatURL(url);
            this.url = url;
            this.audioBuffer = WebAudioSound._dataCache[url];
            if (this.audioBuffer) {
                this._loaded(this.audioBuffer);
                return;
            }
            WebAudioSound.e.on("loaded:" + url, this, this._loaded);
            WebAudioSound.e.on("err:" + url, this, this._err);
            if (WebAudioSound.__loadingSound[url]) {
                return;
            }
            WebAudioSound.__loadingSound[url] = true;
            var request = new Browser.window.XMLHttpRequest();
            request.open("GET", url, true);
            request.responseType = "arraybuffer";
            request.onload = function () {
                me.data = request.response;
                WebAudioSound.buffs.push({ "buffer": me.data, "url": me.url });
                WebAudioSound.decode();
            };
            request.onerror = function (e) {
                me._err();
            };
            request.send();
        };
        __proto._err = function () {
            this._removeLoadEvents();
            WebAudioSound.__loadingSound[this.url] = false;
            this.event("error");
        };
        __proto._loaded = function (audioBuffer) {
            this._removeLoadEvents();
            this.audioBuffer = audioBuffer;
            WebAudioSound._dataCache[this.url] = this.audioBuffer;
            this.loaded = true;
            this.event("complete");
        };
        __proto._removeLoadEvents = function () {
            WebAudioSound.e.off("loaded:" + this.url, this, this._loaded);
            WebAudioSound.e.off("err:" + this.url, this, this._err);
        };
        __proto.__playAfterLoaded = function () {
            if (!this.__toPlays)
                return;
            var i = 0, len = 0;
            var toPlays;
            toPlays = this.__toPlays;
            len = toPlays.length;
            var tParams;
            for (i = 0; i < len; i++) {
                tParams = toPlays[i];
                if (tParams[3] && !(tParams[3]).isStopped) {
                    this.play(tParams[0], tParams[1], tParams[2], tParams[3]);
                }
            }
            this.__toPlays.length = 0;
        };
        __proto.play = function (startTime, loops, playbackRate, channel) {
            (startTime === void 0) && (startTime = 0);
            (loops === void 0) && (loops = 0);
            (playbackRate === void 0) && (playbackRate = 1);
            channel = channel ? channel : new WebAudioSoundChannel();
            if (!this.audioBuffer) {
                if (this.url) {
                    if (!this.__toPlays)
                        this.__toPlays = [];
                    this.__toPlays.push([startTime, loops, playbackRate, channel]);
                    this.once("complete", this, this.__playAfterLoaded);
                    this.load(this.url);
                }
            }
            channel.url = this.url;
            channel.loops = loops;
            channel["audioBuffer"] = this.audioBuffer;
            channel.playbackRate = playbackRate;
            channel.startTime = startTime;
            channel.play();
            SoundManager.addChannel(channel);
            return channel;
        };
        __proto.dispose = function () {
            delete WebAudioSound._dataCache[this.url];
            delete WebAudioSound.__loadingSound[this.url];
            this.audioBuffer = null;
            this.data = null;
            this.__toPlays = [];
        };
        __getset(0, __proto, 'duration', function () {
            if (this.audioBuffer) {
                return this.audioBuffer.duration;
            }
            return 0;
        });
        WebAudioSound.decode = function () {
            if (WebAudioSound.buffs.length <= 0 || WebAudioSound.isDecoding) {
                return;
            }
            WebAudioSound.isDecoding = true;
            WebAudioSound.tInfo = WebAudioSound.buffs.shift();
            WebAudioSound.ctx.decodeAudioData(WebAudioSound.tInfo["buffer"], WebAudioSound._done, WebAudioSound._fail);
        };
        WebAudioSound._done = function (audioBuffer) {
            WebAudioSound.e.event("loaded:" + WebAudioSound.tInfo.url, audioBuffer);
            WebAudioSound.isDecoding = false;
            WebAudioSound.decode();
        };
        WebAudioSound._fail = function () {
            WebAudioSound.e.event("err:" + WebAudioSound.tInfo.url, null);
            WebAudioSound.isDecoding = false;
            WebAudioSound.decode();
        };
        WebAudioSound._playEmptySound = function () {
            if (WebAudioSound.ctx == null) {
                return;
            }
            ;
            var source = WebAudioSound.ctx.createBufferSource();
            source.buffer = WebAudioSound._miniBuffer;
            source.connect(WebAudioSound.ctx.destination);
            source.start(0, 0, 0);
        };
        WebAudioSound._unlock = function () {
            if (WebAudioSound._unlocked) {
                return;
            }
            WebAudioSound._playEmptySound();
            if (WebAudioSound.ctx.state == "running") {
                Browser.document.removeEventListener("mousedown", WebAudioSound._unlock, true);
                Browser.document.removeEventListener("touchend", WebAudioSound._unlock, true);
                WebAudioSound._unlocked = true;
            }
        };
        WebAudioSound.initWebAudio = function () {
            if (WebAudioSound.ctx.state != "running") {
                WebAudioSound._unlock();
                Browser.document.addEventListener("mousedown", WebAudioSound._unlock, true);
                Browser.document.addEventListener("touchend", WebAudioSound._unlock, true);
            }
        };
        WebAudioSound._dataCache = {};
        WebAudioSound.buffs = [];
        WebAudioSound.isDecoding = false;
        WebAudioSound._unlocked = false;
        WebAudioSound.tInfo = null;
        WebAudioSound.__loadingSound = {};
        __static(WebAudioSound, ['window', function () { return this.window = Browser.window; }, 'webAudioEnabled', function () { return this.webAudioEnabled = WebAudioSound.window["AudioContext"] || WebAudioSound.window["webkitAudioContext"] || WebAudioSound.window["mozAudioContext"]; }, 'ctx', function () { return this.ctx = gcTop["audioCtx"] ? gcTop["audioCtx"] : WebAudioSound.webAudioEnabled ? new (WebAudioSound.window["AudioContext"] || WebAudioSound.window["webkitAudioContext"] || WebAudioSound.window["mozAudioContext"])() : undefined; }, '_miniBuffer', function () { return this._miniBuffer = WebAudioSound.ctx.createBuffer(1, 1, 22050); }, 'e', function () { return this.e = new EventDispatcher(); }
        ]);
        return WebAudioSound;
    })(EventDispatcher);
    var HttpRequest = (function (_super) {
        function HttpRequest() {
            this._responseType = null;
            this._data = null;
            HttpRequest.__super.call(this);
            this._http = new Browser.window.XMLHttpRequest();
        }
        __class(HttpRequest, 'laya.net.HttpRequest', _super);
        var __proto = HttpRequest.prototype;
        __proto.send = function (url, data, method, responseType, headers) {
            (method === void 0) && (method = "get");
            (responseType === void 0) && (responseType = "text");
            this._responseType = responseType;
            this._data = null;
            var _this = this;
            var http = this._http;
            http.open(method, url, true);
            if (headers) {
                for (var i = 0; i < headers.length; i++) {
                    http.setRequestHeader(headers[i++], headers[i]);
                }
            }
            else if (!Render.isConchApp) {
                if (!data || (typeof data == 'string'))
                    http.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                else
                    http.setRequestHeader("Content-Type", "application/json");
            }
            http.responseType = responseType !== "arraybuffer" ? "text" : "arraybuffer";
            http.onerror = function (e) {
                _this._onError(e);
            };
            http.onabort = function (e) {
                _this._onAbort(e);
            };
            http.onprogress = function (e) {
                _this._onProgress(e);
            };
            http.onload = function (e) {
                _this._onLoad(e);
            };
            http.send(data);
        };
        __proto._onProgress = function (e) {
            if (e && e.lengthComputable)
                this.event("progress", e.loaded / e.total);
        };
        __proto._onAbort = function (e) {
            this.error("Request was aborted by user");
        };
        __proto._onError = function (e) {
            this.error("Request failed Status:" + this._http.status + " text:" + this._http.statusText);
        };
        __proto._onLoad = function (e) {
            var http = this._http;
            var status = http.status !== undefined ? http.status : 200;
            if (status === 200 || status === 204 || status === 0) {
                this.complete();
            }
            else {
                this.error("[" + http.status + "]" + http.statusText + ":" + http.responseURL);
            }
        };
        __proto.error = function (message) {
            this.clear();
            this.event("error", message);
        };
        __proto.complete = function () {
            this.clear();
            var flag = true;
            try {
                if (this._responseType === "json") {
                    this._data = JSON.parse(this._http.responseText);
                }
                else if (this._responseType === "xml") {
                    this._data = Utils.parseXMLFromString(this._http.responseText);
                }
                else {
                    this._data = this._http.response || this._http.responseText;
                }
            }
            catch (e) {
                flag = false;
                this.error(e.message);
            }
            flag && this.event("complete", (this._data instanceof Array) ? [this._data] : this._data);
        };
        __proto.clear = function () {
            var http = this._http;
            http.onerror = http.onabort = http.onprogress = http.onload = null;
        };
        __getset(0, __proto, 'url', function () {
            return this._http.responseURL;
        });
        __getset(0, __proto, 'http', function () {
            return this._http;
        });
        __getset(0, __proto, 'data', function () {
            return this._data;
        });
        return HttpRequest;
    })(EventDispatcher);
    var Loader = (function (_super) {
        function Loader() {
            this._data = null;
            this._class = null;
            this._url = null;
            this._type = null;
            this._cache = false;
            this._http = null;
            this._customParse = false;
            Loader.__super.call(this);
        }
        __class(Loader, 'laya.net.Loader', _super);
        var __proto = Loader.prototype;
        __proto.load = function (url, type, cache, group, ignoreCache) {
            (cache === void 0) && (cache = true);
            (ignoreCache === void 0) && (ignoreCache = false);
            this._url = url;
            if (url.indexOf("data:image") === 0)
                this._type = type = "image";
            else {
                this._type = type || (type = this.getTypeFromUrl(url));
                url = URL.formatURL(url);
            }
            this._cache = cache;
            this._data = null;
            if (!ignoreCache && Loader.loadedMap[url]) {
                this._data = Loader.loadedMap[url];
                this.event("progress", 1);
                this.event("complete", this._data);
                return;
            }
            if (group)
                Loader.setGroup(url, group);
            if (Loader.parserMap[type] != null) {
                this._customParse = true;
                if (((Loader.parserMap[type]) instanceof laya.utils.Handler))
                    Loader.parserMap[type].runWith(this);
                else
                    Loader.parserMap[type].call(null, this);
                return;
            }
            if (type === "image" || type === "htmlimage" || type === "nativeimage")
                return this._loadImage(url);
            if (type === "sound")
                return this._loadSound(url);
            if (type === "ttf")
                return this._loadTTF(url);
            if (type == "atlas") {
                if (Loader.preLoadedAtlasConfigMap[url]) {
                    this.onLoaded(Loader.preLoadedAtlasConfigMap[url]);
                    delete Loader.preLoadedAtlasConfigMap[url];
                    return;
                }
            }
            if (!this._http) {
                this._http = new HttpRequest();
                this._http.on("progress", this, this.onProgress);
                this._http.on("error", this, this.onError);
                this._http.on("complete", this, this.onLoaded);
            }
            ;
            var contentType;
            switch (type) {
                case "atlas":
                    contentType = "json";
                    break;
                case "font":
                    contentType = "xml";
                    break;
                case "pkm":
                    contentType = "arraybuffer";
                    break;
                default:
                    contentType = type;
            }
            this._http.send(url, null, "get", contentType);
        };
        __proto.getTypeFromUrl = function (url) {
            var type = Utils.getFileExtension(url);
            if (type)
                return Loader.typeMap[type];
            console_warn("Not recognize the resources suffix", url);
            return "text";
        };
        __proto._loadTTF = function (url) {
            url = URL.formatURL(url);
            var ttfLoader = new TTFLoader();
            ttfLoader.complete = Handler.create(this, this.onLoaded);
            ttfLoader.load(url);
        };
        __proto._loadImage = function (url) {
            url = URL.formatURL(url);
            var _this = this;
            var image;
            function clear() {
                image.onload = null;
                image.onerror = null;
                delete Loader.imgCache[url];
            }
            ;
            var onload = function () {
                clear();
                _this.onLoaded(image);
            };
            var onerror = function () {
                clear();
                _this.event("error", "Load image failed");
            };
            if (this._type === "nativeimage") {
                image = new Browser.window.Image();
                image.crossOrigin = "";
                image.onload = onload;
                image.onerror = onerror;
                image.src = url;
                Loader.imgCache[url] = image;
            }
            else {
                new HTMLImage.create(url, {
                    onload: onload, onerror: onerror, onCreate: function (img) {
                        image = img;
                        Loader.imgCache[url] = img;
                    }
                });
            }
        };
        __proto._loadSound = function (url) {
            var sound = (new SoundManager._soundClass());
            var _this = this;
            sound.on("complete", this, soundOnload);
            sound.on("error", this, soundOnErr);
            sound.load(url);
            function soundOnload() {
                clear();
                _this.onLoaded(sound);
            }
            function soundOnErr() {
                clear();
                sound.dispose();
                _this.event("error", "Load sound failed");
            }
            function clear() {
                sound.offAll();
            }
        };
        __proto.onProgress = function (value) {
            if (this._type === "atlas")
                this.event("progress", value * 0.3);
            else
                this.event("progress", value);
        };
        __proto.onError = function (message) {
            this.event("error", message);
        };
        __proto.onLoaded = function (data) {
            var type = this._type;
            if (type === "image") {
                var tex = new Texture(data);
                tex.url = this._url;
                this.complete(tex);
            }
            else if (type === "sound" || type === "htmlimage" || type === "nativeimage") {
                this.complete(data);
            }
            else if (type === "atlas") {
                if (!data.src && !data._setContext) {
                    if (!this._data) {
                        this._data = data;
                        if (data.meta && data.meta.image) {
                            var toloadPics = data.meta.image.split(",");
                            var split = this._url.indexOf("/") >= 0 ? "/" : "\\";
                            var idx = this._url.lastIndexOf(split);
                            var folderPath = idx >= 0 ? this._url.substr(0, idx + 1) : "";
                            for (var i = 0, len = toloadPics.length; i < len; i++) {
                                toloadPics[i] = folderPath + toloadPics[i];
                            }
                        }
                        else {
                            toloadPics = [this._url.replace(".json", ".png")];
                        }
                        toloadPics.reverse();
                        data.toLoads = toloadPics;
                        data.pics = [];
                    }
                    this.event("progress", 0.3 + 1 / toloadPics.length * 0.6);
                    return this._loadImage(toloadPics.pop());
                }
                else {
                    this._data.pics.push(data);
                    if (this._data.toLoads.length > 0) {
                        this.event("progress", 0.3 + 1 / this._data.toLoads.length * 0.6);
                        return this._loadImage(this._data.toLoads.pop());
                    }
                    ;
                    var frames = this._data.frames;
                    var cleanUrl = this._url.split("?")[0];
                    var directory = (this._data.meta && this._data.meta.prefix) ? this._data.meta.prefix : cleanUrl.substring(0, cleanUrl.lastIndexOf(".")) + "/";
                    var pics = this._data.pics;
                    var atlasURL = URL.formatURL(this._url);
                    var map = Loader.atlasMap[atlasURL] || (Loader.atlasMap[atlasURL] = []);
                    map.dir = directory;
                    var scaleRate = 1;
                    if (this._data.meta && this._data.meta.scale && this._data.meta.scale != 1) {
                        scaleRate = parseFloat(this._data.meta.scale);
                        for (var name in frames) {
                            var obj = frames[name];
                            var tPic = pics[obj.frame.idx ? obj.frame.idx : 0];
                            var url = URL.formatURL(directory + name);
                            tPic.scaleRate = scaleRate;
                            Loader.cacheRes(url, Texture.create(tPic, obj.frame.x, obj.frame.y, obj.frame.w, obj.frame.h, obj.spriteSourceSize.x, obj.spriteSourceSize.y, obj.sourceSize.w, obj.sourceSize.h));
                            Loader.loadedMap[url].url = url;
                            map.push(url);
                        }
                    }
                    else {
                        for (name in frames) {
                            obj = frames[name];
                            tPic = pics[obj.frame.idx ? obj.frame.idx : 0];
                            url = URL.formatURL(directory + name);
                            Loader.cacheRes(url, Texture.create(tPic, obj.frame.x, obj.frame.y, obj.frame.w, obj.frame.h, obj.spriteSourceSize.x, obj.spriteSourceSize.y, obj.sourceSize.w, obj.sourceSize.h));
                            Loader.loadedMap[url].url = url;
                            map.push(url);
                        }
                    }
                    delete this._data.pics;
                    this.complete(this._data);
                }
            }
            else if (type == "font") {
                if (!data.src) {
                    this._data = data;
                    this.event("progress", 0.5);
                    return this._loadImage(this._url.replace(".fnt", ".png"));
                }
                else {
                    var bFont = new BitmapFont();
                    bFont.parseFont(this._data, data);
                    var tArr = this._url.split(".fnt")[0].split("/");
                    var fontName = tArr[tArr.length - 1];
                    Text.registerBitmapFont(fontName, bFont);
                    this._data = bFont;
                    this.complete(this._data);
                }
            }
            else if (type == "pkm") {
                var image = HTMLImage.create(data, this._url);
                var tex1 = new Texture(image);
                tex1.url = this._url;
                this.complete(tex1);
            }
            else {
                this.complete(data);
            }
        };
        __proto.complete = function (data) {
            this._data = data;
            if (this._customParse) {
                this.event("loaded", (data instanceof Array) ? [data] : data);
            }
            else {
                Loader._loaders.push(this);
                if (!Loader._isWorking)
                    Loader.checkNext();
            }
        };
        __proto.endLoad = function (content) {
            content && (this._data = content);
            if (this._cache)
                Loader.cacheRes(this._url, this._data);
            this._customParse = false;
            this.event("progress", 1);
            this.event("complete", (this.data instanceof Array) ? [this.data] : this.data);
        };
        __getset(0, __proto, 'url', function () {
            return this._url;
        });
        __getset(0, __proto, 'data', function () {
            return this._data;
        });
        __getset(0, __proto, 'cache', function () {
            return this._cache;
        });
        __getset(0, __proto, 'type', function () {
            return this._type;
        });
        Loader.checkNext = function () {
            Loader._isWorking = true;
            var startTimer = Browser.now();
            var thisTimer = startTimer;
            while (Loader._startIndex < Loader._loaders.length) {
                thisTimer = Browser.now();
                Loader._loaders[Loader._startIndex].endLoad();
                Loader._startIndex++;
                if (Browser.now() - startTimer > Loader.maxTimeOut) {
                    console_warn("loader callback cost a long time:" + (Browser.now() - startTimer) + " url=" + Loader._loaders[Loader._startIndex - 1].url);
                    Laya.timer && Laya.timer.frameOnce(1, null, Loader.checkNext);
                    return;
                }
            }
            Loader._loaders.length = 0;
            Loader._startIndex = 0;
            Loader._isWorking = false;
        };
        Loader.clearRes = function (url, forceDispose) {
            (forceDispose === void 0) && (forceDispose = false);
            url = URL.formatURL(url);
            var arr = Loader.getAtlas(url);
            if (arr) {
                for (var i = 0, n = arr.length; i < n; i++) {
                    var resUrl = arr[i];
                    var tex = Loader.getRes(resUrl);
                    delete Loader.loadedMap[resUrl];
                    if (tex)
                        tex.destroy(forceDispose);
                }
                arr.length = 0;
                delete Loader.atlasMap[url];
                delete Loader.loadedMap[url];
            }
            else {
                var res = Loader.loadedMap[url];
                if (res) {
                    delete Loader.loadedMap[url];
                    if ((res instanceof laya.resource.Texture) && res.bitmap)
                        (res).destroy(forceDispose);
                }
            }
        };
        Loader.clearTextureRes = function (url) {
            url = URL.formatURL(url);
            var arr = laya.net.Loader.getAtlas(url);
            var res = (arr && arr.length > 0) ? laya.net.Loader.getRes(arr[0]) : laya.net.Loader.getRes(url);
            if (res && res.bitmap) {
                if (Render.isConchApp) {
                    if (res.bitmap.source.releaseTexture) {
                        res.bitmap.source.releaseTexture();
                    }
                }
                else if (res.bitmap._atlaser == null) {
                    res.bitmap.releaseResource(true);
                }
            }
        };
        Loader.setAtlasConfigs = function (url, config) {
            Loader.preLoadedAtlasConfigMap[URL.formatURL(url)] = config;
        };
        Loader.getRes = function (url) {
            return Loader.loadedMap[URL.formatURL(url)];
        };
        Loader.getAtlas = function (url) {
            return Loader.atlasMap[URL.formatURL(url)];
        };
        Loader.cacheRes = function (url, data) {
            url = URL.formatURL(url);
            if (Loader.loadedMap[url] != null) {
                console_warn("Resources already exist,is repeated loading:", url);
            }
            else {
                Loader.loadedMap[url] = data;
            }
        };
        Loader.setGroup = function (url, group) {
            if (!Loader.groupMap[group])
                Loader.groupMap[group] = [];
            Loader.groupMap[group].push(url);
        };
        Loader.clearResByGroup = function (group) {
            if (!Loader.groupMap[group])
                return;
            var arr = Loader.groupMap[group], i = 0, len = arr.length;
            for (i = 0; i < len; i++) {
                Loader.clearRes(arr[i]);
            }
            arr.length = 0;
        };
        Loader.TEXT = "text";
        Loader.JSON = "json";
        Loader.XML = "xml";
        Loader.BUFFER = "arraybuffer";
        Loader.IMAGE = "image";
        Loader.SOUND = "sound";
        Loader.ATLAS = "atlas";
        Loader.FONT = "font";
        Loader.TTF = "ttf";
        Loader.PKM = "pkm";
        Loader.typeMap = { "png": "image", "jpg": "image", "jpeg": "image", "txt": "text", "json": "json", "xml": "xml", "als": "atlas", "atlas": "atlas", "mp3": "sound", "ogg": "sound", "wav": "sound", "part": "json", "fnt": "font", "pkm": "pkm", "ttf": "ttf" };
        Loader.parserMap = {};
        Loader.groupMap = {};
        Loader.maxTimeOut = 100;
        Loader.loadedMap = {};
        Loader.preLoadedAtlasConfigMap = {};
        Loader.atlasMap = {};
        Loader._loaders = [];
        Loader._isWorking = false;
        Loader._startIndex = 0;
        Loader.imgCache = {};
        return Loader;
    })(EventDispatcher);
    var LoaderManager = (function (_super) {
        var ResInfo;
        function LoaderManager() {
            this.retryNum = 1;
            this.retryDelay = 0;
            this.maxLoader = 5;
            this._loaders = [];
            this._loaderCount = 0;
            this._resInfos = [];
            this._infoPool = [];
            this._maxPriority = 5;
            this._failRes = {};
            LoaderManager.__super.call(this);
            for (var i = 0; i < this._maxPriority; i++)
                this._resInfos[i] = [];
        }
        __class(LoaderManager, 'laya.net.LoaderManager', _super);
        var __proto = LoaderManager.prototype;
        __proto.create = function (url, complete, progress, clas, params, priority, cache, group) {
            (priority === void 0) && (priority = 1);
            (cache === void 0) && (cache = true);
            if ((url instanceof Array)) {
                var items = url;
                var itemCount = items.length;
                var loadedCount = 0;
                if (progress) {
                    var progress2 = Handler.create(progress.caller, progress.method, progress.args, false);
                }
                for (var i = 0; i < itemCount; i++) {
                    var item = items[i];
                    if ((typeof item == 'string'))
                        item = items[i] = { url: item };
                    item.progress = 0;
                    var progressHandler = progress ? Handler.create(null, onProgress, [item], false) : null;
                    var completeHandler = (progress || complete) ? Handler.create(null, onComplete, [item]) : null;
                    this._create(item.url, completeHandler, progressHandler, item.clas || clas, item.params || params, item.priority || priority, cache, item.group || group);
                }
                function onComplete(item, content) {
                    loadedCount++;
                    item.progress = 1;
                    if (loadedCount === itemCount && complete) {
                        complete.run();
                    }
                }
                function onProgress(item, value) {
                    item.progress = value;
                    var num = 0;
                    for (var j = 0; j < itemCount; j++) {
                        var item1 = items[j];
                        num += item1.progress;
                    }
                    ;
                    var v = num / itemCount;
                    progress2.runWith(v);
                }
                return true;
            }
            else
                return this._create(url, complete, progress, clas, params, priority, cache, group);
        };
        __proto._create = function (url, complete, progress, clas, params, priority, cache, group) {
            (priority === void 0) && (priority = 1);
            (cache === void 0) && (cache = true);
            var formarUrl = URL.formatURL(url);
            var item = this.getRes(formarUrl);
            if (!item) {
                var extension = Utils.getFileExtension(url);
                var creatItem = LoaderManager.createMap[extension];
                if (!creatItem)
                    throw new Error("LoaderManager:unknown file(" + url + ") extension with: " + extension + ".");
                if (!clas)
                    clas = creatItem[0];
                var type = creatItem[1];
                if (extension == "atlas") {
                    this.load(url, complete, progress, type, priority, cache);
                }
                else {
                    if (clas === Texture)
                        type = "htmlimage";
                    item = clas ? new clas() : null;
                    if (item.hasOwnProperty("_loaded"))
                        item._loaded = false;
                    item._setUrl(url);
                    (group) && (item._setGroup(group));
                    this._createLoad(item, url, Handler.create(null, onLoaded), progress, type, priority, false, group, true);
                    function onLoaded(data) {
                        (item && !item.destroyed && data) && (item.onAsynLoaded.call(item, url, data, params));
                        if (complete)
                            complete.run();
                        Laya.loader.event(url);
                    }
                    (cache) && (this.cacheRes(formarUrl, item));
                }
            }
            else {
                if (!item.hasOwnProperty("loaded") || item.loaded) {
                    progress && progress.runWith(1);
                    complete && complete.run();
                }
                else if (complete) {
                    Laya.loader._createListener(url, complete.caller, complete.method, complete.args, true, false);
                }
            }
            return item;
        };
        __proto.load = function (url, complete, progress, type, priority, cache, group, ignoreCache) {
            var _$this = this;
            (priority === void 0) && (priority = 1);
            (cache === void 0) && (cache = true);
            (ignoreCache === void 0) && (ignoreCache = false);
            if ((url instanceof Array))
                return this._loadAssets(url, complete, progress, type, priority, cache, group);
            var content = Loader.getRes(url);
            if (content != null) {
                Laya.timer && Laya.timer.frameOnce(1, null, function () {
                    progress && progress.runWith(1);
                    complete && complete.runWith(content);
                    _$this._loaderCount || _$this.event("complete");
                });
            }
            else {
                var info = LoaderManager._resMap[url];
                if (!info) {
                    info = this._infoPool.length ? this._infoPool.pop() : new ResInfo();
                    info.url = url;
                    info.type = type;
                    info.cache = cache;
                    info.group = group;
                    info.ignoreCache = ignoreCache;
                    complete && info.on("complete", complete.caller, complete.method, complete.args);
                    progress && info.on("progress", progress.caller, progress.method, progress.args);
                    LoaderManager._resMap[url] = info;
                    priority = priority < this._maxPriority ? priority : this._maxPriority - 1;
                    this._resInfos[priority].push(info);
                    this._next();
                }
                else {
                    complete && info._createListener("complete", complete.caller, complete.method, complete.args, false, false);
                    progress && info._createListener("progress", progress.caller, progress.method, progress.args, false, false);
                }
            }
            return this;
        };
        __proto._createLoad = function (item, url, complete, progress, type, priority, cache, group, ignoreCache) {
            var _$this = this;
            (priority === void 0) && (priority = 1);
            (cache === void 0) && (cache = true);
            (ignoreCache === void 0) && (ignoreCache = false);
            if ((url instanceof Array))
                return this._loadAssets(url, complete, progress, type, priority, cache, group);
            var content = Loader.getRes(url);
            if (content != null) {
                Laya.timer.frameOnce(1, null, function () {
                    progress && progress.runWith(1);
                    complete && complete.runWith(content);
                    _$this._loaderCount || _$this.event("complete");
                });
            }
            else {
                var info = LoaderManager._resMap[url];
                if (!info) {
                    info = this._infoPool.length ? this._infoPool.pop() : new ResInfo();
                    info.url = url;
                    info.clas = item;
                    info.type = type;
                    info.cache = cache;
                    info.group = group;
                    info.ignoreCache = ignoreCache;
                    complete && info.on("complete", complete.caller, complete.method, complete.args);
                    progress && info.on("progress", progress.caller, progress.method, progress.args);
                    LoaderManager._resMap[url] = info;
                    priority = priority < this._maxPriority ? priority : this._maxPriority - 1;
                    this._resInfos[priority].push(info);
                    this._next();
                }
                else {
                    complete && info._createListener("complete", complete.caller, complete.method, complete.args, false, false);
                    progress && info._createListener("progress", progress.caller, progress.method, progress.args, false, false);
                }
            }
            return this;
        };
        __proto._next = function () {
            if (this._loaderCount >= this.maxLoader)
                return;
            for (var i = 0; i < this._maxPriority; i++) {
                var infos = this._resInfos[i];
                while (infos.length > 0) {
                    var info = infos.shift();
                    if (info)
                        return this._doLoad(info);
                }
            }
            this._loaderCount || this.event("complete");
        };
        __proto._doLoad = function (resInfo) {
            this._loaderCount++;
            var loader = this._loaders.length ? this._loaders.pop() : new Loader();
            loader.on("complete", null, onLoaded);
            loader.on("progress", null, function (num) {
                resInfo.event("progress", num);
            });
            loader.on("error", null, function (msg) {
                onLoaded(null);
            });
            var _this = this;
            function onLoaded(data) {
                loader.offAll();
                loader._data = null;
                _this._loaders.push(loader);
                _this._endLoad(resInfo, (data instanceof Array) ? [data] : data);
                _this._loaderCount--;
                _this._next();
            }
            loader._class = resInfo.clas;
            loader.load(resInfo.url, resInfo.type, resInfo.cache, resInfo.group, resInfo.ignoreCache);
        };
        __proto._endLoad = function (resInfo, content) {
            var url = resInfo.url;
            if (content == null) {
                var errorCount = this._failRes[url] || 0;
                if (errorCount < this.retryNum) {
                    console_warn("[warn]Retry to load:", url);
                    this._failRes[url] = errorCount + 1;
                    Laya.timer.once(this.retryDelay, this, this._addReTry, [resInfo], false);
                    return;
                }
                else {
                    console_warn("[error]Failed to load:", url);
                    this.event("error", url);
                }
            }
            if (this._failRes[url])
                this._failRes[url] = 0;
            delete LoaderManager._resMap[url];
            resInfo.event("complete", content);
            resInfo.offAll();
            this._infoPool.push(resInfo);
        };
        __proto._addReTry = function (resInfo) {
            this._resInfos[this._maxPriority - 1].push(resInfo);
            this._next();
        };
        __proto.clearRes = function (url, forceDispose) {
            (forceDispose === void 0) && (forceDispose = false);
            Loader.clearRes(url, forceDispose);
        };
        __proto.getRes = function (url) {
            return Loader.getRes(url);
        };
        __proto.cacheRes = function (url, data) {
            Loader.cacheRes(url, data);
        };
        __proto.clearTextureRes = function (url) {
            Loader.clearTextureRes(url);
        };
        __proto.setGroup = function (url, group) {
            Loader.setGroup(url, group);
        };
        __proto.clearResByGroup = function (group) {
            Loader.clearResByGroup(group);
        };
        __proto.clearUnLoaded = function () {
            for (var i = 0; i < this._maxPriority; i++) {
                var infos = this._resInfos[i];
                for (var j = infos.length - 1; j > -1; j--) {
                    var info = infos[j];
                    if (info) {
                        info.offAll();
                        this._infoPool.push(info);
                    }
                }
                infos.length = 0;
            }
            this._loaderCount = 0;
            LoaderManager._resMap = {};
        };
        __proto.cancelLoadByUrls = function (urls) {
            if (!urls)
                return;
            for (var i = 0, n = urls.length; i < n; i++) {
                this.cancelLoadByUrl(urls[i]);
            }
        };
        __proto.cancelLoadByUrl = function (url) {
            for (var i = 0; i < this._maxPriority; i++) {
                var infos = this._resInfos[i];
                for (var j = infos.length - 1; j > -1; j--) {
                    var info = infos[j];
                    if (info && info.url === url) {
                        infos[j] = null;
                        info.offAll();
                        this._infoPool.push(info);
                    }
                }
            }
            if (LoaderManager._resMap[url])
                delete LoaderManager._resMap[url];
        };
        __proto._loadAssets = function (arr, complete, progress, type, priority, cache, group) {
            (priority === void 0) && (priority = 1);
            (cache === void 0) && (cache = true);
            var itemCount = arr.length;
            var loadedCount = 0;
            var totalSize = 0;
            var items = [];
            var success = true;
            for (var i = 0; i < itemCount; i++) {
                var item = arr[i];
                if ((typeof item == 'string'))
                    item = { url: item, type: type, size: 1, priority: priority };
                if (!item.size)
                    item.size = 1;
                item.progress = 0;
                totalSize += item.size;
                items.push(item);
                var progressHandler = progress ? Handler.create(null, loadProgress, [item], false) : null;
                var completeHandler = (complete || progress) ? Handler.create(null, loadComplete, [item]) : null;
                this.load(item.url, completeHandler, progressHandler, item.type, item.priority || 1, cache, item.group || group);
            }
            function loadComplete(item, content) {
                loadedCount++;
                item.progress = 1;
                if (!content)
                    success = false;
                if (loadedCount === itemCount && complete) {
                    complete.runWith(success);
                }
            }
            function loadProgress(item, value) {
                if (progress != null) {
                    item.progress = value;
                    var num = 0;
                    for (var j = 0; j < items.length; j++) {
                        var item1 = items[j];
                        num += item1.size * item1.progress;
                    }
                    ;
                    var v = num / totalSize;
                    progress.runWith(v);
                }
            }
            return this;
        };
        LoaderManager.cacheRes = function (url, data) {
            Loader.cacheRes(url, data);
        };
        LoaderManager._resMap = {};
        __static(LoaderManager, ['createMap', function () { return this.createMap = { atlas: [null, "atlas"] }; }
        ]);
        LoaderManager.__init$ = function () {
            ResInfo = (function (_super) {
                function ResInfo() {
                    this.url = null;
                    this.type = null;
                    this.cache = false;
                    this.group = null;
                    this.ignoreCache = false;
                    this.clas = null;
                    ResInfo.__super.call(this);
                }
                __class(ResInfo, '', _super);
                return ResInfo;
            })(EventDispatcher);
        };
        return LoaderManager;
    })(EventDispatcher);
    var ColorFilter = (function (_super) {
        function ColorFilter(mat) {
            ColorFilter.__super.call(this);
            if (!mat) {
                mat = [0.3, 0.59, 0.11, 0, 0, 0.3, 0.59, 0.11, 0, 0, 0.3, 0.59, 0.11, 0, 0, 0, 0, 0, 1, 0];
            }
            this._mat = new Float32Array(16);
            this._alpha = new Float32Array(4);
            var j = 0;
            var z = 0;
            for (var i = 0; i < 20; i++) {
                if (i % 5 != 4) {
                    this._mat[j++] = mat[i];
                }
                else {
                    this._alpha[z++] = mat[i];
                }
            }
            this._action = RunDriver.createFilterAction(0x20);
            this._action.data = this;
        }
        __class(ColorFilter, 'laya.filters.ColorFilter', _super);
        var __proto = ColorFilter.prototype;
        Laya.imps(__proto, { "laya.filters.IFilter": true });
        __proto.callNative = function (sp) {
            var t = sp._$P.cf = this;
            sp.conchModel && sp.conchModel.setFilterMatrix && sp.conchModel.setFilterMatrix(this._mat, this._alpha);
        };
        __getset(0, __proto, 'type', function () {
            return 0x20;
        });
        __getset(0, __proto, 'action', function () {
            return this._action;
        });
        return ColorFilter;
    })(Filter);
    var Socket = (function (_super) {
        function Socket(host, port, byteClass) {
            this._endian = null;
            this._stamp = NaN;
            this._socket = null;
            this._connected = false;
            this._addInputPosition = 0;
            this._input = null;
            this._output = null;
            this.timeout = 0;
            this.objectEncoding = 0;
            this.disableInput = false;
            this._byteClass = null;
            this.protocols = [];
            (port === void 0) && (port = 0);
            Socket.__super.call(this);
            this._byteClass = byteClass ? byteClass : Byte;
            this.endian = "bigEndian";
            this.timeout = 20000;
            this._addInputPosition = 0;
            if (host && port > 0 && port < 65535)
                this.connect(host, port);
        }
        __class(Socket, 'laya.net.Socket', _super);
        var __proto = Socket.prototype;
        __proto.connect = function (host, port) {
            var url = "ws://" + host + ":" + port;
            if (Browser.window.location.protocol == "https:") {
                url = "wss://" + host + ":" + port;
            }
            else {
                url = "ws://" + host + ":" + port;
            }
            this.connectByUrl(url);
        };
        __proto.connectByUrl = function (url) {
            var _$this = this;
            if (this._socket != null)
                this.close();
            this._socket && this.cleanSocket();
            if (!this.protocols || this.protocols.length == 0) {
                this._socket = new Browser.window.WebSocket(url);
            }
            else {
                this._socket = new Browser.window.WebSocket(url, this.protocols);
            }
            this._socket.binaryType = "arraybuffer";
            this._output = new this._byteClass();
            this._output.endian = this.endian;
            this._input = new this._byteClass();
            this._input.endian = this.endian;
            this._addInputPosition = 0;
            this._socket.onopen = function (e) {
                _$this._onOpen(e);
            };
            this._socket.onmessage = function (msg) {
                _$this._onMessage(msg);
            };
            this._socket.onclose = function (e) {
                _$this._onClose(e);
            };
            this._socket.onerror = function (e) {
                _$this._onError(e);
            };
        };
        __proto.cleanSocket = function () {
            try {
                this._socket.close();
            }
            catch (e) { }
            this._connected = false;
            this._socket.onopen = null;
            this._socket.onmessage = null;
            this._socket.onclose = null;
            this._socket.onerror = null;
            this._socket = null;
        };
        __proto.close = function () {
            if (this._socket != null) {
                try {
                    this._socket.close();
                }
                catch (e) { }
            }
        };
        __proto._onOpen = function (e) {
            this._connected = true;
            this.event("open", e);
        };
        __proto._onMessage = function (msg) {
            if (!msg || !msg.data)
                return;
            var data = msg.data;
            if (this.disableInput && data) {
                this.event("message", data);
                return;
            }
            if (this._input.length > 0 && this._input.bytesAvailable < 1) {
                this._input.clear();
                this._addInputPosition = 0;
            }
            ;
            var pre = this._input.pos;
            !this._addInputPosition && (this._addInputPosition = 0);
            this._input.pos = this._addInputPosition;
            if (data) {
                if ((typeof data == 'string')) {
                    this._input.writeUTFBytes(data);
                }
                else {
                    this._input.writeArrayBuffer(data);
                }
                this._addInputPosition = this._input.pos;
                this._input.pos = pre;
            }
            this.event("message", data);
        };
        __proto._onClose = function (e) {
            this._connected = false;
            this.event("close", e);
        };
        __proto._onError = function (e) {
            this.event("error", e);
        };
        __proto.send = function (data) {
            this._socket.send(data);
        };
        __proto.flush = function () {
            if (this._output && this._output.length > 0) {
                var evt;
                try {
                    this._socket && this._socket.send(this._output.__getBuffer().slice(0, this._output.length));
                }
                catch (e) {
                    evt = e;
                }
                this._output.endian = this.endian;
                this._output.clear();
                if (evt)
                    this.event("error", evt);
            }
        };
        __getset(0, __proto, 'input', function () {
            return this._input;
        });
        __getset(0, __proto, 'output', function () {
            return this._output;
        });
        __getset(0, __proto, 'connected', function () {
            return this._connected;
        });
        __getset(0, __proto, 'endian', function () {
            return this._endian;
        }, function (value) {
            this._endian = value;
            if (this._input != null)
                this._input.endian = value;
            if (this._output != null)
                this._output.endian = value;
        });
        Socket.LITTLE_ENDIAN = "littleEndian";
        Socket.BIG_ENDIAN = "bigEndian";
        return Socket;
    })(EventDispatcher);
    var WorkerLoader = (function (_super) {
        function WorkerLoader() {
            this.worker = null;
            WorkerLoader.__super.call(this);
            var _$this = this;
            this.worker = new Browser.window.Worker(WorkerLoader.workerPath);
            this.worker.onmessage = function (evt) {
                _$this.workerMessage(evt.data);
            };
        }
        __class(WorkerLoader, 'laya.net.WorkerLoader', _super);
        var __proto = WorkerLoader.prototype;
        __proto.workerMessage = function (data) {
            if (data) {
                switch (data.type) {
                    case "Image":
                        this.imageLoaded(data);
                        break;
                    case "Msg":
                        this.event("image_msg", data.msg);
                        break;
                }
            }
        };
        __proto.imageLoaded = function (data) {
            if (data && data.buffer && data.buffer.length < 10) {
                WorkerLoader._enable = false;
                this._myTrace("buffer lost when postmessage ,disable workerloader");
                this.event(data.url, null);
                this.event("image_err", data.url + "\n" + data.msg);
                return;
            }
            if (!data.dataType) {
                this.event(data.url, null);
                this.event("image_err", data.url + "\n" + data.msg);
                return;
            }
            ;
            var canvas, ctx;
            var imageData;
            switch (data.dataType) {
                case "buffer":
                    canvas = new HTMLCanvas("2D");
                    ctx = canvas.source.getContext("2d");
                    imageData = ctx.createImageData(data.width, data.height);
                    imageData.data.set(data.buffer);
                    canvas.size(imageData.width, imageData.height);
                    ctx.putImageData(imageData, 0, 0);
                    canvas.memorySize = 0;
                    break;
                case "imagedata":
                    canvas = new HTMLCanvas("2D");
                    ctx = canvas.source.getContext("2d");
                    imageData = data.imagedata;
                    canvas.size(imageData.width, imageData.height);
                    ctx.putImageData(imageData, 0, 0);
                    imageData = data.imagedata;
                    canvas.memorySize = 0;
                    break;
                case "imageBitmap":
                    imageData = data.imageBitmap;
                    if (!Render.isWebGL) {
                        canvas = new HTMLCanvas("2D");
                        ctx = canvas.source.getContext("2d");
                        canvas.size(imageData.width, imageData.height);
                        ctx.drawImage(imageData, 0, 0);
                        canvas.src = data.url;
                    }
                    else
                        canvas = imageData;
                    break;
            }
            if (Render.isWebGL)
                canvas = new laya.webgl.resource.WebGLImage(canvas, data.url);
            ;
            this.event(data.url, canvas);
        };
        __proto._myTrace = function (__arg) {
            var arg = arguments;
            var rst = [];
            var i = 0, len = arg.length;
            for (i = 0; i < len; i++) {
                rst.push(arg[i]);
            }
            this.event("image_msg", rst.join(" "));
        };
        __proto.loadImage = function (url) {
            var data;
            data = {};
            data.type = "load";
            data.url = url;
            this.worker.postMessage(data);
        };
        __proto._loadImage = function (url) {
            var _this = this;
            if (!WorkerLoader._enable || url.toLowerCase().indexOf(".png") < 0) {
                WorkerLoader._preLoadFun.call(_this, url);
                return;
            }
            url = URL.formatURL(url);
            function clear() {
                laya.net.WorkerLoader.I.off(url, _this, onload);
            }
            ;
            var onload = function (image) {
                clear();
                if (image) {
                    _this["onLoaded"](image);
                }
                else {
                    WorkerLoader._preLoadFun.call(_this, url);
                }
            };
            laya.net.WorkerLoader.I.on(url, _this, onload);
            laya.net.WorkerLoader.I.loadImage(url);
        };
        __getset(1, WorkerLoader, 'enable', function () {
            return WorkerLoader._enable;
        }, function (v) {
            if (WorkerLoader.disableJSDecode && (!Browser.window.createImageBitmap))
                return;
            WorkerLoader._enable = v;
            if (WorkerLoader._enable && WorkerLoader._preLoadFun == null)
                WorkerLoader._enable = WorkerLoader.__init__();
        });
        WorkerLoader.__init__ = function () {
            if (WorkerLoader._preLoadFun != null)
                return false;
            if (!Browser.window.Worker)
                return false;
            WorkerLoader._preLoadFun = Loader["prototype"]["_loadImage"];
            Loader["prototype"]["_loadImage"] = WorkerLoader["prototype"]["_loadImage"];
            if (!WorkerLoader.I)
                WorkerLoader.I = new WorkerLoader();
            return true;
        };
        WorkerLoader.workerSupported = function () {
            return Browser.window.Worker ? true : false;
        };
        WorkerLoader.IMAGE_LOADED = "image_loaded";
        WorkerLoader.IMAGE_ERR = "image_err";
        WorkerLoader.IMAGE_MSG = "image_msg";
        WorkerLoader.I = null;
        WorkerLoader._preLoadFun = null;
        WorkerLoader._enable = false;
        WorkerLoader.workerPath = "libs/worker.js";
        WorkerLoader.disableJSDecode = true;
        return WorkerLoader;
    })(EventDispatcher);
    var Resource = (function (_super) {
        function Resource() {
            Resource.__super.call(this);
            this._$1__id = ++Resource._uniqueIDCounter;
            this.__loaded = true;
            this._destroyed = false;
            this._referenceCount = 0;
            Resource._idResourcesMap[this.id] = this;
            this._released = true;
            this.lock = false;
            this._memorySize = 0;
            this._lastUseFrameCount = -1;
            (ResourceManager.currentResourceManager) && (ResourceManager.currentResourceManager.addResource(this));
        }
        __class(Resource, 'laya.resource.Resource', _super);
        var __proto = Resource.prototype;
        Laya.imps(__proto, { "laya.resource.ICreateResource": true, "laya.resource.IDispose": true });
        __proto._setUrl = function (url) {
            if (this._url !== url) {
                var resList;
                if (this._url) {
                    resList = Resource._urlResourcesMap[this._url];
                    resList.splice(resList.indexOf(this), 1);
                    (resList.length === 0) && (delete Resource._urlResourcesMap[this._url]);
                }
                if (url) {
                    resList = Resource._urlResourcesMap[url];
                    (resList) || (Resource._urlResourcesMap[url] = resList = []);
                    resList.push(this);
                }
                this._url = url;
            }
        };
        __proto._getGroup = function () {
            return this._group;
        };
        __proto._setGroup = function (value) {
            if (this._group !== value) {
                var groupList;
                if (this._group) {
                    groupList = Resource._groupResourcesMap[this._group];
                    groupList.splice(groupList.indexOf(this), 1);
                    (groupList.length === 0) && (delete Resource._groupResourcesMap[this._group]);
                }
                if (value) {
                    groupList = Resource._groupResourcesMap[value];
                    (groupList) || (Resource._groupResourcesMap[value] = groupList = []);
                    groupList.push(this);
                }
                this._group = value;
            }
        };
        __proto._addReference = function () {
            this._referenceCount++;
        };
        __proto._removeReference = function () {
            this._referenceCount--;
        };
        __proto._clearReference = function () {
            this._referenceCount = 0;
        };
        __proto._endLoaded = function () {
            this.__loaded = true;
            this.event("loaded", this);
        };
        __proto.recreateResource = function () {
            this.completeCreate();
        };
        __proto.disposeResource = function () { };
        __proto.activeResource = function (force) {
            (force === void 0) && (force = false);
            this._lastUseFrameCount = Stat.loopCount;
            if (!this._destroyed && this.__loaded && (this._released || force))
                this.recreateResource();
        };
        __proto.releaseResource = function (force) {
            (force === void 0) && (force = false);
            if (!force && this.lock)
                return false;
            if (!this._released || force) {
                this.disposeResource();
                this._released = true;
                this._lastUseFrameCount = -1;
                this.event("released", this);
                return true;
            }
            else {
                return false;
            }
        };
        __proto.onAsynLoaded = function (url, data, params) {
            throw new Error("Resource: must override this function!");
        };
        __proto.destroy = function () {
            if (this._destroyed)
                return;
            if (this._resourceManager !== null)
                this._resourceManager.removeResource(this);
            this._destroyed = true;
            this.lock = false;
            this.releaseResource();
            delete Resource._idResourcesMap[this.id];
            var resList;
            if (this._url) {
                resList = Resource._urlResourcesMap[this._url];
                if (resList) {
                    resList.splice(resList.indexOf(this), 1);
                    (resList.length === 0) && (delete Resource._urlResourcesMap[this.url]);
                }
                Loader.clearRes(this._url);
                (this.__loaded) || (RunDriver.cancelLoadByUrl(this._url));
            }
            if (this._group) {
                resList = Resource._groupResourcesMap[this._group];
                resList.splice(resList.indexOf(this), 1);
                (resList.length === 0) && (delete Resource._groupResourcesMap[this.url]);
            }
        };
        __proto.completeCreate = function () {
            this._released = false;
            this.event("recovered", this);
        };
        __proto.dispose = function () {
            this.destroy();
        };
        __getset(0, __proto, 'memorySize', function () {
            return this._memorySize;
        }, function (value) {
            var offsetValue = value - this._memorySize;
            this._memorySize = value;
            this.resourceManager && this.resourceManager.addSize(offsetValue);
        });
        __getset(0, __proto, '_loaded', null, function (value) {
            this.__loaded = value;
        });
        __getset(0, __proto, 'loaded', function () {
            return this.__loaded;
        });
        __getset(0, __proto, 'id', function () {
            return this._$1__id;
        });
        __getset(0, __proto, 'destroyed', function () {
            return this._destroyed;
        });
        __getset(0, __proto, 'group', function () {
            return this._getGroup();
        }, function (value) {
            this._setGroup(value);
        });
        __getset(0, __proto, 'resourceManager', function () {
            return this._resourceManager;
        });
        __getset(0, __proto, 'url', function () {
            return this._url;
        });
        __getset(0, __proto, 'released', function () {
            return this._released;
        });
        __getset(0, __proto, 'referenceCount', function () {
            return this._referenceCount;
        });
        Resource.getResourceByID = function (id) {
            return Resource._idResourcesMap[id];
        };
        Resource.getResourceByURL = function (url, index) {
            (index === void 0) && (index = 0);
            return Resource._urlResourcesMap[url][index];
        };
        Resource.getResourceCountByURL = function (url) {
            return Resource._urlResourcesMap[url].length;
        };
        Resource.destroyUnusedResources = function (group) {
            var res;
            if (group) {
                var resouList = Resource._groupResourcesMap[group];
                if (resouList) {
                    var tempResouList = resouList.slice();
                    for (var i = 0, n = tempResouList.length; i < n; i++) {
                        res = tempResouList[i];
                        if (!res.lock && res._referenceCount === 0)
                            res.destroy();
                    }
                }
            }
            else {
                for (var k in Resource._idResourcesMap) {
                    res = Resource._idResourcesMap[k];
                    if (!res.lock && res._referenceCount === 0)
                        res.destroy();
                }
            }
        };
        Resource._uniqueIDCounter = 0;
        Resource._idResourcesMap = {};
        Resource._urlResourcesMap = {};
        Resource._groupResourcesMap = {};
        return Resource;
    })(EventDispatcher);
    var Texture = (function (_super) {
        function Texture(bitmap, uv) {
            this.offsetX = 0;
            this.offsetY = 0;
            this.sourceWidth = 0;
            this.sourceHeight = 0;
            this._w = 0;
            this._h = 0;
            this._uvID = 0;
            this._atlasID = -1;
            this.scaleRate = 1;
            Texture.__super.call(this);
            if (bitmap && bitmap._addReference) {
                bitmap._addReference();
            }
            this.setTo(bitmap, uv);
        }
        __class(Texture, 'laya.resource.Texture', _super);
        var __proto = Texture.prototype;
        __proto._setUrl = function (url) {
            this.url = url;
        };
        __proto.setTo = function (bitmap, uv) {
            if (bitmap instanceof window.HTMLElement) {
                var canvas = HTMLCanvas.create("2D", bitmap);
                this.bitmap = canvas;
            }
            else {
                this.bitmap = bitmap;
            }
            this.uv = uv || Texture.DEF_UV;
            if (bitmap) {
                this._w = bitmap.width;
                this._h = bitmap.height;
                this.sourceWidth = this.sourceWidth || this._w;
                this.sourceHeight = this.sourceHeight || this._h;
                this._loaded = this._w > 0;
                var _this = this;
                if (this._loaded) {
                    RunDriver.addToAtlas && RunDriver.addToAtlas(_this);
                }
                else {
                    var bm = bitmap;
                    if ((bm instanceof laya.resource.HTMLImage) && bm.image)
                        bm.image.addEventListener('load', function (e) {
                            RunDriver.addToAtlas && RunDriver.addToAtlas(_this);
                        }, false);
                }
            }
        };
        __proto.active = function () {
            if (this.bitmap)
                this.bitmap.activeResource();
        };
        __proto.destroy = function (forceDispose) {
            (forceDispose === void 0) && (forceDispose = false);
            if (this.bitmap && (this.bitmap).referenceCount > 0) {
                var temp = this.bitmap;
                if (forceDispose) {
                    if (Render.isConchApp && temp.source && temp.source.conchDestroy) {
                        this.bitmap.source.conchDestroy();
                    }
                    this.bitmap = null;
                    temp.dispose();
                    (temp)._clearReference();
                }
                else {
                    (temp)._removeReference();
                    if ((temp).referenceCount == 0) {
                        if (Render.isConchApp && temp.source && temp.source.conchDestroy) {
                            this.bitmap.source.conchDestroy();
                        }
                        this.bitmap = null;
                        temp.dispose();
                    }
                }
                if (this.url && this === Laya.loader.getRes(this.url))
                    Laya.loader.clearRes(this.url, forceDispose);
                this._loaded = false;
            }
        };
        __proto.dispose = function () {
            this.destroy(true);
        };
        __proto.load = function (url) {
            var _$this = this;
            this._loaded = false;
            url = URL.customFormat(url);
            var fileBitmap = (this.bitmap || (this.bitmap = HTMLImage.create(url)));
            if (fileBitmap)
                fileBitmap._addReference();
            var _this = this;
            fileBitmap.onload = function () {
                fileBitmap.onload = null;
                _this._loaded = true;
                _$this.sourceWidth = _$this._w = fileBitmap.width;
                _$this.sourceHeight = _$this._h = fileBitmap.height;
                _this.event("loaded", this);
                (RunDriver.addToAtlas) && (RunDriver.addToAtlas(_this));
            };
        };
        __proto.addTextureToAtlas = function (e) {
            RunDriver.addTextureToAtlas(this);
        };
        __proto.getPixels = function (x, y, width, height) {
            if (Render.isConchApp) {
                var temp = this.bitmap;
                if (temp.source && temp.source.getImageData) {
                    var arraybuffer = temp.source.getImageData(x, y, width, height);
                    var tUint8Array = new Uint8Array(arraybuffer);
                    return Array.from(tUint8Array);
                }
                return null;
            }
            else if (Render.isWebGL) {
                return RunDriver.getTexturePixels(this, x, y, width, height);
            }
            else {
                Browser.canvas.size(width, height);
                Browser.canvas.clear();
                Browser.context.drawTexture(this, -x, -y, this.width, this.height, 0, 0);
                var info = Browser.context.getImageData(0, 0, width, height);
            }
            return info.data;
        };
        __proto.onAsynLoaded = function (url, bitmap) {
            if (bitmap)
                bitmap._addReference();
            this.setTo(bitmap, this.uv);
        };
        __getset(0, __proto, 'source', function () {
            if (!this.bitmap)
                return null;
            this.bitmap.activeResource();
            return this.bitmap.source;
        });
        __getset(0, __proto, 'loaded', function () {
            return this._loaded;
        });
        __getset(0, __proto, 'released', function () {
            if (!this.bitmap)
                return true;
            return this.bitmap.released;
        });
        __getset(0, __proto, 'disposed', function () {
            if (!this.bitmap)
                return true;
            return this.bitmap.released;
        });
        __getset(0, __proto, 'width', function () {
            if (this._w)
                return this._w;
            return (this.uv && this.uv !== Texture.DEF_UV) ? (this.uv[2] - this.uv[0]) * this.bitmap.width : this.bitmap.width;
        }, function (value) {
            this._w = value;
            this.sourceWidth || (this.sourceWidth = value);
        });
        __getset(0, __proto, 'repeat', function () {
            if (Render.isWebGL && this.bitmap) {
                return this.bitmap.repeat;
            }
            return true;
        }, function (value) {
            if (value) {
                if (Render.isWebGL && this.bitmap) {
                    this.bitmap.repeat = value;
                    if (value) {
                        this.bitmap.enableMerageInAtlas = false;
                    }
                }
            }
        });
        __getset(0, __proto, 'height', function () {
            if (this._h)
                return this._h;
            return (this.uv && this.uv !== Texture.DEF_UV) ? (this.uv[5] - this.uv[1]) * this.bitmap.height : this.bitmap.height;
        }, function (value) {
            this._h = value;
            this.sourceHeight || (this.sourceHeight = value);
        });
        __getset(0, __proto, 'isLinearSampling', function () {
            return Render.isWebGL ? (this.bitmap.minFifter != 0x2600) : true;
        }, function (value) {
            if (!value && Render.isWebGL) {
                if (!value && (this.bitmap.minFifter == -1) && (this.bitmap.magFifter == -1)) {
                    this.bitmap.minFifter = 0x2600;
                    this.bitmap.magFifter = 0x2600;
                    this.bitmap.enableMerageInAtlas = false;
                }
            }
        });
        Texture.moveUV = function (offsetX, offsetY, uv) {
            for (var i = 0; i < 8; i += 2) {
                uv[i] += offsetX;
                uv[i + 1] += offsetY;
            }
            return uv;
        };
        Texture.create = function (source, x, y, width, height, offsetX, offsetY, sourceWidth, sourceHeight) {
            (offsetX === void 0) && (offsetX = 0);
            (offsetY === void 0) && (offsetY = 0);
            (sourceWidth === void 0) && (sourceWidth = 0);
            (sourceHeight === void 0) && (sourceHeight = 0);
            var btex = (source instanceof laya.resource.Texture);
            var uv = btex ? source.uv : Texture.DEF_UV;
            var bitmap = btex ? source.bitmap : source;
            var bIsAtlas = RunDriver.isAtlas(bitmap);
            if (bIsAtlas) {
                var atlaser = bitmap._atlaser;
                var nAtlasID = (source)._atlasID;
                if (nAtlasID == -1) {
                    throw new Error("create texture error");
                }
                bitmap = atlaser._inAtlasTextureBitmapValue[nAtlasID];
                uv = atlaser._inAtlasTextureOriUVValue[nAtlasID];
            }
            ;
            var tex = new Texture(bitmap, null);
            if (bitmap.width && (x + width) > bitmap.width)
                width = bitmap.width - x;
            if (bitmap.height && (y + height) > bitmap.height)
                height = bitmap.height - y;
            tex.width = width;
            tex.height = height;
            tex.offsetX = offsetX;
            tex.offsetY = offsetY;
            tex.sourceWidth = sourceWidth || width;
            tex.sourceHeight = sourceHeight || height;
            var dwidth = 1 / bitmap.width;
            var dheight = 1 / bitmap.height;
            x *= dwidth;
            y *= dheight;
            width *= dwidth;
            height *= dheight;
            var u1 = tex.uv[0], v1 = tex.uv[1], u2 = tex.uv[4], v2 = tex.uv[5];
            var inAltasUVWidth = (u2 - u1), inAltasUVHeight = (v2 - v1);
            var oriUV = Texture.moveUV(uv[0], uv[1], [x, y, x + width, y, x + width, y + height, x, y + height]);
            tex.uv = [u1 + oriUV[0] * inAltasUVWidth, v1 + oriUV[1] * inAltasUVHeight, u2 - (1 - oriUV[2]) * inAltasUVWidth, v1 + oriUV[3] * inAltasUVHeight, u2 - (1 - oriUV[4]) * inAltasUVWidth, v2 - (1 - oriUV[5]) * inAltasUVHeight, u1 + oriUV[6] * inAltasUVWidth, v2 - (1 - oriUV[7]) * inAltasUVHeight];
            if (bIsAtlas) {
                tex.addTextureToAtlas();
            }
            ;
            var bitmapScale = bitmap.scaleRate;
            if (bitmapScale && bitmapScale != 1) {
                tex.sourceWidth /= bitmapScale;
                tex.sourceHeight /= bitmapScale;
                tex.width /= bitmapScale;
                tex.height /= bitmapScale;
                tex.scaleRate = bitmapScale;
                tex.offsetX /= bitmapScale;
                tex.offsetY /= bitmapScale;
            }
            else {
                tex.scaleRate = 1;
            }
            return tex;
        };
        Texture.createFromTexture = function (texture, x, y, width, height) {
            var texScaleRate = texture.scaleRate;
            if (texScaleRate != 1) {
                x *= texScaleRate;
                y *= texScaleRate;
                width *= texScaleRate;
                height *= texScaleRate;
            }
            ;
            var rect = Rectangle.TEMP.setTo(x - texture.offsetX, y - texture.offsetY, width, height);
            var result = rect.intersection(Texture._rect1.setTo(0, 0, texture.width, texture.height), Texture._rect2);
            if (result)
                var tex = Texture.create(texture, result.x, result.y, result.width, result.height, result.x - rect.x, result.y - rect.y, width, height);
            else
                return null;
            tex.bitmap._removeReference();
            return tex;
        };
        Texture.DEF_UV = [0, 0, 1.0, 0, 1.0, 1.0, 0, 1.0];
        Texture.INV_UV = [0, 1, 1.0, 1, 1.0, 0.0, 0, 0.0];
        Texture._rect1 = new Rectangle();
        Texture._rect2 = new Rectangle();
        return Texture;
    })(EventDispatcher);
    var TimeLine = (function (_super) {
        var tweenData;
        function TimeLine() {
            this._labelDic = null;
            this._tweenDic = {};
            this._tweenDataList = [];
            this._endTweenDataList = null;
            this._currTime = 0;
            this._lastTime = 0;
            this._startTime = 0;
            this._index = 0;
            this._gidIndex = 0;
            this._firstTweenDic = {};
            this._startTimeSort = false;
            this._endTimeSort = false;
            this._loopKey = false;
            this.scale = 1;
            this._frameRate = 60;
            this._frameIndex = 0;
            this._total = 0;
            TimeLine.__super.call(this);
        }
        __class(TimeLine, 'laya.utils.TimeLine', _super);
        var __proto = TimeLine.prototype;
        __proto.to = function (target, props, duration, ease, offset) {
            (offset === void 0) && (offset = 0);
            return this._create(target, props, duration, ease, offset, true);
        };
        __proto.from = function (target, props, duration, ease, offset) {
            (offset === void 0) && (offset = 0);
            return this._create(target, props, duration, ease, offset, false);
        };
        __proto._create = function (target, props, duration, ease, offset, isTo) {
            var tTweenData = Pool.getItemByClass("tweenData", tweenData);
            tTweenData.isTo = isTo;
            tTweenData.type = 0;
            tTweenData.target = target;
            tTweenData.duration = duration;
            tTweenData.data = props;
            tTweenData.startTime = this._startTime + offset;
            tTweenData.endTime = tTweenData.startTime + tTweenData.duration;
            tTweenData.ease = ease;
            this._startTime = Math.max(tTweenData.endTime, this._startTime);
            this._tweenDataList.push(tTweenData);
            this._startTimeSort = true;
            this._endTimeSort = true;
            return this;
        };
        __proto.addLabel = function (label, offset) {
            var tTweenData = Pool.getItemByClass("tweenData", tweenData);
            tTweenData.type = 1;
            tTweenData.data = label;
            tTweenData.endTime = tTweenData.startTime = this._startTime + offset;
            this._labelDic || (this._labelDic = {});
            this._labelDic[label] = tTweenData;
            this._tweenDataList.push(tTweenData);
            return this;
        };
        __proto.removeLabel = function (label) {
            if (this._labelDic && this._labelDic[label]) {
                var tTweenData = this._labelDic[label];
                if (tTweenData) {
                    var tIndex = this._tweenDataList.indexOf(tTweenData);
                    if (tIndex > -1) {
                        this._tweenDataList.splice(tIndex, 1);
                    }
                }
                delete this._labelDic[label];
            }
        };
        __proto.gotoTime = function (time) {
            if (this._tweenDataList == null || this._tweenDataList.length == 0)
                return;
            var tTween;
            var tObject;
            for (var p in this._firstTweenDic) {
                tObject = this._firstTweenDic[p];
                if (tObject) {
                    for (var tDataP in tObject) {
                        if (tObject.diyTarget.hasOwnProperty(tDataP)) {
                            tObject.diyTarget[tDataP] = tObject[tDataP];
                        }
                    }
                }
            }
            for (p in this._tweenDic) {
                tTween = this._tweenDic[p];
                tTween.clear();
                delete this._tweenDic[p];
            }
            this._index = 0;
            this._gidIndex = 0;
            this._currTime = time;
            this._lastTime = Browser.now();
            var tTweenDataCopyList;
            if (this._endTweenDataList == null || this._endTimeSort) {
                this._endTimeSort = false;
                this._endTweenDataList = tTweenDataCopyList = this._tweenDataList.concat();
                function Compare(paraA, paraB) {
                    if (paraA.endTime > paraB.endTime) {
                        return 1;
                    }
                    else if (paraA.endTime < paraB.endTime) {
                        return -1;
                    }
                    else {
                        return 0;
                    }
                }
                tTweenDataCopyList.sort(Compare);
            }
            else {
                tTweenDataCopyList = this._endTweenDataList;
            }
            ;
            var tTweenData;
            for (var i = 0, n = tTweenDataCopyList.length; i < n; i++) {
                tTweenData = tTweenDataCopyList[i];
                if (tTweenData.type == 0) {
                    if (time >= tTweenData.endTime) {
                        this._index = Math.max(this._index, i + 1);
                        var props = tTweenData.data;
                        if (tTweenData.isTo) {
                            for (var tP in props) {
                                tTweenData.target[tP] = props[tP];
                            }
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            for (i = 0, n = this._tweenDataList.length; i < n; i++) {
                tTweenData = this._tweenDataList[i];
                if (tTweenData.type == 0) {
                    if (time >= tTweenData.startTime && time < tTweenData.endTime) {
                        this._index = Math.max(this._index, i + 1);
                        this._gidIndex++;
                        tTween = Pool.getItemByClass("tween", Tween);
                        tTween._create(tTweenData.target, tTweenData.data, tTweenData.duration, tTweenData.ease, Handler.create(this, this._animComplete, [this._gidIndex]), 0, false, tTweenData.isTo, true, false);
                        tTween.setStartTime(this._currTime - (time - tTweenData.startTime));
                        tTween._updateEase(this._currTime);
                        tTween.gid = this._gidIndex;
                        this._tweenDic[this._gidIndex] = tTween;
                    }
                }
            }
        };
        __proto.gotoLabel = function (Label) {
            if (this._labelDic == null)
                return;
            var tLabelData = this._labelDic[Label];
            if (tLabelData)
                this.gotoTime(tLabelData.startTime);
        };
        __proto.pause = function () {
            Laya.timer.clear(this, this._update);
        };
        __proto.resume = function () {
            this.play(this._currTime, this._loopKey);
        };
        __proto.play = function (timeOrLabel, loop) {
            (timeOrLabel === void 0) && (timeOrLabel = 0);
            (loop === void 0) && (loop = false);
            if (!this._tweenDataList)
                return;
            if (this._startTimeSort) {
                this._startTimeSort = false;
                function Compare(paraA, paraB) {
                    if (paraA.startTime > paraB.startTime) {
                        return 1;
                    }
                    else if (paraA.startTime < paraB.startTime) {
                        return -1;
                    }
                    else {
                        return 0;
                    }
                }
                this._tweenDataList.sort(Compare);
                for (var i = 0, n = this._tweenDataList.length; i < n; i++) {
                    var tTweenData = this._tweenDataList[i];
                    if (tTweenData != null && tTweenData.type == 0) {
                        var tTarget = tTweenData.target;
                        var gid = (tTarget.$_GID || (tTarget.$_GID = Utils.getGID()));
                        var tSrcData = null;
                        if (this._firstTweenDic[gid] == null) {
                            tSrcData = {};
                            tSrcData.diyTarget = tTarget;
                            this._firstTweenDic[gid] = tSrcData;
                        }
                        else {
                            tSrcData = this._firstTweenDic[gid];
                        }
                        for (var p in tTweenData.data) {
                            if (tSrcData[p] == null) {
                                tSrcData[p] = tTarget[p];
                            }
                        }
                    }
                }
            }
            if ((typeof timeOrLabel == 'string')) {
                this.gotoLabel(timeOrLabel);
            }
            else {
                this.gotoTime(timeOrLabel);
            }
            this._loopKey = loop;
            this._lastTime = Browser.now();
            Laya.timer.frameLoop(1, this, this._update);
        };
        __proto._update = function () {
            if (this._currTime >= this._startTime) {
                if (this._loopKey) {
                    this._complete();
                    if (!this._tweenDataList)
                        return;
                    this.gotoTime(0);
                }
                else {
                    for (var p in this._tweenDic) {
                        tTween = this._tweenDic[p];
                        tTween.complete();
                    }
                    this._complete();
                    this.pause();
                    return;
                }
            }
            ;
            var tNow = Browser.now();
            var tFrameTime = tNow - this._lastTime;
            var tCurrTime = this._currTime += tFrameTime * this.scale;
            this._lastTime = tNow;
            for (p in this._tweenDic) {
                tTween = this._tweenDic[p];
                tTween._updateEase(tCurrTime);
            }
            ;
            var tTween;
            if (this._tweenDataList.length != 0 && this._index < this._tweenDataList.length) {
                var tTweenData = this._tweenDataList[this._index];
                if (tCurrTime >= tTweenData.startTime) {
                    this._index++;
                    if (tTweenData.type == 0) {
                        this._gidIndex++;
                        tTween = Pool.getItemByClass("tween", Tween);
                        tTween._create(tTweenData.target, tTweenData.data, tTweenData.duration, tTweenData.ease, Handler.create(this, this._animComplete, [this._gidIndex]), 0, false, tTweenData.isTo, true, false);
                        tTween.setStartTime(tCurrTime);
                        tTween.gid = this._gidIndex;
                        this._tweenDic[this._gidIndex] = tTween;
                        tTween._updateEase(tCurrTime);
                    }
                    else {
                        this.event("label", tTweenData.data);
                    }
                }
            }
        };
        __proto._animComplete = function (index) {
            var tTween = this._tweenDic[index];
            if (tTween)
                delete this._tweenDic[index];
        };
        __proto._complete = function () {
            this.event("complete");
        };
        __proto.reset = function () {
            var p;
            if (this._labelDic) {
                for (p in this._labelDic) {
                    delete this._labelDic[p];
                }
            }
            ;
            var tTween;
            for (p in this._tweenDic) {
                tTween = this._tweenDic[p];
                tTween.clear();
                delete this._tweenDic[p];
            }
            for (p in this._firstTweenDic) {
                delete this._firstTweenDic[p];
            }
            this._endTweenDataList = null;
            if (this._tweenDataList && this._tweenDataList.length) {
                var i = 0, len = 0;
                len = this._tweenDataList.length;
                for (i = 0; i < len; i++) {
                    if (this._tweenDataList[i])
                        this._tweenDataList[i].destroy();
                }
            }
            this._tweenDataList.length = 0;
            this._currTime = 0;
            this._lastTime = 0;
            this._startTime = 0;
            this._index = 0;
            this._gidIndex = 0;
            this.scale = 1;
            Laya.timer.clear(this, this._update);
        };
        __proto.destroy = function () {
            this.reset();
            this._labelDic = null;
            this._tweenDic = null;
            this._tweenDataList = null;
            this._firstTweenDic = null;
        };
        __getset(0, __proto, 'index', function () {
            return this._frameIndex;
        }, function (value) {
            this._frameIndex = value;
            this.gotoTime(this._frameIndex / this._frameRate * 1000);
        });
        __getset(0, __proto, 'total', function () {
            this._total = Math.floor(this._startTime / 1000 * this._frameRate);
            return this._total;
        });
        TimeLine.to = function (target, props, duration, ease, offset) {
            (offset === void 0) && (offset = 0);
            return (new TimeLine()).to(target, props, duration, ease, offset);
        };
        TimeLine.from = function (target, props, duration, ease, offset) {
            (offset === void 0) && (offset = 0);
            return (new TimeLine()).from(target, props, duration, ease, offset);
        };
        TimeLine.__init$ = function () {
            tweenData = (function () {
                function tweenData() {
                    this.type = 0;
                    this.isTo = true;
                    this.startTime = NaN;
                    this.endTime = NaN;
                    this.target = null;
                    this.duration = NaN;
                    this.ease = null;
                    this.data = null;
                }
                __class(tweenData, '');
                var __proto = tweenData.prototype;
                __proto.destroy = function () {
                    this.target = null;
                    this.ease = null;
                    this.data = null;
                    this.isTo = true;
                    this.type = 0;
                    Pool.recover("tweenData", this);
                };
                return tweenData;
            })();
        };
        return TimeLine;
    })(EventDispatcher);
    var Sprite = (function (_super) {
        function Sprite() {
            this._transform = null;
            this._tfChanged = false;
            this._x = 0;
            this._y = 0;
            this._width = 0;
            this._height = 0;
            this._repaint = 1;
            this._mouseEnableState = 0;
            this._zOrder = 0;
            this._graphics = null;
            this._renderType = 0;
            this._optimizeScrollRect = false;
            this._texture = null;
            this.mouseThrough = false;
            this.autoSize = false;
            this.hitTestPrior = false;
            this.viewport = null;
            Sprite.__super.call(this);
            this._style = Style.EMPTY;
        }
        __class(Sprite, 'laya.display.Sprite', _super);
        var __proto = Sprite.prototype;
        Laya.imps(__proto, { "laya.display.ILayout": true });
        __proto.createConchModel = function () {
            return new ConchNode();
        };
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            this._releaseMem();
            _super.prototype.destroy.call(this, destroyChild);
            this._style && this._style.destroy();
            this._transform && this._transform.destroy();
            this._transform = null;
            this._style = null;
            this._graphics = null;
        };
        __proto.updateZOrder = function () {
            Utils.updateOrder(this._childs) && this.repaint();
        };
        __proto.reCache = function () {
            if (this._$P.cacheCanvas)
                this._$P.cacheCanvas.reCache = true;
            this._repaint = 1;
        };
        __proto.setBounds = function (bound) {
            this._set$P("uBounds", bound);
        };
        __proto.getBounds = function () {
            if (!this._$P.mBounds)
                this._set$P("mBounds", new Rectangle());
            return Rectangle._getWrapRec(this._boundPointsToParent(), this._$P.mBounds);
        };
        __proto.getSelfBounds = function () {
            if (this._$P.uBounds)
                return this._$P.uBounds;
            if (!this._$P.mBounds)
                this._set$P("mBounds", new Rectangle());
            return Rectangle._getWrapRec(this._getBoundPointsM(false), this._$P.mBounds);
        };
        __proto._boundPointsToParent = function (ifRotate) {
            (ifRotate === void 0) && (ifRotate = false);
            var pX = 0, pY = 0;
            if (this._style) {
                pX = this._style._tf.translateX;
                pY = this._style._tf.translateY;
                ifRotate = ifRotate || (this._style._tf.rotate !== 0);
                if (this._style.scrollRect) {
                    pX += this._style.scrollRect.x;
                    pY += this._style.scrollRect.y;
                }
            }
            ;
            var pList = this._getBoundPointsM(ifRotate);
            if (!pList || pList.length < 1)
                return pList;
            if (pList.length != 8) {
                pList = ifRotate ? GrahamScan.scanPList(pList) : Rectangle._getWrapRec(pList, Rectangle.TEMP)._getBoundPoints();
            }
            if (!this.transform) {
                Utils.transPointList(pList, this._x - pX, this._y - pY);
                return pList;
            }
            ;
            var tPoint = Point.TEMP;
            var i = 0, len = pList.length;
            for (i = 0; i < len; i += 2) {
                tPoint.x = pList[i];
                tPoint.y = pList[i + 1];
                this.toParentPoint(tPoint);
                pList[i] = tPoint.x;
                pList[i + 1] = tPoint.y;
            }
            return pList;
        };
        __proto.getGraphicBounds = function (realSize) {
            (realSize === void 0) && (realSize = false);
            if (!this._graphics)
                return Rectangle.TEMP.setTo(0, 0, 0, 0);
            return this._graphics.getBounds(realSize);
        };
        __proto._getBoundPointsM = function (ifRotate) {
            (ifRotate === void 0) && (ifRotate = false);
            if (this._$P.uBounds)
                return this._$P.uBounds._getBoundPoints();
            if (!this._$P.temBM)
                this._set$P("temBM", []);
            if (this.scrollRect) {
                var rst = Utils.clearArray(this._$P.temBM);
                var rec = Rectangle.TEMP;
                rec.copyFrom(this.scrollRect);
                Utils.concatArray(rst, rec._getBoundPoints());
                return rst;
            }
            ;
            var pList = this._graphics ? this._graphics.getBoundPoints() : Utils.clearArray(this._$P.temBM);
            var child;
            var cList;
            var __childs;
            __childs = this._childs;
            for (var i = 0, n = __childs.length; i < n; i++) {
                child = __childs[i];
                if ((child instanceof laya.display.Sprite) && child.visible == true) {
                    cList = child._boundPointsToParent(ifRotate);
                    if (cList)
                        pList = pList ? Utils.concatArray(pList, cList) : cList;
                }
            }
            return pList;
        };
        __proto.getStyle = function () {
            this._style === Style.EMPTY && (this._style = new Style());
            return this._style;
        };
        __proto.setStyle = function (value) {
            this._style = value;
        };
        __proto._adjustTransform = function () {
            'use strict';
            this._tfChanged = false;
            var style = this._style;
            var tf = style._tf;
            var sx = tf.scaleX, sy = tf.scaleY;
            var m;
            if (tf.rotate || sx !== 1 || sy !== 1 || tf.skewX || tf.skewY) {
                m = this._transform || (this._transform = Matrix.create());
                m.bTransform = true;
                var skx = (tf.rotate - tf.skewX) * 0.0174532922222222;
                var sky = (tf.rotate + tf.skewY) * 0.0174532922222222;
                var cx = Math.cos(sky);
                var ssx = Math.sin(sky);
                var cy = Math.sin(skx);
                var ssy = Math.cos(skx);
                m.a = sx * cx;
                m.b = sx * ssx;
                m.c = -sy * cy;
                m.d = sy * ssy;
                m.tx = m.ty = 0;
                return m;
            }
            else {
                this._transform && this._transform.destroy();
                this._transform = null;
                this._renderType &= ~0x04;
            }
            return m;
        };
        __proto.pos = function (x, y, speedMode) {
            (speedMode === void 0) && (speedMode = false);
            if (this._x !== x || this._y !== y) {
                if (this.destroyed)
                    return this;
                if (speedMode) {
                    this._x = x;
                    this._y = y;
                    this.conchModel && this.conchModel.pos(this._x, this._y);
                    var p = this._parent;
                    if (p && p._repaint === 0) {
                        p._repaint = 1;
                        p.parentRepaint();
                    }
                    if (this._$P.maskParent && this._$P.maskParent._repaint === 0) {
                        this._$P.maskParent._repaint = 1;
                        this._$P.maskParent.parentRepaint();
                    }
                }
                else {
                    this.x = x;
                    this.y = y;
                }
            }
            return this;
        };
        __proto.pivot = function (x, y) {
            this.pivotX = x;
            this.pivotY = y;
            return this;
        };
        __proto.size = function (width, height) {
            this.width = width;
            this.height = height;
            return this;
        };
        __proto.scale = function (scaleX, scaleY, speedMode) {
            (speedMode === void 0) && (speedMode = false);
            var style = this.getStyle();
            var _tf = style._tf;
            if (_tf.scaleX != scaleX || _tf.scaleY != scaleY) {
                if (this.destroyed)
                    return this;
                if (speedMode) {
                    style.setScale(scaleX, scaleY);
                    this._tfChanged = true;
                    this.conchModel && this.conchModel.scale(scaleX, scaleY);
                    this._renderType |= 0x04;
                    var p = this._parent;
                    if (p && p._repaint === 0) {
                        p._repaint = 1;
                        p.parentRepaint();
                    }
                }
                else {
                    this.scaleX = scaleX;
                    this.scaleY = scaleY;
                }
            }
            return this;
        };
        __proto.skew = function (skewX, skewY) {
            this.skewX = skewX;
            this.skewY = skewY;
            return this;
        };
        __proto.render = function (context, x, y) {
            Stat.spriteCount++;
            RenderSprite.renders[this._renderType]._fun(this, context, x + this._x, y + this._y);
            this._repaint = 0;
        };
        __proto.drawToCanvas = function (canvasWidth, canvasHeight, offsetX, offsetY) {
            if (Render.isConchNode) {
                var canvas = HTMLCanvas.create("2D");
                var context = new RenderContext(canvasWidth, canvasHeight, canvas);
                context.ctx.setCanvasType(1);
                this.conchModel.drawToCanvas(canvas.source, offsetX, offsetY);
                return canvas;
            }
            else {
                return RunDriver.drawToCanvas(this, this._renderType, canvasWidth, canvasHeight, offsetX, offsetY);
            }
        };
        __proto.customRender = function (context, x, y) {
            this._renderType |= 0x400;
        };
        __proto._applyFilters = function () {
            if (Render.isWebGL)
                return;
            var _filters;
            _filters = this._$P.filters;
            if (!_filters || _filters.length < 1)
                return;
            for (var i = 0, n = _filters.length; i < n; i++) {
                _filters[i].action.apply(this._$P.cacheCanvas);
            }
        };
        __proto._isHaveGlowFilter = function () {
            var i = 0, len = 0;
            if (this.filters) {
                for (i = 0; i < this.filters.length; i++) {
                    if (this.filters[i].type == 0x08) {
                        return true;
                    }
                }
            }
            for (i = 0, len = this._childs.length; i < len; i++) {
                if (this._childs[i]._isHaveGlowFilter()) {
                    return true;
                }
            }
            return false;
        };
        __proto.localToGlobal = function (point, createNewPoint) {
            (createNewPoint === void 0) && (createNewPoint = true);
            if (createNewPoint === true) {
                point = new Point(point.x, point.y);
            }
            ;
            var ele = this;
            while (ele) {
                if (ele == Laya.stage)
                    break;
                point = ele.toParentPoint(point);
                ele = ele.parent;
            }
            return point;
        };
        __proto.globalToLocal = function (point, createNewPoint) {
            (createNewPoint === void 0) && (createNewPoint = false);
            if (createNewPoint) {
                point = new Point(point.x, point.y);
            }
            ;
            var ele = this;
            var list = [];
            while (ele) {
                if (ele == Laya.stage)
                    break;
                list.push(ele);
                ele = ele.parent;
            }
            ;
            var i = list.length - 1;
            while (i >= 0) {
                ele = list[i];
                point = ele.fromParentPoint(point);
                i--;
            }
            return point;
        };
        __proto.toParentPoint = function (point) {
            if (!point)
                return point;
            point.x -= this.pivotX;
            point.y -= this.pivotY;
            if (this.transform) {
                this._transform.transformPoint(point);
            }
            point.x += this._x;
            point.y += this._y;
            var scroll = this._style.scrollRect;
            if (scroll) {
                point.x -= scroll.x;
                point.y -= scroll.y;
            }
            return point;
        };
        __proto.fromParentPoint = function (point) {
            if (!point)
                return point;
            point.x -= this._x;
            point.y -= this._y;
            var scroll = this._style.scrollRect;
            if (scroll) {
                point.x += scroll.x;
                point.y += scroll.y;
            }
            if (this.transform) {
                this._transform.invertTransformPoint(point);
            }
            point.x += this.pivotX;
            point.y += this.pivotY;
            return point;
        };
        __proto.on = function (type, caller, listener, args) {
            if (this._mouseEnableState !== 1 && this.isMouseEvent(type)) {
                this.mouseEnabled = true;
                this._setBit(0x2, true);
                if (this._parent) {
                    this._$2__onDisplay();
                }
                return this._createListener(type, caller, listener, args, false);
            }
            return _super.prototype.on.call(this, type, caller, listener, args);
        };
        __proto.once = function (type, caller, listener, args) {
            if (this._mouseEnableState !== 1 && this.isMouseEvent(type)) {
                this.mouseEnabled = true;
                this._setBit(0x2, true);
                if (this._parent) {
                    this._$2__onDisplay();
                }
                return this._createListener(type, caller, listener, args, true);
            }
            return _super.prototype.once.call(this, type, caller, listener, args);
        };
        __proto._$2__onDisplay = function () {
            if (this._mouseEnableState !== 1) {
                var ele = this;
                ele = ele.parent;
                while (ele && ele._mouseEnableState !== 1) {
                    if (ele._getBit(0x2))
                        break;
                    ele.mouseEnabled = true;
                    ele._setBit(0x2, true);
                    ele = ele.parent;
                }
            }
        };
        __proto.loadImage = function (url, x, y, width, height, complete) {
            var _$this = this;
            (x === void 0) && (x = 0);
            (y === void 0) && (y = 0);
            (width === void 0) && (width = 0);
            (height === void 0) && (height = 0);
            function loaded(tex) {
                if (!_$this.destroyed) {
                    _$this.size(x + (width || tex.width), y + (height || tex.height));
                    _$this.repaint();
                    complete && complete.runWith(tex);
                }
            }
            this.graphics.loadImage(url, x, y, width, height, loaded);
            return this;
        };
        __proto.repaint = function () {
            this.conchModel && this.conchModel.repaint && this.conchModel.repaint();
            if (this._repaint === 0) {
                this._repaint = 1;
                this.parentRepaint();
            }
            if (this._$P && this._$P.maskParent) {
                this._$P.maskParent.repaint();
            }
        };
        __proto._needRepaint = function () {
            return (this._repaint !== 0) && this._$P.cacheCanvas && this._$P.cacheCanvas.reCache;
        };
        __proto._childChanged = function (child) {
            if (this._childs.length)
                this._renderType |= 0x800;
            else
                this._renderType &= ~0x800;
            if (child && this._get$P("hasZorder"))
                Laya.timer.callLater(this, this.updateZOrder);
            this.repaint();
        };
        __proto.parentRepaint = function () {
            var p = this._parent;
            if (p && p._repaint === 0) {
                p._repaint = 1;
                p.parentRepaint();
            }
        };
        __proto.startDrag = function (area, hasInertia, elasticDistance, elasticBackTime, data, disableMouseEvent, ratio) {
            (hasInertia === void 0) && (hasInertia = false);
            (elasticDistance === void 0) && (elasticDistance = 0);
            (elasticBackTime === void 0) && (elasticBackTime = 300);
            (disableMouseEvent === void 0) && (disableMouseEvent = false);
            (ratio === void 0) && (ratio = 0.92);
            this._$P.dragging || (this._set$P("dragging", new Dragging()));
            this._$P.dragging.start(this, area, hasInertia, elasticDistance, elasticBackTime, data, disableMouseEvent, ratio);
        };
        __proto.stopDrag = function () {
            this._$P.dragging && this._$P.dragging.stop();
        };
        __proto._releaseMem = function () {
            if (!this._$P)
                return;
            var cc = this._$P.cacheCanvas;
            if (cc && cc.ctx) {
                Pool.recover("RenderContext", cc.ctx);
                cc.ctx.canvas.size(0, 0);
                cc.ctx = null;
            }
            ;
            var fc = this._$P._filterCache;
            if (fc) {
                fc.destroy();
                fc.recycle();
                this._set$P('_filterCache', null);
            }
            this._$P._isHaveGlowFilter && this._set$P('_isHaveGlowFilter', false);
            this._$P._isHaveGlowFilter = null;
        };
        __proto._setDisplay = function (value) {
            if (!value)
                this._releaseMem();
            _super.prototype._setDisplay.call(this, value);
        };
        __proto.hitTestPoint = function (x, y) {
            var point = this.globalToLocal(Point.TEMP.setTo(x, y));
            x = point.x;
            y = point.y;
            var rect = this._$P.hitArea ? this._$P.hitArea : (this._width > 0 && this._height > 0) ? Rectangle.TEMP.setTo(0, 0, this._width, this._height) : this.getSelfBounds();
            return rect.contains(x, y);
        };
        __proto.getMousePoint = function () {
            return this.globalToLocal(Point.TEMP.setTo(Laya.stage.mouseX, Laya.stage.mouseY));
        };
        __proto._getWords = function () {
            return null;
        };
        __proto._addChildsToLayout = function (out) {
            var words = this._getWords();
            if (words == null && this._childs.length == 0)
                return false;
            if (words) {
                for (var i = 0, n = words.length; i < n; i++) {
                    out.push(words[i]);
                }
            }
            this._childs.forEach(function (o, index, array) {
                o._style._enableLayout() && o._addToLayout(out);
            });
            return true;
        };
        __proto._addToLayout = function (out) {
            if (this._style.absolute)
                return;
            this._style.block ? out.push(this) : (this._addChildsToLayout(out) && (this.x = this.y = 0));
        };
        __proto._isChar = function () {
            return false;
        };
        __proto._getCSSStyle = function () {
            return this._style.getCSSStyle();
        };
        __proto._setAttributes = function (name, value) {
            switch (name) {
                case 'x':
                    this.x = parseFloat(value);
                    break;
                case 'y':
                    this.y = parseFloat(value);
                    break;
                case 'width':
                    this.width = parseFloat(value);
                    break;
                case 'height':
                    this.height = parseFloat(value);
                    break;
                default:
                    this[name] = value;
            }
        };
        __proto._layoutLater = function () {
            this.parent && (this.parent)._layoutLater();
        };
        __getset(0, __proto, 'optimizeScrollRect', function () {
            return this._optimizeScrollRect;
        }, function (b) {
            if (this._optimizeScrollRect != b) {
                this._optimizeScrollRect = b;
                this.conchModel && this.conchModel.optimizeScrollRect(b);
            }
        });
        __getset(0, __proto, 'customRenderEnable', null, function (b) {
            if (b) {
                this._renderType |= 0x400;
                if (Render.isConchNode) {
                    Sprite.CustomList.push(this);
                    var canvas = new HTMLCanvas("2d");
                    canvas._setContext(new CanvasRenderingContext2D());
                    this.customContext = new RenderContext(0, 0, canvas);
                    canvas.context.setCanvasType && canvas.context.setCanvasType(2);
                    this.conchModel.custom(canvas.context);
                }
            }
        });
        __getset(0, __proto, 'cacheAsBitmap', function () {
            return this.cacheAs !== "none";
        }, function (value) {
            this.cacheAs = value ? (this._$P["hasFilter"] ? "none" : "normal") : "none";
        });
        __getset(0, __proto, 'cacheAs', function () {
            return this._$P.cacheCanvas == null ? "none" : this._$P.cacheCanvas.type;
        }, function (value) {
            var cacheCanvas = this._$P.cacheCanvas;
            if (value === (cacheCanvas ? cacheCanvas.type : "none"))
                return;
            if (value !== "none") {
                if (!this._getBit(0x1))
                    this._setUpNoticeType(0x1);
                cacheCanvas || (cacheCanvas = this._set$P("cacheCanvas", Pool.getItemByClass("cacheCanvas", Object)));
                cacheCanvas.type = value;
                cacheCanvas.reCache = true;
                this._renderType |= 0x10;
                if (value == "bitmap")
                    this.conchModel && this.conchModel.cacheAs(1);
                this._set$P("cacheForFilters", false);
            }
            else {
                if (this._$P["hasFilter"]) {
                    this._set$P("cacheForFilters", true);
                }
                else {
                    if (cacheCanvas) {
                        var cc = cacheCanvas;
                        if (cc && cc.ctx) {
                            Pool.recover("RenderContext", cc.ctx);
                            cc.ctx.canvas.size(0, 0);
                            cc.ctx = null;
                        }
                        Pool.recover("cacheCanvas", cacheCanvas);
                    }
                    this._$P.cacheCanvas = null;
                    this._renderType &= ~0x10;
                    this.conchModel && this.conchModel.cacheAs(0);
                }
            }
            this.repaint();
        });
        __getset(0, __proto, 'zOrder', function () {
            return this._zOrder;
        }, function (value) {
            if (this._zOrder != value) {
                this._zOrder = value;
                this.conchModel && this.conchModel.setZOrder && this.conchModel.setZOrder(value);
                if (this._parent) {
                    value && this._parent._set$P("hasZorder", true);
                    Laya.timer.callLater(this._parent, this.updateZOrder);
                }
            }
        });
        __getset(0, __proto, 'rotation', function () {
            return this._style._tf.rotate;
        }, function (value) {
            var style = this.getStyle();
            if (style && style._tf.rotate !== value) {
                style.setRotate(value);
                this._tfChanged = true;
                this.conchModel && this.conchModel.rotate(value);
                this._renderType |= 0x04;
                var p = this._parent;
                if (p && p._repaint === 0) {
                    p._repaint = 1;
                    p.parentRepaint();
                }
            }
        });
        __getset(0, __proto, 'width', function () {
            if (!this.autoSize)
                return this._width;
            return this.getSelfBounds().width;
        }, function (value) {
            if (this._width !== value) {
                this._width = value;
                this.conchModel && this.conchModel.size(value, this._height);
                this.repaint();
            }
        });
        __getset(0, __proto, 'x', function () {
            return this._x;
        }, function (value) {
            if (this._x !== value) {
                if (this.destroyed)
                    return;
                this._x = value;
                this.conchModel && this.conchModel.pos(value, this._y);
                var p = this._parent;
                if (p && p._repaint === 0) {
                    p._repaint = 1;
                    p.parentRepaint();
                }
                if (this._$P.maskParent && this._$P.maskParent._repaint === 0) {
                    this._$P.maskParent._repaint = 1;
                    this._$P.maskParent.parentRepaint();
                }
            }
        });
        __getset(0, __proto, 'globalScaleY', function () {
            var scale = 1;
            var ele = this;
            while (ele) {
                if (ele === Laya.stage)
                    break;
                scale *= ele.scaleY;
                ele = ele.parent;
            }
            return scale;
        });
        __getset(0, __proto, 'hitArea', function () {
            return this._$P.hitArea;
        }, function (value) {
            this._set$P("hitArea", value);
        });
        __getset(0, __proto, 'staticCache', function () {
            return this._$P.staticCache;
        }, function (value) {
            this._set$P("staticCache", value);
            if (!value)
                this.reCache();
        });
        __getset(0, __proto, 'texture', function () {
            return this._texture;
        }, function (value) {
            if (this._texture != value) {
                this._texture = value;
                this.graphics.cleanByTexture(value, 0, 0);
            }
        });
        __getset(0, __proto, 'y', function () {
            return this._y;
        }, function (value) {
            if (this._y !== value) {
                if (this.destroyed)
                    return;
                this._y = value;
                this.conchModel && this.conchModel.pos(this._x, value);
                var p = this._parent;
                if (p && p._repaint === 0) {
                    p._repaint = 1;
                    p.parentRepaint();
                }
                if (this._$P.maskParent && this._$P.maskParent._repaint === 0) {
                    this._$P.maskParent._repaint = 1;
                    this._$P.maskParent.parentRepaint();
                }
            }
        });
        __getset(0, __proto, 'height', function () {
            if (!this.autoSize)
                return this._height;
            return this.getSelfBounds().height;
        }, function (value) {
            if (this._height !== value) {
                this._height = value;
                this.conchModel && this.conchModel.size(this._width, value);
                this.repaint();
            }
        });
        __getset(0, __proto, 'blendMode', function () {
            return this._style.blendMode;
        }, function (value) {
            this.getStyle().blendMode = value;
            this.conchModel && this.conchModel.blendMode(value);
            if (value && value != "source-over")
                this._renderType |= 0x08;
            else
                this._renderType &= ~0x08;
            this.parentRepaint();
        });
        __getset(0, __proto, 'scaleX', function () {
            return this._style._tf.scaleX;
        }, function (value) {
            var style = this.getStyle();
            if (style && style._tf.scaleX !== value) {
                style.setScaleX(value);
                this._tfChanged = true;
                this.conchModel && this.conchModel.scale(value, style._tf.scaleY);
                this._renderType |= 0x04;
                var p = this._parent;
                if (p && p._repaint === 0) {
                    p._repaint = 1;
                    p.parentRepaint();
                }
            }
        });
        __getset(0, __proto, 'scaleY', function () {
            return this._style._tf.scaleY;
        }, function (value) {
            var style = this.getStyle();
            if (style && style._tf.scaleY !== value) {
                style.setScaleY(value);
                this._tfChanged = true;
                this.conchModel && this.conchModel.scale(style._tf.scaleX, value);
                this._renderType |= 0x04;
                var p = this._parent;
                if (p && p._repaint === 0) {
                    p._repaint = 1;
                    p.parentRepaint();
                }
            }
        });
        __getset(0, __proto, 'stage', function () {
            return this.displayedInStage ? Laya.stage : null;
        });
        __getset(0, __proto, 'skewX', function () {
            return this._style._tf.skewX;
        }, function (value) {
            var style = this.getStyle();
            if (style._tf.skewX !== value) {
                style.setSkewX(value);
                this._tfChanged = true;
                this.conchModel && this.conchModel.skew(value, style._tf.skewY);
                this._renderType |= 0x04;
                var p = this._parent;
                if (p && p._repaint === 0) {
                    p._repaint = 1;
                    p.parentRepaint();
                }
            }
        });
        __getset(0, __proto, 'scrollRect', function () {
            return this._style.scrollRect;
        }, function (value) {
            this.getStyle().scrollRect = value;
            this.repaint();
            if (value) {
                this._renderType |= 0x80;
                this.conchModel && this.conchModel.scrollRect(value.x, value.y, value.width, value.height);
            }
            else {
                this._renderType &= ~0x80;
                if (this.conchModel) {
                    if (Sprite.RUNTIMEVERION < "0.9.1")
                        this.conchModel.removeType(0x40);
                    else
                        this.conchModel.removeType(0x80);
                }
            }
        });
        __getset(0, __proto, 'skewY', function () {
            return this._style._tf.skewY;
        }, function (value) {
            var style = this.getStyle();
            if (style._tf.skewY !== value) {
                style.setSkewY(value);
                this._tfChanged = true;
                this.conchModel && this.conchModel.skew(style._tf.skewX, value);
                this._renderType |= 0x04;
                var p = this._parent;
                if (p && p._repaint === 0) {
                    p._repaint = 1;
                    p.parentRepaint();
                }
            }
        });
        __getset(0, __proto, 'transform', function () {
            return this._tfChanged ? this._adjustTransform() : this._transform;
        }, function (value) {
            this._tfChanged = false;
            this._transform = value;
            if (value) {
                this._x = value.tx;
                this._y = value.ty;
                value.tx = value.ty = 0;
                this.conchModel && this.conchModel.transform(value.a, value.b, value.c, value.d, this._x, this._y);
            }
            if (value)
                this._renderType |= 0x04;
            else {
                this._renderType &= ~0x04;
                this.conchModel && this.conchModel.removeType(0x04);
            }
            this.parentRepaint();
        });
        __getset(0, __proto, 'pivotX', function () {
            return this._style._tf.translateX;
        }, function (value) {
            this.getStyle().setTranslateX(value);
            this.conchModel && this.conchModel.pivot(value, this._style._tf.translateY);
            this.repaint();
        });
        __getset(0, __proto, 'pivotY', function () {
            return this._style._tf.translateY;
        }, function (value) {
            this.getStyle().setTranslateY(value);
            this.conchModel && this.conchModel.pivot(this._style._tf.translateX, value);
            this.repaint();
        });
        __getset(0, __proto, 'alpha', function () {
            return this._style.alpha;
        }, function (value) {
            if (this._style && this._style.alpha !== value) {
                value = value < 0 ? 0 : (value > 1 ? 1 : value);
                this.getStyle().alpha = value;
                this.conchModel && this.conchModel.alpha(value);
                if (value !== 1)
                    this._renderType |= 0x02;
                else
                    this._renderType &= ~0x02;
                this.parentRepaint();
            }
        });
        __getset(0, __proto, 'visible', function () {
            return this._style.visible;
        }, function (value) {
            if (this._style && this._style.visible !== value) {
                this.getStyle().visible = value;
                this.conchModel && this.conchModel.visible(value);
                this.parentRepaint();
            }
        });
        __getset(0, __proto, 'graphics', function () {
            return this._graphics || (this.graphics = RunDriver.createGraphics());
        }, function (value) {
            if (this._graphics)
                this._graphics._sp = null;
            this._graphics = value;
            if (value) {
                this._renderType &= ~0x01;
                this._renderType |= 0x200;
                value._sp = this;
                this.conchModel && this.conchModel.graphics(this._graphics);
            }
            else {
                this._renderType &= ~0x200;
                this._renderType &= ~0x01;
                if (this.conchModel) {
                    if (Sprite.RUNTIMEVERION < "0.9.1")
                        this.conchModel.removeType(0x100);
                    else
                        this.conchModel.removeType(0x200);
                }
            }
            this.repaint();
        });
        __getset(0, __proto, 'filters', function () {
            return this._$P.filters;
        }, function (value) {
            value && value.length === 0 && (value = null);
            if (this._$P.filters == value)
                return;
            this._set$P("filters", value ? value.slice() : null);
            if (Render.isConchApp) {
                if (this.conchModel) {
                    if (Sprite.RUNTIMEVERION < "0.9.1")
                        this.conchModel.removeType(0x10);
                    else
                        this.conchModel.removeType(0x20);
                }
                if (this._$P.filters && this._$P.filters.length == 1) {
                    this._$P.filters[0].callNative(this);
                }
            }
            if (Render.isWebGL) {
                if (value && value.length) {
                    this._renderType |= 0x20;
                }
                else {
                    this._renderType &= ~0x20;
                }
            }
            if (value && value.length > 0) {
                if (!this._getBit(0x1))
                    this._setUpNoticeType(0x1);
                if (!(Render.isWebGL && value.length == 1 && (((value[0]) instanceof laya.filters.ColorFilter)))) {
                    if (this.cacheAs != "bitmap") {
                        if (!Render.isConchNode)
                            this.cacheAs = "bitmap";
                        this._set$P("cacheForFilters", true);
                    }
                    this._set$P("hasFilter", true);
                }
            }
            else {
                this._set$P("hasFilter", false);
                if (this._$P["cacheForFilters"] && this.cacheAs == "bitmap") {
                    this.cacheAs = "none";
                }
            }
            this.repaint();
        });
        __getset(0, __proto, 'parent', _super.prototype._$get_parent, function (value) {
            Laya.superSet(Node, this, 'parent', value);
            if (value && this._getBit(0x2)) {
                this._$2__onDisplay();
            }
        });
        __getset(0, __proto, 'mask', function () {
            return this._$P._mask;
        }, function (value) {
            if (value && this.mask && this.mask._$P.maskParent)
                return;
            if (value) {
                this.cacheAs = "bitmap";
                this._set$P("_mask", value);
                value._set$P("maskParent", this);
            }
            else {
                this.cacheAs = "none";
                this.mask && this.mask._set$P("maskParent", null);
                this._set$P("_mask", value);
            }
            this.conchModel && this.conchModel.mask(value ? value.conchModel : null);
            this._renderType |= 0x40;
            this.parentRepaint();
        });
        __getset(0, __proto, 'mouseEnabled', function () {
            return this._mouseEnableState > 1;
        }, function (value) {
            this._mouseEnableState = value ? 2 : 1;
        });
        __getset(0, __proto, 'globalScaleX', function () {
            var scale = 1;
            var ele = this;
            while (ele) {
                if (ele === Laya.stage)
                    break;
                scale *= ele.scaleX;
                ele = ele.parent;
            }
            return scale;
        });
        __getset(0, __proto, 'mouseX', function () {
            return this.getMousePoint().x;
        });
        __getset(0, __proto, 'mouseY', function () {
            return this.getMousePoint().y;
        });
        Sprite.fromImage = function (url) {
            return new Sprite().loadImage(url);
        };
        Sprite.CustomList = [];
        __static(Sprite, ['RUNTIMEVERION', function () { return this.RUNTIMEVERION = window.conch ? conchConfig.getRuntimeVersion().substr(conchConfig.getRuntimeVersion().lastIndexOf('-') + 1) : ''; }
        ]);
        return Sprite;
    })(Node);
    var AudioSoundChannel = (function (_super) {
        function AudioSoundChannel(audio) {
            this._audio = null;
            this._onEnd = null;
            this._resumePlay = null;
            AudioSoundChannel.__super.call(this);
            this._onEnd = Utils.bind(this.__onEnd, this);
            this._resumePlay = Utils.bind(this.__resumePlay, this);
            audio.addEventListener("ended", this._onEnd);
            this._audio = audio;
        }
        __class(AudioSoundChannel, 'laya.media.h5audio.AudioSoundChannel', _super);
        var __proto = AudioSoundChannel.prototype;
        __proto.__onEnd = function () {
            if (this.loops == 1) {
                if (this.completeHandler) {
                    Laya.timer.once(10, this, this.__runComplete, [this.completeHandler], false);
                    this.completeHandler = null;
                }
                this.stop();
                this.event("complete");
                return;
            }
            if (this.loops > 0) {
                this.loops--;
            }
            this.startTime = 0;
            this.play();
        };
        __proto.__resumePlay = function () {
            if (this._audio)
                this._audio.removeEventListener("canplay", this._resumePlay);
            try {
                this._audio.currentTime = this.startTime;
                Browser.container.appendChild(this._audio);
                this._audio.play();
            }
            catch (e) {
                this.event("error");
            }
        };
        __proto.play = function () {
            this.isStopped = false;
            if (!this._audio)
                return;
            try {
                this._audio.currentTime = this.startTime;
            }
            catch (e) {
                this._audio.addEventListener("canplay", this._resumePlay);
                return;
            }
            SoundManager.addChannel(this);
            Browser.container.appendChild(this._audio);
            if ("play" in this._audio)
                this._audio.play();
        };
        __proto.stop = function () {
            this.isStopped = true;
            SoundManager.removeChannel(this);
            this.completeHandler = null;
            if (!this._audio)
                return;
            if ("pause" in this._audio)
                if (Render.isConchApp) {
                    this._audio.stop();
                }
            this._audio.pause();
            this._audio.removeEventListener("ended", this._onEnd);
            this._audio.removeEventListener("canplay", this._resumePlay);
            if (!Browser.onIE) {
                if (this._audio != AudioSound._musicAudio) {
                    Pool.recover("audio:" + this.url, this._audio);
                }
            }
            Browser.removeElement(this._audio);
            this._audio = null;
        };
        __proto.pause = function () {
            this.isStopped = true;
            SoundManager.removeChannel(this);
            if ("pause" in this._audio)
                this._audio.pause();
        };
        __proto.resume = function () {
            if (!this._audio)
                return;
            this.isStopped = false;
            SoundManager.addChannel(this);
            if ("play" in this._audio)
                this._audio.play();
        };
        __getset(0, __proto, 'position', function () {
            if (!this._audio)
                return 0;
            return this._audio.currentTime;
        });
        __getset(0, __proto, 'duration', function () {
            if (!this._audio)
                return 0;
            return this._audio.duration;
        });
        __getset(0, __proto, 'volume', function () {
            if (!this._audio)
                return 1;
            return this._audio.volume;
        }, function (v) {
            if (!this._audio)
                return;
            this._audio.volume = v;
        });
        __getset(0, __proto, 'playbackRate', function () {
            if (!this._audio)
                return 1;
            return this._audio.playbackRate;
        }, function (v) {
            if (!this._audio)
                return;
            this._audio.playbackRate = v;
        });
        return AudioSoundChannel;
    })(SoundChannel);
    var WebAudioSoundChannel = (function (_super) {
        function WebAudioSoundChannel() {
            this.audioBuffer = null;
            this.gain = null;
            this.bufferSource = null;
            this._currentTime = 0;
            this._volume = 1;
            this._startTime = 0;
            this._pauseTime = 0;
            this._onPlayEnd = null;
            this.context = WebAudioSound.ctx;
            WebAudioSoundChannel.__super.call(this);
            this._onPlayEnd = Utils.bind(this.__onPlayEnd, this);
            if (this.context["createGain"] && typeof this.context["createGain"] == "function") {
                this.gain = this.context["createGain"]();
            }
            else if (this.context["createGainNode"] && typeof this.context["createGainNode"] == "function") {
                this.gain = this.context["createGainNode"]();
            }
            else {
                return function () { return 0; };
            }
        }
        __class(WebAudioSoundChannel, 'laya.media.webaudio.WebAudioSoundChannel', _super);
        var __proto = WebAudioSoundChannel.prototype;
        __proto.play = function () {
            SoundManager.addChannel(this);
            this.isStopped = false;
            this._clearBufferSource();
            if (!this.audioBuffer)
                return;
            var context = this.context;
            var gain = this.gain;
            var bufferSource = context.createBufferSource();
            this.bufferSource = bufferSource;
            bufferSource.buffer = this.audioBuffer;
            bufferSource.connect(gain);
            if (gain)
                gain.disconnect();
            gain.connect(context.destination);
            bufferSource.onended = this._onPlayEnd;
            if (this.startTime >= this.duration)
                this.startTime = 0;
            this._startTime = Browser.now();
            this.gain.gain.value = this._volume;
            if (this.loops == 0) {
                bufferSource.loop = true;
            }
            bufferSource.playbackRate.value = this._playbackRate;
            bufferSource.start(0, this.startTime);
            this._currentTime = 0;
        };
        __proto.__onPlayEnd = function () {
            if (this.loops == 1) {
                if (this.completeHandler) {
                    Laya.timer.once(10, this, this.__runComplete, [this.completeHandler], false);
                    this.completeHandler = null;
                }
                this.stop();
                this.event("complete");
                return;
            }
            if (this.loops > 0) {
                this.loops--;
            }
            this.startTime = 0;
            this.play();
        };
        __proto._clearBufferSource = function () {
            if (this.bufferSource) {
                var sourceNode = this.bufferSource;
                if (sourceNode.stop) {
                    sourceNode.stop(0);
                }
                else {
                    sourceNode.noteOff(0);
                }
                sourceNode.disconnect(0);
                sourceNode.onended = null;
                if (!WebAudioSoundChannel._tryCleanFailed)
                    this._tryClearBuffer(sourceNode);
                this.bufferSource = null;
            }
        };
        __proto._tryClearBuffer = function (sourceNode) {
            if (!Browser.onMac) {
                try {
                    sourceNode.buffer = null;
                }
                catch (e) {
                    WebAudioSoundChannel._tryCleanFailed = true;
                }
                return;
            }
            try {
                sourceNode.buffer = WebAudioSound._miniBuffer;
            }
            catch (e) {
                WebAudioSoundChannel._tryCleanFailed = true;
            }
        };
        __proto.stop = function () {
            this._clearBufferSource();
            this.audioBuffer = null;
            if (this.gain)
                this.gain.disconnect();
            this.isStopped = true;
            SoundManager.removeChannel(this);
            this.completeHandler = null;
            if (SoundManager.autoReleaseSound)
                Laya.timer.once(5000, null, SoundManager.disposeSoundIfNotUsed, [this.url], false);
        };
        __proto.pause = function () {
            if (!this.isStopped) {
                this._pauseTime = this.position;
            }
            this._clearBufferSource();
            if (this.gain)
                this.gain.disconnect();
            this.isStopped = true;
            SoundManager.removeChannel(this);
            if (SoundManager.autoReleaseSound)
                Laya.timer.once(5000, null, SoundManager.disposeSoundIfNotUsed, [this.url], false);
        };
        __proto.resume = function () {
            this.startTime = this._pauseTime;
            this.play();
        };
        __getset(0, __proto, 'position', function () {
            if (this.bufferSource) {
                return (Browser.now() - this._startTime) / 1000 + this.startTime;
            }
            return 0;
        });
        __getset(0, __proto, 'duration', function () {
            if (this.audioBuffer) {
                return this.audioBuffer.duration;
            }
            return 0;
        });
        __getset(0, __proto, 'volume', function () {
            return this._volume;
        }, function (v) {
            if (this.isStopped) {
                return;
            }
            this._volume = v;
            this.gain.gain.value = v;
        });
        __getset(0, __proto, 'playbackRate', function () {
            return this._playbackRate;
        }, function (v) {
            if (this.isStopped) {
                return;
            }
            this._playbackRate = v;
        });
        WebAudioSoundChannel._tryCleanFailed = false;
        return WebAudioSoundChannel;
    })(SoundChannel);
    var Bitmap = (function (_super) {
        function Bitmap() {
            Bitmap.__super.call(this);
            this._w = 0;
            this._h = 0;
        }
        __class(Bitmap, 'laya.resource.Bitmap', _super);
        var __proto = Bitmap.prototype;
        __getset(0, __proto, 'width', function () {
            return this._w;
        });
        __getset(0, __proto, 'height', function () {
            return this._h;
        });
        __getset(0, __proto, 'source', function () {
            return this._source;
        });
        return Bitmap;
    })(Resource);
    var AnimationPlayerBase = (function (_super) {
        function AnimationPlayerBase() {
            this.loop = false;
            this.wrapMode = 0;
            this._index = 0;
            this._count = 0;
            this._isPlaying = false;
            this._labels = null;
            this._isReverse = false;
            this._frameRateChanged = false;
            this._controlNode = null;
            this._actionName = null;
            AnimationPlayerBase.__super.call(this);
            this._interval = Config.animationInterval;
            this._setUpNoticeType(0x1);
        }
        __class(AnimationPlayerBase, 'laya.display.AnimationPlayerBase', _super);
        var __proto = AnimationPlayerBase.prototype;
        __proto.play = function (start, loop, name, showWarn) {
            (start === void 0) && (start = 0);
            (loop === void 0) && (loop = true);
            (name === void 0) && (name = "");
            (showWarn === void 0) && (showWarn = true);
            this._isPlaying = true;
            this.index = ((typeof start == 'string')) ? this._getFrameByLabel(start) : start;
            this.loop = loop;
            this._actionName = name;
            this._isReverse = this.wrapMode == 1;
            if (this.interval > 0) {
                this.timerLoop(this.interval, this, this._frameLoop, null, true, true);
            }
        };
        __proto._getFrameByLabel = function (label) {
            var i = 0;
            for (i = 0; i < this._count; i++) {
                if (this._labels[i] && (this._labels[i]).indexOf(label) >= 0)
                    return i;
            }
            return 0;
        };
        __proto._frameLoop = function () {
            if (this._isReverse) {
                this._index--;
                if (this._index < 0) {
                    if (this.loop) {
                        if (this.wrapMode == 2) {
                            this._index = this._count > 0 ? 1 : 0;
                            this._isReverse = false;
                        }
                        else {
                            this._index = this._count - 1;
                        }
                        this.event("complete");
                    }
                    else {
                        this._index = 0;
                        this.stop();
                        this.event("complete");
                        return;
                    }
                }
            }
            else {
                this._index++;
                if (this._index >= this._count) {
                    if (this.loop) {
                        if (this.wrapMode == 2) {
                            this._index = this._count - 2 >= 0 ? this._count - 2 : 0;
                            this._isReverse = true;
                        }
                        else {
                            this._index = 0;
                        }
                        this.event("complete");
                    }
                    else {
                        this._index--;
                        this.stop();
                        this.event("complete");
                        return;
                    }
                }
            }
            this.index = this._index;
        };
        __proto._setControlNode = function (node) {
            if (this._controlNode) {
                this._controlNode.off("display", this, this._checkResumePlaying);
                this._controlNode.off("undisplay", this, this._checkResumePlaying);
            }
            this._controlNode = node;
            if (node && node != this) {
                node.on("display", this, this._checkResumePlaying);
                node.on("undisplay", this, this._checkResumePlaying);
            }
        };
        __proto._setDisplay = function (value) {
            _super.prototype._setDisplay.call(this, value);
            this._checkResumePlaying();
        };
        __proto._checkResumePlaying = function () {
            if (this._isPlaying) {
                if (this._controlNode.displayedInStage)
                    this.play(this._index, this.loop, this._actionName);
                else
                    this.clearTimer(this, this._frameLoop);
            }
        };
        __proto.stop = function () {
            this._isPlaying = false;
            this.clearTimer(this, this._frameLoop);
        };
        __proto.addLabel = function (label, index) {
            if (!this._labels)
                this._labels = {};
            if (!this._labels[index])
                this._labels[index] = [];
            this._labels[index].push(label);
        };
        __proto.removeLabel = function (label) {
            if (!label)
                this._labels = null;
            else if (this._labels) {
                for (var name in this._labels) {
                    this._removeLabelFromLabelList(this._labels[name], label);
                }
            }
        };
        __proto._removeLabelFromLabelList = function (list, label) {
            if (!list)
                return;
            for (var i = list.length - 1; i >= 0; i--) {
                if (list[i] == label) {
                    list.splice(i, 1);
                }
            }
        };
        __proto.gotoAndStop = function (position) {
            this.index = ((typeof position == 'string')) ? this._getFrameByLabel(position) : position;
            this.stop();
        };
        __proto._displayToIndex = function (value) { };
        __proto.clear = function () {
            this.stop();
            this._labels = null;
        };
        __getset(0, __proto, 'interval', function () {
            return this._interval;
        }, function (value) {
            if (this._interval != value) {
                this._frameRateChanged = true;
                this._interval = value;
                if (this._isPlaying && value > 0) {
                    this.timerLoop(value, this, this._frameLoop, null, true, true);
                }
            }
        });
        __getset(0, __proto, 'isPlaying', function () {
            return this._isPlaying;
        });
        __getset(0, __proto, 'index', function () {
            return this._index;
        }, function (value) {
            this._index = value;
            this._displayToIndex(value);
            if (this._labels && this._labels[value]) {
                var tArr = this._labels[value];
                for (var i = 0, len = tArr.length; i < len; i++) {
                    this.event("label", tArr[i]);
                }
            }
        });
        __getset(0, __proto, 'count', function () {
            return this._count;
        });
        AnimationPlayerBase.WRAP_POSITIVE = 0;
        AnimationPlayerBase.WRAP_REVERSE = 1;
        AnimationPlayerBase.WRAP_PINGPONG = 2;
        return AnimationPlayerBase;
    })(Sprite);
    var Text = (function (_super) {
        function Text() {
            this._clipPoint = null;
            this._currBitmapFont = null;
            this._text = null;
            this._isChanged = false;
            this._textWidth = 0;
            this._textHeight = 0;
            this._lines = [];
            this._lineWidths = [];
            this._startX = NaN;
            this._startY = NaN;
            this._lastVisibleLineIndex = -1;
            this._words = null;
            this._charSize = {};
            this.underline = false;
            this._underlineColor = null;
            Text.__super.call(this);
            this.overflow = Text.VISIBLE;
            this._style = new CSSStyle(this);
            (this._style).wordWrap = false;
        }
        __class(Text, 'laya.display.Text', _super);
        var __proto = Text.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._lines = null;
            if (this._words) {
                this._words.length = 0;
                this._words = null;
            }
        };
        __proto._getBoundPointsM = function (ifRotate) {
            (ifRotate === void 0) && (ifRotate = false);
            var rec = Rectangle.TEMP;
            rec.setTo(0, 0, this.width, this.height);
            return rec._getBoundPoints();
        };
        __proto.getGraphicBounds = function (realSize) {
            (realSize === void 0) && (realSize = false);
            var rec = Rectangle.TEMP;
            rec.setTo(0, 0, this.width, this.height);
            return rec;
        };
        __proto._getCSSStyle = function () {
            return this._style;
        };
        __proto.lang = function (text, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10) {
            text = Text.langPacks && Text.langPacks[text] ? Text.langPacks[text] : text;
            if (arguments.length < 2) {
                this._text = text;
            }
            else {
                for (var i = 0, n = arguments.length; i < n; i++) {
                    text = text.replace("{" + i + "}", arguments[i + 1]);
                }
                this._text = text;
            }
        };
        __proto._isPassWordMode = function () {
            var style = this._style;
            var password = style.password;
            if (("prompt" in this) && this['prompt'] == this._text)
                password = false;
            return password;
        };
        __proto._getPassWordTxt = function (txt) {
            var len = txt.length;
            var word;
            word = "";
            for (var j = len; j > 0; j--) {
                word += "●";
            }
            return word;
        };
        __proto.renderText = function (begin, visibleLineCount) {
            var graphics = this.graphics;
            graphics.clear(true);
            var ctxFont = (this.italic ? "italic " : "") + (this.bold ? "bold " : "") + this.fontSize + "px " + (Browser.onIPhone ? (laya.display.Text._fontFamilyMap[this.font] || this.font) : this.font);
            Browser.context.font = ctxFont;
            var padding = this.padding;
            var startX = padding[3];
            var textAlgin = "left";
            var lines = this._lines;
            var __leading = this.leading;
            if (this.stroke > 0)
                __leading *= 2;
            var lineHeight = __leading + this._charSize.height;
            var tCurrBitmapFont = this._currBitmapFont;
            if (tCurrBitmapFont) {
                lineHeight = __leading + tCurrBitmapFont.getMaxHeight();
            }
            var startY = padding[0];
            var strokeW = this._width;
            if (this.stroke > 0)
                strokeW *= 2;
            var strokeH = this._height;
            if (this.stroke > 0)
                strokeH *= 2;
            if ((!tCurrBitmapFont) && strokeW > 0 && this._textWidth <= strokeW) {
                if (this.align == "right") {
                    textAlgin = "right";
                    startX = strokeW - padding[1];
                }
                else if (this.align == "center") {
                    textAlgin = "center";
                    startX = strokeW * 0.5 + padding[3] - padding[1];
                }
            }
            if (strokeH > 0) {
                var tempVAlign = (this._textHeight > strokeH) ? "top" : this.valign;
                if (tempVAlign === "middle")
                    startY = (strokeH - visibleLineCount * lineHeight) * 0.5 + padding[0] - padding[2];
                else if (tempVAlign === "bottom")
                    startY = strokeH - visibleLineCount * lineHeight - padding[2];
            }
            //
            var style = this._style;
            if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize) {
                var bitmapScale = tCurrBitmapFont.fontSize / this.fontSize;
            }
            if (this._clipPoint) {
                graphics.save();
                var tClipWidth = 0;
                var tClipHeight = 0;
                this._width ? tClipWidth = (this._width - padding[3] - padding[1]) : tClipWidth = this._textWidth;
                this._height ? tClipHeight = (this._height - padding[0] - padding[2]) : tClipHeight = this._textHeight;
                if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize) {
                    tClipWidth *= bitmapScale;
                    tClipHeight *= bitmapScale;
                }
                if (this.stroke > 0) {
                    tClipWidth *= 2;
                    tClipHeight *= 2;
                }
                graphics.clipRect(padding[3], padding[0], tClipWidth, tClipHeight);
            }
            var password = style.password;
            if (("prompt" in this) && this['prompt'] == this._text)
                password = false;
            var x = 0, y = 0;
            var end = Math.min(this._lines.length, visibleLineCount + begin) || 1;
            for (var i = begin; i < end; i++) {
                var word = lines[i];
                var _word;
                if (password) {
                    var len = word.length;
                    word = "";
                    for (var j = len; j > 0; j--) {
                        word += "●";
                    }
                }
                //计算字间距
                var letterSpacingW = 0;
                if (textAlgin == "right") {
                    letterSpacingW = (this.letterSpacing * (word.length - 1)) * (this.stroke ? 2 : 1);
                }
                else if (textAlgin == "center") {
                    letterSpacingW = (this.letterSpacing * (word.length - 1)) * (this.stroke ? 2 : 1) * 0.5;
                }
                x = startX - (this._clipPoint ? this._clipPoint.x : 0) - letterSpacingW;
                y = startY + lineHeight * i - (this._clipPoint ? this._clipPoint.y : 0);
                this.underline && this.drawUnderline(textAlgin, x, y, i);
                if (tCurrBitmapFont) {
                    var tWidth = this.width;
                    if (tCurrBitmapFont.autoScaleSize) {
                        tWidth = this.width * bitmapScale;
                    }
                    tCurrBitmapFont.drawText(word, this, x, y, this.align, tWidth);
                }
                else {
                    if (Render.isWebGL) {
                        this._words || (this._words = []);
                        _word = this._words.length > (i - begin) ? this._words[i - begin] : new WordText();
                        _word.setText(word, this.letterSpacing, this.stroke);
                    }
                    else {
                        _word = word;
                    }
                    style.stroke ? graphics.fillBorderText(_word, x, y, ctxFont, this.color, style.strokeColor, style.stroke, textAlgin) : graphics.fillText(_word, x, y, ctxFont, this.color, textAlgin);
                }
            }
            if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize) {
                var tScale = 1 / bitmapScale;
                this.scale(tScale, tScale);
            }
            if (this._clipPoint)
                graphics.restore();
            this._startX = startX;
            this._startY = startY;
        };
        __proto.drawUnderline = function (align, x, y, lineIndex) {
            var lineWidth = this._lineWidths[lineIndex];
            switch (align) {
                case 'center':
                    x -= lineWidth / 2;
                    break;
                case 'right':
                    x -= lineWidth;
                    break;
                case 'left':
                default:
                    break;
            }
            y += this._charSize.height;
            this._graphics.drawLine(x, y, x + lineWidth, y, this.underlineColor || this.color, 1);
        };
        __proto.typeset = function () {
            this._isChanged = false;
            if (!this._text) {
                this._clipPoint = null;
                this._textWidth = this._textHeight = 0;
                this.graphics.clear(true);
                return;
            }
            Browser.context.font = this._getCSSStyle().font;
            this._lines.length = 0;
            this._lineWidths.length = 0;
            if (this._isPassWordMode()) {
                this.parseLines(this._getPassWordTxt(this._text));
            }
            else
                this.parseLines(this._text);
            this.evalTextSize();
            if (this.checkEnabledViewportOrNot())
                this._clipPoint || (this._clipPoint = new Point(0, 0));
            else
                this._clipPoint = null;
            var lineCount = this._lines.length;
            var __leading = this.leading;
            if (this.stroke > 0)
                __leading *= 2;
            if (this.overflow != Text.VISIBLE) {
                var func = this.overflow == Text.HIDDEN ? Math.floor : Math.ceil;
                lineCount = Math.min(lineCount, func((this.height - this.padding[0] - this.padding[2]) / (__leading + this._charSize.height)));
            }
            var startLine = this.scrollY / (this._charSize.height + __leading) | 0;
            this.renderText(startLine, lineCount);
            this.repaint();
        };
        __proto.evalTextSize = function () {
            var nw = NaN, nh = NaN;
            nw = this.___maxValue; //Math.max.apply(this, this._lineWidths) ;
            nw += this.___wordWidthPlus;
            var __leading = this.leading;
            if (this.stroke > 0)
                __leading *= 2;
            if (this._currBitmapFont)
                nh = this._lines.length * (this._currBitmapFont.getMaxHeight() + __leading) + this.padding[0] + this.padding[2];
            else
                nh = this._lines.length * (this._charSize.height + __leading) + this.padding[0] + this.padding[2];
            if (nw != this._textWidth || nh != this._textHeight) {
                this._textWidth = nw;
                this._textHeight = nh;
                if (!this._width || !this._height)
                    this.conchModel && this.conchModel.size(this._width || this._textWidth, this._height || this._textHeight);
            }
        };
        __proto.checkEnabledViewportOrNot = function () {
            return this.overflow == Text.SCROLL && ((this._width > 0 && this._textWidth > this._width) || (this._height > 0 && this._textHeight > this._height));
        };
        __proto.changeText = function (text) {
            if (this._text !== text) {
                this.lang(text + "");
                if (this._graphics && this._graphics.replaceText(this._text)) {
                }
                else {
                    this.typeset();
                }
            }
        };
        __proto.parseLines = function (text) {
            var needWordWrapOrTruncate = this.wordWrap || this.overflow == Text.HIDDEN;
            if (needWordWrapOrTruncate) {
                var wordWrapWidth = this.getWordWrapWidth();
            }
            if (this._currBitmapFont) {
                this._charSize.width = this._currBitmapFont.getMaxWidth();
                this._charSize.height = this._currBitmapFont.getMaxHeight();
            }
            else {
                var measureResult = Browser.context.measureText(Text._testWord);
                this._charSize.width = measureResult.width;
                this._charSize.height = (measureResult.height || this.fontSize);
            }
            var maxValue = 0; // 行最大宽度
            this.___maxValue = 0;
            // this.___wordWidthPlus 自动换行需要追加的值
            var lines = text.replace(/\r\n/g, "\n").split("\n");
            for (var i = 0, n = lines.length; i < n; i++) {
                var line = lines[i];
                if (needWordWrapOrTruncate) {
                    // KDS 追加计算 wordWrapWidth ，根据描边和字间距决定
                    var wordWrapWidthReal = wordWrapWidth;
                    if (this.stroke > 0) {
                        wordWrapWidthReal *= 2;
                    }
                    this.parseLine(line, wordWrapWidthReal);
                }
                else {
                    var w = this.getTextWidth(line);
                    if (w > maxValue) {
                        maxValue = w;
                        // maxIndex = i;
                        this.___maxValue = maxValue;
                        this.___wordWidthPlus = this.letterSpacing * (line.length - 1) * (this.stroke ? 2 : 1);
                    }
                    this._lineWidths.push(w);
                    this._lines.push(line);
                }
            }
            if (needWordWrapOrTruncate) {
                // var _lineCalc = this._lineWidths.concat();
                for (var i = 0; i < this._lineWidths.length; i++) {
                    var w = this._lineWidths[i];
                    if (w > maxValue) {
                        maxValue = w;
                        // maxIndex = i;
                        this.___maxValue = maxValue;
                        this.___wordWidthPlus = 0;
                    }
                }
            }
        };
        __proto.parseLine = function (line, wordWrapWidth) {
            var lines = this._lines;
            var maybeIndex = 0;
            var execResult;
            var charsWidth = NaN;
            var wordWidth = NaN;
            var startIndex = 0;
            var ___lineWidth = this.getTextWidth(line);
            var letterSpacingW = (this.letterSpacing * (line.length - 1)) * (this.stroke ? 2 : 1);
            wordWrapWidth = Math.max(wordWrapWidth, this._charSize.width);
            charsWidth = ___lineWidth + letterSpacingW;
            // 一行内解决的情况，直接添加到一行
            if (charsWidth <= wordWrapWidth) {
                lines.push(line);
                this._lineWidths.push(charsWidth);
                return;
            }
            charsWidth = this._charSize.width + letterSpacingW;
            maybeIndex = Math.floor((wordWrapWidth - this._charSize.width) / charsWidth);
            (maybeIndex <= 0 || maybeIndex == Infinity) && (maybeIndex = 1);
            charsWidth = this.getTextWidth(line.substring(0, maybeIndex));
            wordWidth = charsWidth;
            var ___letterSpacing = this.letterSpacing * (this.stroke ? 2 : 1);
            var needPlusLetterSpacing = true;
            for (var j = maybeIndex, m = line.length; j < m; j++) {
                charsWidth = this.getTextWidth(line.charAt(j)) + (needPlusLetterSpacing ? ___letterSpacing : 0);
                needPlusLetterSpacing = true;
                wordWidth += charsWidth;
                if (wordWidth > wordWrapWidth) {
                    needPlusLetterSpacing = false;
                    if (this.wordWrap) {
                        var newLine = line.substring(startIndex, j);
                        if (newLine.charCodeAt(newLine.length - 1) < 255) {
                            execResult = /(?:\w|-)+$/.exec(newLine);
                            if (execResult) {
                                j = execResult.index + startIndex;
                                if (execResult.index == 0)
                                    j += newLine.length;
                                else
                                    newLine = line.substring(startIndex, j);
                            }
                        }
                        else if (Text.RightToLeft) {
                            execResult = /([\u0600-\u06FF])+$/.exec(newLine);
                            if (execResult) {
                                j = execResult.index + startIndex;
                                if (execResult.index == 0)
                                    j += newLine.length;
                                else
                                    newLine = line.substring(startIndex, j);
                            }
                        }
                        lines.push(newLine);
                        this._lineWidths.push(wordWidth - charsWidth);
                        startIndex = j;
                        if (j + maybeIndex < m) {
                            j += maybeIndex;
                            charsWidth = this.getTextWidth(line.substring(startIndex, j)) + ___letterSpacing;
                            wordWidth = charsWidth;
                            j--;
                        }
                        else {
                            lines.push(line.substring(startIndex, m));
                            this._lineWidths.push(this.getTextWidth(lines[lines.length - 1]) + ___letterSpacing);
                            startIndex = -1;
                            break;
                        }
                    }
                    else if (this.overflow == Text.HIDDEN) {
                        lines.push(line.substring(0, j));
                        this._lineWidths.push(this.getTextWidth(lines[lines.length - 1]) + ___letterSpacing);
                        return;
                    }
                }
            }
            if (this.wordWrap && startIndex != -1) {
                lines.push(line.substring(startIndex, m));
                this._lineWidths.push(this.getTextWidth(lines[lines.length - 1]) + ___letterSpacing);
            }
        };
        __proto.getTextWidth = function (text) {
            if (this._currBitmapFont)
                return this._currBitmapFont.getTextWidth(text);
            else
                return Browser.context.measureText(text).width;
        };
        __proto.getWordWrapWidth = function () {
            var p = this.padding;
            var w = NaN;
            if (this._currBitmapFont && this._currBitmapFont.autoScaleSize)
                w = this._width * (this._currBitmapFont.fontSize / this.fontSize);
            else
                w = this._width;
            if (w <= 0) {
                w = this.wordWrap ? 100 : Browser.width;
            }
            w <= 0 && (w = 100);
            return w - p[3] - p[1];
        };
        __proto.getCharPoint = function (charIndex, out) {
            this._isChanged && Laya.timer.runCallLater(this, this.typeset);
            var len = 0, lines = this._lines, startIndex = 0;
            for (var i = 0, n = lines.length; i < n; i++) {
                len += lines[i].length;
                if (charIndex < len) {
                    var line = i;
                    break;
                }
                startIndex = len;
            }
            ;
            var ctxFont = (this.italic ? "italic " : "") + (this.bold ? "bold " : "") + this.fontSize + "px " + this.font;
            Browser.context.font = ctxFont;
            var width = this.getTextWidth(this._text.substring(startIndex, charIndex));
            var point = out || new Point();
            var __leading = this.leading;
            if (this.stroke > 0)
                __leading *= 2;
            return point.setTo(this._startX + width - (this._clipPoint ? this._clipPoint.x : 0), this._startY + line * (this._charSize.height + __leading) - (this._clipPoint ? this._clipPoint.y : 0));
        };
        __getset(0, __proto, 'width', function () {
            var __width = this._width ? this._width : (this.textWidth + this.padding[1] + this.padding[3]);
            if (this.stroke > 0) {
                return __width * 2;
            }
            else {
                return __width;
            }
            // if (this._width)
            //     return this._width;
            // return this.textWidth + this.padding[1] + this.padding[3];
        }, function (value) {
            if (value != this._width) {
                Laya.superSet(Sprite, this, 'width', value);
                this.isChanged = true;
            }
        });
        __getset(0, __proto, 'textWidth', function () {
            this._isChanged && Laya.timer.runCallLater(this, this.typeset);
            if (this.stroke > 0) {
                return this._textWidth * 0.5;
            }
            else {
                return this._textWidth;
            }
            // return this._textWidth;
        });
        __getset(0, __proto, 'height', function () {
            var __height = this._height ? this._height : (this.textHeight + this.padding[0] + this.padding[2]);
            if (this.stroke > 0) {
                return __height * 2;
            }
            else {
                return __height;
            }
            // if (this._height)
            //     return this._height;
            // return this.textHeight + this.padding[0] + this.padding[2];
        }, function (value) {
            if (value != this._height) {
                Laya.superSet(Sprite, this, 'height', value);
                this.isChanged = true;
            }
        });
        __getset(0, __proto, 'textHeight', function () {
            this._isChanged && Laya.timer.runCallLater(this, this.typeset);
            if (this.stroke > 0) {
                return this._textHeight * 0.5;
            }
            else {
                return this._textHeight;
            }
            // return this._textHeight;
        });
        __getset(0, __proto, 'padding', function () {
            return this._getCSSStyle().padding;
        }, function (value) {
            this._getCSSStyle().padding = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'bold', function () {
            return this._getCSSStyle().bold;
        }, function (value) {
            this._getCSSStyle().bold = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'text', function () {
            return this._text || "";
        }, function (value) {
            if (this._text !== value) {
                this.lang(value + "");
                this.isChanged = true;
                this.event("change");
            }
        });
        __getset(0, __proto, 'color', function () {
            return this._getCSSStyle().color;
        }, function (value) {
            if (this._getCSSStyle().color != value) {
                this._getCSSStyle().color = value;
                if (!this._isChanged && this._graphics) {
                    this._graphics.replaceTextColor(this.color);
                }
                else {
                    this.isChanged = true;
                }
            }
        });
        __getset(0, __proto, 'font', function () {
            var font = this._getCSSStyle().fontFamily;
            return font == "Arial" ? Font.defaultFont : font;
        }, function (value) {
            if (this._currBitmapFont) {
                this._currBitmapFont = null;
                this.scale(1, 1);
            }
            if (Text._bitmapFonts && Text._bitmapFonts[value]) {
                this._currBitmapFont = Text._bitmapFonts[value];
            }
            this._getCSSStyle().fontFamily = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'fontSize', function () {
            return this._getCSSStyle().fontSize;
        }, function (value) {
            this._getCSSStyle().fontSize = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'italic', function () {
            return this._getCSSStyle().italic;
        }, function (value) {
            this._getCSSStyle().italic = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'align', function () {
            return this._getCSSStyle().align;
        }, function (value) {
            this._getCSSStyle().align = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'valign', function () {
            return this._getCSSStyle().valign;
        }, function (value) {
            this._getCSSStyle().valign = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'wordWrap', function () {
            return this._getCSSStyle().wordWrap;
        }, function (value) {
            this._getCSSStyle().wordWrap = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'leading', function () {
            return this._getCSSStyle().leading;
        }, function (value) {
            this._getCSSStyle().leading = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'letterSpacing', function () {
            return this._getCSSStyle().letterSpacing;
        }, function (value) {
            this._getCSSStyle().letterSpacing = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'bgColor', function () {
            return this._getCSSStyle().backgroundColor;
        }, function (value) {
            this._getCSSStyle().backgroundColor = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'borderColor', function () {
            return this._getCSSStyle().borderColor;
        }, function (value) {
            this._getCSSStyle().borderColor = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'stroke', function () {
            return this._getCSSStyle().stroke;
        }, function (value) {
            this._getCSSStyle().stroke = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'strokeColor', function () {
            return this._getCSSStyle().strokeColor;
        }, function (value) {
            this._getCSSStyle().strokeColor = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'isChanged', null, function (value) {
            if (this._isChanged !== value) {
                this._isChanged = value;
                value && Laya.timer.callLater(this, this.typeset);
            }
        });
        __getset(0, __proto, 'scrollX', function () {
            if (!this._clipPoint)
                return 0;
            return this._clipPoint.x;
        }, function (value) {
            if (this.overflow != Text.SCROLL || (this._textWidth < this._width || !this._clipPoint))
                return;
            value = value < this.padding[3] ? this.padding[3] : value;
            var maxScrollX = this._textWidth - this._width;
            value = value > maxScrollX ? maxScrollX : value;
            var __leading = this.leading;
            if (this.stroke > 0)
                __leading *= 2;
            var visibleLineCount = this._height / (this._charSize.height + __leading) | 0 + 1;
            this._clipPoint.x = value;
            this.renderText(this._lastVisibleLineIndex, visibleLineCount);
        });
        __getset(0, __proto, 'scrollY', function () {
            if (!this._clipPoint)
                return 0;
            return this._clipPoint.y;
        }, function (value) {
            if (this.overflow != Text.SCROLL || (this._textHeight < this._height || !this._clipPoint))
                return;
            value = value < this.padding[0] ? this.padding[0] : value;
            var maxScrollY = this._textHeight - this._height;
            value = value > maxScrollY ? maxScrollY : value;
            var __leading = this.leading;
            if (this.stroke > 0)
                __leading *= 2;
            var startLine = value / (this._charSize.height + __leading) | 0;
            this._lastVisibleLineIndex = startLine;
            var visibleLineCount = (this._height / (this._charSize.height + __leading) | 0) + 1;
            this._clipPoint.y = value;
            this.renderText(startLine, visibleLineCount);
        });
        __getset(0, __proto, 'maxScrollX', function () {
            return (this._textWidth < this._width) ? 0 : this._textWidth - this._width;
        });
        __getset(0, __proto, 'maxScrollY', function () {
            return (this._textHeight < this._height) ? 0 : this._textHeight - this._height;
        });
        __getset(0, __proto, 'lines', function () {
            if (this._isChanged)
                this.typeset();
            return this._lines;
        });
        __getset(0, __proto, 'underlineColor', function () {
            return this._underlineColor;
        }, function (value) {
            this._underlineColor = value;
            this._isChanged = true;
            this.typeset();
        });
        Text.registerBitmapFont = function (name, bitmapFont) {
            Text._bitmapFonts || (Text._bitmapFonts = {});
            Text._bitmapFonts[name] = bitmapFont;
        };
        Text.unregisterBitmapFont = function (name, destroy) {
            (destroy === void 0) && (destroy = true);
            if (Text._bitmapFonts && Text._bitmapFonts[name]) {
                var tBitmapFont = Text._bitmapFonts[name];
                if (destroy) {
                    tBitmapFont.destroy();
                }
                delete Text._bitmapFonts[name];
            }
        };
        Text.setTextRightToLeft = function () {
            var style;
            style = Browser.canvas.source.style;
            style.display = "none";
            style.position = "absolute";
            style.direction = "rtl";
            Render._mainCanvas.source.style.direction = "rtl";
            laya.display.Text.RightToLeft = true;
            Browser.document.body.appendChild(Browser.canvas.source);
        };
        Text.supportFont = function (font) {
            Browser.context.font = "10px sans-serif";
            var defaultFontWidth = Browser.context.measureText("abcji").width;
            Browser.context.font = "10px " + font;
            var customFontWidth = Browser.context.measureText("abcji").width;
            console_log(defaultFontWidth, customFontWidth);
            if (defaultFontWidth === customFontWidth)
                return false;
            else
                return true;
        };
        Text._testWord = "游";
        Text.langPacks = null;
        Text.VISIBLE = "visible";
        Text.SCROLL = "scroll";
        Text.HIDDEN = "hidden";
        Text.CharacterCache = true;
        Text.RightToLeft = false;
        Text._bitmapFonts = null;
        __static(Text, ['_fontFamilyMap', function () { return this._fontFamilyMap = { "报隶": "报隶-简", "黑体": "黑体-简", "楷体": "楷体-简", "兰亭黑": "兰亭黑-简", "隶变": "隶变-简", "凌慧体": "凌慧体-简", "翩翩体": "翩翩体-简", "苹方": "苹方-简", "手札体": "手札体-简", "宋体": "宋体-简", "娃娃体": "娃娃体-简", "魏碑": "魏碑-简", "行楷": "行楷-简", "雅痞": "雅痞-简", "圆体": "圆体-简" }; }
        ]);
        return Text;
    })(Sprite);
    var Stage = (function (_super) {
        function Stage() {
            this.focus = null;
            this.designWidth = 0;
            this.designHeight = 0;
            this.canvasRotation = false;
            this.canvasDegree = 0;
            this.renderingEnabled = true;
            this.screenAdaptationEnabled = true;
            this._screenMode = "none";
            this._scaleMode = "noscale";
            this._alignV = "top";
            this._alignH = "left";
            this._bgColor = "black";
            this._mouseMoveTime = 0;
            this._renderCount = 0;
            this._frameStartTime = NaN;
            this._isFocused = false;
            this._isVisibility = false;
            this._scenes = null;
            this._frameRate = "fast";
            Stage.__super.call(this);
            this.offset = new Point();
            this._canvasTransform = new Matrix();
            this._previousOrientation = Browser.window.orientation;
            var _$this = this;
            this.transform = Matrix.create();
            this._scenes = [];
            this.mouseEnabled = true;
            this.hitTestPrior = true;
            this.autoSize = false;
            this._displayedInStage = true;
            this._isFocused = true;
            this._isVisibility = true;
            var window = Browser.window;
            var _this = this;
            window.addEventListener("focus", function () {
                _$this._isFocused = true;
                _this.event("focus");
                _this.event("focuschange");
            });
            window.addEventListener("blur", function () {
                _$this._isFocused = false;
                _this.event("blur");
                _this.event("focuschange");
                if (_this._isInputting())
                    Input["inputElement"].target.focus = false;
            });
            var hidden = "hidden", state = "visibilityState", visibilityChange = "visibilitychange";
            var document = window.document;
            if (typeof document.hidden !== "undefined") {
                visibilityChange = "visibilitychange";
                state = "visibilityState";
            }
            else if (typeof document.mozHidden !== "undefined") {
                visibilityChange = "mozvisibilitychange";
                state = "mozVisibilityState";
            }
            else if (typeof document.msHidden !== "undefined") {
                visibilityChange = "msvisibilitychange";
                state = "msVisibilityState";
            }
            else if (typeof document.webkitHidden !== "undefined") {
                visibilityChange = "webkitvisibilitychange";
                state = "webkitVisibilityState";
            }
            window.document.addEventListener(visibilityChange, visibleChangeFun);
            function visibleChangeFun() {
                if (Browser.document[state] == "hidden") {
                    _this._setStageVisible(false);
                }
                else {
                    _this._setStageVisible(true);
                }
            }
            window.document.addEventListener("qbrowserVisibilityChange", qbroserVisibleChangeFun);
            function qbroserVisibleChangeFun(e) {
                _this._setStageVisible(!e.hidden);
            }
            window.addEventListener("resize", function () {
                var orientation = Browser.window.orientation;
                if (orientation != null && orientation != _$this._previousOrientation && _this._isInputting()) {
                    Input["inputElement"].target.focus = false;
                }
                _$this._previousOrientation = orientation;
                if (_this._isInputting())
                    return;
                _this._resetCanvas();
            });
            window.addEventListener("orientationchange", function (e) {
                _this._resetCanvas();
            });
            this.on("mousemove", this, this._onmouseMove);
            if (Browser.onMobile)
                this.on("mousedown", this, this._onmouseMove);
        }
        __class(Stage, 'laya.display.Stage', _super);
        var __proto = Stage.prototype;
        __proto._setStageVisible = function (value) {
            if (this._isVisibility == value)
                return;
            this._isVisibility = value;
            if (!this._isVisibility)
                if (this._isInputting())
                    Input["inputElement"].target.focus = false;
            this.event("visibilitychange");
        };
        __proto._isInputting = function () {
            return (Browser.onMobile && Input.isInputting);
        };
        __proto._changeCanvasSize = function () {
            this.setScreenSize(Browser.clientWidth * Browser.pixelRatio, Browser.clientHeight * Browser.pixelRatio);
        };
        __proto._resetCanvas = function () {
            if (!this.screenAdaptationEnabled)
                return;
            var canvas = Render._mainCanvas;
            var canvasStyle = canvas.source.style;
            canvas.size(1, 1);
            Laya.timer.once(100, this, this._changeCanvasSize);
        };
        __proto.setScreenSize = function (screenWidth, screenHeight) {
            var rotation = false;
            if (this._screenMode !== "none") {
                var screenType = screenWidth / screenHeight < 1 ? "vertical" : "horizontal";
                rotation = screenType !== this._screenMode;
                if (rotation) {
                    var temp = screenHeight;
                    screenHeight = screenWidth;
                    screenWidth = temp;
                }
            }
            this.canvasRotation = rotation;
            var canvas = Render._mainCanvas;
            var canvasStyle = canvas.source.style;
            var mat = this._canvasTransform.identity();
            var scaleMode = this._scaleMode;
            var scaleX = screenWidth / this.designWidth;
            var scaleY = screenHeight / this.designHeight;
            var canvasWidth = this.designWidth;
            var canvasHeight = this.designHeight;
            var realWidth = screenWidth;
            var realHeight = screenHeight;
            var pixelRatio = Browser.pixelRatio;
            this._width = this.designWidth;
            this._height = this.designHeight;
            switch (scaleMode) {
                case "noscale":
                    scaleX = scaleY = 1;
                    realWidth = this.designWidth;
                    realHeight = this.designHeight;
                    break;
                case "showall":
                    scaleX = scaleY = Math.min(scaleX, scaleY);
                    canvasWidth = realWidth = Math.round(this.designWidth * scaleX);
                    canvasHeight = realHeight = Math.round(this.designHeight * scaleY);
                    break;
                case "noborder":
                    scaleX = scaleY = Math.max(scaleX, scaleY);
                    realWidth = Math.round(this.designWidth * scaleX);
                    realHeight = Math.round(this.designHeight * scaleY);
                    break;
                case "full":
                    scaleX = scaleY = 1;
                    this._width = canvasWidth = screenWidth;
                    this._height = canvasHeight = screenHeight;
                    break;
                case "fixedwidth":
                    scaleY = scaleX;
                    this._height = canvasHeight = Math.round(screenHeight / scaleX);
                    break;
                case "fixedheight":
                    scaleX = scaleY;
                    this._width = canvasWidth = Math.round(screenWidth / scaleY);
                    break;
                case "fixedauto":
                    if ((screenWidth / screenHeight) < (this.designWidth / this.designHeight)) {
                        scaleY = scaleX;
                        this._height = canvasHeight = Math.round(screenHeight / scaleX);
                    }
                    else {
                        scaleX = scaleY;
                        this._width = canvasWidth = Math.round(screenWidth / scaleY);
                    }
                    break;
            }
            if (this.conchModel)
                this.conchModel.size(this._width, this._height);
            scaleX *= this.scaleX;
            scaleY *= this.scaleY;
            if (scaleX === 1 && scaleY === 1) {
                this.transform.identity();
            }
            else {
                this.transform.a = this._formatData(scaleX / (realWidth / canvasWidth));
                this.transform.d = this._formatData(scaleY / (realHeight / canvasHeight));
                this.conchModel && this.conchModel.scale(this.transform.a, this.transform.d);
            }
            canvas.size(canvasWidth, canvasHeight);
            RunDriver.changeWebGLSize(canvasWidth, canvasHeight);
            mat.scale(realWidth / canvasWidth / pixelRatio, realHeight / canvasHeight / pixelRatio);
            if (this._alignH === "left")
                this.offset.x = 0;
            else if (this._alignH === "right")
                this.offset.x = screenWidth - realWidth;
            else
                this.offset.x = (screenWidth - realWidth) * 0.5 / pixelRatio;
            if (this._alignV === "top")
                this.offset.y = 0;
            else if (this._alignV === "bottom")
                this.offset.y = screenHeight - realHeight;
            else
                this.offset.y = (screenHeight - realHeight) * 0.5 / pixelRatio;
            this.offset.x = Math.round(this.offset.x);
            this.offset.y = Math.round(this.offset.y);
            mat.translate(this.offset.x, this.offset.y);
            this.canvasDegree = 0;
            if (rotation) {
                if (this._screenMode === "horizontal") {
                    mat.rotate(Math.PI / 2);
                    mat.translate(screenHeight / pixelRatio, 0);
                    this.canvasDegree = 90;
                }
                else {
                    mat.rotate(-Math.PI / 2);
                    mat.translate(0, screenWidth / pixelRatio);
                    this.canvasDegree = -90;
                }
            }
            mat.a = this._formatData(mat.a);
            mat.d = this._formatData(mat.d);
            mat.tx = this._formatData(mat.tx);
            mat.ty = this._formatData(mat.ty);
            canvasStyle.transformOrigin = canvasStyle.webkitTransformOrigin = canvasStyle.msTransformOrigin = canvasStyle.mozTransformOrigin = canvasStyle.oTransformOrigin = "0px 0px 0px";
            canvasStyle.transform = canvasStyle.webkitTransform = canvasStyle.msTransform = canvasStyle.mozTransform = canvasStyle.oTransform = "matrix(" + mat.toString() + ")";
            mat.translate(parseInt(canvasStyle.left) || 0, parseInt(canvasStyle.top) || 0);
            this.visible = true;
            this._repaint = 1;
            this.event("resize");
        };
        __proto._formatData = function (value) {
            if (Math.abs(value) < 0.000001)
                return 0;
            if (Math.abs(1 - value) < 0.001)
                return value > 0 ? 1 : -1;
            return value;
        };
        __proto.getMousePoint = function () {
            return Point.TEMP.setTo(this.mouseX, this.mouseY);
        };
        __proto.repaint = function () {
            this._repaint = 1;
        };
        __proto.parentRepaint = function () { };
        __proto._loop = function () {
            this.render(Render.context, 0, 0);
            return true;
        };
        __proto._onmouseMove = function (e) {
            this._mouseMoveTime = Browser.now();
        };
        __proto.getTimeFromFrameStart = function () {
            return Browser.now() - this._frameStartTime;
        };
        __proto.render = function (context, x, y) {
            if (this._frameRate === "sleep" && !Render.isConchApp) {
                var now = Browser.now();
                if (now - this._frameStartTime >= 1000)
                    this._frameStartTime = now;
                else
                    return;
            }
            this._renderCount++;
            Render.isFlash && this.repaint();
            if (!this._style.visible) {
                if (this._renderCount % 5 === 0) {
                    Stat.loopCount++;
                    MouseManager.instance.runEvent();
                    Laya.timer._update();
                }
                return;
            }
            this._frameStartTime = Browser.now();
            var frameMode = this._frameRate === "mouse" ? (((this._frameStartTime - this._mouseMoveTime) < 2000) ? "fast" : "slow") : this._frameRate;
            var isFastMode = (frameMode !== "slow");
            var isDoubleLoop = (this._renderCount % 2 === 0);
            Stat.renderSlow = !isFastMode;
            if (isFastMode || isDoubleLoop || Render.isConchApp) {
                Stat.loopCount++;
                MouseManager.instance.runEvent();
                window.___callbackBeforeRenderFunc();
                Laya.stage.event(EventObject.RENDER);
                Laya.timer._update();
                RunDriver.update3DLoop();
                var scene;
                var i = 0, n = 0;
                if (Render.isConchNode) {
                    for (i = 0, n = this._scenes.length; i < n; i++) {
                        scene = this._scenes[i];
                        (scene) && (scene._updateSceneConch());
                    }
                }
                else {
                    for (i = 0, n = this._scenes.length; i < n; i++) {
                        scene = this._scenes[i];
                        (scene) && (scene._updateScene());
                    }
                }
                if (Render.isConchNode) {
                    var customList = Sprite["CustomList"];
                    for (i = 0, n = customList.length; i < n; i++) {
                        var customItem = customList[i];
                        customItem.customRender(customItem.customContext, 0, 0);
                    }
                    return;
                }
            }
            if (Render.isConchNode)
                return;
            if (this.renderingEnabled && (isFastMode || !isDoubleLoop)) {
                if (Render.isWebGL) {
                    context.clear();
                    _super.prototype.render.call(this, context, x, y);
                    Stat._show && Stat._sp && Stat._sp.render(context, x, y);
                    RunDriver.clear(this._bgColor);
                    RunDriver.beginFlush();
                    context.flush();
                    RunDriver.endFinish();
                    VectorGraphManager.instance && VectorGraphManager.getInstance().endDispose();
                }
                else {
                    RunDriver.clear(this._bgColor);
                    _super.prototype.render.call(this, context, x, y);
                    Stat._show && Stat._sp && Stat._sp.render(context, x, y);
                }
            }
        };
        __proto._requestFullscreen = function () {
            var element = Browser.document.documentElement;
            if (element.requestFullscreen) {
                element.requestFullscreen();
            }
            else if (element.mozRequestFullScreen) {
                element.mozRequestFullScreen();
            }
            else if (element.webkitRequestFullscreen) {
                element.webkitRequestFullscreen();
            }
            else if (element.msRequestFullscreen) {
                element.msRequestFullscreen();
            }
        };
        __proto._fullScreenChanged = function () {
            Laya.stage.event("fullscreenchange");
        };
        __proto.exitFullscreen = function () {
            var document = Browser.document;
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
            else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            }
            else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            }
        };
        __getset(0, __proto, 'clientScaleX', function () {
            return this._transform ? this._transform.getScaleX() : 1;
        });
        __getset(0, __proto, 'desginHeight', function () {
            console_debug("desginHeight已经弃用，请使用designHeight代替");
            return this.designHeight;
        });
        __getset(0, __proto, 'frameRate', function () {
            return this._frameRate;
        }, function (value) {
            this._frameRate = value;
            if (Render.isConchApp) {
                switch (this._frameRate) {
                    case "slow":
                        Browser.window.conch && Browser.window.conchConfig.setSlowFrame && Browser.window.conchConfig.setSlowFrame(true);
                        break;
                    case "fast":
                        Browser.window.conch && Browser.window.conchConfig.setSlowFrame && Browser.window.conchConfig.setSlowFrame(false);
                        break;
                    case "mouse":
                        Browser.window.conch && Browser.window.conchConfig.setMouseFrame && Browser.window.conchConfig.setMouseFrame(2000);
                        break;
                    case "sleep":
                        Browser.window.conch && Browser.window.conchConfig.setLimitFPS && Browser.window.conchConfig.setLimitFPS(1);
                        break;
                    default:
                        throw new Error("Stage:frameRate invalid.");
                        break;
                }
            }
        });
        __getset(0, __proto, 'clientScaleY', function () {
            return this._transform ? this._transform.getScaleY() : 1;
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            this.designWidth = value;
            Laya.superSet(Sprite, this, 'width', value);
            Laya.timer.callLater(this, this._changeCanvasSize);
        });
        __getset(0, __proto, 'alignH', function () {
            return this._alignH;
        }, function (value) {
            this._alignH = value;
            Laya.timer.callLater(this, this._changeCanvasSize);
        });
        __getset(0, __proto, 'isFocused', function () {
            return this._isFocused;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            this.designHeight = value;
            Laya.superSet(Sprite, this, 'height', value);
            Laya.timer.callLater(this, this._changeCanvasSize);
        });
        __getset(0, __proto, 'transform', function () {
            if (this._tfChanged)
                this._adjustTransform();
            return this._transform = this._transform || Matrix.create();
        }, _super.prototype._$set_transform);
        __getset(0, __proto, 'isVisibility', function () {
            return this._isVisibility;
        });
        __getset(0, __proto, 'desginWidth', function () {
            console_debug("desginWidth已经弃用，请使用designWidth代替");
            return this.designWidth;
        });
        __getset(0, __proto, 'scaleMode', function () {
            return this._scaleMode;
        }, function (value) {
            this._scaleMode = value;
            Laya.timer.callLater(this, this._changeCanvasSize);
        });
        __getset(0, __proto, 'alignV', function () {
            return this._alignV;
        }, function (value) {
            this._alignV = value;
            Laya.timer.callLater(this, this._changeCanvasSize);
        });
        __getset(0, __proto, 'bgColor', function () {
            return this._bgColor;
        }, function (value) {
            this._bgColor = value;
            this.conchModel && this.conchModel.bgColor(value);
            if (Render.isWebGL) {
                if (value && value !== "black" && value !== "#000000") {
                    Stage._wgColor = Color.create(value)._color;
                }
                else {
                    if (!Browser.onMiniGame)
                        Stage._wgColor = null;
                }
            }
            if (Browser.onLimixiu) {
                Stage._wgColor = Color.create(value)._color;
            }
            else if (value) {
                Render.canvas.style.background = value;
            }
            else {
                Render.canvas.style.background = "none";
            }
        });
        __getset(0, __proto, 'mouseX', function () {
            return Math.round(MouseManager.instance.mouseX / this.clientScaleX);
        });
        __getset(0, __proto, 'mouseY', function () {
            return Math.round(MouseManager.instance.mouseY / this.clientScaleY);
        });
        __getset(0, __proto, 'screenMode', function () {
            return this._screenMode;
        }, function (value) {
            this._screenMode = value;
        });
        __getset(0, __proto, 'visible', _super.prototype._$get_visible, function (value) {
            if (this.visible !== value) {
                Laya.superSet(Sprite, this, 'visible', value);
                var style = Render._mainCanvas.source.style;
                style.visibility = value ? "visible" : "hidden";
            }
        });
        __getset(0, __proto, 'fullScreenEnabled', null, function (value) {
            var document = Browser.document;
            var canvas = Render.canvas;
            if (value) {
                canvas.addEventListener('mousedown', this._requestFullscreen);
                canvas.addEventListener('touchstart', this._requestFullscreen);
                document.addEventListener("fullscreenchange", this._fullScreenChanged);
                document.addEventListener("mozfullscreenchange", this._fullScreenChanged);
                document.addEventListener("webkitfullscreenchange", this._fullScreenChanged);
                document.addEventListener("msfullscreenchange", this._fullScreenChanged);
            }
            else {
                canvas.removeEventListener('mousedown', this._requestFullscreen);
                canvas.removeEventListener('touchstart', this._requestFullscreen);
                document.removeEventListener("fullscreenchange", this._fullScreenChanged);
                document.removeEventListener("mozfullscreenchange", this._fullScreenChanged);
                document.removeEventListener("webkitfullscreenchange", this._fullScreenChanged);
                document.removeEventListener("msfullscreenchange", this._fullScreenChanged);
            }
        });
        Stage.SCALE_NOSCALE = "noscale";
        Stage.SCALE_EXACTFIT = "exactfit";
        Stage.SCALE_SHOWALL = "showall";
        Stage.SCALE_NOBORDER = "noborder";
        Stage.SCALE_FULL = "full";
        Stage.SCALE_FIXED_WIDTH = "fixedwidth";
        Stage.SCALE_FIXED_HEIGHT = "fixedheight";
        Stage.SCALE_FIXED_AUTO = "fixedauto";
        Stage.ALIGN_LEFT = "left";
        Stage.ALIGN_RIGHT = "right";
        Stage.ALIGN_CENTER = "center";
        Stage.ALIGN_TOP = "top";
        Stage.ALIGN_MIDDLE = "middle";
        Stage.ALIGN_BOTTOM = "bottom";
        Stage.SCREEN_NONE = "none";
        Stage.SCREEN_HORIZONTAL = "horizontal";
        Stage.SCREEN_VERTICAL = "vertical";
        Stage.FRAME_FAST = "fast";
        Stage.FRAME_SLOW = "slow";
        Stage.FRAME_MOUSE = "mouse";
        Stage.FRAME_SLEEP = "sleep";
        Stage._wgColor = null;
        Stage.FRAME_MOUSE_THREDHOLD = 2000;
        return Stage;
    })(Sprite);
    var SoundNode = (function (_super) {
        function SoundNode() {
            this.url = null;
            this._channel = null;
            this._tar = null;
            this._playEvents = null;
            this._stopEvents = null;
            SoundNode.__super.call(this);
            this.visible = false;
            this.on("added", this, this._onParentChange);
            this.on("removed", this, this._onParentChange);
        }
        __class(SoundNode, 'laya.media.SoundNode', _super);
        var __proto = SoundNode.prototype;
        __proto._onParentChange = function () {
            this.target = this.parent;
        };
        __proto.play = function (loops, complete) {
            (loops === void 0) && (loops = 1);
            if (isNaN(loops)) {
                loops = 1;
            }
            if (!this.url)
                return;
            this.stop();
            this._channel = SoundManager.playSound(this.url, loops, complete);
        };
        __proto.stop = function () {
            if (this._channel && !this._channel.isStopped) {
                this._channel.stop();
            }
            this._channel = null;
        };
        __proto._setPlayAction = function (tar, event, action, add) {
            (add === void 0) && (add = true);
            if (!this[action])
                return;
            if (!tar)
                return;
            if (add) {
                tar.on(event, this, this[action]);
            }
            else {
                tar.off(event, this, this[action]);
            }
        };
        __proto._setPlayActions = function (tar, events, action, add) {
            (add === void 0) && (add = true);
            if (!tar)
                return;
            if (!events)
                return;
            var eventArr = events.split(",");
            var i = 0, len = 0;
            len = eventArr.length;
            for (i = 0; i < len; i++) {
                this._setPlayAction(tar, eventArr[i], action, add);
            }
        };
        __getset(0, __proto, 'playEvent', null, function (events) {
            this._playEvents = events;
            if (!events)
                return;
            if (this._tar) {
                this._setPlayActions(this._tar, events, "play");
            }
        });
        __getset(0, __proto, 'target', null, function (tar) {
            if (this._tar) {
                this._setPlayActions(this._tar, this._playEvents, "play", false);
                this._setPlayActions(this._tar, this._stopEvents, "stop", false);
            }
            this._tar = tar;
            if (this._tar) {
                this._setPlayActions(this._tar, this._playEvents, "play", true);
                this._setPlayActions(this._tar, this._stopEvents, "stop", true);
            }
        });
        __getset(0, __proto, 'stopEvent', null, function (events) {
            this._stopEvents = events;
            if (!events)
                return;
            if (this._tar) {
                this._setPlayActions(this._tar, events, "stop");
            }
        });
        return SoundNode;
    })(Sprite);
    var FileBitmap = (function (_super) {
        function FileBitmap() {
            this._src = null;
            this._onload = null;
            this._onerror = null;
            FileBitmap.__super.call(this);
        }
        __class(FileBitmap, 'laya.resource.FileBitmap', _super);
        var __proto = FileBitmap.prototype;
        __getset(0, __proto, 'src', function () {
            return this._src;
        }, function (value) {
            this._src = value;
        });
        __getset(0, __proto, 'onload', null, function (value) {
        });
        __getset(0, __proto, 'onerror', null, function (value) {
        });
        return FileBitmap;
    })(Bitmap);
    var HTMLCanvas = (function (_super) {
        function HTMLCanvas(type, canvas) {
            this._is2D = false;
            HTMLCanvas.__super.call(this);
            var _$this = this;
            this._source = this;
            if (type === "2D" || (type === "AUTO" && !Render.isWebGL)) {
                this._is2D = true;
                this._source = canvas || Browser.createElement("canvas");
                this._w = this._source.width;
                this._h = this._source.height;
                var o = this;
                o.getContext = function (contextID, other) {
                    if (_$this._ctx)
                        return _$this._ctx;
                    var ctx = _$this._ctx = _$this._source.getContext(contextID, other);
                    if (ctx) {
                        ctx._canvas = o;
                        if (!Render.isFlash && !Browser.onLimixiu)
                            ctx.size = function (w, h) {
                            };
                    }
                    return ctx;
                };
            }
            this.lock = true;
        }
        __class(HTMLCanvas, 'laya.resource.HTMLCanvas', _super);
        var __proto = HTMLCanvas.prototype;
        __proto.clear = function () {
            this._ctx && this._ctx.clear();
        };
        __proto.destroy = function () {
            this._ctx && this._ctx.destroy();
            this._ctx = null;
            laya.resource.Resource.prototype.destroy.call(this);
        };
        __proto.release = function () { };
        __proto._setContext = function (context) {
            this._ctx = context;
        };
        __proto.getContext = function (contextID, other) {
            return this._ctx ? this._ctx : (this._ctx = HTMLCanvas._createContext(this));
        };
        __proto.getMemSize = function () {
            return 0;
        };
        __proto.size = function (w, h) {
            if (this._w != w || this._h != h || (this._source && (this._source.width != w || this._source.height != h))) {
                this._w = w;
                this._h = h;
                this.memorySize = this._w * this._h * 4;
                this._ctx && this._ctx.size(w, h);
                this._source && (this._source.height = h, this._source.width = w);
            }
        };
        __proto.getCanvas = function () {
            return this._source;
        };
        __proto.toBase64 = function (type, encoderOptions, callBack) {
            if (this._source) {
                if (Render.isConchApp && this._source.toBase64) {
                    this._source.toBase64(type, encoderOptions, callBack);
                }
                else {
                    var base64Data = this._source.toDataURL(type, encoderOptions);
                    callBack.call(this, base64Data);
                }
            }
        };
        __getset(0, __proto, 'context', function () {
            return this._ctx;
        });
        __getset(0, __proto, 'asBitmap', null, function (value) {
        });
        HTMLCanvas.create = function (type, canvas) {
            return new HTMLCanvas(type, canvas);
        };
        HTMLCanvas.TYPE2D = "2D";
        HTMLCanvas.TYPE3D = "3D";
        HTMLCanvas.TYPEAUTO = "AUTO";
        HTMLCanvas._createContext = null;
        return HTMLCanvas;
    })(Bitmap);
    var HTMLSubImage = (function (_super) {
        function HTMLSubImage(canvas, offsetX, offsetY, width, height, atlasImage, src, allowMerageInAtlas) {
            HTMLSubImage.__super.call(this);
            throw new Error("不允许new！");
        }
        __class(HTMLSubImage, 'laya.resource.HTMLSubImage', _super);
        HTMLSubImage.create = function (canvas, offsetX, offsetY, width, height, atlasImage, src, allowMerageInAtlas) {
            (allowMerageInAtlas === void 0) && (allowMerageInAtlas = false);
            return new HTMLSubImage(canvas, offsetX, offsetY, width, height, atlasImage, src, allowMerageInAtlas);
        };
        return HTMLSubImage;
    })(Bitmap);
    var Animation = (function (_super) {
        function Animation() {
            this._frames = null;
            this._url = null;
            Animation.__super.call(this);
            this._setControlNode(this);
        }
        __class(Animation, 'laya.display.Animation', _super);
        var __proto = Animation.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            this.stop();
            laya.display.Sprite.prototype.destroy.call(this, destroyChild);
            this._frames = null;
            this._labels = null;
        };
        __proto.play = function (start, loop, name, showWarn) {
            (start === void 0) && (start = 0);
            (loop === void 0) && (loop = true);
            (name === void 0) && (name = "");
            (showWarn === void 0) && (showWarn = true);
            if (name)
                this._setFramesFromCache(name, showWarn);
            this._isPlaying = true;
            this.index = ((typeof start == 'string')) ? this._getFrameByLabel(start) : start;
            this.loop = loop;
            this._actionName = name;
            this._isReverse = this.wrapMode == 1;
            if (this._frames && this.interval > 0) {
                this.timerLoop(this.interval, this, this._frameLoop, null, true, true);
            }
        };
        __proto._setFramesFromCache = function (name, showWarn) {
            (showWarn === void 0) && (showWarn = false);
            if (this._url)
                name = this._url + "#" + name;
            if (name && Animation.framesMap[name]) {
                var tAniO;
                tAniO = Animation.framesMap[name];
                if ((tAniO instanceof Array)) {
                    this._frames = Animation.framesMap[name];
                    this._count = this._frames.length;
                }
                else {
                    if (tAniO.nodeRoot) {
                        Animation.framesMap[name] = this._parseGraphicAnimationByData(tAniO);
                        tAniO = Animation.framesMap[name];
                    }
                    this._frames = tAniO.frames;
                    this._count = this._frames.length;
                    if (!this._frameRateChanged)
                        this._interval = tAniO.interval;
                    this._labels = this._copyLabels(tAniO.labels);
                }
                return true;
            }
            else {
                if (showWarn)
                    console_log("ani not found:", name);
            }
            return false;
        };
        __proto._copyLabels = function (labels) {
            if (!labels)
                return null;
            var rst;
            rst = {};
            var key;
            for (key in labels) {
                rst[key] = Utils.copyArray([], labels[key]);
            }
            return rst;
        };
        __proto._frameLoop = function () {
            if (this._style.visible && this._style.alpha > 0.01) {
                _super.prototype._frameLoop.call(this);
            }
        };
        __proto._displayToIndex = function (value) {
            if (this._frames)
                this.graphics = this._frames[value];
        };
        __proto.clear = function () {
            this.stop();
            this.graphics = null;
            this._frames = null;
            this._labels = null;
        };
        __proto.loadImages = function (urls, cacheName) {
            (cacheName === void 0) && (cacheName = "");
            this._url = "";
            if (!this._setFramesFromCache(cacheName)) {
                this.frames = Animation.framesMap[cacheName] ? Animation.framesMap[cacheName] : Animation.createFrames(urls, cacheName);
            }
            return this;
        };
        __proto.loadAtlas = function (url, loaded, cacheName) {
            (cacheName === void 0) && (cacheName = "");
            this._url = "";
            var _this_ = this;
            function onLoaded(loadUrl) {
                if (url === loadUrl) {
                    _this_.frames = Animation.framesMap[cacheName] ? Animation.framesMap[cacheName] : Animation.createFrames(url, cacheName);
                    if (loaded)
                        loaded.run();
                }
            }
            if (!_this_._setFramesFromCache(cacheName)) {
                if (Loader.getAtlas(url))
                    onLoaded(url);
                else
                    Laya.loader.load(url, Handler.create(null, onLoaded, [url]), null, "atlas");
            }
            return this;
        };
        __proto.loadAnimation = function (url, loaded, atlas) {
            this._url = url;
            var _this_ = this;
            if (!this._actionName)
                this._actionName = "";
            if (!_this_._setFramesFromCache("")) {
                if (!atlas || Loader.getAtlas(atlas)) {
                    this._loadAnimationData(url, loaded, atlas);
                }
                else {
                    Laya.loader.load(atlas, Handler.create(this, this._loadAnimationData, [url, loaded, atlas]), null, "atlas");
                }
            }
            else {
                _this_._setFramesFromCache(this._actionName, true);
                this.index = 0;
                if (loaded)
                    loaded.run();
            }
            return this;
        };
        __proto._loadAnimationData = function (url, loaded, atlas) {
            var _$this = this;
            if (atlas && !Loader.getAtlas(atlas)) {
                console_warn("atlas load fail:" + atlas);
                return;
            }
            ;
            var _this_ = this;
            function onLoaded(loadUrl) {
                if (!Loader.getRes(loadUrl))
                    return;
                if (url === loadUrl) {
                    var tAniO;
                    if (!Animation.framesMap[url + "#"]) {
                        var aniData = _this_._parseGraphicAnimation(Loader.getRes(url));
                        if (!aniData)
                            return;
                        var aniList = aniData.animationList;
                        var i = 0, len = aniList.length;
                        var defaultO;
                        for (i = 0; i < len; i++) {
                            tAniO = aniList[i];
                            Animation.framesMap[url + "#" + tAniO.name] = tAniO;
                            if (!defaultO)
                                defaultO = tAniO;
                        }
                        if (defaultO) {
                            Animation.framesMap[url + "#"] = defaultO;
                            _this_._setFramesFromCache(_$this._actionName, true);
                            _$this.index = 0;
                        }
                        _$this._checkResumePlaying();
                    }
                    else {
                        _this_._setFramesFromCache(_$this._actionName, true);
                        _$this.index = 0;
                        _$this._checkResumePlaying();
                    }
                    if (loaded)
                        loaded.run();
                }
            }
            if (Loader.getRes(url))
                onLoaded(url);
            else
                Laya.loader.load(url, Handler.create(null, onLoaded, [url]), null, "json");
            Loader.clearRes(url);
        };
        __proto._parseGraphicAnimation = function (animationData) {
            return GraphicAnimation.parseAnimationData(animationData);
        };
        __proto._parseGraphicAnimationByData = function (animationObject) {
            return GraphicAnimation.parseAnimationByData(animationObject);
        };
        __getset(0, __proto, 'frames', function () {
            return this._frames;
        }, function (value) {
            this._frames = value;
            if (value) {
                this._count = value.length;
                if (this._isPlaying)
                    this.play(this._index, this.loop, this._actionName);
                else
                    this.index = this._index;
            }
        });
        __getset(0, __proto, 'autoPlay', null, function (value) {
            if (value)
                this.play();
            else
                this.stop();
        });
        __getset(0, __proto, 'source', null, function (value) {
            if (value.indexOf(".ani") > -1)
                this.loadAnimation(value);
            else if (value.indexOf(".json") > -1 || value.indexOf("als") > -1 || value.indexOf("atlas") > -1)
                this.loadAtlas(value);
            else
                this.loadImages(value.split(","));
        });
        __getset(0, __proto, 'autoAnimation', null, function (value) {
            this.play(0, true, value, false);
        });
        Animation.createFrames = function (url, name) {
            var arr, i = 0, n = 0, g;
            if ((typeof url == 'string')) {
                var atlas = Loader.getAtlas(url);
                if (atlas && atlas.length) {
                    arr = [];
                    for (i = 0, n = atlas.length; i < n; i++) {
                        g = new RunDriver.createGraphics();
                        g.drawTexture(Loader.getRes(atlas[i]), 0, 0);
                        arr.push(g);
                    }
                }
            }
            else if ((url instanceof Array)) {
                arr = [];
                for (i = 0, n = url.length; i < n; i++) {
                    g = new RunDriver.createGraphics();
                    g.loadImage(url[i], 0, 0);
                    arr.push(g);
                }
            }
            if (name)
                Animation.framesMap[name] = arr;
            return arr;
        };
        Animation.clearCache = function (key) {
            var cache = Animation.framesMap;
            var val;
            var key2 = key + "#";
            for (val in cache) {
                if (val === key || val.indexOf(key2) == 0) {
                    delete Animation.framesMap[val];
                }
            }
        };
        Animation.framesMap = {};
        return Animation;
    })(AnimationPlayerBase);
    var FrameAnimation = (function (_super) {
        function FrameAnimation() {
            this._targetDic = null;
            this._animationData = null;
            this._animationNewFrames = null;
            FrameAnimation.__super.call(this);
            if (FrameAnimation._sortIndexFun == null) {
                FrameAnimation._sortIndexFun = MathUtil.sortByKey("index", false, true);
            }
        }
        __class(FrameAnimation, 'laya.display.FrameAnimation', _super);
        var __proto = FrameAnimation.prototype;
        __proto._setUp = function (targetDic, animationData) {
            this._labels = null;
            this._animationNewFrames = null;
            this._targetDic = targetDic;
            this._animationData = animationData;
            this.interval = 1000 / animationData.frameRate;
            if (animationData.parsed) {
                this._count = animationData.count;
                this._labels = animationData.labels;
                this._animationNewFrames = animationData.animationNewFrames;
            }
            else {
                this._animationNewFrames = [];
                this._calculateDatas();
            }
            animationData.parsed = true;
            animationData.labels = this._labels;
            animationData.count = this._count;
            animationData.animationNewFrames = this._animationNewFrames;
        };
        __proto.clear = function () {
            _super.prototype.clear.call(this);
            this._targetDic = null;
            this._animationData = null;
        };
        __proto._displayToIndex = function (value) {
            if (!this._animationData)
                return;
            if (value < 0)
                value = 0;
            if (value > this._count)
                value = this._count;
            var nodes = this._animationData.nodes, i = 0, len = nodes.length;
            for (i = 0; i < len; i++) {
                this._displayNodeToFrame(nodes[i], value);
            }
        };
        __proto._displayNodeToFrame = function (node, frame, targetDic) {
            if (!targetDic)
                targetDic = this._targetDic;
            var target = targetDic[node.target];
            if (!target) {
                return;
            }
            ;
            var frames = node.frames, key, propFrames, value;
            var keys = node.keys, i = 0, len = keys.length;
            for (i = 0; i < len; i++) {
                key = keys[i];
                propFrames = frames[key];
                if (propFrames.length > frame) {
                    value = propFrames[frame];
                }
                else {
                    value = propFrames[propFrames.length - 1];
                }
                target[key] = value;
            }
        };
        __proto._calculateDatas = function () {
            if (!this._animationData)
                return;
            var nodes = this._animationData.nodes, i = 0, len = nodes.length, tNode;
            this._count = 0;
            for (i = 0; i < len; i++) {
                tNode = nodes[i];
                this._calculateNodeKeyFrames(tNode);
            }
            this._count += 1;
        };
        __proto._calculateNodeKeyFrames = function (node) {
            var keyFrames = node.keyframes, key, tKeyFrames, target = node.target;
            if (!node.frames) {
                node.frames = {};
            }
            if (!node.keys) {
                node.keys = [];
            }
            else {
                node.keys.length = 0;
            }
            if (!node.initValues) {
                node.initValues = {};
            }
            for (key in keyFrames) {
                tKeyFrames = keyFrames[key];
                if (!node.frames[key]) {
                    node.frames[key] = [];
                }
                if (this._targetDic && this._targetDic[target]) {
                    node.initValues[key] = this._targetDic[target][key];
                }
                tKeyFrames.sort(FrameAnimation._sortIndexFun);
                node.keys.push(key);
                this._calculateNodePropFrames(tKeyFrames, node.frames[key], key, target);
            }
        };
        __proto.resetToInitState = function () {
            if (!this._targetDic)
                return;
            if (!this._animationData)
                return;
            var nodes = this._animationData.nodes, i = 0, len = nodes.length;
            var tNode;
            var initValues;
            for (i = 0; i < len; i++) {
                tNode = nodes[i];
                initValues = tNode.initValues;
                if (!initValues)
                    continue;
                var target = this._targetDic[tNode.target];
                if (!target)
                    continue;
                var key;
                for (key in initValues) {
                    target[key] = initValues[key];
                }
            }
        };
        __proto._calculateNodePropFrames = function (keyframes, frames, key, target) {
            var i = 0, len = keyframes.length - 1;
            frames.length = keyframes[len].index + 1;
            for (i = 0; i < len; i++) {
                this._dealKeyFrame(keyframes[i]);
                this._calculateFrameValues(keyframes[i], keyframes[i + 1], frames);
            }
            if (len == 0) {
                frames[0] = keyframes[0].value;
                if (this._animationNewFrames)
                    this._animationNewFrames[keyframes[0].index] = true;
            }
            this._dealKeyFrame(keyframes[i]);
        };
        __proto._dealKeyFrame = function (keyFrame) {
            if (keyFrame.label && keyFrame.label != "")
                this.addLabel(keyFrame.label, keyFrame.index);
        };
        __proto._calculateFrameValues = function (startFrame, endFrame, result) {
            var i = 0, easeFun;
            var start = startFrame.index, end = endFrame.index;
            var startValue = startFrame.value;
            var dValue = endFrame.value - startFrame.value;
            var dLen = end - start;
            if (end > this._count)
                this._count = end;
            if (startFrame.tween) {
                easeFun = Ease[startFrame.tweenMethod];
                if (easeFun == null) {
                    easeFun = Ease.linearNone;
                }
                for (i = start; i < end; i++) {
                    result[i] = easeFun(i - start, startValue, dValue, dLen);
                    if (this._animationNewFrames) {
                        this._animationNewFrames[i] = true;
                    }
                }
            }
            else {
                for (i = start; i < end; i++) {
                    result[i] = startValue;
                }
            }
            if (this._animationNewFrames) {
                this._animationNewFrames[startFrame.index] = true;
                this._animationNewFrames[endFrame.index] = true;
            }
            result[endFrame.index] = endFrame.value;
        };
        FrameAnimation._sortIndexFun = null;
        return FrameAnimation;
    })(AnimationPlayerBase);
    var Input = (function (_super) {
        function Input() {
            this._focus = false;
            this._multiline = false;
            this._editable = true;
            this._restrictPattern = null;
            this._type = "text";
            this._prompt = '';
            this._promptColor = "#A9A9A9";
            this._originColor = "#000000";
            this._content = '';
            Input.__super.call(this);
            this._maxChars = 1E5;
            this._width = 100;
            this._height = 20;
            this.multiline = false;
            this.overflow = Text.SCROLL;
            this.on("mousedown", this, this._onMouseDown);
            this.on("undisplay", this, this._onUnDisplay);
        }
        __class(Input, 'laya.display.Input', _super);
        var __proto = Input.prototype;
        __proto.setSelection = function (startIndex, endIndex) {
            this.focus = true;
            laya.display.Input.inputElement.selectionStart = startIndex;
            laya.display.Input.inputElement.selectionEnd = endIndex;
        };
        __proto._onUnDisplay = function (e) {
            this.focus = false;
        };
        __proto._onMouseDown = function (e) {
            this.focus = true;
        };
        __proto._syncInputTransform = function () {
            var inputElement = this.nativeInput;
            var transform = Utils.getTransformRelativeToWindow(this, this.padding[3], this.padding[0]);
            var inputWid = (this.stroke > 0 ? this._width * 2 : this._width) - this.padding[1] - this.padding[3] - 15;
            var inputHei = (this.stroke > 0 ? this._height * 2 : this._height) - this.padding[0] - this.padding[2];
            if (Render.isConchApp) {
                inputElement.setScale(transform.scaleX, transform.scaleY);
                inputElement.setSize(inputWid, inputHei);
                inputElement.setPos(transform.x, transform.y);
            }
            else {
                Input.inputContainer.style.transform = Input.inputContainer.style.webkitTransform = "scale(" + transform.scaleX + "," + transform.scaleY + ") rotate(" + (Laya.stage.canvasDegree) + "deg)";
                inputElement.style.width = inputWid + 'px';
                inputElement.style.height = inputHei + 'px';
                Input.inputContainer.style.left = transform.x + 'px';
                Input.inputContainer.style.top = transform.y + 'px';
            }
        };
        __proto.select = function () {
            this.nativeInput.select();
        };
        __proto._setInputMethod = function () {
            this.input.parentElement && (Input.inputContainer.removeChild(this.input));
            this.area.parentElement && (Input.inputContainer.removeChild(this.area));
            Input.inputElement = (this._multiline ? this.area : this.input);
            Input.inputContainer.appendChild(Input.inputElement);
            if (Text.RightToLeft) {
                Input.inputElement.style.direction = "rtl";
            }
        };
        __proto._focusIn = function () {
            laya.display.Input.isInputting = true;
            var input = this.nativeInput;
            this._focus = true;
            var cssStyle = input.style;
            cssStyle.whiteSpace = (this.wordWrap ? "pre-wrap" : "nowrap");
            this._setPromptColor();
            input.readOnly = !this._editable;
            if (Render.isConchApp) {
                input.setType(this._type);
                input.setForbidEdit(!this._editable);
            }
            input.maxLength = this._maxChars;
            input.type = this._type;
            input.value = this._content;
            input.placeholder = this._prompt;
            Laya.stage.off("keydown", this, this._onKeyDown);
            Laya.stage.on("keydown", this, this._onKeyDown);
            Laya.stage.focus = this;
            this.event("focus");
            if (Browser.onPC)
                input.focus();
            if (!Browser.onMiniGame) {
                var temp = this._text;
                this._text = null;
            }
            this.typeset();
            input.setColor(this._originColor);
            input.setFontSize(this.fontSize);
            input.setFontFace(Browser.onIPhone ? (Text._fontFamilyMap[this.font] || this.font) : this.font);
            if (Render.isConchApp) {
                input.setMultiAble && input.setMultiAble(this._multiline);
            }
            cssStyle.lineHeight = (this.leading + this.fontSize) + "px";
            cssStyle.fontStyle = (this.italic ? "italic" : "normal");
            cssStyle.fontWeight = (this.bold ? "bold" : "normal");
            cssStyle.textAlign = this.align;
            cssStyle.padding = "0 0";
            this._syncInputTransform();
            if (!Render.isConchApp && Browser.onPC)
                Laya.timer.frameLoop(1, this, this._syncInputTransform);
        };
        __proto._setPromptColor = function () {
            Input.promptStyleDOM = Browser.getElementById("promptStyle");
            if (!Input.promptStyleDOM) {
                Input.promptStyleDOM = Browser.createElement("style");
                Input.promptStyleDOM.setAttribute("id", "promptStyle");
                Browser.document.head.appendChild(Input.promptStyleDOM);
            }
            Input.promptStyleDOM.innerText = "input::-webkit-input-placeholder, textarea::-webkit-input-placeholder {" + "color:" + this._promptColor + "}" + "input:-moz-placeholder, textarea:-moz-placeholder {" + "color:" + this._promptColor + "}" + "input::-moz-placeholder, textarea::-moz-placeholder {" + "color:" + this._promptColor + "}" + "input:-ms-input-placeholder, textarea:-ms-input-placeholder {" + "color:" + this._promptColor + "}" + "input::-webkit-outer-spin-button,input::-webkit-inner-spin-button{ -webkit-appearance:none;}" +
                "input[type='number']{ -moz-appearance:textfield;}";
        };
        __proto._focusOut = function () {
            laya.display.Input.isInputting = false;
            this._focus = false;
            this._text = null;
            this._content = this.nativeInput.value;
            if (!this._content) {
                Laya.superSet(Text, this, 'text', this._prompt);
                Laya.superSet(Text, this, 'color', this._promptColor);
            }
            else {
                Laya.superSet(Text, this, 'text', this._content);
                Laya.superSet(Text, this, 'color', this._originColor);
            }
            Laya.stage.off("keydown", this, this._onKeyDown);
            Laya.stage.focus = null;
            this.event("blur");
            if (Render.isConchApp)
                this.nativeInput.blur();
            Browser.onPC && Laya.timer.clear(this, this._syncInputTransform);
        };
        __proto._onKeyDown = function (e) {
            if (e.keyCode === 13) {
                if (Browser.onMobile && !this._multiline)
                    this.focus = false;
                this.event("enter");
            }
        };
        __proto.changeText = function (text) {
            this._content = text;
            if (this._focus) {
                this.nativeInput.value = text || '';
                this.event("change");
            }
            else {
                _super.prototype.changeText.call(this, text);
            }
        };
        __getset(0, __proto, 'color', _super.prototype._$get_color, function (value) {
            if (this._focus)
                this.nativeInput.setColor(value);
            Laya.superSet(Text, this, 'color', this._content ? value : this._promptColor);
            this._originColor = value;
        });
        __getset(0, __proto, 'inputElementYAdjuster', function () {
            console_warn("deprecated: 由于即使设置了该值，在各平台和浏览器之间也不一定一致，inputElementYAdjuster已弃用。");
            return 0;
        }, function (value) {
            console_warn("deprecated: 由于即使设置了该值，在各平台和浏览器之间也不一定一致，inputElementYAdjuster已弃用。");
        });
        __getset(0, __proto, 'multiline', function () {
            return this._multiline;
        }, function (value) {
            this._multiline = value;
            this.valign = value ? "top" : "middle";
        });
        __getset(0, __proto, 'maxChars', function () {
            return this._maxChars;
        }, function (value) {
            if (value <= 0)
                value = 1E5;
            this._maxChars = value;
        });
        __getset(0, __proto, 'text', function () {
            if (this._focus)
                return this.nativeInput.value;
            else
                return this._content || "";
        }, function (value) {
            Laya.superSet(Text, this, 'color', this._originColor);
            value += '';
            if (this._focus) {
                this.nativeInput.value = value || '';
                this.event("change");
            }
            else {
                if (!this._multiline)
                    value = value.replace(/\r?\n/g, '');
                this._content = value;
                if (value)
                    Laya.superSet(Text, this, 'text', value);
                else {
                    Laya.superSet(Text, this, 'text', this._prompt);
                    Laya.superSet(Text, this, 'color', this.promptColor);
                }
            }
        });
        __getset(0, __proto, 'nativeInput', function () {
            return this._multiline ? this.area : this.input;
        });
        __getset(0, __proto, 'input', function () {
            return this._type == "password" ? Input.inputPassword : Input.inputText;
        });
        __getset(0, __proto, 'area', function () {
            return this._type == "password" ? Input.areaPassword : Input.areaText;
        });
        __getset(0, __proto, 'prompt', function () {
            return this._prompt;
        }, function (value) {
            if (!this._text && value)
                Laya.superSet(Text, this, 'color', this._promptColor);
            this.promptColor = this._promptColor;
            if (this._text)
                Laya.superSet(Text, this, 'text', (this._text == this._prompt) ? value : this._text);
            else
                Laya.superSet(Text, this, 'text', value);
            this._prompt = Text.langPacks && Text.langPacks[value] ? Text.langPacks[value] : value;
        });
        __getset(0, __proto, 'focus', function () {
            return this._focus;
        }, function (value) {
            var input = this.nativeInput;
            if (this._focus !== value) {
                if (value) {
                    if (Input.lastFocuInput) {
                        if (Input.lastFocuInput != input) {
                            if (Input.lastFocuInput.target)
                                Input.lastFocuInput.target._focusOut();
                            Browser.document.body.scrollTop = 0;
                            Input.lastFocuInput.blur();
                            if (Render.isConchApp) {
                                Input.lastFocuInput.setPos(-10000, -10000);
                            }
                            else if (Input.inputContainer.contains(Input.lastFocuInput))
                                Input.inputContainer.removeChild(Input.lastFocuInput);
                        }
                    }
                    this._setInputMethod();
                    Input.lastFocuInput = input;
                    if (input.target != this) {
                        if (input.target)
                            input.target._focusOut();
                        input.target = this;
                    }
                    this._focusIn();
                }
                else {
                    input.target = null;
                    this._focusOut();
                    Browser.document.body.scrollTop = 0;
                    input.blur();
                    if (Render.isConchApp) {
                        input.setPos(-10000, -10000);
                    }
                    else if (Input.inputContainer.contains(input))
                        Input.inputContainer.removeChild(input);
                }
            }
        });
        __getset(0, __proto, 'restrict', function () {
            if (this._restrictPattern) {
                return this._restrictPattern.source;
            }
            return "";
        }, function (pattern) {
            if (pattern) {
                pattern = "[^" + pattern + "]";
                if (pattern.indexOf("^^") > -1)
                    pattern = pattern.replace("^^", "");
                this._restrictPattern = new RegExp(pattern, "g");
            }
            else
                this._restrictPattern = null;
        });
        __getset(0, __proto, 'editable', function () {
            return this._editable;
        }, function (value) {
            this._editable = value;
            if (Render.isConchApp) {
                this.input.setForbidEdit(!value);
            }
        });
        __getset(0, __proto, 'promptColor', function () {
            return this._promptColor;
        }, function (value) {
            this._promptColor = value;
            if (!this._content)
                Laya.superSet(Text, this, 'color', value);
        });
        __getset(0, __proto, 'type', function () {
            return this._type;
        }, function (value) {
            if (value == "password") {
                this._getCSSStyle().password = true;
            }
            else {
                this._getCSSStyle().password = false;
            }
            this._type = value;
            if (Render.isConchApp) {
                this.nativeInput.setType(value);
            }
        });
        __getset(0, __proto, 'inputElementXAdjuster', function () {
            console_warn("deprecated: 由于即使设置了该值，在各平台和浏览器之间也不一定一致，inputElementXAdjuster已弃用。");
            return 0;
        }, function (value) {
            console_warn("deprecated: 由于即使设置了该值，在各平台和浏览器之间也不一定一致，inputElementXAdjuster已弃用。");
        });
        __getset(0, __proto, 'asPassword', function () {
            return this._getCSSStyle().password;
        }, function (value) {
            this._getCSSStyle().password = value;
            this._type = "password";
            console_warn("deprecated: 使用type=\"password\"替代设置asPassword, asPassword将在下次重大更新时删去");
            this.isChanged = true;
        });
        Input.__init__ = function () {
            Input._createInputElement();
            if (Browser.onMobile)
                Render.canvas.addEventListener(Input.IOS_IFRAME ? (Browser.onMiniGame ? "touchend" : "click") : "touchend", Input._popupInputMethod);
        };
        Input._popupInputMethod = function (e) {
            if (!laya.display.Input.isInputting)
                return;
            var input = laya.display.Input.inputElement;
            input.focus();
        };
        Input._createInputElement = function () {
            Input._initInput(Input.areaText = Browser.createElement("textarea"));
            Input._initInput(Input.areaPassword = Browser.createElement("textarea"), true);
            Input._initInput(Input.inputText = Browser.createElement("input"));
            Input._initInput(Input.inputPassword = Browser.createElement("input"), true);
            Input.inputContainer = Browser.createElement("div");
            Input.inputContainer.style.position = "absolute";
            Input.inputContainer.style.zIndex = 1E5;
            Browser.container.appendChild(Input.inputContainer);
            Input.inputContainer.setPos = function (x, y) { Input.inputContainer.style.left = x + 'px'; Input.inputContainer.style.top = y + 'px'; };
        };
        Input._initInput = function (input, password) {
            var style = input.style;
            style.cssText = "position:absolute;overflow:hidden;resize:none;transform-origin:0 0;-webkit-transform-origin:0 0;-moz-transform-origin:0 0;-o-transform-origin:0 0;";
            style.resize = 'none';
            style.backgroundColor = 'transparent';
            style.border = 'none';
            style.outline = 'none';
            style.zIndex = 1;
            if (password)
                input.type = "password";
            input.addEventListener('input', Input._processInputting);
            input.addEventListener('mousemove', Input._stopEvent);
            input.addEventListener('mousedown', Input._stopEvent);
            input.addEventListener('touchmove', Input._stopEvent);
            input.setFontFace = function (fontFace) { input.style.fontFamily = fontFace; };
            if (!Render.isConchApp) {
                input.setColor = function (color) { input.style.color = color; };
                input.setFontSize = function (fontSize) { input.style.fontSize = fontSize + 'px'; };
            }
        };
        Input._processInputting = function (e) {
            var input = laya.display.Input.inputElement.target;
            if (!input)
                return;
            var value = laya.display.Input.inputElement.value;
            if (input._restrictPattern) {
                value = value.replace(/\u2006|\x27/g, "");
                if (input._restrictPattern.test(value)) {
                    value = value.replace(input._restrictPattern, "");
                    laya.display.Input.inputElement.value = value;
                }
            }
            //number类型限制最大字符串
            if (laya.display.Input.inputElement.type == "number") {
                var max = laya.display.Input.inputElement.maxLength;
                if (value.length > max) {
                    value = value.slice(0, max);
                    laya.display.Input.inputElement.value = value;
                }
            }
            input._text = value;
            input.event("input");
        };
        Input._stopEvent = function (e) {
            if (e.type == 'touchmove')
                e.preventDefault();
            e.stopPropagation && e.stopPropagation();
        };
        Input.TYPE_TEXT = "text";
        Input.TYPE_PASSWORD = "password";
        Input.TYPE_EMAIL = "email";
        Input.TYPE_URL = "url";
        Input.TYPE_NUMBER = "number";
        Input.TYPE_RANGE = "range";
        Input.TYPE_DATE = "date";
        Input.TYPE_MONTH = "month";
        Input.TYPE_WEEK = "week";
        Input.TYPE_TIME = "time";
        Input.TYPE_DATE_TIME = "datetime";
        Input.TYPE_DATE_TIME_LOCAL = "datetime-local";
        Input.TYPE_SEARCH = "search";
        Input.inputText = null;
        Input.inputPassword = null;
        Input.areaText = null;
        Input.areaPassword = null;
        Input.inputElement = null;
        Input.lastFocuInput = null;
        Input.inputContainer = null;
        Input.confirmButton = null;
        Input.promptStyleDOM = null;
        Input.inputHeight = 45;
        Input.isInputting = false;
        Input.stageMatrix = null;
        __static(Input, ['IOS_IFRAME', function () { return this.IOS_IFRAME = (Browser.onIOS && Browser.window.top != Browser.window.self); }
        ]);
        return Input;
    })(Text);
    var HTMLImage = (function (_super) {
        function HTMLImage(src, def) {
            this._recreateLock = false;
            this._needReleaseAgain = false;
            this._enableMerageInAtlas = true;
            HTMLImage.__super.call(this);
            this._init_(src, def);
        }
        __class(HTMLImage, 'laya.resource.HTMLImage', _super);
        var __proto = HTMLImage.prototype;
        __proto._init_ = function (src, def) {
            this._src = src;
            this._source = new Browser.window.Image();
            if (def) {
                def.onload && (this.onload = def.onload);
                def.onerror && (this.onerror = def.onerror);
                def.onCreate && def.onCreate(this);
            }
            if (src.indexOf("data:image") != 0)
                this._source.crossOrigin = "";
            (src) && (this._source.src = src);
        };
        __proto.recreateResource = function () {
            var _$this = this;
            if (this._src === "")
                throw new Error("src no null！");
            this._needReleaseAgain = false;
            if (!this._source) {
                this._recreateLock = true;
                var _this = this;
                this._source = new Browser.window.Image();
                this._source.crossOrigin = "";
                this._source.onload = function () {
                    if (_this._needReleaseAgain) {
                        _this._needReleaseAgain = false;
                        _this._source.onload = null;
                        _this._source = null;
                        return;
                    }
                    _this._source.onload = null;
                    _this.memorySize = _$this._w * _$this._h * 4;
                    _this._recreateLock = false;
                    _this.completeCreate();
                };
                this._source.src = this._src;
            }
            else {
                if (this._recreateLock)
                    return;
                this.memorySize = this._w * this._h * 4;
                this._recreateLock = false;
                this.completeCreate();
            }
        };
        __proto.disposeResource = function () {
            if (this._recreateLock)
                this._needReleaseAgain = true;
            (this._source) && (this._source = null, this.memorySize = 0);
        };
        __proto.onresize = function () {
            this._w = this._source.width;
            this._h = this._source.height;
        };
        __getset(0, __proto, 'onload', null, function (value) {
            var _$this = this;
            this._onload = value;
            this._source && (this._source.onload = this._onload != null ? (function () {
                _$this.onresize();
                _$this._onload();
            }) : null);
        });
        __getset(0, __proto, 'onerror', null, function (value) {
            var _$this = this;
            this._onerror = value;
            this._source && (this._source.onerror = this._onerror != null ? (function () {
                _$this._onerror();
            }) : null);
        });
        __getset(0, __proto, 'enableMerageInAtlas', function () {
            return this._enableMerageInAtlas;
        }, function (value) {
            this._enableMerageInAtlas = value;
            if (Render.isConchApp) {
                if (this._source)
                    this._source.enableMerageInAtlas = value;
            }
        });
        HTMLImage.create = function (src, def) {
            return new HTMLImage(src, def);
        };
        return HTMLImage;
    })(FileBitmap);
    var EffectAnimation = (function (_super) {
        function EffectAnimation() {
            this._target = null;
            this._playEvents = null;
            this._initData = {};
            this._aniKeys = null;
            this._effectClass = null;
            EffectAnimation.__super.call(this);
        }
        __class(EffectAnimation, 'laya.display.EffectAnimation', _super);
        var __proto = EffectAnimation.prototype;
        __proto._onOtherBegin = function (effect) {
            if (effect == this)
                return;
            this.stop();
        };
        __proto.addEvent = function () {
            if (!this._target || !this._playEvents)
                return;
            this._setControlNode(this._target);
            this._target.on(this._playEvents, this, this._onPlayAction);
        };
        __proto._onPlayAction = function () {
            this.play(0, false);
        };
        __proto.play = function (start, loop, name, showWarn) {
            (start === void 0) && (start = 0);
            (loop === void 0) && (loop = true);
            (name === void 0) && (name = "");
            (showWarn === void 0) && (showWarn = true);
            if (!this._target)
                return;
            this._target.event("effectanimationbegin", [this]);
            this._recordInitData();
            laya.display.AnimationPlayerBase.prototype.play.call(this, start, loop, name, showWarn);
        };
        __proto._recordInitData = function () {
            if (!this._aniKeys)
                return;
            var i = 0, len = 0;
            len = this._aniKeys.length;
            var key;
            for (i = 0; i < len; i++) {
                key = this._aniKeys[i];
                this._initData[key] = this._target[key];
            }
        };
        __proto._displayToIndex = function (value) {
            if (!this._animationData)
                return;
            if (value < 0)
                value = 0;
            if (value > this._count)
                value = this._count;
            var nodes = this._animationData.nodes, i = 0, len = nodes.length;
            len = len > 1 ? 1 : len;
            for (i = 0; i < len; i++) {
                this._displayNodeToFrame(nodes[i], value);
            }
        };
        __proto._displayNodeToFrame = function (node, frame, targetDic) {
            if (!this._target)
                return;
            var target;
            target = this._target;
            var frames = node.frames, key, propFrames, value;
            var keys = node.keys, i = 0, len = keys.length;
            var secondFrames;
            secondFrames = node.secondFrames;
            var tSecondFrame = 0;
            var easeFun;
            var tKeyFrames;
            var startFrame;
            var endFrame;
            for (i = 0; i < len; i++) {
                key = keys[i];
                propFrames = frames[key];
                tSecondFrame = secondFrames[key];
                if (tSecondFrame == -1) {
                    value = this._initData[key];
                }
                else {
                    if (frame < tSecondFrame) {
                        tKeyFrames = node.keyframes[key];
                        startFrame = tKeyFrames[0];
                        if (startFrame.tween) {
                            easeFun = Ease[startFrame.tweenMethod];
                            if (easeFun == null) {
                                easeFun = Ease.linearNone;
                            }
                            endFrame = tKeyFrames[1];
                            value = easeFun(frame, this._initData[key], endFrame.value - this._initData[key], endFrame.index);
                        }
                        else {
                            value = this._initData[key];
                        }
                    }
                    else {
                        if (propFrames.length > frame) {
                            value = propFrames[frame];
                        }
                        else {
                            value = propFrames[propFrames.length - 1];
                        }
                    }
                }
                target[key] = value;
            }
        };
        __proto._calculateNodeKeyFrames = function (node) {
            _super.prototype._calculateNodeKeyFrames.call(this, node);
            var keyFrames = node.keyframes, key, tKeyFrames, target = node.target;
            var secondFrames;
            secondFrames = {};
            node.secondFrames = secondFrames;
            for (key in keyFrames) {
                tKeyFrames = keyFrames[key];
                if (tKeyFrames.length <= 1) {
                    secondFrames[key] = -1;
                }
                else {
                    secondFrames[key] = tKeyFrames[1].index;
                }
            }
        };
        __getset(0, __proto, 'target', function () {
            return this._target;
        }, function (v) {
            if (this._target) {
                this._target.off("effectanimationbegin", this, this._onOtherBegin);
            }
            this._target = v;
            if (this._target) {
                this._target.on("effectanimationbegin", this, this._onOtherBegin);
            }
            this.addEvent();
        });
        __getset(0, __proto, 'playEvent', null, function (event) {
            this._playEvents = event;
            if (!event)
                return;
            this.addEvent();
        });
        __getset(0, __proto, 'effectData', null, function (uiData) {
            if (uiData) {
                var aniData;
                aniData = uiData["animations"];
                if (aniData && aniData[0]) {
                    this._setUp({}, aniData[0]);
                    if (aniData[0].nodes && aniData[0].nodes[0]) {
                        this._aniKeys = aniData[0].nodes[0].keys;
                    }
                }
            }
        });
        __getset(0, __proto, 'effectClass', null, function (classStr) {
            this._effectClass = ClassUtils.getClass(classStr);
            if (this._effectClass) {
                var uiData;
                uiData = this._effectClass["uiView"];
                if (uiData) {
                    var aniData;
                    aniData = uiData["animations"];
                    if (aniData && aniData[0]) {
                        this._setUp({}, aniData[0]);
                        if (aniData[0].nodes && aniData[0].nodes[0]) {
                            this._aniKeys = aniData[0].nodes[0].keys;
                        }
                    }
                }
            }
        });
        EffectAnimation.EffectAnimationBegin = "effectanimationbegin";
        return EffectAnimation;
    })(FrameAnimation);
    var GraphicAnimation = (function (_super) {
        var GraphicNode;
        function GraphicAnimation() {
            this.animationList = null;
            this.animationDic = null;
            this._nodeList = null;
            this._nodeDefaultProps = null;
            this._gList = null;
            this._nodeIDAniDic = {};
            this._rootNode = null;
            this._nodeGDic = null;
            GraphicAnimation.__super.call(this);
        }
        __class(GraphicAnimation, 'laya.utils.GraphicAnimation', _super);
        var __proto = GraphicAnimation.prototype;
        __proto._parseNodeList = function (uiView) {
            if (!this._nodeList) {
                this._nodeList = [];
            }
            this._nodeDefaultProps[uiView.compId] = uiView.props;
            if (uiView.compId)
                this._nodeList.push(uiView.compId);
            var childs = uiView.child;
            if (childs) {
                var i = 0, len = childs.length;
                for (i = 0; i < len; i++) {
                    this._parseNodeList(childs[i]);
                }
            }
        };
        __proto._calGraphicData = function (aniData) {
            this._setUp(null, aniData);
            this._createGraphicData();
            if (this._nodeIDAniDic) {
                var key;
                for (key in this._nodeIDAniDic) {
                    this._nodeIDAniDic[key] = null;
                }
            }
        };
        __proto._createGraphicData = function () {
            var gList = [];
            var i = 0, len = this.count;
            var animationDataNew = this._animationNewFrames;
            if (!animationDataNew)
                animationDataNew = [];
            var preGraphic;
            for (i = 0; i < len; i++) {
                if (animationDataNew[i] || !preGraphic) {
                    preGraphic = this._createFrameGraphic(i);
                }
                gList.push(preGraphic);
            }
            this._gList = gList;
        };
        __proto._createFrameGraphic = function (frame) {
            var g = RunDriver.createGraphics();
            if (!GraphicAnimation._rootMatrix)
                GraphicAnimation._rootMatrix = new Matrix();
            this._updateNodeGraphic(this._rootNode, frame, GraphicAnimation._rootMatrix, g);
            return g;
        };
        __proto._updateNodeGraphic = function (node, frame, parentTransfrom, g, alpha) {
            (alpha === void 0) && (alpha = 1);
            var tNodeG;
            tNodeG = this._nodeGDic[node.compId] = this._getNodeGraphicData(node.compId, frame, this._nodeGDic[node.compId]);
            var tGraphicAlpha = tNodeG.alpha * alpha;
            if (tGraphicAlpha < 0.01)
                return;
            if (!tNodeG.resultTransform) {
                tNodeG.resultTransform = Matrix.create();
            }
            ;
            var tResultTransform;
            tResultTransform = tNodeG.resultTransform;
            Matrix.mul(tNodeG.transform, parentTransfrom, tResultTransform);
            var tTex;
            if (tNodeG.skin) {
                tTex = this._getTextureByUrl(tNodeG.skin);
                if (tTex) {
                    if (tResultTransform._checkTransform()) {
                        g.drawTexture(tTex, 0, 0, tNodeG.width, tNodeG.height, tResultTransform, tGraphicAlpha);
                        tNodeG.resultTransform = null;
                    }
                    else {
                        g.drawTexture(tTex, tResultTransform.tx, tResultTransform.ty, tNodeG.width, tNodeG.height, null, tGraphicAlpha);
                    }
                }
            }
            ;
            var childs;
            childs = node.child;
            if (!childs)
                return;
            var i = 0, len = 0;
            len = childs.length;
            for (i = 0; i < len; i++) {
                this._updateNodeGraphic(childs[i], frame, tResultTransform, g, tGraphicAlpha);
            }
        };
        __proto._updateNoChilds = function (tNodeG, g) {
            if (!tNodeG.skin)
                return;
            var tTex = this._getTextureByUrl(tNodeG.skin);
            if (!tTex)
                return;
            var tTransform = tNodeG.transform;
            tTransform._checkTransform();
            var onlyTranslate = false;
            onlyTranslate = !tTransform.bTransform;
            if (!onlyTranslate) {
                g.drawTexture(tTex, 0, 0, tNodeG.width, tNodeG.height, tTransform.clone(), tNodeG.alpha);
            }
            else {
                g.drawTexture(tTex, tTransform.tx, tTransform.ty, tNodeG.width, tNodeG.height, null, tNodeG.alpha);
            }
        };
        __proto._updateNodeGraphic2 = function (node, frame, g) {
            var tNodeG;
            tNodeG = this._nodeGDic[node.compId] = this._getNodeGraphicData(node.compId, frame, this._nodeGDic[node.compId]);
            if (!node.child) {
                this._updateNoChilds(tNodeG, g);
                return;
            }
            ;
            var tTransform = tNodeG.transform;
            tTransform._checkTransform();
            var onlyTranslate = false;
            onlyTranslate = !tTransform.bTransform;
            var hasTrans = false;
            hasTrans = onlyTranslate && (tTransform.tx != 0 || tTransform.ty != 0);
            var ifSave = false;
            ifSave = (tTransform.bTransform) || tNodeG.alpha != 1;
            if (ifSave) {
                g.save();
            }
            if (tNodeG.alpha != 1) {
                g.alpha(tNodeG.alpha);
            }
            if (!onlyTranslate) {
                g.transform(tTransform.clone());
            }
            else if (hasTrans) {
                g.translate(tTransform.tx, tTransform.ty);
            }
            ;
            var childs;
            childs = node.child;
            var tTex;
            if (tNodeG.skin) {
                tTex = this._getTextureByUrl(tNodeG.skin);
                if (tTex) {
                    g.drawTexture(tTex, 0, 0, tNodeG.width, tNodeG.height);
                }
            }
            if (childs) {
                var i = 0, len = 0;
                len = childs.length;
                for (i = 0; i < len; i++) {
                    this._updateNodeGraphic2(childs[i], frame, g);
                }
            }
            if (ifSave) {
                g.restore();
            }
            else {
                if (!onlyTranslate) {
                    g.transform(tTransform.clone().invert());
                }
                else if (hasTrans) {
                    g.translate(-tTransform.tx, -tTransform.ty);
                }
            }
        };
        __proto._calculateNodeKeyFrames = function (node) {
            _super.prototype._calculateNodeKeyFrames.call(this, node);
            this._nodeIDAniDic[node.target] = node;
        };
        __proto.getNodeDataByID = function (nodeID) {
            return this._nodeIDAniDic[nodeID];
        };
        __proto._getParams = function (obj, params, frame, obj2) {
            var rst = GraphicAnimation._temParam;
            rst.length = params.length;
            var i = 0, len = params.length;
            for (i = 0; i < len; i++) {
                rst[i] = this._getObjVar(obj, params[i][0], frame, params[i][1], obj2);
            }
            return rst;
        };
        __proto._getObjVar = function (obj, key, frame, noValue, obj2) {
            if (obj.hasOwnProperty(key)) {
                var vArr = obj[key];
                if (frame >= vArr.length)
                    frame = vArr.length - 1;
                return obj[key][frame];
            }
            if (obj2.hasOwnProperty(key)) {
                return obj2[key];
            }
            return noValue;
        };
        __proto._getNodeGraphicData = function (nodeID, frame, rst) {
            if (!rst)
                rst = GraphicNode.create();
            if (!rst.transform) {
                rst.transform = Matrix.create();
            }
            else {
                rst.transform.identity();
            }
            ;
            var node = this.getNodeDataByID(nodeID);
            if (!node)
                return rst;
            var frameData = node.frames;
            var params = this._getParams(frameData, GraphicAnimation._drawTextureCmd, frame, this._nodeDefaultProps[nodeID]);
            var url = params[0];
            var width = NaN, height = NaN;
            var px = params[5], py = params[6];
            var aX = params[13], aY = params[14];
            var sx = params[7], sy = params[8];
            var rotate = params[9];
            var skewX = params[11], skewY = params[12];
            width = params[3];
            height = params[4];
            if (width == 0 || height == 0)
                url = null;
            if (width == -1)
                width = 0;
            if (height == -1)
                height = 0;
            var tex;
            rst.skin = url;
            rst.width = width;
            rst.height = height;
            if (url) {
                tex = this._getTextureByUrl(url);
                if (tex) {
                    if (!width)
                        width = tex.sourceWidth;
                    if (!height)
                        height = tex.sourceHeight;
                }
                else {
                    console_warn("lost skin:", url, ",you may load pics first");
                }
            }
            rst.alpha = params[10];
            var m;
            m = rst.transform;
            if (aX != 0) {
                px = aX * width;
            }
            if (aY != 0) {
                py = aY * height;
            }
            if (px != 0 || py != 0) {
                m.translate(-px, -py);
            }
            ;
            var tm = null;
            if (rotate || sx !== 1 || sy !== 1 || skewX || skewY) {
                tm = GraphicAnimation._tempMt;
                tm.identity();
                tm.bTransform = true;
                var skx = (rotate - skewX) * 0.0174532922222222;
                var sky = (rotate + skewY) * 0.0174532922222222;
                var cx = Math.cos(sky);
                var ssx = Math.sin(sky);
                var cy = Math.sin(skx);
                var ssy = Math.cos(skx);
                tm.a = sx * cx;
                tm.b = sx * ssx;
                tm.c = -sy * cy;
                tm.d = sy * ssy;
                tm.tx = tm.ty = 0;
            }
            if (tm) {
                m = Matrix.mul(m, tm, m);
            }
            m.translate(params[1], params[2]);
            return rst;
        };
        __proto._getTextureByUrl = function (url) {
            return Loader.getRes(url);
        };
        __proto.setAniData = function (uiView, aniName) {
            if (uiView.animations) {
                this._nodeDefaultProps = {};
                this._nodeGDic = {};
                if (this._nodeList)
                    this._nodeList.length = 0;
                this._rootNode = uiView;
                this._parseNodeList(uiView);
                var aniDic = {};
                var anilist = [];
                var animations = uiView.animations;
                var i = 0, len = animations.length;
                var tAniO;
                for (i = 0; i < len; i++) {
                    tAniO = animations[i];
                    this._labels = null;
                    if (aniName && aniName != tAniO.name) {
                        continue;
                    }
                    if (!tAniO)
                        continue;
                    try {
                        this._calGraphicData(tAniO);
                    }
                    catch (e) {
                        console_warn("parse animation fail:" + tAniO.name + ",empty animation created");
                        this._gList = [];
                    }
                    ;
                    var frameO = {};
                    frameO.interval = 1000 / tAniO["frameRate"];
                    frameO.frames = this._gList;
                    frameO.labels = this._labels;
                    frameO.name = tAniO.name;
                    anilist.push(frameO);
                    aniDic[tAniO.name] = frameO;
                }
                this.animationList = anilist;
                this.animationDic = aniDic;
            }
            GraphicAnimation._temParam.length = 0;
        };
        __proto.parseByData = function (aniData) {
            var rootNode, aniO;
            rootNode = aniData.nodeRoot;
            aniO = aniData.aniO;
            delete aniData.nodeRoot;
            delete aniData.aniO;
            this._nodeDefaultProps = {};
            this._nodeGDic = {};
            if (this._nodeList)
                this._nodeList.length = 0;
            this._rootNode = rootNode;
            this._parseNodeList(rootNode);
            this._labels = null;
            try {
                this._calGraphicData(aniO);
            }
            catch (e) {
                console_warn("parse animation fail:" + aniO.name + ",empty animation created");
                this._gList = [];
            }
            ;
            var frameO = aniData;
            frameO.interval = 1000 / aniO["frameRate"];
            frameO.frames = this._gList;
            frameO.labels = this._labels;
            frameO.name = aniO.name;
            return frameO;
        };
        __proto.setUpAniData = function (uiView) {
            if (uiView.animations) {
                var aniDic = {};
                var anilist = [];
                var animations = uiView.animations;
                var i = 0, len = animations.length;
                var tAniO;
                for (i = 0; i < len; i++) {
                    tAniO = animations[i];
                    if (!tAniO)
                        continue;
                    var frameO = {};
                    frameO.name = tAniO.name;
                    frameO.aniO = tAniO;
                    frameO.nodeRoot = uiView;
                    anilist.push(frameO);
                    aniDic[tAniO.name] = frameO;
                }
                this.animationList = anilist;
                this.animationDic = aniDic;
            }
        };
        __proto._clear = function () {
            this.animationList = null;
            this.animationDic = null;
            this._gList = null;
            if (this._nodeGDic) {
                var key;
                var tGNode;
                for (key in this._nodeGDic) {
                    tGNode = this._nodeGDic[key];
                    if (tGNode)
                        tGNode.recover();
                }
            }
            this._nodeGDic = null;
        };
        GraphicAnimation.parseAnimationByData = function (animationObject) {
            if (!GraphicAnimation._I)
                GraphicAnimation._I = new GraphicAnimation();
            var rst;
            rst = GraphicAnimation._I.parseByData(animationObject);
            GraphicAnimation._I._clear();
            return rst;
        };
        GraphicAnimation.parseAnimationData = function (aniData) {
            if (!GraphicAnimation._I)
                GraphicAnimation._I = new GraphicAnimation();
            GraphicAnimation._I.setUpAniData(aniData);
            var rst;
            rst = {};
            rst.animationList = GraphicAnimation._I.animationList;
            rst.animationDic = GraphicAnimation._I.animationDic;
            GraphicAnimation._I._clear();
            return rst;
        };
        GraphicAnimation._drawTextureCmd = [["skin", null], ["x", 0], ["y", 0], ["width", -1], ["height", -1], ["pivotX", 0], ["pivotY", 0], ["scaleX", 1], ["scaleY", 1], ["rotation", 0], ["alpha", 1], ["skewX", 0], ["skewY", 0], ["anchorX", 0], ["anchorY", 0]];
        GraphicAnimation._temParam = [];
        GraphicAnimation._I = null;
        GraphicAnimation._rootMatrix = null;
        __static(GraphicAnimation, ['_tempMt', function () { return this._tempMt = new Matrix(); }
        ]);
        GraphicAnimation.__init$ = function () {
            GraphicNode = (function () {
                function GraphicNode() {
                    this.skin = null;
                    this.transform = null;
                    this.resultTransform = null;
                    this.width = NaN;
                    this.height = NaN;
                    this.alpha = 1;
                }
                __class(GraphicNode, '');
                var __proto = GraphicNode.prototype;
                __proto.recover = function () {
                    this.skin = null;
                    this.width = 0;
                    this.height = 0;
                    this.alpha = 1;
                    if (this.transform) {
                        this.transform.destroy();
                        this.transform = null;
                    }
                    if (this.resultTransform) {
                        this.resultTransform.destroy();
                        this.resultTransform = null;
                    }
                    Pool.recover("GraphicNode", this);
                };
                GraphicNode.create = function () {
                    return Pool.getItemByClass("GraphicNode", GraphicNode);
                };
                return GraphicNode;
            })();
        };
        return GraphicAnimation;
    })(FrameAnimation);
    Laya.__init([EventDispatcher, LoaderManager, Render, Browser, Timer, LocalStorage, TimeLine, GraphicAnimation]);
})(window, document, Laya);
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    var The3Main = (function () {
        function The3Main() { }
        __class(The3Main, 'The3Main');
        return The3Main;
    })();
    new The3Main();
})(window, document, Laya);
if (typeof define === 'function' && define.amd) {
    define('laya.core', ['require', "exports"], function (require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
            var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    var Arith = laya.maths.Arith, Bezier = laya.maths.Bezier, Bitmap = laya.resource.Bitmap, Browser = laya.utils.Browser;
    var Byte = laya.utils.Byte, Color = laya.utils.Color, ColorFilter = laya.filters.ColorFilter, Config = Laya.Config, Context = laya.resource.Context;
    var Event = laya.events.Event, Filter = laya.filters.Filter, Graphics = laya.display.Graphics, HTMLCanvas = laya.resource.HTMLCanvas;
    var HTMLChar = laya.utils.HTMLChar, HTMLImage = laya.resource.HTMLImage, HTMLSubImage = laya.resource.HTMLSubImage;
    var Handler = laya.utils.Handler, Loader = laya.net.Loader, Matrix = laya.maths.Matrix, Point = laya.maths.Point, Rectangle = laya.maths.Rectangle;
    var Render = laya.renders.Render, RenderContext = laya.renders.RenderContext, RenderSprite = laya.renders.RenderSprite;
    var Resource = laya.resource.Resource, ResourceManager = laya.resource.ResourceManager, RunDriver = laya.utils.RunDriver;
    var Sprite = laya.display.Sprite, Stage = laya.display.Stage, Stat = laya.utils.Stat, StringKey = laya.utils.StringKey;
    var Style = laya.display.css.Style, System = laya.system.System, Text = laya.display.Text, Texture = laya.resource.Texture;
    var TransformInfo = laya.display.css.TransformInfo, URL = laya.net.URL, Utils = laya.utils.Utils, VectorGraphManager = laya.utils.VectorGraphManager;
    var WordText = laya.utils.WordText;
    Laya.interface('laya.webgl.shapes.IShape');
    Laya.interface('laya.webgl.submit.ISubmit');
    Laya.interface('laya.webgl.text.ICharSegment');
    Laya.interface('laya.webgl.canvas.save.ISaveData');
    Laya.interface('laya.webgl.resource.IMergeAtlasBitmap');
    Laya.interface('laya.filters.IFilterActionGL', 'laya.filters.IFilterAction');
    var FilterActionGL = (function () {
        function FilterActionGL() { }
        __class(FilterActionGL, 'laya.filters.webgl.FilterActionGL');
        var __proto = FilterActionGL.prototype;
        Laya.imps(__proto, { "laya.filters.IFilterActionGL": true });
        __proto.setValue = function (shader) { };
        __proto.setValueMix = function (shader) { };
        __proto.apply3d = function (scope, sprite, context, x, y) { return null; };
        __proto.apply = function (srcCanvas) { return null; };
        __getset(0, __proto, 'typeMix', function () {
            return 0;
        });
        return FilterActionGL;
    })();
    var ShaderValue = (function () {
        function ShaderValue() { }
        __class(ShaderValue, 'laya.webgl.shader.ShaderValue');
        return ShaderValue;
    })();
    var AtlasGrid = (function () {
        var TexRowInfo, TexMergeTexSize;
        function AtlasGrid(width, height, atlasID) {
            this._atlasID = 0;
            this._width = 0;
            this._height = 0;
            this._texCount = 0;
            this._rowInfo = null;
            this._cells = null;
            this._failSize = new TexMergeTexSize();
            (width === void 0) && (width = 0);
            (height === void 0) && (height = 0);
            (atlasID === void 0) && (atlasID = 0);
            this._cells = null;
            this._rowInfo = null;
            this._init(width, height);
            this._atlasID = atlasID;
        }
        __class(AtlasGrid, 'laya.webgl.atlas.AtlasGrid');
        var __proto = AtlasGrid.prototype;
        __proto.getAltasID = function () {
            return this._atlasID;
        };
        __proto.setAltasID = function (atlasID) {
            if (atlasID >= 0) {
                this._atlasID = atlasID;
            }
        };
        __proto.addTex = function (type, width, height) {
            var result = this._get(width, height);
            if (result.ret == false) {
                return result;
            }
            this._fill(result.x, result.y, width, height, type);
            this._texCount++;
            return result;
        };
        __proto._release = function () {
            if (this._cells != null) {
                this._cells.length = 0;
                this._cells = null;
            }
            if (this._rowInfo) {
                this._rowInfo.length = 0;
                this._rowInfo = null;
            }
        };
        __proto._init = function (width, height) {
            this._width = width;
            this._height = height;
            this._release();
            if (this._width == 0)
                return false;
            this._cells = new Uint8Array(this._width * this._height * 3);
            this._rowInfo = __newvec(this._height);
            for (var i = 0; i < this._height; i++) {
                this._rowInfo[i] = new TexRowInfo();
            }
            this._clear();
            return true;
        };
        __proto._get = function (width, height) {
            var pFillInfo = new MergeFillInfo();
            if (width >= this._failSize.width && height >= this._failSize.height) {
                return pFillInfo;
            }
            ;
            var rx = -1;
            var ry = -1;
            var nWidth = this._width;
            var nHeight = this._height;
            var pCellBox = this._cells;
            for (var y = 0; y < nHeight; y++) {
                if (this._rowInfo[y].spaceCount < width)
                    continue;
                for (var x = 0; x < nWidth;) {
                    var tm = (y * nWidth + x) * 3;
                    if (pCellBox[tm] != 0 || pCellBox[tm + 1] < width || pCellBox[tm + 2] < height) {
                        x += pCellBox[tm + 1];
                        continue;
                    }
                    rx = x;
                    ry = y;
                    for (var xx = 0; xx < width; xx++) {
                        if (pCellBox[3 * xx + tm + 2] < height) {
                            rx = -1;
                            break;
                        }
                    }
                    if (rx < 0) {
                        x += pCellBox[tm + 1];
                        continue;
                    }
                    pFillInfo.ret = true;
                    pFillInfo.x = rx;
                    pFillInfo.y = ry;
                    return pFillInfo;
                }
            }
            return pFillInfo;
        };
        __proto._fill = function (x, y, w, h, type) {
            var nWidth = this._width;
            var nHeghit = this._height;
            this._check((x + w) <= nWidth && (y + h) <= nHeghit);
            for (var yy = y; yy < (h + y); ++yy) {
                this._check(this._rowInfo[yy].spaceCount >= w);
                this._rowInfo[yy].spaceCount -= w;
                for (var xx = 0; xx < w; xx++) {
                    var tm = (x + yy * nWidth + xx) * 3;
                    this._check(this._cells[tm] == 0);
                    this._cells[tm] = type;
                    this._cells[tm + 1] = w;
                    this._cells[tm + 2] = h;
                }
            }
            if (x > 0) {
                for (yy = 0; yy < h; ++yy) {
                    var s = 0;
                    for (xx = x - 1; xx >= 0; --xx, ++s) {
                        if (this._cells[((y + yy) * nWidth + xx) * 3] != 0)
                            break;
                    }
                    for (xx = s; xx > 0; --xx) {
                        this._cells[((y + yy) * nWidth + x - xx) * 3 + 1] = xx;
                        this._check(xx > 0);
                    }
                }
            }
            if (y > 0) {
                for (xx = x; xx < (x + w); ++xx) {
                    s = 0;
                    for (yy = y - 1; yy >= 0; --yy, s++) {
                        if (this._cells[(xx + yy * nWidth) * 3] != 0)
                            break;
                    }
                    for (yy = s; yy > 0; --yy) {
                        this._cells[(xx + (y - yy) * nWidth) * 3 + 2] = yy;
                        this._check(yy > 0);
                    }
                }
            }
        };
        __proto._check = function (ret) {
            if (ret == false) {
                console_log("xtexMerger 错误啦");
            }
        };
        __proto._clear = function () {
            this._texCount = 0;
            for (var y = 0; y < this._height; y++) {
                this._rowInfo[y].spaceCount = this._width;
            }
            for (var i = 0; i < this._height; i++) {
                for (var j = 0; j < this._width; j++) {
                    var tm = (i * this._width + j) * 3;
                    this._cells[tm] = 0;
                    this._cells[tm + 1] = this._width - j;
                    this._cells[tm + 2] = this._width - i;
                }
            }
            this._failSize.width = this._width + 1;
            this._failSize.height = this._height + 1;
        };
        AtlasGrid.__init$ = function () {
            TexRowInfo = (function () {
                function TexRowInfo() {
                    this.spaceCount = 0;
                }
                __class(TexRowInfo, '');
                return TexRowInfo;
            })();
            TexMergeTexSize = (function () {
                function TexMergeTexSize() {
                    this.width = 0;
                    this.height = 0;
                }
                __class(TexMergeTexSize, '');
                return TexMergeTexSize;
            })();
        };
        return AtlasGrid;
    })();
    var AtlasResourceManager = (function () {
        function AtlasResourceManager(width, height, gridSize, maxTexNum) {
            this._currentAtlasCount = 0;
            this._maxAtlaserCount = 0;
            this._width = 0;
            this._height = 0;
            this._gridSize = 0;
            this._gridNumX = 0;
            this._gridNumY = 0;
            this._init = false;
            this._curAtlasIndex = 0;
            this._setAtlasParam = false;
            this._atlaserArray = null;
            this._needGC = false;
            this._setAtlasParam = true;
            this._width = width;
            this._height = height;
            this._gridSize = gridSize;
            this._maxAtlaserCount = maxTexNum;
            this._gridNumX = width / gridSize;
            this._gridNumY = height / gridSize;
            this._curAtlasIndex = 0;
            this._atlaserArray = [];
        }
        __class(AtlasResourceManager, 'laya.webgl.atlas.AtlasResourceManager');
        var __proto = AtlasResourceManager.prototype;
        __proto.setAtlasParam = function (width, height, gridSize, maxTexNum) {
            if (this._setAtlasParam == true) {
                AtlasResourceManager._sid_ = 0;
                this._width = width;
                this._height = height;
                this._gridSize = gridSize;
                this._maxAtlaserCount = maxTexNum;
                this._gridNumX = width / gridSize;
                this._gridNumY = height / gridSize;
                this._curAtlasIndex = 0;
                this.freeAll();
                return true;
            }
            else {
                console_log("设置大图合集参数错误，只能在开始页面设置各种参数");
                throw -1;
                return false;
            }
            return false;
        };
        __proto.pushData = function (texture) {
            var bitmap = texture.bitmap;
            var nWebGLImageIndex = -1;
            var curAtlas = null;
            var i = 0, n = 0, altasIndex = 0;
            for (i = 0, n = this._atlaserArray.length; i < n; i++) {
                altasIndex = (this._curAtlasIndex + i) % n;
                curAtlas = this._atlaserArray[altasIndex];
                nWebGLImageIndex = curAtlas.findBitmapIsExist(bitmap);
                if (nWebGLImageIndex != -1) {
                    break;
                }
            }
            if (nWebGLImageIndex != -1) {
                var offset = curAtlas.InAtlasWebGLImagesOffsetValue[nWebGLImageIndex];
                offsetX = offset[0];
                offsetY = offset[1];
                curAtlas.addToAtlas(texture, offsetX, offsetY);
                return true;
            }
            else {
                var tex = texture;
                this._setAtlasParam = false;
                var bFound = false;
                var nImageGridX = (Math.ceil((texture.bitmap.width + 2) / this._gridSize));
                var nImageGridY = (Math.ceil((texture.bitmap.height + 2) / this._gridSize));
                var bSuccess = false;
                for (var k = 0; k < 2; k++) {
                    var maxAtlaserCount = this._maxAtlaserCount;
                    for (i = 0; i < maxAtlaserCount; i++) {
                        altasIndex = (this._curAtlasIndex + i) % maxAtlaserCount;
                        (this._atlaserArray.length - 1 >= altasIndex) || (this._atlaserArray.push(new Atlaser(this._gridNumX, this._gridNumY, this._width, this._height, AtlasResourceManager._sid_++)));
                        var atlas = this._atlaserArray[altasIndex];
                        var offsetX = 0, offsetY = 0;
                        var fillInfo = atlas.addTex(1, nImageGridX, nImageGridY);
                        if (fillInfo.ret) {
                            offsetX = fillInfo.x * this._gridSize + 1;
                            offsetY = fillInfo.y * this._gridSize + 1;
                            bitmap.lock = true;
                            atlas.addToAtlasTexture((bitmap), offsetX, offsetY);
                            atlas.addToAtlas(texture, offsetX, offsetY);
                            bSuccess = true;
                            this._curAtlasIndex = altasIndex;
                            break;
                        }
                    }
                    if (bSuccess)
                        break;
                    this._atlaserArray.push(new Atlaser(this._gridNumX, this._gridNumY, this._width, this._height, AtlasResourceManager._sid_++));
                    this._needGC = true;
                    this.garbageCollection();
                    this._curAtlasIndex = this._atlaserArray.length - 1;
                }
                if (!bSuccess) {
                    console_log(">>>AtlasManager pushData error");
                }
                return bSuccess;
            }
        };
        __proto.addToAtlas = function (tex) {
            laya.webgl.atlas.AtlasResourceManager.instance.pushData(tex);
        };
        __proto.garbageCollection = function () {
            if (this._needGC === true) {
                var n = this._atlaserArray.length - this._maxAtlaserCount;
                for (var i = 0; i < n; i++) {
                    this._atlaserArray[i].dispose();
                    console_log("AtlasResourceManager:Dispose the inner Atlas。");
                }
                console_log(">>>>altas garbageCollection =" + n);
                this._atlaserArray.splice(0, n);
                this._needGC = false;
            }
            return true;
        };
        __proto.freeAll = function () {
            for (var i = 0, n = this._atlaserArray.length; i < n; i++) {
                this._atlaserArray[i].dispose();
            }
            this._atlaserArray.length = 0;
            this._curAtlasIndex = 0;
        };
        __proto.getAtlaserCount = function () {
            return this._atlaserArray.length;
        };
        __proto.getAtlaserByIndex = function (index) {
            return this._atlaserArray[index];
        };
        __getset(1, AtlasResourceManager, 'instance', function () {
            if (!AtlasResourceManager._Instance) {
                AtlasResourceManager._Instance = new AtlasResourceManager(laya.webgl.atlas.AtlasResourceManager.atlasTextureWidth, laya.webgl.atlas.AtlasResourceManager.atlasTextureHeight, 16, laya.webgl.atlas.AtlasResourceManager.maxTextureCount);
            }
            return AtlasResourceManager._Instance;
        });
        __getset(1, AtlasResourceManager, 'enabled', function () {
            return Config.atlasEnable;
        });
        __getset(1, AtlasResourceManager, 'atlasLimitWidth', function () {
            return AtlasResourceManager._atlasLimitWidth;
        }, function (value) {
            AtlasResourceManager._atlasLimitWidth = value;
        });
        __getset(1, AtlasResourceManager, 'atlasLimitHeight', function () {
            return AtlasResourceManager._atlasLimitHeight;
        }, function (value) {
            AtlasResourceManager._atlasLimitHeight = value;
        });
        AtlasResourceManager._enable = function () {
            Config.atlasEnable = true;
        };
        AtlasResourceManager._disable = function () {
            Config.atlasEnable = false;
        };
        AtlasResourceManager.__init__ = function () {
            AtlasResourceManager.atlasTextureWidth = 2048;
            AtlasResourceManager.atlasTextureHeight = 2048;
            AtlasResourceManager.maxTextureCount = 6;
            AtlasResourceManager.atlasLimitWidth = 512;
            AtlasResourceManager.atlasLimitHeight = 512;
        };
        AtlasResourceManager._atlasLimitWidth = 0;
        AtlasResourceManager._atlasLimitHeight = 0;
        AtlasResourceManager.gridSize = 16;
        AtlasResourceManager.atlasTextureWidth = 0;
        AtlasResourceManager.atlasTextureHeight = 0;
        AtlasResourceManager.maxTextureCount = 0;
        AtlasResourceManager._atlasRestore = 0;
        AtlasResourceManager.BOARDER_TYPE_NO = 0;
        AtlasResourceManager.BOARDER_TYPE_RIGHT = 1;
        AtlasResourceManager.BOARDER_TYPE_LEFT = 2;
        AtlasResourceManager.BOARDER_TYPE_BOTTOM = 4;
        AtlasResourceManager.BOARDER_TYPE_TOP = 8;
        AtlasResourceManager.BOARDER_TYPE_ALL = 15;
        AtlasResourceManager._sid_ = 0;
        AtlasResourceManager._Instance = null;
        return AtlasResourceManager;
    })();
    var MergeFillInfo = (function () {
        function MergeFillInfo() {
            this.x = 0;
            this.y = 0;
            this.ret = false;
            this.ret = false;
            this.x = 0;
            this.y = 0;
        }
        __class(MergeFillInfo, 'laya.webgl.atlas.MergeFillInfo');
        return MergeFillInfo;
    })();
    var BlendMode = (function () {
        function BlendMode() { }
        __class(BlendMode, 'laya.webgl.canvas.BlendMode');
        BlendMode._init_ = function (gl) {
            BlendMode.fns = [BlendMode.BlendNormal, BlendMode.BlendAdd, BlendMode.BlendMultiply, BlendMode.BlendScreen, BlendMode.BlendOverlay, BlendMode.BlendLight, BlendMode.BlendMask, BlendMode.BlendDestinationOut];
            BlendMode.targetFns = [BlendMode.BlendNormalTarget, BlendMode.BlendAddTarget, BlendMode.BlendMultiplyTarget, BlendMode.BlendScreenTarget, BlendMode.BlendOverlayTarget, BlendMode.BlendLightTarget, BlendMode.BlendMask, BlendMode.BlendDestinationOut];
        };
        BlendMode.BlendNormal = function (gl) {
            gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/ 1, /*laya.webgl.WebGLContext.ONE_MINUS_SRC_ALPHA*/ 0x0303);
        };
        BlendMode.BlendAdd = function (gl) {
            gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/ 1, /*laya.webgl.WebGLContext.DST_ALPHA*/ 0x0304);
        };
        BlendMode.BlendMultiply = function (gl) {
            gl.blendFunc(0x0306, 0x0303);
        };
        BlendMode.BlendScreen = function (gl) {
            gl.blendFunc(1, 1);
        };
        BlendMode.BlendOverlay = function (gl) {
            gl.blendFunc(1, 0x0301);
        };
        BlendMode.BlendLight = function (gl) {
            gl.blendFunc(1, 1);
        };
        BlendMode.BlendNormalTarget = function (gl) {
            gl.blendFunc(1, 0x0303);
        };
        BlendMode.BlendAddTarget = function (gl) {
            gl.blendFunc(1, 0x0304);
        };
        BlendMode.BlendMultiplyTarget = function (gl) {
            gl.blendFunc(0x0306, 0x0303);
        };
        BlendMode.BlendScreenTarget = function (gl) {
            gl.blendFunc(1, 1);
        };
        BlendMode.BlendOverlayTarget = function (gl) {
            gl.blendFunc(1, 0x0301);
        };
        BlendMode.BlendLightTarget = function (gl) {
            gl.blendFunc(1, 1);
        };
        BlendMode.BlendMask = function (gl) {
            gl.blendFunc(0, 0x0302);
        };
        BlendMode.BlendDestinationOut = function (gl) {
            gl.blendFunc(0, 0);
        };
        BlendMode.activeBlendFunction = null;
        BlendMode.NAMES = ["normal", "add", "multiply", "screen", "overlay", "light", "mask", "destination-out"];
        BlendMode.TOINT = { "normal": 0, "add": 1, "multiply": 2, "screen": 3, "lighter": 1, "overlay": 4, "light": 5, "mask": 6, "destination-out": 7 };
        BlendMode.NORMAL = "normal";
        BlendMode.ADD = "add";
        BlendMode.MULTIPLY = "multiply";
        BlendMode.SCREEN = "screen";
        BlendMode.LIGHT = "light";
        BlendMode.OVERLAY = "overlay";
        BlendMode.DESTINATIONOUT = "destination-out";
        BlendMode.fns = [];
        BlendMode.targetFns = [];
        return BlendMode;
    })();
    var DrawStyle = (function () {
        function DrawStyle(value) {
            this._color = Color.create("black");
            this.setValue(value);
        }
        __class(DrawStyle, 'laya.webgl.canvas.DrawStyle');
        var __proto = DrawStyle.prototype;
        __proto.setValue = function (value) {
            if (value) {
                if ((typeof value == 'string')) {
                    this._color = Color.create(value);
                    return;
                }
                if ((value instanceof laya.utils.Color)) {
                    this._color = value;
                    return;
                }
            }
        };
        __proto.reset = function () {
            this._color = Color.create("black");
        };
        __proto.equal = function (value) {
            if ((typeof value == 'string'))
                return this._color.strColor === value;
            if ((value instanceof laya.utils.Color))
                return this._color.numColor === (value).numColor;
            return false;
        };
        __proto.toColorStr = function () {
            return this._color.strColor;
        };
        DrawStyle.create = function (value) {
            if (value) {
                var color;
                if ((typeof value == 'string'))
                    color = Color.create(value);
                else if ((value instanceof laya.utils.Color))
                    color = value;
                if (color) {
                    return color._drawStyle || (color._drawStyle = new DrawStyle(value));
                }
            }
            return laya.webgl.canvas.DrawStyle.DEFAULT;
        };
        __static(DrawStyle, ['DEFAULT', function () { return this.DEFAULT = new DrawStyle("#000000"); }
        ]);
        return DrawStyle;
    })();
    var Path = (function () {
        function Path() {
            this._x = 0;
            this._y = 0;
            this.dirty = false;
            this.offset = 0;
            this.count = 0;
            this.geoStart = 0;
            this.tempArray = [];
            this.closePath = false;
            this.geomatrys = [];
            var gl = WebGL.mainContext;
            this.ib = IndexBuffer2D.create(0x88E8);
            this.vb = VertexBuffer2D.create(5);
        }
        __class(Path, 'laya.webgl.canvas.Path');
        var __proto = Path.prototype;
        __proto.addPoint = function (pointX, pointY) {
            this.tempArray.push(pointX, pointY);
        };
        __proto.getEndPointX = function () {
            return this.tempArray[this.tempArray.length - 2];
        };
        __proto.getEndPointY = function () {
            return this.tempArray[this.tempArray.length - 1];
        };
        __proto.polygon = function (x, y, points, color, borderWidth, borderColor) {
            var geo;
            this.geomatrys.push(this._curGeomatry = geo = new Polygon(x, y, points, color, borderWidth, borderColor));
            if (!color)
                geo.fill = false;
            if (borderColor == undefined)
                geo.borderWidth = 0;
            return geo;
        };
        __proto.setGeomtry = function (shape) {
            this.geomatrys.push(this._curGeomatry = shape);
        };
        __proto.drawLine = function (x, y, points, width, color) {
            var geo;
            if (this.closePath) {
                this.geomatrys.push(this._curGeomatry = geo = new LoopLine(x, y, points, width, color));
            }
            else {
                this.geomatrys.push(this._curGeomatry = geo = new Line(x, y, points, width, color));
            }
            geo.fill = false;
            return geo;
        };
        __proto.update = function () {
            var si = this.ib._byteLength;
            var len = this.geomatrys.length;
            this.offset = si;
            for (var i = this.geoStart; i < len; i++) {
                this.geomatrys[i].getData(this.ib, this.vb, this.vb._byteLength / 20);
            }
            this.geoStart = len;
            this.count = (this.ib._byteLength - si) / CONST3D2D.BYTES_PIDX;
        };
        __proto.reset = function () {
            this.vb.clear();
            this.ib.clear();
            this.offset = this.count = this.geoStart = 0;
            this.geomatrys.length = 0;
        };
        __proto.recover = function () {
            this._curGeomatry = null;
            this.vb.destory();
            this.vb = null;
            this.ib.destory();
            this.ib = null;
        };
        return Path;
    })();
    var SaveBase = (function () {
        function SaveBase() {
        }
        __class(SaveBase, 'laya.webgl.canvas.save.SaveBase');
        var __proto = SaveBase.prototype;
        Laya.imps(__proto, { "laya.webgl.canvas.save.ISaveData": true });
        __proto.isSaveMark = function () { return false; };
        __proto.restore = function (context) {
            this._dataObj[this._valueName] = this._value;
            SaveBase._cache[SaveBase._cache._length++] = this;
            this._newSubmit && (context._curSubmit = Submit.RENDERBASE, context._renderKey = 0);
        };
        SaveBase._createArray = function () {
            var value = [];
            value._length = 0;
            return value;
        };
        SaveBase._init = function () {
            var namemap = SaveBase._namemap = {};
            namemap[0x1] = "ALPHA";
            namemap[0x2] = "fillStyle";
            namemap[0x8] = "font";
            namemap[0x100] = "lineWidth";
            namemap[0x200] = "strokeStyle";
            namemap[0x2000] = "_mergeID";
            namemap[0x400] = namemap[0x800] = namemap[0x1000] = [];
            namemap[0x4000] = "textBaseline";
            namemap[0x8000] = "textAlign";
            namemap[0x10000] = "_nBlendType";
            namemap[0x100000] = "shader";
            namemap[0x200000] = "filters";
            return namemap;
        };
        SaveBase.save = function (context, type, dataObj, newSubmit) {
            if ((context._saveMark._saveuse & type) !== type) {
                context._saveMark._saveuse |= type;
                var cache = SaveBase._cache;
                var o = cache._length > 0 ? cache[--cache._length] : (new SaveBase());
                o._value = dataObj[o._valueName = SaveBase._namemap[type]];
                o._dataObj = dataObj;
                o._newSubmit = newSubmit;
                var _save = context._save;
                _save[_save._length++] = o;
            }
        };
        SaveBase._cache = laya.webgl.canvas.save.SaveBase._createArray();
        SaveBase._namemap = SaveBase._init();
        return SaveBase;
    })();
    var SaveClipRect = (function () {
        function SaveClipRect() {
            this._clipRect = new Rectangle();
        }
        __class(SaveClipRect, 'laya.webgl.canvas.save.SaveClipRect');
        var __proto = SaveClipRect.prototype;
        Laya.imps(__proto, { "laya.webgl.canvas.save.ISaveData": true });
        __proto.isSaveMark = function () { return false; };
        __proto.restore = function (context) {
            context._clipRect = this._clipSaveRect;
            SaveClipRect._cache[SaveClipRect._cache._length++] = this;
            this._submitScissor.submitLength = context._submits._length - this._submitScissor.submitIndex;
            context._curSubmit = Submit.RENDERBASE;
            context._renderKey = 0;
        };
        SaveClipRect.save = function (context, submitScissor) {
            if ((context._saveMark._saveuse & 0x20000) == 0x20000)
                return;
            context._saveMark._saveuse |= 0x20000;
            var cache = SaveClipRect._cache;
            var o = cache._length > 0 ? cache[--cache._length] : (new SaveClipRect());
            o._clipSaveRect = context._clipRect;
            context._clipRect = o._clipRect.copyFrom(context._clipRect);
            o._submitScissor = submitScissor;
            var _save = context._save;
            _save[_save._length++] = o;
        };
        __static(SaveClipRect, ['_cache', function () { return this._cache = SaveBase._createArray(); }
        ]);
        return SaveClipRect;
    })();
    var SaveClipRectStencil = (function () {
        function SaveClipRectStencil() {
            this._contextX = 0;
            this._contextY = 0;
            this._clipRect = new Rectangle();
            this._rect = new Rectangle();
            this._matrix = new Matrix();
        }
        __class(SaveClipRectStencil, 'laya.webgl.canvas.save.SaveClipRectStencil');
        var __proto = SaveClipRectStencil.prototype;
        Laya.imps(__proto, { "laya.webgl.canvas.save.ISaveData": true });
        __proto.isSaveMark = function () { return false; };
        __proto.restore = function (context) {
            SubmitStencil.restore(context, this._rect, this._saveMatrix, this._contextX, this._contextY);
            context._clipRect = this._clipSaveRect;
            context._curMat = this._saveMatrix;
            context._x = this._contextX;
            context._y = this._contextY;
            SaveClipRectStencil._cache[SaveClipRectStencil._cache._length++] = this;
            context._curSubmit = Submit.RENDERBASE;
        };
        SaveClipRectStencil.save = function (context, submitStencil, x, y, width, height, clipX, clipY, clipWidth, clipHeight) {
            if ((context._saveMark._saveuse & 0x40000) == 0x40000)
                return;
            context._saveMark._saveuse |= 0x40000;
            var cache = SaveClipRectStencil._cache;
            var o = cache._length > 0 ? cache[--cache._length] : (new SaveClipRectStencil());
            o._clipSaveRect = context._clipRect;
            o._clipRect.setTo(clipX, clipY, clipWidth, clipHeight);
            context._clipRect = o._clipRect;
            o._rect.x = x;
            o._rect.y = y;
            o._rect.width = width;
            o._rect.height = height;
            o._contextX = context._x;
            o._contextY = context._y;
            o._saveMatrix = context._curMat;
            context._curMat.copyTo(o._matrix);
            context._curMat = o._matrix;
            o._submitStencil = submitStencil;
            var _save = context._save;
            _save[_save._length++] = o;
        };
        __static(SaveClipRectStencil, ['_cache', function () { return this._cache = SaveBase._createArray(); }
        ]);
        return SaveClipRectStencil;
    })();
    var SaveMark = (function () {
        function SaveMark() {
            this._saveuse = 0;
            ;
        }
        __class(SaveMark, 'laya.webgl.canvas.save.SaveMark');
        var __proto = SaveMark.prototype;
        Laya.imps(__proto, { "laya.webgl.canvas.save.ISaveData": true });
        __proto.isSaveMark = function () {
            return true;
        };
        __proto.restore = function (context) {
            context._saveMark = this._preSaveMark;
            SaveMark._no[SaveMark._no._length++] = this;
        };
        SaveMark.Create = function (context) {
            var no = SaveMark._no;
            var o = no._length > 0 ? no[--no._length] : (new SaveMark());
            o._saveuse = 0;
            o._preSaveMark = context._saveMark;
            context._saveMark = o;
            return o;
        };
        __static(SaveMark, ['_no', function () { return this._no = SaveBase._createArray(); }
        ]);
        return SaveMark;
    })();
    var SaveTransform = (function () {
        function SaveTransform() {
            this._matrix = new Matrix();
        }
        __class(SaveTransform, 'laya.webgl.canvas.save.SaveTransform');
        var __proto = SaveTransform.prototype;
        Laya.imps(__proto, { "laya.webgl.canvas.save.ISaveData": true });
        __proto.isSaveMark = function () { return false; };
        __proto.restore = function (context) {
            context._curMat = this._savematrix;
            SaveTransform._no[SaveTransform._no._length++] = this;
        };
        SaveTransform.save = function (context) {
            var _saveMark = context._saveMark;
            if ((_saveMark._saveuse & 0x800) === 0x800)
                return;
            _saveMark._saveuse |= 0x800;
            var no = SaveTransform._no;
            var o = no._length > 0 ? no[--no._length] : (new SaveTransform());
            o._savematrix = context._curMat;
            context._curMat = context._curMat.copyTo(o._matrix);
            var _save = context._save;
            _save[_save._length++] = o;
        };
        __static(SaveTransform, ['_no', function () { return this._no = SaveBase._createArray(); }
        ]);
        return SaveTransform;
    })();
    var SaveTranslate = (function () {
        function SaveTranslate() {
        }
        __class(SaveTranslate, 'laya.webgl.canvas.save.SaveTranslate');
        var __proto = SaveTranslate.prototype;
        Laya.imps(__proto, { "laya.webgl.canvas.save.ISaveData": true });
        __proto.isSaveMark = function () { return false; };
        __proto.restore = function (context) {
            var mat = context._curMat;
            context._x = this._x;
            context._y = this._y;
            SaveTranslate._no[SaveTranslate._no._length++] = this;
        };
        SaveTranslate.save = function (context) {
            var no = SaveTranslate._no;
            var o = no._length > 0 ? no[--no._length] : (new SaveTranslate());
            o._x = context._x;
            o._y = context._y;
            var _save = context._save;
            _save[_save._length++] = o;
        };
        __static(SaveTranslate, ['_no', function () { return this._no = SaveBase._createArray(); }
        ]);
        return SaveTranslate;
    })();
    var RenderTargetMAX = (function () {
        function RenderTargetMAX() {
            this.target = null;
            this.repaint = false;
            this._width = NaN;
            this._height = NaN;
            this._sp = null;
            this._clipRect = new Rectangle();
        }
        __class(RenderTargetMAX, 'laya.webgl.resource.RenderTargetMAX');
        var __proto = RenderTargetMAX.prototype;
        __proto.setSP = function (sp) {
            this._sp = sp;
        };
        __proto.size = function (w, h) {
            var _$this = this;
            if (this._width === w && this._height === h) {
                this.target.size(w, h);
                return;
            }
            this.repaint = true;
            this._width = w;
            this._height = h;
            if (!this.target)
                this.target = RenderTarget2D.create(w, h);
            else
                this.target.size(w, h);
            if (!this.target.hasListener("recovered")) {
                this.target.on("recovered", this, function (e) {
                    Laya.timer.callLater(_$this._sp, _$this._sp.repaint);
                });
            }
        };
        __proto._flushToTarget = function (context, target) {
            if (target._destroy)
                return;
            var worldScissorTest = RenderState2D.worldScissorTest;
            var preworldClipRect = RenderState2D.worldClipRect;
            RenderState2D.worldClipRect = this._clipRect;
            this._clipRect.x = this._clipRect.y = 0;
            this._clipRect.width = this._width;
            this._clipRect.height = this._height;
            RenderState2D.worldScissorTest = false;
            WebGL.mainContext.disable(0x0C11);
            var preAlpha = RenderState2D.worldAlpha;
            var preMatrix4 = RenderState2D.worldMatrix4;
            var preMatrix = RenderState2D.worldMatrix;
            var preFilters = RenderState2D.worldFilters;
            var preShaderDefines = RenderState2D.worldShaderDefines;
            RenderState2D.worldMatrix = Matrix.EMPTY;
            RenderState2D.restoreTempArray();
            RenderState2D.worldMatrix4 = RenderState2D.TEMPMAT4_ARRAY;
            RenderState2D.worldAlpha = 1;
            RenderState2D.worldFilters = null;
            RenderState2D.worldShaderDefines = null;
            BaseShader.activeShader = null;
            target.start();
            Config.showCanvasMark ? target.clear(0, 1, 0, 0.3) : target.clear(0, 0, 0, 0);
            context.flush();
            target.end();
            BaseShader.activeShader = null;
            RenderState2D.worldAlpha = preAlpha;
            RenderState2D.worldMatrix4 = preMatrix4;
            RenderState2D.worldMatrix = preMatrix;
            RenderState2D.worldFilters = preFilters;
            RenderState2D.worldShaderDefines = preShaderDefines;
            RenderState2D.worldScissorTest = worldScissorTest;
            if (worldScissorTest) {
                var y = RenderState2D.height - preworldClipRect.y - preworldClipRect.height;
                WebGL.mainContext.scissor(preworldClipRect.x, y, preworldClipRect.width, preworldClipRect.height);
                WebGL.mainContext.enable(0x0C11);
            }
            RenderState2D.worldClipRect = preworldClipRect;
        };
        __proto.flush = function (context) {
            if (this.repaint) {
                this._flushToTarget(context, this.target);
                this.repaint = false;
            }
        };
        __proto.drawTo = function (context, x, y, width, height) {
            context.drawTexture(this.target.getTexture(), x, y, width, height, 0, 0);
        };
        __proto.destroy = function () {
            if (this.target) {
                this.target.destroy();
                this.target = null;
                this._sp = null;
            }
        };
        return RenderTargetMAX;
    })();
    var Shader2D = (function () {
        function Shader2D() {
            this.ALPHA = 1;
            this.shaderType = 0;
            this.defines = new ShaderDefines2D();
        }
        __class(Shader2D, 'laya.webgl.shader.d2.Shader2D');
        var __proto = Shader2D.prototype;
        __proto.destroy = function () {
            this.defines = null;
            this.filters = null;
            this.glTexture = null;
            this.strokeStyle = null;
            this.fillStyle = null;
        };
        Shader2D.__init__ = function () {
            Shader.addInclude("parts/ColorFilter_ps_uniform.glsl", "uniform vec4 colorAlpha;\nuniform mat4 colorMat;");
            Shader.addInclude("parts/ColorFilter_ps_logic.glsl", "mat4 alphaMat =colorMat;\n\nalphaMat[0][3] *= gl_FragColor.a;\nalphaMat[1][3] *= gl_FragColor.a;\nalphaMat[2][3] *= gl_FragColor.a;\n\ngl_FragColor = gl_FragColor * alphaMat;\ngl_FragColor += colorAlpha/255.0*gl_FragColor.a;\n");
            Shader.addInclude("parts/GlowFilter_ps_uniform.glsl", "uniform vec4 u_color;\nuniform float u_strength;\nuniform float u_blurX;\nuniform float u_blurY;\nuniform float u_offsetX;\nuniform float u_offsetY;\nuniform float u_textW;\nuniform float u_textH;");
            Shader.addInclude("parts/GlowFilter_ps_logic.glsl", "const float c_IterationTime = 10.0;\nfloat floatIterationTotalTime = c_IterationTime * c_IterationTime;\nvec4 vec4Color = vec4(0.0,0.0,0.0,0.0);\nvec2 vec2FilterDir = vec2(-(u_offsetX)/u_textW,-(u_offsetY)/u_textH);\nvec2 vec2FilterOff = vec2(u_blurX/u_textW/c_IterationTime * 2.0,u_blurY/u_textH/c_IterationTime * 2.0);\nfloat maxNum = u_blurX * u_blurY;\nvec2 vec2Off = vec2(0.0,0.0);\nfloat floatOff = c_IterationTime/2.0;\nfor(float i = 0.0;i<=c_IterationTime; ++i){\n	for(float j = 0.0;j<=c_IterationTime; ++j){\n		vec2Off = vec2(vec2FilterOff.x * (i - floatOff),vec2FilterOff.y * (j - floatOff));\n		vec4Color += texture2D(texture, v_texcoord + vec2FilterDir + vec2Off)/floatIterationTotalTime;\n	}\n}\ngl_FragColor = vec4(u_color.rgb,vec4Color.a * u_strength);\ngl_FragColor.rgb *= gl_FragColor.a;");
            Shader.addInclude("parts/BlurFilter_ps_logic.glsl", "gl_FragColor =   blur();\ngl_FragColor.w*=alpha;");
            Shader.addInclude("parts/BlurFilter_ps_uniform.glsl", "uniform vec4 strength_sig2_2sig2_gauss1;\nuniform vec2 blurInfo;\n\n#define PI 3.141593\n\n//float sigma=strength/3.0;//3σ以外影响很小。即当σ=1的时候，半径为3\n//float sig2 = sigma*sigma;\n//float _2sig2 = 2.0*sig2;\n//return 1.0/(2*PI*sig2)*exp(-(x*x+y*y)/_2sig2)\n//float gauss1 = 1.0/(2.0*PI*sig2);\n\nfloat getGaussian(float x, float y){\n    return strength_sig2_2sig2_gauss1.w*exp(-(x*x+y*y)/strength_sig2_2sig2_gauss1.z);\n}\n\nvec4 blur(){\n    const float blurw = 9.0;\n    vec4 vec4Color = vec4(0.0,0.0,0.0,0.0);\n    vec2 halfsz=vec2(blurw,blurw)/2.0/blurInfo;    \n    vec2 startpos=v_texcoord-halfsz;\n    vec2 ctexcoord = startpos;\n    vec2 step = 1.0/blurInfo;  //每个像素      \n    \n    for(float y = 0.0;y<=blurw; ++y){\n        ctexcoord.x=startpos.x;\n        for(float x = 0.0;x<=blurw; ++x){\n            //TODO 纹理坐标的固定偏移应该在vs中处理\n            vec4Color += texture2D(texture, ctexcoord)*getGaussian(x-blurw/2.0,y-blurw/2.0);\n            ctexcoord.x+=step.x;\n        }\n        ctexcoord.y+=step.y;\n    }\n    return vec4Color;\n}");
            Shader.addInclude("parts/ColorAdd_ps_uniform.glsl", "uniform vec4 colorAdd;\n");
            Shader.addInclude("parts/ColorAdd_ps_logic.glsl", "gl_FragColor = vec4(colorAdd.rgb,colorAdd.a*gl_FragColor.a);\ngl_FragColor.xyz *= colorAdd.a;");
            var vs, ps;
            vs = "attribute vec4 position;\nattribute vec2 texcoord;\nuniform vec2 size;\n\n#ifdef WORLDMAT\nuniform mat4 mmat;\n#endif\nvarying vec2 v_texcoord;\nvoid main() {\n  #ifdef WORLDMAT\n  vec4 pos=mmat*position;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  #else\n  gl_Position =vec4((position.x/size.x-0.5)*2.0,(0.5-position.y/size.y)*2.0,position.z,1.0);\n  #endif\n  \n  v_texcoord = texcoord;\n}";
            ps = "precision mediump float;\n//precision highp float;\nvarying vec2 v_texcoord;\nuniform sampler2D texture;\nuniform float alpha;\n#include?BLUR_FILTER  \"parts/BlurFilter_ps_uniform.glsl\";\n#include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\n#include?GLOW_FILTER \"parts/GlowFilter_ps_uniform.glsl\";\n#include?COLOR_ADD \"parts/ColorAdd_ps_uniform.glsl\";\n\nvoid main() {\n   vec4 color= texture2D(texture, v_texcoord);\n   color.a*=alpha;\n   color.rgb*=alpha;\n   gl_FragColor=color;\n   #include?COLOR_ADD \"parts/ColorAdd_ps_logic.glsl\";   \n   #include?BLUR_FILTER  \"parts/BlurFilter_ps_logic.glsl\";\n   #include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n   #include?GLOW_FILTER \"parts/GlowFilter_ps_logic.glsl\";\n}";
            Shader.preCompile2D(0, /*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/ 0x01, vs, ps, null);
            vs = "attribute vec4 position;\nuniform vec2 size;\nuniform mat4 mmat;\nvoid main() {\n  vec4 pos=mmat*position;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n}";
            ps = "precision mediump float;\nuniform vec4 color;\nuniform float alpha;\n#include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\nvoid main() {\n	vec4 a = vec4(color.r, color.g, color.b, color.a);\n	a.w = alpha;\n	a.xyz *= alpha;\n	gl_FragColor = a;\n	#include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n}";
            Shader.preCompile2D(0, 0x02, vs, ps, null);
            vs = "attribute vec4 position;\nattribute vec3 a_color;\nuniform mat4 mmat;\nuniform mat4 u_mmat2;\nuniform vec2 u_pos;\nuniform vec2 size;\nvarying vec3 color;\nvoid main(){\n  vec4 tPos = vec4(position.x + u_pos.x,position.y + u_pos.y,position.z,position.w);\n  vec4 pos=mmat*u_mmat2*tPos;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  color=a_color;\n}";
            ps = "precision mediump float;\n//precision mediump float;\nvarying vec3 color;\nuniform float alpha;\nvoid main(){\n	//vec4 a=vec4(color.r, color.g, color.b, 1);\n	//a.a*=alpha;\n    gl_FragColor=vec4(color.r, color.g, color.b, alpha);\n	gl_FragColor.rgb*=alpha;\n}";
            Shader.preCompile2D(0, 0x04, vs, ps, null);
            vs = "attribute vec4 position;\nattribute vec2 texcoord;\nuniform vec2 size;\n\n#ifdef WORLDMAT\nuniform mat4 mmat;\n#endif\nvarying vec2 v_texcoord;\nvoid main() {\n  #ifdef WORLDMAT\n  vec4 pos=mmat*position;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  #else\n  gl_Position =vec4((position.x/size.x-0.5)*2.0,(0.5-position.y/size.y)*2.0,position.z,1.0);\n  #endif\n  \n  v_texcoord = texcoord;\n}";
            ps = "#ifdef FSHIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n//precision highp float;\nvarying vec2 v_texcoord;\nuniform sampler2D texture;\nuniform float alpha;\nuniform vec4 u_TexRange;\nuniform vec2 u_offset;\n#include?BLUR_FILTER  \"parts/BlurFilter_ps_uniform.glsl\";\n#include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\n#include?GLOW_FILTER \"parts/GlowFilter_ps_uniform.glsl\";\n#include?COLOR_ADD \"parts/ColorAdd_ps_uniform.glsl\";\n\nvoid main() {\n   vec2 newTexCoord;\n   newTexCoord.x = mod(u_offset.x + v_texcoord.x,u_TexRange.y) + u_TexRange.x;\n   newTexCoord.y = mod(u_offset.y + v_texcoord.y,u_TexRange.w) + u_TexRange.z;\n   vec4 color= texture2D(texture, newTexCoord);\n if(color.a<1.0)color.rgb*=1.0/color.a;  color.a*=alpha;\n   gl_FragColor=color;\n   #include?COLOR_ADD \"parts/ColorAdd_ps_logic.glsl\";   \n   #include?BLUR_FILTER  \"parts/BlurFilter_ps_logic.glsl\";\n   #include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n   #include?GLOW_FILTER \"parts/GlowFilter_ps_logic.glsl\";\n}";
            Shader.preCompile2D(0, 0x100, vs, ps, null);
            vs = "attribute vec2 position;\nattribute vec2 texcoord;\nattribute vec4 color;\nuniform vec2 size;\nuniform float offsetX;\nuniform float offsetY;\nuniform mat4 mmat;\nuniform mat4 u_mmat2;\nvarying vec2 v_texcoord;\nvarying vec4 v_color;\nvoid main() {\n  vec4 pos=mmat*u_mmat2*vec4(offsetX+position.x,offsetY+position.y,0,1 );\n  gl_Position = vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  v_color = color;\n  v_color.rgb *= v_color.a;\n  v_texcoord = texcoord;  \n}";
            ps = "precision mediump float;\nvarying vec2 v_texcoord;\nvarying vec4 v_color;\nuniform sampler2D texture;\nuniform float alpha;\nvoid main() {\n	vec4 t_color = texture2D(texture, v_texcoord);\n	gl_FragColor = t_color.rgba * v_color;\n	gl_FragColor *= alpha;\n}";
            Shader.preCompile2D(0, 0x200, vs, ps, null);
        };
        return Shader2D;
    })();
    var ShaderDefines = (function () {
        function ShaderDefines(name2int, int2name, int2nameMap) {
            this._value = 0;
            this._name2int = name2int;
            this._int2name = int2name;
            this._int2nameMap = int2nameMap;
        }
        __class(ShaderDefines, 'laya.webgl.shader.ShaderDefines');
        var __proto = ShaderDefines.prototype;
        __proto.add = function (value) {
            if ((typeof value == 'string'))
                value = this._name2int[value];
            this._value |= value;
            return this._value;
        };
        __proto.addInt = function (value) {
            this._value |= value;
            return this._value;
        };
        __proto.remove = function (value) {
            if ((typeof value == 'string'))
                value = this._name2int[value];
            this._value &= (~value);
            return this._value;
        };
        __proto.isDefine = function (def) {
            return (this._value & def) === def;
        };
        __proto.getValue = function () {
            return this._value;
        };
        __proto.setValue = function (value) {
            this._value = value;
        };
        __proto.toNameDic = function (shaderValue) {
            var r = this._int2nameMap[this._value];
            var res = (r && !shaderValue.kdsSetMaterialMacros) ? r : ShaderDefines._toText(this._value, this._int2name, this._int2nameMap, true);
            if (shaderValue.kdsSetMaterialMacros) {
                for (var i = 0; i < shaderValue.kdsSetMaterialMacros.length; i++) {
                    var kdsMaterialID = shaderValue.kdsSetMaterialMacros[i];
                    res["KDS_M" + kdsMaterialID] = (i + 1);
                }
                for (var i = 0; i < shaderValue.kdsVarMacros.length; i++) {
                    res[shaderValue.kdsVarMacros[i]] = "";
                }
            }
            return res;
        };
        ShaderDefines._reg = function (name, value, _name2int, _int2name) {
            _name2int[name] = value;
            _int2name[value] = name;
        };
        ShaderDefines._toText = function (value, _int2name, _int2nameMap, ignoreCache) {
            var r = _int2nameMap[value];
            if (r && !ignoreCache)
                return r;
            var o = {};
            var d = 1;
            for (var i = 0; i < 32; i++) {
                d = 1 << i;
                if (d > value)
                    break;
                if (value & d) {
                    var name = _int2name[d];
                    if (name && name.indexOf("KDS_M") == 0)
                        continue;
                    name && (o[name] = "");
                }
            }
            _int2nameMap[value] = o;
            return o;
        };
        ShaderDefines._toInt = function (names, _name2int) {
            var words = names.split('.');
            var num = 0;
            for (var i = 0, n = words.length; i < n; i++) {
                var value = _name2int[words[i]];
                if (!value)
                    throw new Error("Defines to int err:" + names + "/" + words[i]);
                num |= value;
            }
            return num;
        };
        return ShaderDefines;
    })();
    var SkinMesh = (function () {
        function SkinMesh() {
            this.mVBBuffer = null;
            this.mIBBuffer = null;
            this.mVBData = null;
            this.mIBData = null;
            this.mEleNum = 0;
            this.mTexture = null;
            this.transform = null;
            this._vs = null;
            this._ps = null;
            this._indexStart = -1;
            this._verticles = null;
            this._uvs = null;
            this._tempMatrix = new Matrix();
        }
        __class(SkinMesh, 'laya.webgl.shader.d2.skinAnishader.SkinMesh');
        var __proto = SkinMesh.prototype;
        __proto.init = function (texture, vs, ps) {
            if (vs) {
                this._vs = vs;
            }
            else {
                this._vs = [];
                var tWidth = texture.width;
                var tHeight = texture.height;
                var tRed = 1;
                var tGreed = 1;
                var tBlue = 1;
                var tAlpha = 1;
                this._vs.push(0, 0, 0, 0, tRed, tGreed, tBlue, tAlpha);
                this._vs.push(tWidth, 0, 1, 0, tRed, tGreed, tBlue, tAlpha);
                this._vs.push(tWidth, tHeight, 1, 1, tRed, tGreed, tBlue, tAlpha);
                this._vs.push(0, tHeight, 0, 1, tRed, tGreed, tBlue, tAlpha);
            }
            if (ps) {
                this._ps = ps;
            }
            else {
                if (!SkinMesh._defaultPS) {
                    SkinMesh._defaultPS = [];
                    SkinMesh._defaultPS.push(0, 1, 3, 3, 1, 2);
                }
                this._ps = SkinMesh._defaultPS;
            }
            this.mVBData = new Float32Array(this._vs);
            this.mIBData = new Uint16Array(this._ps.length);
            this.mIBData["start"] = -1;
            this.mEleNum = this._ps.length;
            this.mTexture = texture;
        };
        __proto.init2 = function (texture, vs, ps, verticles, uvs) {
            if (this.transform)
                this.transform = null;
            if (ps) {
                this._ps = ps;
            }
            else {
                this._ps = [];
                this._ps.push(0, 1, 3, 3, 1, 2);
            }
            this._verticles = verticles;
            this._uvs = uvs;
            this.mEleNum = this._ps.length;
            this.mTexture = texture;
            if (Render.isConchNode || Render.isConchApp) {
                this._initMyData();
                this.mVBData = new Float32Array(this._vs);
            }
        };
        __proto._initMyData = function () {
            var vsI = 0;
            var vI = 0;
            var vLen = this._verticles.length;
            var tempVLen = vLen * 4;
            this._vs = SkinMesh._tempVS;
            var insertNew = false;
            if (Render.isConchNode || Render.isConchApp) {
                this._vs.length = tempVLen;
                insertNew = true;
            }
            else {
                if (this._vs.length < tempVLen) {
                    this._vs.length = tempVLen;
                    insertNew = true;
                }
            }
            SkinMesh._tVSLen = tempVLen;
            if (insertNew) {
                while (vsI < tempVLen) {
                    this._vs[vsI] = this._verticles[vI];
                    this._vs[vsI + 1] = this._verticles[vI + 1];
                    this._vs[vsI + 2] = this._uvs[vI];
                    this._vs[vsI + 3] = this._uvs[vI + 1];
                    this._vs[vsI + 4] = 1;
                    this._vs[vsI + 5] = 1;
                    this._vs[vsI + 6] = 1;
                    this._vs[vsI + 7] = 1;
                    vsI += 8;
                    vI += 2;
                }
            }
            else {
                while (vsI < tempVLen) {
                    this._vs[vsI] = this._verticles[vI];
                    this._vs[vsI + 1] = this._verticles[vI + 1];
                    this._vs[vsI + 2] = this._uvs[vI];
                    this._vs[vsI + 3] = this._uvs[vI + 1];
                    vsI += 8;
                    vI += 2;
                }
            }
        };
        __proto.getData2 = function (vb, ib, start) {
            this.mVBBuffer = vb;
            this.mIBBuffer = ib;
            this._initMyData();
            vb.appendEx2(this._vs, Float32Array, SkinMesh._tVSLen, 4);
            this._indexStart = ib._byteLength;
            var tIB;
            tIB = SkinMesh._tempIB;
            if (tIB.length < this._ps.length) {
                tIB.length = this._ps.length;
            }
            for (var i = 0, n = this._ps.length; i < n; i++) {
                tIB[i] = this._ps[i] + start;
            }
            ib.appendEx2(tIB, Uint16Array, this._ps.length, 2);
        };
        __proto.getData = function (vb, ib, start) {
            this.mVBBuffer = vb;
            this.mIBBuffer = ib;
            vb.append(this.mVBData);
            this._indexStart = ib._byteLength;
            if (this.mIBData["start"] != start) {
                for (var i = 0, n = this._ps.length; i < n; i++) {
                    this.mIBData[i] = this._ps[i] + start;
                }
                this.mIBData["start"] = start;
            }
            ib.append(this.mIBData);
        };
        __proto.render = function (context, x, y) {
            if (Render.isWebGL && this.mTexture) {
                context._renderKey = 0;
                context._shader2D.glTexture = null;
                SkinMeshBuffer.getInstance().addSkinMesh(this);
                var tempSubmit = Submit.createShape(context, this.mIBBuffer, this.mVBBuffer, this.mEleNum, this._indexStart, Value2D.create(0x200, 0));
                this.transform || (this.transform = Matrix.EMPTY);
                this.transform.translate(x, y);
                Matrix.mul(this.transform, context._curMat, this._tempMatrix);
                this.transform.translate(-x, -y);
                var tShaderValue = tempSubmit.shaderValue;
                var tArray = tShaderValue.u_mmat2 || RenderState2D.getMatrArray();
                RenderState2D.mat2MatArray(this._tempMatrix, tArray);
                tShaderValue.textureHost = this.mTexture;
                tShaderValue.offsetX = 0;
                tShaderValue.offsetY = 0;
                tShaderValue.u_mmat2 = tArray;
                tShaderValue.ALPHA = context._shader2D.ALPHA;
                context._submits[context._submits._length++] = tempSubmit;
            }
            else if (Render.isConchApp && this.mTexture) {
                this.transform || (this.transform = Matrix.EMPTY);
                context.setSkinMesh && context.setSkinMesh(x, y, this._ps, this.mVBData, this.mEleNum, 0, this.mTexture, this.transform);
            }
        };
        SkinMesh._tempVS = [];
        SkinMesh._tempIB = [];
        SkinMesh._defaultPS = null;
        SkinMesh._tVSLen = 0;
        return SkinMesh;
    })();
    var SkinMeshBuffer = (function () {
        function SkinMeshBuffer() {
            this.ib = null;
            this.vb = null;
            var gl = WebGL.mainContext;
            this.ib = IndexBuffer2D.create(0x88E8);
            this.vb = VertexBuffer2D.create(8);
        }
        __class(SkinMeshBuffer, 'laya.webgl.shader.d2.skinAnishader.SkinMeshBuffer');
        var __proto = SkinMeshBuffer.prototype;
        __proto.addSkinMesh = function (skinMesh) {
            skinMesh.getData2(this.vb, this.ib, this.vb._byteLength / 32);
        };
        __proto.reset = function () {
            this.vb.clear();
            this.ib.clear();
        };
        SkinMeshBuffer.getInstance = function () {
            return SkinMeshBuffer.instance = SkinMeshBuffer.instance || new SkinMeshBuffer();
        };
        SkinMeshBuffer.instance = null;
        return SkinMeshBuffer;
    })();
    var BasePoly = (function () {
        function BasePoly(x, y, width, height, edges, color, borderWidth, borderColor, round) {
            this.r0 = 0;
            this.fill = true;
            this.r1 = Math.PI / 2;
            (round === void 0) && (round = 0);
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.edges = edges;
            this.color = color;
            this.borderWidth = borderWidth;
            this.borderColor = borderColor;
        }
        __class(BasePoly, 'laya.webgl.shapes.BasePoly');
        var __proto = BasePoly.prototype;
        Laya.imps(__proto, { "laya.webgl.shapes.IShape": true });
        __proto.getData = function (ib, vb, start) { };
        __proto.rebuild = function (points) { };
        __proto.setMatrix = function (mat) { };
        __proto.needUpdate = function (mat) {
            return true;
        };
        __proto.sector = function (outVert, outIndex, start) {
            var x = this.x, y = this.y, edges = this.edges, seg = (this.r1 - this.r0) / edges;
            var w = this.width, h = this.height, color = this.color;
            var r = ((color >> 16) & 0x0000ff) / 255, g = ((color >> 8) & 0xff) / 255, b = (color & 0x0000ff) / 255;
            outVert.push(x, y, r, g, b);
            for (var i = 0; i < edges + 1; i++) {
                outVert.push(x + Math.sin(seg * i + this.r0) * w, y + Math.cos(seg * i + this.r0) * h);
                outVert.push(r, g, b);
            }
            for (i = 0; i < edges; i++) {
                outIndex.push(start, start + i + 1, start + i + 2);
            }
        };
        __proto.createLine2 = function (p, indices, lineWidth, len, outVertex, indexCount) {
            var points = p.concat();
            var result = outVertex;
            var color = this.borderColor;
            var r = ((color >> 16) & 0x0000ff) / 255, g = ((color >> 8) & 0xff) / 255, b = (color & 0x0000ff) / 255;
            var length = points.length / 2;
            var iStart = len, w = lineWidth / 2;
            var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
            var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
            var a1, b1, c1, a2, b2, c2;
            var denom, pdist, dist;
            p1x = points[0];
            p1y = points[1];
            p2x = points[2];
            p2y = points[3];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt(perpx * perpx + perpy * perpy);
            perpx = perpx / dist * w;
            perpy = perpy / dist * w;
            result.push(p1x - perpx + this.x, p1y - perpy + this.y, r, g, b, p1x + perpx + this.x, p1y + perpy + this.y, r, g, b);
            for (var i = 1; i < length - 1; i++) {
                p1x = points[(i - 1) * 2];
                p1y = points[(i - 1) * 2 + 1];
                p2x = points[(i) * 2];
                p2y = points[(i) * 2 + 1];
                p3x = points[(i + 1) * 2];
                p3y = points[(i + 1) * 2 + 1];
                perpx = -(p1y - p2y);
                perpy = p1x - p2x;
                dist = Math.sqrt(perpx * perpx + perpy * perpy);
                perpx = perpx / dist * w;
                perpy = perpy / dist * w;
                perp2x = -(p2y - p3y);
                perp2y = p2x - p3x;
                dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
                perp2x = perp2x / dist * w;
                perp2y = perp2y / dist * w;
                a1 = (-perpy + p1y) - (-perpy + p2y);
                b1 = (-perpx + p2x) - (-perpx + p1x);
                c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
                a2 = (-perp2y + p3y) - (-perp2y + p2y);
                b2 = (-perp2x + p2x) - (-perp2x + p3x);
                c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
                denom = a1 * b2 - a2 * b1;
                if (Math.abs(denom) < 0.1) {
                    denom += 10.1;
                    result.push(p2x - perpx + this.x, p2y - perpy + this.y, r, g, b, p2x + perpx + this.x, p2y + perpy + this.y, r, g, b);
                    continue;
                }
                px = (b1 * c2 - b2 * c1) / denom;
                py = (a2 * c1 - a1 * c2) / denom;
                pdist = (px - p2x) * (px - p2x) + (py - p2y) + (py - p2y);
                result.push(px + this.x, py + this.y, r, g, b, p2x - (px - p2x) + this.x, p2y - (py - p2y) + this.y, r, g, b);
            }
            p1x = points[points.length - 4];
            p1y = points[points.length - 3];
            p2x = points[points.length - 2];
            p2y = points[points.length - 1];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt(perpx * perpx + perpy * perpy);
            perpx = perpx / dist * w;
            perpy = perpy / dist * w;
            result.push(p2x - perpx + this.x, p2y - perpy + this.y, r, g, b, p2x + perpx + this.x, p2y + perpy + this.y, r, g, b);
            var groupLen = indexCount;
            for (i = 1; i < groupLen; i++) {
                indices.push(iStart + (i - 1) * 2, iStart + (i - 1) * 2 + 1, iStart + i * 2 + 1, iStart + i * 2 + 1, iStart + i * 2, iStart + (i - 1) * 2);
            }
            return result;
        };
        __proto.createLine = function (p, indices, lineWidth, len) {
            var points = p.concat();
            var result = p;
            var color = this.borderColor;
            var r = ((color >> 16) & 0x0000ff) / 255, g = ((color >> 8) & 0xff) / 255, b = (color & 0x0000ff) / 255;
            points.splice(0, 5);
            var length = points.length / 5;
            var iStart = len, w = lineWidth / 2;
            var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
            var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
            var a1, b1, c1, a2, b2, c2;
            var denom, pdist, dist;
            p1x = points[0];
            p1y = points[1];
            p2x = points[5];
            p2y = points[6];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt(perpx * perpx + perpy * perpy);
            perpx = perpx / dist * w;
            perpy = perpy / dist * w;
            result.push(p1x - perpx, p1y - perpy, r, g, b, p1x + perpx, p1y + perpy, r, g, b);
            for (var i = 1; i < length - 1; i++) {
                p1x = points[(i - 1) * 5];
                p1y = points[(i - 1) * 5 + 1];
                p2x = points[(i) * 5];
                p2y = points[(i) * 5 + 1];
                p3x = points[(i + 1) * 5];
                p3y = points[(i + 1) * 5 + 1];
                perpx = -(p1y - p2y);
                perpy = p1x - p2x;
                dist = Math.sqrt(perpx * perpx + perpy * perpy);
                perpx = perpx / dist * w;
                perpy = perpy / dist * w;
                perp2x = -(p2y - p3y);
                perp2y = p2x - p3x;
                dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
                perp2x = perp2x / dist * w;
                perp2y = perp2y / dist * w;
                a1 = (-perpy + p1y) - (-perpy + p2y);
                b1 = (-perpx + p2x) - (-perpx + p1x);
                c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
                a2 = (-perp2y + p3y) - (-perp2y + p2y);
                b2 = (-perp2x + p2x) - (-perp2x + p3x);
                c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
                denom = a1 * b2 - a2 * b1;
                if (Math.abs(denom) < 0.1) {
                    denom += 10.1;
                    result.push(p2x - perpx, p2y - perpy, r, g, b, p2x + perpx, p2y + perpy, r, g, b);
                    continue;
                }
                px = (b1 * c2 - b2 * c1) / denom;
                py = (a2 * c1 - a1 * c2) / denom;
                pdist = (px - p2x) * (px - p2x) + (py - p2y) + (py - p2y);
                result.push(px, py, r, g, b, p2x - (px - p2x), p2y - (py - p2y), r, g, b);
            }
            p1x = points[points.length - 10];
            p1y = points[points.length - 9];
            p2x = points[points.length - 5];
            p2y = points[points.length - 4];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt(perpx * perpx + perpy * perpy);
            perpx = perpx / dist * w;
            perpy = perpy / dist * w;
            result.push(p2x - perpx, p2y - perpy, r, g, b, p2x + perpx, p2y + perpy, r, g, b);
            var groupLen = this.edges + 1;
            for (i = 1; i < groupLen; i++) {
                indices.push(iStart + (i - 1) * 2, iStart + (i - 1) * 2 + 1, iStart + i * 2 + 1, iStart + i * 2 + 1, iStart + i * 2, iStart + (i - 1) * 2);
            }
            return result;
        };
        __proto.createLoopLine = function (p, indices, lineWidth, len, outVertex, outIndex) {
            var points = p.concat();
            var result = outVertex ? outVertex : p;
            var color = this.borderColor;
            var r = ((color >> 16) & 0x0000ff) / 255, g = ((color >> 8) & 0xff) / 255, b = (color & 0x0000ff) / 255;
            points.splice(0, 5);
            var firstPoint = [points[0], points[1]];
            var lastPoint = [points[points.length - 5], points[points.length - 4]];
            var midPointX = lastPoint[0] + (firstPoint[0] - lastPoint[0]) * 0.5;
            var midPointY = lastPoint[1] + (firstPoint[1] - lastPoint[1]) * 0.5;
            points.unshift(midPointX, midPointY, 0, 0, 0);
            points.push(midPointX, midPointY, 0, 0, 0);
            var length = points.length / 5;
            var iStart = len, w = lineWidth / 2;
            var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
            var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
            var a1, b1, c1, a2, b2, c2;
            var denom, pdist, dist;
            p1x = points[0];
            p1y = points[1];
            p2x = points[5];
            p2y = points[6];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt(perpx * perpx + perpy * perpy);
            perpx = perpx / dist * w;
            perpy = perpy / dist * w;
            result.push(p1x - perpx, p1y - perpy, r, g, b, p1x + perpx, p1y + perpy, r, g, b);
            for (var i = 1; i < length - 1; i++) {
                p1x = points[(i - 1) * 5];
                p1y = points[(i - 1) * 5 + 1];
                p2x = points[(i) * 5];
                p2y = points[(i) * 5 + 1];
                p3x = points[(i + 1) * 5];
                p3y = points[(i + 1) * 5 + 1];
                perpx = -(p1y - p2y);
                perpy = p1x - p2x;
                dist = Math.sqrt(perpx * perpx + perpy * perpy);
                perpx = perpx / dist * w;
                perpy = perpy / dist * w;
                perp2x = -(p2y - p3y);
                perp2y = p2x - p3x;
                dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
                perp2x = perp2x / dist * w;
                perp2y = perp2y / dist * w;
                a1 = (-perpy + p1y) - (-perpy + p2y);
                b1 = (-perpx + p2x) - (-perpx + p1x);
                c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
                a2 = (-perp2y + p3y) - (-perp2y + p2y);
                b2 = (-perp2x + p2x) - (-perp2x + p3x);
                c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
                denom = a1 * b2 - a2 * b1;
                if (Math.abs(denom) < 0.1) {
                    denom += 10.1;
                    result.push(p2x - perpx, p2y - perpy, r, g, b, p2x + perpx, p2y + perpy, r, g, b);
                    continue;
                }
                px = (b1 * c2 - b2 * c1) / denom;
                py = (a2 * c1 - a1 * c2) / denom;
                pdist = (px - p2x) * (px - p2x) + (py - p2y) + (py - p2y);
                result.push(px, py, r, g, b, p2x - (px - p2x), p2y - (py - p2y), r, g, b);
            }
            if (outIndex) {
                indices = outIndex;
            }
            ;
            var groupLen = this.edges + 1;
            for (i = 1; i < groupLen; i++) {
                indices.push(iStart + (i - 1) * 2, iStart + (i - 1) * 2 + 1, iStart + i * 2 + 1, iStart + i * 2 + 1, iStart + i * 2, iStart + (i - 1) * 2);
            }
            indices.push(iStart + (i - 1) * 2, iStart + (i - 1) * 2 + 1, iStart + 1, iStart + 1, iStart, iStart + (i - 1) * 2);
            return result;
        };
        return BasePoly;
    })();
    var Earcut = (function () {
        function Earcut() { }
        __class(Earcut, 'laya.webgl.shapes.Earcut');
        Earcut.earcut = function (data, holeIndices, dim) {
            dim = dim || 2;
            var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = Earcut.linkedList(data, 0, outerLen, dim, true), triangles = [];
            if (!outerNode)
                return triangles;
            var minX, minY, maxX, maxY, x, y, invSize;
            if (hasHoles)
                outerNode = Earcut.eliminateHoles(data, holeIndices, outerNode, dim);
            if (data.length > 80 * dim) {
                minX = maxX = data[0];
                minY = maxY = data[1];
                for (var i = dim; i < outerLen; i += dim) {
                    x = data[i];
                    y = data[i + 1];
                    if (x < minX)
                        minX = x;
                    if (y < minY)
                        minY = y;
                    if (x > maxX)
                        maxX = x;
                    if (y > maxY)
                        maxY = y;
                }
                invSize = Math.max(maxX - minX, maxY - minY);
                invSize = invSize !== 0 ? 1 / invSize : 0;
            }
            Earcut.earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
            return triangles;
        };
        Earcut.linkedList = function (data, start, end, dim, clockwise) {
            var i, last;
            if (clockwise === (Earcut.signedArea(data, start, end, dim) > 0)) {
                for (i = start; i < end; i += dim)
                    last = Earcut.insertNode(i, data[i], data[i + 1], last);
            }
            else {
                for (i = end - dim; i >= start; i -= dim)
                    last = Earcut.insertNode(i, data[i], data[i + 1], last);
            }
            if (last && Earcut.equals(last, last.next)) {
                Earcut.removeNode(last);
                last = last.next;
            }
            return last;
        };
        Earcut.filterPoints = function (start, end) {
            if (!start)
                return start;
            if (!end)
                end = start;
            var p = start, again;
            do {
                again = false;
                if (!p.steiner && (Earcut.equals(p, p.next) || Earcut.area(p.prev, p, p.next) === 0)) {
                    Earcut.removeNode(p);
                    p = end = p.prev;
                    if (p === p.next)
                        break;
                    again = true;
                }
                else {
                    p = p.next;
                }
            } while (again || p !== end);
            return end;
        };
        Earcut.earcutLinked = function (ear, triangles, dim, minX, minY, invSize, pass) {
            if (!ear)
                return;
            if (!pass && invSize)
                Earcut.indexCurve(ear, minX, minY, invSize);
            var stop = ear, prev, next;
            while (ear.prev !== ear.next) {
                prev = ear.prev;
                next = ear.next;
                if (invSize ? Earcut.isEarHashed(ear, minX, minY, invSize) : Earcut.isEar(ear)) {
                    triangles.push(prev.i / dim);
                    triangles.push(ear.i / dim);
                    triangles.push(next.i / dim);
                    Earcut.removeNode(ear);
                    ear = next.next;
                    stop = next.next;
                    continue;
                }
                ear = next;
                if (ear === stop) {
                    if (!pass) {
                        Earcut.earcutLinked(Earcut.filterPoints(ear, null), triangles, dim, minX, minY, invSize, 1);
                    }
                    else if (pass === 1) {
                        ear = Earcut.cureLocalIntersections(ear, triangles, dim);
                        Earcut.earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                    }
                    else if (pass === 2) {
                        Earcut.splitEarcut(ear, triangles, dim, minX, minY, invSize);
                    }
                    break;
                }
            }
        };
        Earcut.isEar = function (ear) {
            var a = ear.prev, b = ear, c = ear.next;
            if (Earcut.area(a, b, c) >= 0)
                return false;
            var p = ear.next.next;
            while (p !== ear.prev) {
                if (Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                    Earcut.area(p.prev, p, p.next) >= 0)
                    return false;
                p = p.next;
            }
            return true;
        };
        Earcut.isEarHashed = function (ear, minX, minY, invSize) {
            var a = ear.prev, b = ear, c = ear.next;
            if (Earcut.area(a, b, c) >= 0)
                return false;
            var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
            var minZ = Earcut.zOrder(minTX, minTY, minX, minY, invSize), maxZ = Earcut.zOrder(maxTX, maxTY, minX, minY, invSize);
            var p = ear.nextZ;
            while (p && p.z <= maxZ) {
                if (p !== ear.prev && p !== ear.next &&
                    Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                    Earcut.area(p.prev, p, p.next) >= 0)
                    return false;
                p = p.nextZ;
            }
            p = ear.prevZ;
            while (p && p.z >= minZ) {
                if (p !== ear.prev && p !== ear.next &&
                    Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                    Earcut.area(p.prev, p, p.next) >= 0)
                    return false;
                p = p.prevZ;
            }
            return true;
        };
        Earcut.cureLocalIntersections = function (start, triangles, dim) {
            var p = start;
            do {
                var a = p.prev, b = p.next.next;
                if (!Earcut.equals(a, b) && Earcut.intersects(a, p, p.next, b) && Earcut.locallyInside(a, b) && Earcut.locallyInside(b, a)) {
                    triangles.push(a.i / dim);
                    triangles.push(p.i / dim);
                    triangles.push(b.i / dim);
                    Earcut.removeNode(p);
                    Earcut.removeNode(p.next);
                    p = start = b;
                }
                p = p.next;
            } while (p !== start);
            return p;
        };
        Earcut.splitEarcut = function (start, triangles, dim, minX, minY, invSize) {
            var a = start;
            do {
                var b = a.next.next;
                while (b !== a.prev) {
                    if (a.i !== b.i && Earcut.isValidDiagonal(a, b)) {
                        var c = Earcut.splitPolygon(a, b);
                        a = Earcut.filterPoints(a, a.next);
                        c = Earcut.filterPoints(c, c.next);
                        Earcut.earcutLinked(a, triangles, dim, minX, minY, invSize);
                        Earcut.earcutLinked(c, triangles, dim, minX, minY, invSize);
                        return;
                    }
                    b = b.next;
                }
                a = a.next;
            } while (a !== start);
        };
        Earcut.eliminateHoles = function (data, holeIndices, outerNode, dim) {
            var queue = [], i, len, start, end, list;
            for (i = 0, len = holeIndices.length; i < len; i++) {
                start = holeIndices[i] * dim;
                end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                list = Earcut.linkedList(data, start, end, dim, false);
                if (list === list.next)
                    list.steiner = true;
                queue.push(Earcut.getLeftmost(list));
            }
            queue.sort(Earcut.compareX);
            for (i = 0; i < queue.length; i++) {
                Earcut.eliminateHole(queue[i], outerNode);
                outerNode = Earcut.filterPoints(outerNode, outerNode.next);
            }
            return outerNode;
        };
        Earcut.compareX = function (a, b) {
            return a.x - b.x;
        };
        Earcut.eliminateHole = function (hole, outerNode) {
            outerNode = Earcut.findHoleBridge(hole, outerNode);
            if (outerNode) {
                var b = Earcut.splitPolygon(outerNode, hole);
                Earcut.filterPoints(b, b.next);
            }
        };
        Earcut.findHoleBridge = function (hole, outerNode) {
            var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
            do {
                if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                    var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                    if (x <= hx && x > qx) {
                        qx = x;
                        if (x === hx) {
                            if (hy === p.y)
                                return p;
                            if (hy === p.next.y)
                                return p.next;
                        }
                        m = p.x < p.next.x ? p : p.next;
                    }
                }
                p = p.next;
            } while (p !== outerNode);
            if (!m)
                return null;
            if (hx === qx)
                return m.prev;
            var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
            p = m.next;
            while (p !== stop) {
                if (hx >= p.x && p.x >= mx && hx !== p.x &&
                    Earcut.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                    tan = Math.abs(hy - p.y) / (hx - p.x);
                    if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && Earcut.locallyInside(p, hole)) {
                        m = p;
                        tanMin = tan;
                    }
                }
                p = p.next;
            }
            return m;
        };
        Earcut.indexCurve = function (start, minX, minY, invSize) {
            var p = start;
            do {
                if (p.z === null)
                    p.z = Earcut.zOrder(p.x, p.y, minX, minY, invSize);
                p.prevZ = p.prev;
                p.nextZ = p.next;
                p = p.next;
            } while (p !== start);
            p.prevZ.nextZ = null;
            p.prevZ = null;
            Earcut.sortLinked(p);
        };
        Earcut.sortLinked = function (list) {
            var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
            do {
                p = list;
                list = null;
                tail = null;
                numMerges = 0;
                while (p) {
                    numMerges++;
                    q = p;
                    pSize = 0;
                    for (i = 0; i < inSize; i++) {
                        pSize++;
                        q = q.nextZ;
                        if (!q)
                            break;
                    }
                    qSize = inSize;
                    while (pSize > 0 || (qSize > 0 && q)) {
                        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                            e = p;
                            p = p.nextZ;
                            pSize--;
                        }
                        else {
                            e = q;
                            q = q.nextZ;
                            qSize--;
                        }
                        if (tail)
                            tail.nextZ = e;
                        else
                            list = e;
                        e.prevZ = tail;
                        tail = e;
                    }
                    p = q;
                }
                tail.nextZ = null;
                inSize *= 2;
            } while (numMerges > 1);
            return list;
        };
        Earcut.zOrder = function (x, y, minX, minY, invSize) {
            x = 32767 * (x - minX) * invSize;
            y = 32767 * (y - minY) * invSize;
            x = (x | (x << 8)) & 0x00FF00FF;
            x = (x | (x << 4)) & 0x0F0F0F0F;
            x = (x | (x << 2)) & 0x33333333;
            x = (x | (x << 1)) & 0x55555555;
            y = (y | (y << 8)) & 0x00FF00FF;
            y = (y | (y << 4)) & 0x0F0F0F0F;
            y = (y | (y << 2)) & 0x33333333;
            y = (y | (y << 1)) & 0x55555555;
            return x | (y << 1);
        };
        Earcut.getLeftmost = function (start) {
            var p = start, leftmost = start;
            do {
                if (p.x < leftmost.x)
                    leftmost = p;
                p = p.next;
            } while (p !== start);
            return leftmost;
        };
        Earcut.pointInTriangle = function (ax, ay, bx, by, cx, cy, px, py) {
            return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
                (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
                (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
        };
        Earcut.isValidDiagonal = function (a, b) {
            return a.next.i !== b.i && a.prev.i !== b.i && !Earcut.intersectsPolygon(a, b) &&
                Earcut.locallyInside(a, b) && Earcut.locallyInside(b, a) && Earcut.middleInside(a, b);
        };
        Earcut.area = function (p, q, r) {
            return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
        };
        Earcut.equals = function (p1, p2) {
            return p1.x === p2.x && p1.y === p2.y;
        };
        Earcut.intersects = function (p1, q1, p2, q2) {
            if ((Earcut.equals(p1, q1) && Earcut.equals(p2, q2)) ||
                (Earcut.equals(p1, q2) && Earcut.equals(p2, q1)))
                return true;
            return Earcut.area(p1, q1, p2) > 0 !== Earcut.area(p1, q1, q2) > 0 &&
                Earcut.area(p2, q2, p1) > 0 !== Earcut.area(p2, q2, q1) > 0;
        };
        Earcut.intersectsPolygon = function (a, b) {
            var p = a;
            do {
                if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                    Earcut.intersects(p, p.next, a, b))
                    return true;
                p = p.next;
            } while (p !== a);
            return false;
        };
        Earcut.locallyInside = function (a, b) {
            return Earcut.area(a.prev, a, a.next) < 0 ?
                Earcut.area(a, b, a.next) >= 0 && Earcut.area(a, a.prev, b) >= 0 :
                Earcut.area(a, b, a.prev) < 0 || Earcut.area(a, a.next, b) < 0;
        };
        Earcut.middleInside = function (a, b) {
            var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
            do {
                if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                    (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                    inside = !inside;
                p = p.next;
            } while (p !== a);
            return inside;
        };
        Earcut.splitPolygon = function (a, b) {
            var a2 = new EarcutNode(a.i, a.x, a.y), b2 = new EarcutNode(b.i, b.x, b.y), an = a.next, bp = b.prev;
            a.next = b;
            b.prev = a;
            a2.next = an;
            an.prev = a2;
            b2.next = a2;
            a2.prev = b2;
            bp.next = b2;
            b2.prev = bp;
            return b2;
        };
        Earcut.insertNode = function (i, x, y, last) {
            var p = new EarcutNode(i, x, y);
            if (!last) {
                p.prev = p;
                p.next = p;
            }
            else {
                p.next = last.next;
                p.prev = last;
                last.next.prev = p;
                last.next = p;
            }
            return p;
        };
        Earcut.removeNode = function (p) {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            if (p.prevZ)
                p.prevZ.nextZ = p.nextZ;
            if (p.nextZ)
                p.nextZ.prevZ = p.prevZ;
        };
        Earcut.signedArea = function (data, start, end, dim) {
            var sum = 0;
            for (var i = start, j = end - dim; i < end; i += dim) {
                sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
                j = i;
            }
            return sum;
        };
        return Earcut;
    })();
    var EarcutNode = (function () {
        function EarcutNode(i, x, y) {
            this.i = null;
            this.x = null;
            this.y = null;
            this.prev = null;
            this.next = null;
            this.z = null;
            this.prevZ = null;
            this.nextZ = null;
            this.steiner = null;
            this.i = i;
            this.x = x;
            this.y = y;
            this.prev = null;
            this.next = null;
            this.z = null;
            this.prevZ = null;
            this.nextZ = null;
            this.steiner = false;
        }
        __class(EarcutNode, 'laya.webgl.shapes.EarcutNode');
        return EarcutNode;
    })();
    var GeometryData = (function () {
        function GeometryData(lineWidth, lineColor, lineAlpha, fillColor, fillAlpha, fill, shape) {
            this.lineWidth = lineWidth;
            this.lineColor = lineColor;
            this.lineAlpha = lineAlpha;
            this.fillColor = fillColor;
            this.fillAlpha = fillAlpha;
            this.shape = shape;
            this.fill = fill;
        }
        __class(GeometryData, 'laya.webgl.shapes.GeometryData');
        var __proto = GeometryData.prototype;
        __proto.clone = function () {
            return new GeometryData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape);
        };
        __proto.getIndexData = function () {
            return null;
        };
        __proto.getVertexData = function () {
            return null;
        };
        __proto.destroy = function () {
            this.shape = null;
        };
        return GeometryData;
    })();
    var Vertex = (function () {
        function Vertex(p) {
            if ((p instanceof Float32Array))
                this.points = p;
            else if ((p instanceof Array)) {
                var len = p.length;
                this.points = new Float32Array(p);
            }
        }
        __class(Vertex, 'laya.webgl.shapes.Vertex');
        var __proto = Vertex.prototype;
        Laya.imps(__proto, { "laya.webgl.shapes.IShape": true });
        __proto.getData = function (ib, vb, start) { };
        __proto.needUpdate = function (mat) {
            return false;
        };
        __proto.rebuild = function (points) { };
        __proto.setMatrix = function (mat) { };
        return Vertex;
    })();
    var Submit = (function () {
        function Submit(renderType) {
            (renderType === void 0) && (renderType = 10000);
            this._renderType = renderType;
        }
        __class(Submit, 'laya.webgl.submit.Submit');
        var __proto = Submit.prototype;
        Laya.imps(__proto, { "laya.webgl.submit.ISubmit": true });
        __proto.releaseRender = function () {
            var cache = Submit._cache;
            cache[cache._length++] = this;
            this.shaderValue.release();
            this._vb = null;
        };
        __proto.getRenderType = function () {
            return this._renderType;
        };
        __proto.renderSubmit = function () {
            if (this._numEle === 0)
                return 1;
            var _tex = this.shaderValue.textureHost;
            if (_tex) {
                var source = _tex.source;
                if (!_tex.bitmap || !source)
                    return 1;
                this.shaderValue.texture = source;
            }
            this._vb.bind_upload(this._ib);
            var gl = WebGL.mainContext;
            this.shaderValue.upload();
            if (BlendMode.activeBlendFunction !== this._blendFn) {
                gl.enable(0x0BE2);
                this._blendFn(gl);
                BlendMode.activeBlendFunction = this._blendFn;
            }
            Stat.drawCall++;
            Stat.trianglesFaces += this._numEle / 3;
            gl.drawElements(0x0004, this._numEle, 0x1403, this._startIdx);
            return 1;
        };
        Submit.__init__ = function () {
            var s = Submit.RENDERBASE = new Submit(-1);
            s.shaderValue = new Value2D(0, 0);
            s.shaderValue.ALPHA = -1234;
        };
        Submit.createSubmit = function (context, ib, vb, pos, sv) {
            var o = Submit._cache._length ? Submit._cache[--Submit._cache._length] : new Submit();
            if (vb == null) {
                vb = o._selfVb || (o._selfVb = VertexBuffer2D.create(-1));
                vb.clear();
                pos = 0;
            }
            o._ib = ib;
            o._vb = vb;
            o._startIdx = pos * CONST3D2D.BYTES_PIDX;
            o._numEle = 0;
            var blendType = context._nBlendType;
            o._blendFn = context._targets ? BlendMode.targetFns[blendType] : BlendMode.fns[blendType];
            o.shaderValue = sv;
            o.shaderValue.setValue(context._shader2D);
            var filters = context._shader2D.filters;
            filters && o.shaderValue.setFilters(filters);
            return o;
        };
        Submit.createShape = function (ctx, ib, vb, numEle, offset, sv) {
            var o = (!Submit._cache._length) ? (new Submit()) : Submit._cache[--Submit._cache._length];
            o._ib = ib;
            o._vb = vb;
            o._numEle = numEle;
            o._startIdx = offset;
            o.shaderValue = sv;
            o.shaderValue.setValue(ctx._shader2D);
            var blendType = ctx._nBlendType;
            o._blendFn = ctx._targets ? BlendMode.targetFns[blendType] : BlendMode.fns[blendType];
            return o;
        };
        Submit.TYPE_2D = 10000;
        Submit.TYPE_CANVAS = 10003;
        Submit.TYPE_CMDSETRT = 10004;
        Submit.TYPE_CUSTOM = 10005;
        Submit.TYPE_BLURRT = 10006;
        Submit.TYPE_CMDDESTORYPRERT = 10007;
        Submit.TYPE_DISABLESTENCIL = 10008;
        Submit.TYPE_OTHERIBVB = 10009;
        Submit.TYPE_PRIMITIVE = 10010;
        Submit.TYPE_RT = 10011;
        Submit.TYPE_BLUR_RT = 10012;
        Submit.TYPE_TARGET = 10013;
        Submit.TYPE_CHANGE_VALUE = 10014;
        Submit.TYPE_SHAPE = 10015;
        Submit.TYPE_TEXTURE = 10016;
        Submit.TYPE_FILLTEXTURE = 10017;
        Submit.RENDERBASE = null;
        Submit._cache = (Submit._cache = [], Submit._cache._length = 0, Submit._cache);
        return Submit;
    })();
    var SubmitCMD = (function () {
        function SubmitCMD() {
            this.fun = null;
            this.args = null;
        }
        __class(SubmitCMD, 'laya.webgl.submit.SubmitCMD');
        var __proto = SubmitCMD.prototype;
        Laya.imps(__proto, { "laya.webgl.submit.ISubmit": true });
        __proto.renderSubmit = function () {
            this.fun.apply(null, this.args);
            return 1;
        };
        __proto.getRenderType = function () {
            return 0;
        };
        __proto.releaseRender = function () {
            var cache = SubmitCMD._cache;
            cache[cache._length++] = this;
        };
        SubmitCMD.create = function (args, fun) {
            var o = SubmitCMD._cache._length ? SubmitCMD._cache[--SubmitCMD._cache._length] : new SubmitCMD();
            o.fun = fun;
            o.args = args;
            return o;
        };
        SubmitCMD._cache = (SubmitCMD._cache = [], SubmitCMD._cache._length = 0, SubmitCMD._cache);
        return SubmitCMD;
    })();
    var SubmitCMDScope = (function () {
        function SubmitCMDScope() {
            this.variables = {};
        }
        __class(SubmitCMDScope, 'laya.webgl.submit.SubmitCMDScope');
        var __proto = SubmitCMDScope.prototype;
        __proto.getValue = function (name) {
            return this.variables[name];
        };
        __proto.addValue = function (name, value) {
            return this.variables[name] = value;
        };
        __proto.setValue = function (name, value) {
            if (this.variables.hasOwnProperty(name)) {
                return this.variables[name] = value;
            }
            return null;
        };
        __proto.clear = function () {
            for (var key in this.variables) {
                delete this.variables[key];
            }
        };
        __proto.recycle = function () {
            this.clear();
            SubmitCMDScope.POOL.push(this);
        };
        SubmitCMDScope.create = function () {
            var scope = SubmitCMDScope.POOL.pop();
            scope || (scope = new SubmitCMDScope());
            return scope;
        };
        SubmitCMDScope.POOL = [];
        return SubmitCMDScope;
    })();
    var SubmitOtherIBVB = (function () {
        function SubmitOtherIBVB() {
            this.offset = 0;
            this.startIndex = 0;
            ;
            this._mat = Matrix.create();
        }
        __class(SubmitOtherIBVB, 'laya.webgl.submit.SubmitOtherIBVB');
        var __proto = SubmitOtherIBVB.prototype;
        Laya.imps(__proto, { "laya.webgl.submit.ISubmit": true });
        __proto.releaseRender = function () {
            var cache = SubmitOtherIBVB._cache;
            cache[cache._length++] = this;
        };
        __proto.getRenderType = function () {
            return 10009;
        };
        __proto.renderSubmit = function () {
            var _tex = this._shaderValue.textureHost;
            if (_tex) {
                var source = _tex.source;
                if (!_tex.bitmap || !source)
                    return 1;
                this._shaderValue.texture = source;
            }
            this._vb.bind_upload(this._ib);
            var w = RenderState2D.worldMatrix4;
            var wmat = Matrix.TEMP;
            Matrix.mulPre(this._mat, w[0], w[1], w[4], w[5], w[12], w[13], wmat);
            var tmp = RenderState2D.worldMatrix4 = SubmitOtherIBVB.tempMatrix4;
            tmp[0] = wmat.a;
            tmp[1] = wmat.b;
            tmp[4] = wmat.c;
            tmp[5] = wmat.d;
            tmp[12] = wmat.tx;
            tmp[13] = wmat.ty;
            this._shader._offset = this.offset;
            this._shaderValue.refresh();
            this._shader.upload(this._shaderValue);
            this._shader._offset = 0;
            var gl = WebGL.mainContext;
            if (BlendMode.activeBlendFunction !== this._blendFn) {
                gl.enable(0x0BE2);
                this._blendFn(gl);
                BlendMode.activeBlendFunction = this._blendFn;
            }
            Stat.drawCall++;
            Stat.trianglesFaces += this._numEle / 3;
            gl.drawElements(0x0004, this._numEle, 0x1403, this.startIndex);
            RenderState2D.worldMatrix4 = w;
            BaseShader.activeShader = null;
            return 1;
        };
        SubmitOtherIBVB.create = function (context, vb, ib, numElement, shader, shaderValue, startIndex, offset, type) {
            (type === void 0) && (type = 0);
            var o = (!SubmitOtherIBVB._cache._length) ? (new SubmitOtherIBVB()) : SubmitOtherIBVB._cache[--SubmitOtherIBVB._cache._length];
            o._ib = ib;
            o._vb = vb;
            o._numEle = numElement;
            o._shader = shader;
            o._shaderValue = shaderValue;
            var blendType = context._nBlendType;
            o._blendFn = context._targets ? BlendMode.targetFns[blendType] : BlendMode.fns[blendType];
            switch (type) {
                case 0:
                    o.offset = 0;
                    o.startIndex = offset / (CONST3D2D.BYTES_PE * vb.vertexStride) * 1.5;
                    o.startIndex *= CONST3D2D.BYTES_PIDX;
                    break;
                case 1:
                    o.startIndex = startIndex;
                    o.offset = offset;
                    break;
            }
            return o;
        };
        SubmitOtherIBVB._cache = (SubmitOtherIBVB._cache = [], SubmitOtherIBVB._cache._length = 0, SubmitOtherIBVB._cache);
        SubmitOtherIBVB.tempMatrix4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,];
        return SubmitOtherIBVB;
    })();
    var SubmitScissor = (function () {
        function SubmitScissor() {
            this.submitIndex = 0;
            this.submitLength = 0;
            this.context = null;
            this.clipRect = new Rectangle();
            this.screenRect = new Rectangle();
        }
        __class(SubmitScissor, 'laya.webgl.submit.SubmitScissor');
        var __proto = SubmitScissor.prototype;
        Laya.imps(__proto, { "laya.webgl.submit.ISubmit": true });
        __proto._scissor = function (x, y, w, h) {
            var m = RenderState2D.worldMatrix4;
            var a = m[0], d = m[5], tx = m[12], ty = m[13];
            x = x * a + tx;
            y = y * d + ty;
            w *= a;
            h *= d;
            if (w < 1 || h < 1) {
                return false;
            }
            ;
            var r = x + w;
            var b = y + h;
            x < 0 && (x = 0, w = r - x);
            y < 0 && (y = 0, h = b - y);
            var screen = RenderState2D.worldClipRect;
            x = Math.max(x, screen.x);
            y = Math.max(y, screen.y);
            w = Math.min(r, screen.right) - x;
            h = Math.min(b, screen.bottom) - y;
            if (w < 1 || h < 1) {
                return false;
            }
            ;
            var worldScissorTest = RenderState2D.worldScissorTest;
            this.screenRect.copyFrom(screen);
            screen.x = x;
            screen.y = y;
            screen.width = w;
            screen.height = h;
            RenderState2D.worldScissorTest = true;
            y = RenderState2D.height - y - h;
            WebGL.mainContext.scissor(x, y, w, h);
            WebGL.mainContext.enable(0x0C11);
            this.context.submitElement(this.submitIndex, this.submitIndex + this.submitLength);
            if (worldScissorTest) {
                y = RenderState2D.height - this.screenRect.y - this.screenRect.height;
                WebGL.mainContext.scissor(this.screenRect.x, y, this.screenRect.width, this.screenRect.height);
                WebGL.mainContext.enable(0x0C11);
            }
            else {
                WebGL.mainContext.disable(0x0C11);
                RenderState2D.worldScissorTest = false;
            }
            screen.copyFrom(this.screenRect);
            return true;
        };
        __proto._scissorWithTagart = function (x, y, w, h) {
            if (w < 1 || h < 1) {
                return false;
            }
            ;
            var r = x + w;
            var b = y + h;
            x < 0 && (x = 0, w = r - x);
            y < 0 && (y = 0, h = b - y);
            var screen = RenderState2D.worldClipRect;
            x = Math.max(x, screen.x);
            y = Math.max(y, screen.y);
            w = Math.min(r, screen.right) - x;
            h = Math.min(b, screen.bottom) - y;
            if (w < 1 || h < 1) {
                return false;
            }
            ;
            var worldScissorTest = RenderState2D.worldScissorTest;
            this.screenRect.copyFrom(screen);
            RenderState2D.worldScissorTest = true;
            screen.x = x;
            screen.y = y;
            screen.width = w;
            screen.height = h;
            y = RenderState2D.height - y - h;
            WebGL.mainContext.scissor(x, y, w, h);
            WebGL.mainContext.enable(0x0C11);
            this.context.submitElement(this.submitIndex, this.submitIndex + this.submitLength);
            if (worldScissorTest) {
                y = RenderState2D.height - this.screenRect.y - this.screenRect.height;
                WebGL.mainContext.scissor(this.screenRect.x, y, this.screenRect.width, this.screenRect.height);
                WebGL.mainContext.enable(0x0C11);
            }
            else {
                WebGL.mainContext.disable(0x0C11);
                RenderState2D.worldScissorTest = false;
            }
            screen.copyFrom(this.screenRect);
            return true;
        };
        __proto.renderSubmit = function () {
            this.submitLength = Math.min(this.context._submits._length - 1, this.submitLength);
            if (this.submitLength < 1 || this.clipRect.width < 1 || this.clipRect.height < 1)
                return this.submitLength + 1;
            if (this.context._targets)
                this._scissorWithTagart(this.clipRect.x, this.clipRect.y, this.clipRect.width, this.clipRect.height);
            else
                this._scissor(this.clipRect.x, this.clipRect.y, this.clipRect.width, this.clipRect.height);
            return this.submitLength + 1;
        };
        __proto.getRenderType = function () {
            return 0;
        };
        __proto.releaseRender = function () {
            var cache = SubmitScissor._cache;
            cache[cache._length++] = this;
            this.context = null;
        };
        SubmitScissor.create = function (context) {
            var o = SubmitScissor._cache._length ? SubmitScissor._cache[--SubmitScissor._cache._length] : new SubmitScissor();
            o.context = context;
            return o;
        };
        SubmitScissor._cache = (SubmitScissor._cache = [], SubmitScissor._cache._length = 0, SubmitScissor._cache);
        return SubmitScissor;
    })();
    var SubmitStencil = (function () {
        function SubmitStencil() {
            this.step = 0;
            this.blendMode = null;
            this.level = 0;
        }
        __class(SubmitStencil, 'laya.webgl.submit.SubmitStencil');
        var __proto = SubmitStencil.prototype;
        Laya.imps(__proto, { "laya.webgl.submit.ISubmit": true });
        __proto.renderSubmit = function () {
            switch (this.step) {
                case 1:
                    this.do1();
                    break;
                case 2:
                    this.do2();
                    break;
                case 3:
                    this.do3();
                    break;
                case 4:
                    this.do4();
                    break;
                case 5:
                    this.do5();
                    break;
                case 6:
                    this.do6();
                    break;
                case 7:
                    this.do7();
                    break;
                case 8:
                    this.do8();
                    break;
            }
            return 1;
        };
        __proto.getRenderType = function () {
            return 0;
        };
        __proto.releaseRender = function () {
            var cache = SubmitStencil._cache;
            cache[cache._length++] = this;
        };
        __proto.do1 = function () {
            var gl = WebGL.mainContext;
            gl.enable(0x0B90);
            gl.clear(0x00000400);
            gl.colorMask(false, false, false, false);
            gl.stencilFunc(0x0202, this.level, 0xFF);
            gl.stencilOp(0x1E00, 0x1E00, 0x1E02);
        };
        __proto.do2 = function () {
            var gl = WebGL.mainContext;
            gl.stencilFunc(0x0202, this.level + 1, 0xFF);
            gl.colorMask(true, true, true, true);
            gl.stencilOp(0x1E00, 0x1E00, 0x1E00);
        };
        __proto.do3 = function () {
            var gl = WebGL.mainContext;
            gl.colorMask(true, true, true, true);
            gl.stencilOp(0x1E00, 0x1E00, 0x1E00);
            gl.clear(0x00000400);
            gl.disable(0x0B90);
        };
        __proto.do4 = function () {
            var gl = WebGL.mainContext;
            if (this.level == 0) {
                gl.enable(0x0B90);
                gl.clear(0x00000400);
            }
            gl.colorMask(false, false, false, false);
            gl.stencilFunc(0x0207, 0, 0xFF);
            gl.stencilOp(0x1E00, 0x1E00, 0x1E02);
        };
        __proto.do5 = function () {
            var gl = WebGL.mainContext;
            gl.stencilFunc(0x0202, this.level, 0xFF);
            gl.colorMask(true, true, true, true);
            gl.stencilOp(0x1E00, 0x1E00, 0x1E00);
        };
        __proto.do6 = function () {
            var gl = WebGL.mainContext;
            BlendMode.targetFns[BlendMode.TOINT[this.blendMode]](gl);
        };
        __proto.do7 = function () {
            var gl = WebGL.mainContext;
            gl.colorMask(false, false, false, false);
            gl.stencilOp(0x1E00, 0x1E00, 0x1E03);
        };
        __proto.do8 = function () {
            var gl = WebGL.mainContext;
            gl.colorMask(true, true, true, true);
            gl.stencilFunc(0x0202, this.level, 0xFF);
            gl.stencilOp(0x1E00, 0x1E00, 0x1E00);
        };
        SubmitStencil.restore = function (context, clip, m, _x, _y) {
            var submitStencil;
            context._renderKey = 0;
            if (SubmitStencil._mask > 0) {
                SubmitStencil._mask--;
            }
            if (SubmitStencil._mask == 0) {
                submitStencil = laya.webgl.submit.SubmitStencil.create(3);
                context.addRenderObject(submitStencil);
                context._curSubmit = Submit.RENDERBASE;
            }
            else {
                submitStencil = laya.webgl.submit.SubmitStencil.create(7);
                context.addRenderObject(submitStencil);
                var vb = context._vb;
                var nPos = (vb._byteLength >> 2);
                if (GlUtils.fillRectImgVb(vb, null, clip.x, clip.y, clip.width, clip.height, Texture.DEF_UV, m, _x, _y, 0, 0)) {
                    var shader = context._shader2D;
                    shader.glTexture = null;
                    var submit = context._curSubmit = Submit.createSubmit(context, context._ib, vb, ((vb._byteLength - 16 * 4) / 32) * 3, Value2D.create(0x02, 0));
                    submit.shaderValue.ALPHA = 1.0;
                    context._submits[context._submits._length++] = submit;
                    context._curSubmit._numEle += 6;
                    context._curSubmit = Submit.RENDERBASE;
                }
                else {
                    alert("clipRect calc stencil rect error");
                }
                submitStencil = laya.webgl.submit.SubmitStencil.create(8);
                context.addRenderObject(submitStencil);
            }
        };
        SubmitStencil.restore2 = function (context, submit) {
            var submitStencil;
            context._renderKey = 0;
            if (SubmitStencil._mask > 0) {
                SubmitStencil._mask--;
            }
            if (SubmitStencil._mask == 0) {
                submitStencil = laya.webgl.submit.SubmitStencil.create(3);
                context.addRenderObject(submitStencil);
                context._curSubmit = Submit.RENDERBASE;
            }
            else {
                submitStencil = laya.webgl.submit.SubmitStencil.create(7);
                context.addRenderObject(submitStencil);
                context._submits[context._submits._length++] = submit;
                submitStencil = laya.webgl.submit.SubmitStencil.create(8);
                context.addRenderObject(submitStencil);
            }
        };
        SubmitStencil.create = function (step) {
            var o = SubmitStencil._cache._length ? SubmitStencil._cache[--SubmitStencil._cache._length] : new SubmitStencil();
            o.step = step;
            if (step == 5)
                ++SubmitStencil._mask;
            o.level = SubmitStencil._mask;
            return o;
        };
        SubmitStencil._cache = (SubmitStencil._cache = [], SubmitStencil._cache._length = 0, SubmitStencil._cache);
        SubmitStencil._mask = 0;
        return SubmitStencil;
    })();
    var SubmitTarget = (function () {
        function SubmitTarget() {
            this._renderType = 0;
            this._vb = null;
            this._ib = null;
            this._startIdx = 0;
            this._numEle = 0;
            this.shaderValue = null;
            this.blendType = 0;
            this.proName = null;
            this.scope = null;
        }
        __class(SubmitTarget, 'laya.webgl.submit.SubmitTarget');
        var __proto = SubmitTarget.prototype;
        Laya.imps(__proto, { "laya.webgl.submit.ISubmit": true });
        __proto.renderSubmit = function () {
            this._vb.bind_upload(this._ib);
            var target = this.scope.getValue(this.proName);
            if (target) {
                this.shaderValue.texture = target.source;
                if (this.shaderValue["strength"] && !this.shaderValue["blurInfo"]) {
                    this.shaderValue["blurInfo"] = [target.width, target.height];
                }
                this.shaderValue.upload();
                this.blend();
                Stat.drawCall++;
                Stat.trianglesFaces += this._numEle / 3;
                WebGL.mainContext.drawElements(0x0004, this._numEle, 0x1403, this._startIdx);
            }
            return 1;
        };
        __proto.blend = function () {
            if (BlendMode.activeBlendFunction !== BlendMode.fns[this.blendType]) {
                var gl = WebGL.mainContext;
                gl.enable(0x0BE2);
                BlendMode.fns[this.blendType](gl);
                BlendMode.activeBlendFunction = BlendMode.fns[this.blendType];
            }
        };
        __proto.getRenderType = function () {
            return 0;
        };
        __proto.releaseRender = function () {
            var cache = SubmitTarget._cache;
            cache[cache._length++] = this;
        };
        SubmitTarget.create = function (context, ib, vb, pos, sv, proName) {
            var o = SubmitTarget._cache._length ? SubmitTarget._cache[--SubmitTarget._cache._length] : new SubmitTarget();
            o._ib = ib;
            o._vb = vb;
            o.proName = proName;
            o._startIdx = pos * CONST3D2D.BYTES_PIDX;
            o._numEle = 0;
            o.blendType = context._nBlendType;
            o.shaderValue = sv;
            o.shaderValue.setValue(context._shader2D);
            return o;
        };
        SubmitTarget._cache = (SubmitTarget._cache = [], SubmitTarget._cache._length = 0, SubmitTarget._cache);
        return SubmitTarget;
    })();
    var CharSegment = (function () {
        function CharSegment() {
            this._sourceStr = null;
        }
        __class(CharSegment, 'laya.webgl.text.CharSegment');
        var __proto = CharSegment.prototype;
        Laya.imps(__proto, { "laya.webgl.text.ICharSegment": true });
        __proto.textToSpit = function (str) {
            this._sourceStr = str;
        };
        __proto.getChar = function (i) {
            return this._sourceStr.charAt(i);
        };
        __proto.getCharCode = function (i) {
            return this._sourceStr.charCodeAt(i);
        };
        __proto.length = function () {
            return this._sourceStr.length;
        };
        return CharSegment;
    })();
    var DrawText = (function () {
        var CharValue;
        function DrawText() { }
        __class(DrawText, 'laya.webgl.text.DrawText');
        DrawText.__init__ = function () {
            DrawText._charsTemp = new Array;
            DrawText._drawValue = new CharValue();
            DrawText._charSeg = new CharSegment();
        };
        DrawText.customCharSeg = function (charseg) {
            DrawText._charSeg = charseg;
        };
        DrawText.getChar = function (char, id, drawValue) {
            var result = WebGLCharImage.createOneChar(char, drawValue);
            if (id != -1)
                DrawText._charsCache[id] = result;
            return result;
        };
        DrawText._drawSlow = function (save, ctx, txt, words, curMat, font, textAlign, fillColor, borderColor, lineWidth, x, y, sx, sy, underLine) {
            var drawValue = DrawText._drawValue.value(font, fillColor, borderColor, lineWidth, sx, sy, underLine);
            var i = 0, n = 0;
            var chars = DrawText._charsTemp;
            var width = 0, oneChar, htmlWord, id = NaN;
            var isWordText = txt instanceof laya.utils.WordText;
            var txtLetterSpacing = isWordText ? txt._letterSpacing : 0;
            if (words) {
                chars.length = words.length;
                for (i = 0, n = words.length; i < n; i++) {
                    htmlWord = words[i];
                    id = htmlWord.charNum + drawValue.txtID;
                    chars[i] = oneChar = DrawText._charsCache[id] || DrawText.getChar(htmlWord.char, id, drawValue);
                    oneChar.active();
                }
            }
            else {
                var text = isWordText ? txt.toString() : txt;
                if (Text.CharacterCache) {
                    DrawText._charSeg.textToSpit(text);
                    var len = DrawText._charSeg.length();
                    chars.length = len;
                    for (i = 0, n = len; i < n; i++) {
                        id = DrawText._charSeg.getCharCode(i) + drawValue.txtID;
                        chars[i] = oneChar = DrawText._charsCache[id] || DrawText.getChar(DrawText._charSeg.getChar(i), id, drawValue);
                        oneChar.active();
                        width += oneChar.cw;
                    }
                }
                else {
                    chars.length = 0;
                    oneChar = DrawText.getChar(text, -1, drawValue);
                    oneChar.active();
                    width += oneChar.cw;
                    chars[0] = oneChar;
                }
            }
            ;
            var dx = 0;
            if (textAlign !== null && textAlign !== "left")
                dx = -(textAlign == "center" ? (width / 2) : width);
            var uv, bdSz = NaN, texture, value, saveLength = 0;
            if (words) {
                for (i = 0, n = chars.length; i < n; i++) {
                    oneChar = chars[i];
                    if (!oneChar.isSpace) {
                        htmlWord = words[i];
                        bdSz = oneChar.borderSize;
                        texture = oneChar.texture;
                        ctx._drawText(texture, x + dx + htmlWord.x * sx - bdSz, y + htmlWord.y * sy - bdSz, texture.width, texture.height, curMat, 0, 0, 0, 0);
                    }
                }
            }
            else {
                for (i = 0, n = chars.length; i < n; i++) {
                    oneChar = chars[i];
                    if (!oneChar.isSpace) {
                        bdSz = oneChar.borderSize;
                        texture = oneChar.texture;
                        var toX = dx - bdSz + i * txtLetterSpacing;
                        ctx._drawText(texture, x + toX, y - bdSz, texture.width, texture.height, curMat, 0, 0, 0, 0);
                        save && (value = save[saveLength++], value || (value = save[saveLength - 1] = []), value[0] = texture, value[1] = toX, value[2] = -bdSz);
                    }
                    dx += oneChar.cw;
                }
                save && (save.length = saveLength);
            }
        };
        DrawText._drawFast = function (save, ctx, curMat, x, y) {
            var texture, value;
            for (var i = 0, n = save.length; i < n; i++) {
                value = save[i];
                texture = value[0];
                texture.active();
                ctx._drawText(texture, x + value[1], y + value[2], texture.width, texture.height, curMat, 0, 0, 0, 0);
            }
        };
        DrawText.drawText = function (ctx, txt, words, curMat, font, textAlign, fillColor, borderColor, lineWidth, x, y, underLine) {
            (underLine === void 0) && (underLine = 0);
            if ((txt && txt.length === 0) || (words && words.length === 0))
                return;
            var sx = curMat.a, sy = curMat.d;
            (curMat.b !== 0 || curMat.c !== 0) && (sx = sy = 1);
            var scale = sx !== 1 || sy !== 1;
            if (scale && Laya.stage.transform) {
                var t = Laya.stage.transform;
                scale = t.a === sx && t.d === sy;
            }
            else
                scale = false;
            if (scale) {
                curMat = curMat.copyTo(WebGLContext2D._tmpMatrix);
                var tempTx = curMat.tx;
                var tempTy = curMat.ty;
                curMat.scale(1 / sx, 1 / sy);
                curMat._checkTransform();
                x *= sx;
                y *= sy;
                x += tempTx - curMat.tx;
                y += tempTy - curMat.ty;
            }
            else
                sx = sy = 1;
            if (words) {
                DrawText._drawSlow(null, ctx, txt, words, curMat, font, textAlign, fillColor, borderColor, lineWidth, x, y, sx, sy, underLine);
            }
            else {
                if (txt.toUpperCase === null) {
                    var idNum = sx + sy * 100000;
                    var myCache = txt;
                    if (!myCache.changed && myCache.id === idNum) {
                        DrawText._drawFast(myCache.save, ctx, curMat, x, y);
                    }
                    else {
                        myCache.id = idNum;
                        myCache.changed = false;
                        DrawText._drawSlow(myCache.save, ctx, txt, words, curMat, font, textAlign, fillColor, borderColor, lineWidth, x, y, sx, sy, underLine);
                    }
                    return;
                }
                ;
                var id = txt + font.toString() + fillColor + borderColor + lineWidth + sx + sy + textAlign;
                var cache = DrawText._textsCache[id];
                if (Text.CharacterCache) {
                    if (cache) {
                        DrawText._drawFast(cache, ctx, curMat, x, y);
                    }
                    else {
                        DrawText._textsCache.__length || (DrawText._textsCache.__length = 0);
                        if (DrawText._textsCache.__length > Config.WebGLTextCacheCount) {
                            DrawText._textsCache = {};
                            DrawText._textsCache.__length = 0;
                            DrawText._curPoolIndex = 0;
                        }
                        DrawText._textCachesPool[DrawText._curPoolIndex] ? (cache = DrawText._textsCache[id] = DrawText._textCachesPool[DrawText._curPoolIndex], cache.length = 0) : (DrawText._textCachesPool[DrawText._curPoolIndex] = cache = DrawText._textsCache[id] = []);
                        DrawText._textsCache.__length++;
                        DrawText._curPoolIndex++;
                        DrawText._drawSlow(cache, ctx, txt, words, curMat, font, textAlign, fillColor, borderColor, lineWidth, x, y, sx, sy, underLine);
                    }
                }
                else {
                    DrawText._drawSlow(cache, ctx, txt, words, curMat, font, textAlign, fillColor, borderColor, lineWidth, x, y, sx, sy, underLine);
                }
            }
        };
        DrawText._charsTemp = null;
        DrawText._textCachesPool = [];
        DrawText._curPoolIndex = 0;
        DrawText._charsCache = {};
        DrawText._textsCache = {};
        DrawText._drawValue = null;
        DrawText.d = [];
        DrawText._charSeg = null;
        DrawText.__init$ = function () {
            CharValue = (function () {
                function CharValue() {
                }
                __class(CharValue, '');
                var __proto = CharValue.prototype;
                __proto.value = function (font, fillColor, borderColor, lineWidth, scaleX, scaleY, underLine) {
                    this.font = font;
                    this.fillColor = fillColor;
                    this.borderColor = borderColor;
                    this.lineWidth = lineWidth;
                    this.scaleX = scaleX;
                    this.scaleY = scaleY;
                    this.underLine = underLine;
                    var key = font.toString() + scaleX + scaleY + lineWidth + fillColor + borderColor + underLine;
                    this.txtID = CharValue._keymap[key];
                    if (!this.txtID) {
                        this.txtID = (++CharValue._keymapCount) * 0.0000001;
                        CharValue._keymap[key] = this.txtID;
                    }
                    return this;
                };
                CharValue.clear = function () {
                    CharValue._keymap = {};
                    CharValue._keymapCount = 1;
                };
                CharValue._keymap = {};
                CharValue._keymapCount = 1;
                return CharValue;
            })();
        };
        return DrawText;
    })();
    var FontInContext = (function () {
        function FontInContext(font) {
            this._index = 0;
            this._size = 14;
            this._italic = -2;
            FontInContext._cache2 = FontInContext._cache2 || [];
            this.setFont(font || "14px Arial");
        }
        __class(FontInContext, 'laya.webgl.text.FontInContext');
        var __proto = FontInContext.prototype;
        __proto.setFont = function (value) {
            var arr = FontInContext._cache2[value];
            if (!arr) {
                this._words = value.split(' ');
                for (var i = 0, n = this._words.length; i < n; i++) {
                    if (this._words[i].indexOf('px') > 0) {
                        this._index = i;
                        break;
                    }
                }
                this._size = parseInt(this._words[this._index]);
                FontInContext._cache2[value] = [this._words, this._size];
            }
            else {
                this._words = arr[0];
                this._size = arr[1];
            }
            this._text = null;
            this._italic = -2;
        };
        __proto.getItalic = function () {
            this._italic === -2 && (this._italic = this.hasType("italic"));
            return this._italic;
        };
        __proto.hasType = function (name) {
            for (var i = 0, n = this._words.length; i < n; i++)
                if (this._words[i] === name)
                    return i;
            return -1;
        };
        __proto.removeType = function (name) {
            for (var i = 0, n = this._words.length; i < n; i++)
                if (this._words[i] === name) {
                    this._words.splice(i, 1);
                    if (this._index > i)
                        this._index--;
                    break;
                }
            this._text = null;
            this._italic = -2;
        };
        __proto.copyTo = function (dec) {
            dec._text = this._text;
            dec._size = this._size;
            dec._index = this._index;
            dec._words = this._words.slice();
            dec._italic = -2;
            return dec;
        };
        __proto.toString = function () {
            return this._text ? this._text : (this._text = this._words.join(' '));
        };
        __getset(0, __proto, 'size', function () {
            return this._size;
        }, function (value) {
            this._size = value;
            this._words[this._index] = value + "px";
            this._text = null;
        });
        FontInContext.create = function (font) {
            var r = FontInContext._cache[font];
            if (r)
                return r;
            r = FontInContext._cache[font] = new FontInContext(font);
            return r;
        };
        FontInContext.EMPTY = new FontInContext();
        FontInContext._cache = {};
        FontInContext._cache2 = null;
        return FontInContext;
    })();
    var CONST3D2D = (function () {
        function CONST3D2D() { }
        __class(CONST3D2D, 'laya.webgl.utils.CONST3D2D');
        CONST3D2D.defaultMatrix4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        CONST3D2D.defaultMinusYMatrix4 = [1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        CONST3D2D.uniformMatrix3 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0];
        CONST3D2D._TMPARRAY = [];
        CONST3D2D._OFFSETX = 0;
        CONST3D2D._OFFSETY = 0;
        __static(CONST3D2D, ['BYTES_PE', function () { return this.BYTES_PE = Float32Array.BYTES_PER_ELEMENT; }, 'BYTES_PIDX', function () { return this.BYTES_PIDX = Uint16Array.BYTES_PER_ELEMENT; }
        ]);
        return CONST3D2D;
    })();
    var GlUtils = (function () {
        function GlUtils() { }
        __class(GlUtils, 'laya.webgl.utils.GlUtils');
        GlUtils.make2DProjection = function (width, height, depth) {
            return [2.0 / width, 0, 0, 0, 0, -2.0 / height, 0, 0, 0, 0, 2.0 / depth, 0, -1, 1, 0, 1,];
        };
        GlUtils.fillIBQuadrangle = function (buffer, count) {
            if (count > 65535 / 4) {
                throw Error("IBQuadrangle count:" + count + " must<:" + Math.floor(65535 / 4));
                return false;
            }
            count = Math.floor(count);
            buffer._resizeBuffer((count + 1) * 6 * 2, false);
            buffer.byteLength = buffer.bufferLength;
            var bufferData = buffer.getUint16Array();
            var idx = 0;
            for (var i = 0; i < count; i++) {
                bufferData[idx++] = i * 4;
                bufferData[idx++] = i * 4 + 2;
                bufferData[idx++] = i * 4 + 1;
                bufferData[idx++] = i * 4;
                bufferData[idx++] = i * 4 + 3;
                bufferData[idx++] = i * 4 + 2;
            }
            buffer.setNeedUpload();
            return true;
        };
        GlUtils.expandIBQuadrangle = function (buffer, count) {
            buffer.bufferLength >= (count * 6 * 2) || GlUtils.fillIBQuadrangle(buffer, count);
        };
        GlUtils.mathCeilPowerOfTwo = function (value) {
            value--;
            value |= value >> 1;
            value |= value >> 2;
            value |= value >> 4;
            value |= value >> 8;
            value |= value >> 16;
            value++;
            return value;
        };
        GlUtils.fillQuadrangleImgVb = function (vb, x, y, point4, uv, m, _x, _y) {
            'use strict';
            var vpos = (vb._byteLength >> 2) + 16;
            vb.byteLength = (vpos << 2);
            var vbdata = vb.getFloat32Array();
            vpos -= 16;
            vbdata[vpos + 2] = uv[0];
            vbdata[vpos + 3] = uv[1];
            vbdata[vpos + 6] = uv[2];
            vbdata[vpos + 7] = uv[3];
            vbdata[vpos + 10] = uv[4];
            vbdata[vpos + 11] = uv[5];
            vbdata[vpos + 14] = uv[6];
            vbdata[vpos + 15] = uv[7];
            var a = m.a, b = m.b, c = m.c, d = m.d;
            if (a !== 1 || b !== 0 || c !== 0 || d !== 1) {
                m.bTransform = true;
                var tx = m.tx + _x, ty = m.ty + _y;
                vbdata[vpos] = (point4[0] + x) * a + (point4[1] + y) * c + tx;
                vbdata[vpos + 1] = (point4[0] + x) * b + (point4[1] + y) * d + ty;
                vbdata[vpos + 4] = (point4[2] + x) * a + (point4[3] + y) * c + tx;
                vbdata[vpos + 5] = (point4[2] + x) * b + (point4[3] + y) * d + ty;
                vbdata[vpos + 8] = (point4[4] + x) * a + (point4[5] + y) * c + tx;
                vbdata[vpos + 9] = (point4[4] + x) * b + (point4[5] + y) * d + ty;
                vbdata[vpos + 12] = (point4[6] + x) * a + (point4[7] + y) * c + tx;
                vbdata[vpos + 13] = (point4[6] + x) * b + (point4[7] + y) * d + ty;
            }
            else {
                m.bTransform = false;
                x += m.tx + _x;
                y += m.ty + _y;
                vbdata[vpos] = x + point4[0];
                vbdata[vpos + 1] = y + point4[1];
                vbdata[vpos + 4] = x + point4[2];
                vbdata[vpos + 5] = y + point4[3];
                vbdata[vpos + 8] = x + point4[4];
                vbdata[vpos + 9] = y + point4[5];
                vbdata[vpos + 12] = x + point4[6];
                vbdata[vpos + 13] = y + point4[7];
            }
            vb._upload = true;
            return true;
        };
        GlUtils.fillTranglesVB = function (vb, x, y, points, m, _x, _y) {
            var vpos = (vb._byteLength >> 2) + points.length;
            vb.byteLength = (vpos << 2);
            var vbdata = vb.getFloat32Array();
            vpos -= points.length;
            var len = points.length;
            var a = m.a, b = m.b, c = m.c, d = m.d;
            for (var i = 0; i < len; i += 4) {
                vbdata[vpos + i + 2] = points[i + 2];
                vbdata[vpos + i + 3] = points[i + 3];
                if (a !== 1 || b !== 0 || c !== 0 || d !== 1) {
                    m.bTransform = true;
                    var tx = m.tx + _x, ty = m.ty + _y;
                    vbdata[vpos + i] = (points[i] + x) * a + (points[i + 1] + y) * c + tx;
                    vbdata[vpos + i + 1] = (points[i] + x) * b + (points[i + 1] + y) * d + ty;
                }
                else {
                    m.bTransform = false;
                    x += m.tx + _x;
                    y += m.ty + _y;
                    vbdata[vpos + i] = x + points[i];
                    vbdata[vpos + i + 1] = y + points[i + 1];
                }
            }
            vb._upload = true;
            return true;
        };
        GlUtils.copyPreImgVb = function (vb, dx, dy) {
            var vpos = (vb._byteLength >> 2);
            vb.byteLength = ((vpos + 16) << 2);
            var vbdata = vb.getFloat32Array();
            for (var i = 0, ci = vpos - 16; i < 4; i++) {
                vbdata[vpos] = vbdata[ci] + dx;
                ++vpos;
                ++ci;
                vbdata[vpos] = vbdata[ci] + dy;
                ++vpos;
                ++ci;
                vbdata[vpos] = vbdata[ci];
                ++vpos;
                ++ci;
                vbdata[vpos] = vbdata[ci];
                ++vpos;
                ++ci;
            }
            vb._upload = true;
        };
        GlUtils.fillRectImgVb = function (vb, clip, x, y, width, height, uv, m, _x, _y, dx, dy, round) {
            (round === void 0) && (round = false);
            var mType = 1;
            var toBx, toBy, toEx, toEy;
            var cBx, cBy, cEx, cEy;
            var w0, h0, tx, ty;
            var finalX, finalY, offsetX, offsetY;
            var a = m.a, b = m.b, c = m.c, d = m.d;
            var useClip = clip && clip.width < 99999999;
            if (a !== 1 || b !== 0 || c !== 0 || d !== 1) {
                m.bTransform = true;
                if (b === 0 && c === 0) {
                    mType = 23;
                    w0 = width + x, h0 = height + y;
                    tx = m.tx + _x, ty = m.ty + _y;
                    toBx = a * x + tx;
                    toEx = a * w0 + tx;
                    toBy = d * y + ty;
                    toEy = d * h0 + ty;
                }
            }
            else {
                mType = 23;
                m.bTransform = false;
                toBx = x + m.tx + _x;
                toEx = toBx + width;
                toBy = y + m.ty + _y;
                toEy = toBy + height;
            }
            if (useClip) {
                cBx = clip.x, cBy = clip.y, cEx = clip.width + cBx, cEy = clip.height + cBy;
            }
            if (mType !== 1) {
                if (Math.min(toBx, toEx) >= cEx)
                    return false;
                if (Math.min(toBy, toEy) >= cEy)
                    return false;
                if (Math.max(toEx, toBx) <= cBx)
                    return false;
                if (Math.max(toEy, toBy) <= cBy)
                    return false;
            }
            ;
            var vpos = (vb._byteLength >> 2);
            vb.byteLength = ((vpos + 16) << 2);
            var vbdata = vb.getFloat32Array();
            vbdata[vpos + 2] = uv[0];
            vbdata[vpos + 3] = uv[1];
            vbdata[vpos + 6] = uv[2];
            vbdata[vpos + 7] = uv[3];
            vbdata[vpos + 10] = uv[4];
            vbdata[vpos + 11] = uv[5];
            vbdata[vpos + 14] = uv[6];
            vbdata[vpos + 15] = uv[7];
            switch (mType) {
                case 1:
                    tx = m.tx + _x, ty = m.ty + _y;
                    w0 = width + x, h0 = height + y;
                    var w1 = x, h1 = y;
                    var aw1 = a * w1, ch1 = c * h1, dh1 = d * h1, bw1 = b * w1;
                    var aw0 = a * w0, ch0 = c * h0, dh0 = d * h0, bw0 = b * w0;
                    if (round) {
                        finalX = aw1 + ch1 + tx;
                        offsetX = Math.round(finalX) - finalX;
                        finalY = dh1 + bw1 + ty;
                        offsetY = Math.round(finalY) - finalY;
                        vbdata[vpos] = finalX + offsetX;
                        vbdata[vpos + 1] = finalY + offsetY;
                        vbdata[vpos + 4] = aw0 + ch1 + tx + offsetX;
                        vbdata[vpos + 5] = dh1 + bw0 + ty + offsetY;
                        vbdata[vpos + 8] = aw0 + ch0 + tx + offsetX;
                        vbdata[vpos + 9] = dh0 + bw0 + ty + offsetY;
                        vbdata[vpos + 12] = aw1 + ch0 + tx + offsetX;
                        vbdata[vpos + 13] = dh0 + bw1 + ty + offsetY;
                    }
                    else {
                        vbdata[vpos] = aw1 + ch1 + tx;
                        vbdata[vpos + 1] = dh1 + bw1 + ty;
                        vbdata[vpos + 4] = aw0 + ch1 + tx;
                        vbdata[vpos + 5] = dh1 + bw0 + ty;
                        vbdata[vpos + 8] = aw0 + ch0 + tx;
                        vbdata[vpos + 9] = dh0 + bw0 + ty;
                        vbdata[vpos + 12] = aw1 + ch0 + tx;
                        vbdata[vpos + 13] = dh0 + bw1 + ty;
                    }
                    break;
                case 23:
                    if (round) {
                        finalX = toBx + dx;
                        offsetX = Math.round(finalX) - finalX;
                        finalY = toBy;
                        offsetY = Math.round(finalY) - finalY;
                        vbdata[vpos] = finalX + offsetX;
                        vbdata[vpos + 1] = finalY + offsetY;
                        vbdata[vpos + 4] = toEx + dx + offsetX;
                        vbdata[vpos + 5] = toBy + offsetY;
                        vbdata[vpos + 8] = toEx + offsetX;
                        vbdata[vpos + 9] = toEy + offsetY;
                        vbdata[vpos + 12] = toBx + offsetX;
                        vbdata[vpos + 13] = toEy + offsetY;
                    }
                    else {
                        vbdata[vpos] = toBx + dx;
                        vbdata[vpos + 1] = toBy;
                        vbdata[vpos + 4] = toEx + dx;
                        vbdata[vpos + 5] = toBy;
                        vbdata[vpos + 8] = toEx;
                        vbdata[vpos + 9] = toEy;
                        vbdata[vpos + 12] = toBx;
                        vbdata[vpos + 13] = toEy;
                    }
                    break;
            }
            vb._upload = true;
            return true;
        };
        GlUtils.fillLineVb = function (vb, clip, fx, fy, tx, ty, width, mat) {
            'use strict';
            var linew = width * .5;
            var data = GlUtils._fillLineArray;
            var perpx = -(fy - ty), perpy = fx - tx;
            var dist = Math.sqrt(perpx * perpx + perpy * perpy);
            perpx /= dist, perpy /= dist, perpx *= linew, perpy *= linew;
            data[0] = fx - perpx, data[1] = fy - perpy, data[4] = fx + perpx, data[5] = fy + perpy, data[8] = tx + perpx, data[9] = ty + perpy, data[12] = tx - perpx, data[13] = ty - perpy;
            mat && mat.transformPointArray(data, data);
            var vpos = (vb._byteLength >> 2) + 16;
            vb.byteLength = (vpos << 2);
            vb.insertData(data, vpos - 16);
            return true;
        };
        GlUtils._fillLineArray = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        return GlUtils;
    })();
    var MatirxArray = (function () {
        function MatirxArray() { }
        __class(MatirxArray, 'laya.webgl.utils.MatirxArray');
        MatirxArray.ArrayMul = function (a, b, o) {
            if (!a) {
                MatirxArray.copyArray(b, o);
                return;
            }
            if (!b) {
                MatirxArray.copyArray(a, o);
                return;
            }
            ;
            var ai0 = NaN, ai1 = NaN, ai2 = NaN, ai3 = NaN;
            for (var i = 0; i < 4; i++) {
                ai0 = a[i];
                ai1 = a[i + 4];
                ai2 = a[i + 8];
                ai3 = a[i + 12];
                o[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];
                o[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];
                o[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];
                o[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
            }
        };
        MatirxArray.copyArray = function (f, t) {
            if (!f)
                return;
            if (!t)
                return;
            for (var i = 0; i < f.length; i++) {
                t[i] = f[i];
            }
        };
        return MatirxArray;
    })();
    var Mesh2D = (function () {
        function Mesh2D(stride, vballoc, iballoc) {
            this._stride = 0;
            this.vertNum = 0;
            this.indexNum = 0;
            this._applied = false;
            this._vb = null;
            this._ib = null;
            this._vao = null;
            this._attribInfo = null;
            this._quadNum = 0;
            this.canReuse = false;
            this._stride = stride;
            this._vb = new VertexBuffer2D(stride, 0x88E8);
            if (vballoc) {
                this._vb._resizeBuffer(vballoc, false);
            }
            else { }
            this._ib = new IndexBuffer2D();
            if (iballoc) {
                this._ib._resizeBuffer(iballoc, false);
            }
        }
        __class(Mesh2D, 'laya.webgl.utils.Mesh2D');
        var __proto = Mesh2D.prototype;
        __proto.cloneWithNewVB = function () {
            var mesh = new Mesh2D(this._stride, 0, 0);
            mesh._ib = this._ib;
            mesh._quadNum = this._quadNum;
            mesh._attribInfo = this._attribInfo;
            return mesh;
        };
        __proto.cloneWithNewVBIB = function () {
            var mesh = new Mesh2D(this._stride, 0, 0);
            mesh._attribInfo = this._attribInfo;
            return mesh;
        };
        __proto.getVBW = function () {
            this._vb.setNeedUpload();
            return this._vb;
        };
        __proto.getVBR = function () {
            return this._vb;
        };
        __proto.getIBR = function () {
            return this._ib;
        };
        __proto.getIBW = function () {
            this._ib.setNeedUpload();
            return this._ib;
        };
        __proto.createQuadIB = function (QuadNum) {
            this._quadNum = QuadNum;
            this._ib._resizeBuffer(QuadNum * 6 * 2, false);
            this._ib.byteLength = this._ib.bufferLength;
            var bd = this._ib.getUint16Array();
            var idx = 0;
            var curvert = 0;
            for (var i = 0; i < QuadNum; i++) {
                bd[idx++] = curvert;
                bd[idx++] = curvert + 2;
                bd[idx++] = curvert + 1;
                bd[idx++] = curvert;
                bd[idx++] = curvert + 3;
                bd[idx++] = curvert + 2;
                curvert += 4;
            }
            this._ib.setNeedUpload();
        };
        __proto.setAttributes = function (attribs) {
            this._attribInfo = attribs;
            if (this._attribInfo.length % 3 != 0) {
                throw 'Mesh2D setAttributes error!';
            }
        };
        __proto.getEleNum = function () {
            return this._ib.getBuffer().byteLength / 2;
        };
        __proto.releaseMesh = function () { };
        __proto.destroy = function () { };
        __proto.clearVB = function () {
            this._vb.clear();
        };
        Mesh2D._gvaoid = 0;
        return Mesh2D;
    })();
    var RenderState2D = (function () {
        function RenderState2D() { }
        __class(RenderState2D, 'laya.webgl.utils.RenderState2D');
        RenderState2D.getMatrArray = function () {
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        };
        RenderState2D.mat2MatArray = function (mat, matArray) {
            var m = mat;
            var m4 = matArray;
            m4[0] = m.a;
            m4[1] = m.b;
            m4[2] = RenderState2D.EMPTYMAT4_ARRAY[2];
            m4[3] = RenderState2D.EMPTYMAT4_ARRAY[3];
            m4[4] = m.c;
            m4[5] = m.d;
            m4[6] = RenderState2D.EMPTYMAT4_ARRAY[6];
            m4[7] = RenderState2D.EMPTYMAT4_ARRAY[7];
            m4[8] = RenderState2D.EMPTYMAT4_ARRAY[8];
            m4[9] = RenderState2D.EMPTYMAT4_ARRAY[9];
            m4[10] = RenderState2D.EMPTYMAT4_ARRAY[10];
            m4[11] = RenderState2D.EMPTYMAT4_ARRAY[11];
            m4[12] = m.tx;
            m4[13] = m.ty;
            m4[14] = RenderState2D.EMPTYMAT4_ARRAY[14];
            m4[15] = RenderState2D.EMPTYMAT4_ARRAY[15];
            return matArray;
        };
        RenderState2D.restoreTempArray = function () {
            RenderState2D.TEMPMAT4_ARRAY[0] = 1;
            RenderState2D.TEMPMAT4_ARRAY[1] = 0;
            RenderState2D.TEMPMAT4_ARRAY[4] = 0;
            RenderState2D.TEMPMAT4_ARRAY[5] = 1;
            RenderState2D.TEMPMAT4_ARRAY[12] = 0;
            RenderState2D.TEMPMAT4_ARRAY[13] = 0;
        };
        RenderState2D.clear = function () {
            RenderState2D.worldScissorTest = false;
            RenderState2D.worldShaderDefines = null;
            RenderState2D.worldFilters = null;
            RenderState2D.worldAlpha = 1;
            RenderState2D.worldClipRect.x = RenderState2D.worldClipRect.y = 0;
            RenderState2D.worldClipRect.width = RenderState2D.width;
            RenderState2D.worldClipRect.height = RenderState2D.height;
            RenderState2D.curRenderTarget = null;
        };
        RenderState2D._MAXSIZE = 99999999;
        RenderState2D.EMPTYMAT4_ARRAY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        RenderState2D.TEMPMAT4_ARRAY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        RenderState2D.worldMatrix4 = RenderState2D.TEMPMAT4_ARRAY;
        RenderState2D.worldAlpha = 1.0;
        RenderState2D.worldScissorTest = false;
        RenderState2D.worldFilters = null;
        RenderState2D.worldShaderDefines = null;
        RenderState2D.curRenderTarget = null;
        RenderState2D.width = 0;
        RenderState2D.height = 0;
        __static(RenderState2D, ['worldMatrix', function () { return this.worldMatrix = new Matrix(); }, 'worldClipRect', function () { return this.worldClipRect = new Rectangle(0, 0, 99999999, 99999999); }
        ]);
        return RenderState2D;
    })();
    var ShaderCompile = (function () {
        var ShaderNode, InlcudeFile;
        function ShaderCompile(name, vs, ps, nameMap, defs) {
            var _$this = this;
            function _compile(script) {
                var includefiles = [];
                var top = new ShaderNode(includefiles);
                _$this._compileToTree(top, script.split('\n'), 0, includefiles, defs);
                return top;
            }
            ;
            var startTime = Browser.now();
            this._VS = _compile(vs);
            this._PS = _compile(ps);
            this._nameMap = nameMap;
            if ((Browser.now() - startTime) > 2)
                console_log("ShaderCompile use time:" + (Browser.now() - startTime) + "  size:" + vs.length + "/" + ps.length);
        }
        __class(ShaderCompile, 'laya.webgl.utils.ShaderCompile');
        var __proto = ShaderCompile.prototype;
        __proto._compileToTree = function (parent, lines, start, includefiles, defs) {
            var node, preNode;
            var text, name, fname;
            var ofs = 0, words, noUseNode;
            var i = 0, n = 0, j = 0;
            for (i = start; i < lines.length; i++) {
                text = lines[i];
                if (text.length < 1)
                    continue;
                ofs = text.indexOf("//");
                if (ofs === 0)
                    continue;
                if (ofs >= 0)
                    text = text.substr(0, ofs);
                node = noUseNode || new ShaderNode(includefiles);
                noUseNode = null;
                node.text = text;
                node.noCompile = true;
                if ((ofs = text.indexOf("#")) >= 0) {
                    name = "#";
                    for (j = ofs + 1, n = text.length; j < n; j++) {
                        var c = text.charAt(j);
                        if (c === ' ' || c === '\t' || c === '?')
                            break;
                        name += c;
                    }
                    node.name = name;
                    switch (name) {
                        case "#ifdef":
                        case "#ifndef":
                            node.src = text;
                            node.noCompile = text.match(/[!&|()=<>]/) != null;
                            if (!node.noCompile) {
                                words = text.replace(/^\s*/, '').split(/\s+/);
                                node.setCondition(words[1], name === "#ifdef" ? 1 : 2);
                                node.text = "//" + node.text;
                            }
                            else {
                                console_log("function():Boolean{return " + text.substr(ofs + node.name.length) + "}");
                            }
                            node.setParent(parent);
                            parent = node;
                            if (defs) {
                                words = text.substr(j).split(ShaderCompile._splitToWordExps3);
                                for (j = 0; j < words.length; j++) {
                                    text = words[j];
                                    text.length && (defs[text] = true);
                                }
                            }
                            continue;
                        case "#if":
                            node.src = text;
                            node.noCompile = true;
                            node.setParent(parent);
                            parent = node;
                            if (defs) {
                                words = text.substr(j).split(ShaderCompile._splitToWordExps3);
                                for (j = 0; j < words.length; j++) {
                                    text = words[j];
                                    text.length && text != "defined" && (defs[text] = true);
                                }
                            }
                            continue;
                        case "#else":
                            node.src = text;
                            parent = parent.parent;
                            preNode = parent.childs[parent.childs.length - 1];
                            node.noCompile = preNode.noCompile;
                            if (!(node.noCompile)) {
                                node.condition = preNode.condition;
                                node.conditionType = preNode.conditionType == 1 ? 2 : 1;
                                node.text = "//" + node.text + " " + preNode.text + " " + node.conditionType;
                            }
                            node.setParent(parent);
                            parent = node;
                            continue;
                        case "#endif":
                            parent = parent.parent;
                            preNode = parent.childs[parent.childs.length - 1];
                            node.noCompile = preNode.noCompile;
                            if (!(node.noCompile)) {
                                node.text = "//" + node.text;
                            }
                            node.setParent(parent);
                            continue;
                        case "#include":
                            words = ShaderCompile.splitToWords(text, null);
                            var inlcudeFile = ShaderCompile.includes[words[1]];
                            if (!inlcudeFile) {
                                throw "ShaderCompile error no this include file:" + words[1];
                                return;
                            }
                            if ((ofs = words[0].indexOf("?")) < 0) {
                                node.setParent(parent);
                                text = inlcudeFile.getWith(words[2] == 'with' ? words[3] : null);
                                this._compileToTree(node, text.split('\n'), 0, includefiles, defs);
                                node.text = "";
                                continue;
                            }
                            node.setCondition(words[0].substr(ofs + 1), 1);
                            node.text = inlcudeFile.getWith(words[2] == 'with' ? words[3] : null);
                            break;
                        case "#import":
                            words = ShaderCompile.splitToWords(text, null);
                            fname = words[1];
                            includefiles.push({ node: node, file: ShaderCompile.includes[fname], ofs: node.text.length });
                            continue;
                    }
                }
                else {
                    preNode = parent.childs[parent.childs.length - 1];
                    if (preNode && !preNode.name) {
                        includefiles.length > 0 && ShaderCompile.splitToWords(text, preNode);
                        noUseNode = node;
                        preNode.text += "\n" + text;
                        continue;
                    }
                    includefiles.length > 0 && ShaderCompile.splitToWords(text, node);
                }
                node.setParent(parent);
            }
        };
        __proto.createShader = function (define, shaderName, createShader) {
            var defMap = {};
            // 按照顺序取得代码
            var kds_logic_ps_codes = "";
            var kds_logic_ps_codesArr = [];
            var defineStr = "";
            if (define) {
                for (var i in define) {
                    defineStr += "#define " + i + "\n";
                    defMap[i] = true;
                    if (Shader.KDSPSShaderLogicArr) {
                        var logic_ps_code = Shader.KDSPSShaderLogicArr[i];
                        if (logic_ps_code != null) {
                            var logicOrder = define[i];
                            kds_logic_ps_codesArr[logicOrder - 1] = logic_ps_code;
                        }
                    }
                }
            }
            ;
            kds_logic_ps_codes = kds_logic_ps_codesArr.join("");
            var vs = this._VS.toscript(defMap, []);
            var ps = this._PS.toscript(defMap, [], kds_logic_ps_codes);
            return (createShader || Shader.create)(defineStr + vs.join('\n'), defineStr + ps.join('\n'), shaderName, this._nameMap);
        };
        ShaderCompile._parseOne = function (attributes, uniforms, words, i, word, b) {
            var one = { type: ShaderCompile.shaderParamsMap[words[i + 1]], name: words[i + 2], size: isNaN(parseInt(words[i + 3])) ? 1 : parseInt(words[i + 3]) };
            if (b) {
                if (word == "attribute") {
                    attributes.push(one);
                }
                else {
                    uniforms.push(one);
                }
            }
            if (words[i + 3] == ':') {
                one.type = words[i + 4];
                i += 2;
            }
            i += 2;
            return i;
        };
        ShaderCompile.addInclude = function (fileName, txt, force) {
            if (!txt || txt.length === 0)
                throw new Error("add shader include file err:" + fileName);
            if (!force && ShaderCompile.includes[fileName])
                throw new Error("add shader include file err, has add:" + fileName);
            ShaderCompile.includes[fileName] = new InlcudeFile(txt);
        };
        ShaderCompile.preGetParams = function (vs, ps) {
            var text = [vs, ps];
            var result = {};
            var attributes = [];
            var uniforms = [];
            var definesInfo = {};
            var definesName = [];
            result.attributes = attributes;
            result.uniforms = uniforms;
            result.defines = definesInfo;
            var i = 0, n = 0, one;
            for (var s = 0; s < 2; s++) {
                text[s] = text[s].replace(ShaderCompile._removeAnnotation, "");
                var words = text[s].match(ShaderCompile._reg);
                var tempelse;
                for (i = 0, n = words.length; i < n; i++) {
                    var word = words[i];
                    if (word != "attribute" && word != "uniform") {
                        if (word == "#define") {
                            word = words[++i];
                            definesName[word] = 1;
                            continue;
                        }
                        else if (word == "#ifdef") {
                            tempelse = words[++i];
                            var def = definesInfo[tempelse] = definesInfo[tempelse] || [];
                            for (i++; i < n; i++) {
                                word = words[i];
                                if (word != "attribute" && word != "uniform") {
                                    if (word == "#else") {
                                        for (i++; i < n; i++) {
                                            word = words[i];
                                            if (word != "attribute" && word != "uniform") {
                                                if (word == "#endif") {
                                                    break;
                                                }
                                                continue;
                                            }
                                            i = ShaderCompile._parseOne(attributes, uniforms, words, i, word, !definesName[tempelse]);
                                        }
                                    }
                                    continue;
                                }
                                i = ShaderCompile._parseOne(attributes, uniforms, words, i, word, definesName[tempelse]);
                            }
                        }
                        continue;
                    }
                    i = ShaderCompile._parseOne(attributes, uniforms, words, i, word, true);
                }
            }
            return result;
        };
        ShaderCompile.splitToWords = function (str, block) {
            var out = [];
            var c;
            var ofs = -1;
            var word;
            for (var i = 0, n = str.length; i < n; i++) {
                c = str.charAt(i);
                if (" \t=+-*/&%!<>()'\",;".indexOf(c) >= 0) {
                    if (ofs >= 0 && (i - ofs) > 1) {
                        word = str.substr(ofs, i - ofs);
                        out.push(word);
                    }
                    if (c == '"' || c == "'") {
                        var ofs2 = str.indexOf(c, i + 1);
                        if (ofs2 < 0) {
                            throw "Sharder err:" + str;
                        }
                        out.push(str.substr(i + 1, ofs2 - i - 1));
                        i = ofs2;
                        ofs = -1;
                        continue;
                    }
                    if (c == '(' && block && out.length > 0) {
                        word = out[out.length - 1] + ";";
                        if ("vec4;main;".indexOf(word) < 0)
                            block.useFuns += word;
                    }
                    ofs = -1;
                    continue;
                }
                if (ofs < 0)
                    ofs = i;
            }
            if (ofs < n && (n - ofs) > 1) {
                word = str.substr(ofs, n - ofs);
                out.push(word);
            }
            return out;
        };
        ShaderCompile.IFDEF_NO = 0;
        ShaderCompile.IFDEF_YES = 1;
        ShaderCompile.IFDEF_ELSE = 2;
        ShaderCompile.IFDEF_PARENT = 3;
        ShaderCompile._removeAnnotation = new RegExp("(/\\*([^*]|[\\r\\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+/)|(//.*)", "g");
        ShaderCompile._reg = new RegExp("(\".*\")|('.*')|([#\\w\\*-\\.+/()=<>{}\\\\]+)|([,;:\\\\])", "g");
        ShaderCompile._splitToWordExps = new RegExp("[(\".*\")]+|[('.*')]+|([ \\t=\\+\\-*/&%!<>!%\(\),;])", "g");
        ShaderCompile.includes = {};
        __static(ShaderCompile, ['shaderParamsMap', function () { return this.shaderParamsMap = { "float": 0x1406, "int": 0x1404, "bool": 0x8B56, "vec2": 0x8B50, "vec3": 0x8B51, "vec4": 0x8B52, "ivec2": 0x8B53, "ivec3": 0x8B54, "ivec4": 0x8B55, "bvec2": 0x8B57, "bvec3": 0x8B58, "bvec4": 0x8B59, "mat2": 0x8B5A, "mat3": 0x8B5B, "mat4": 0x8B5C, "sampler2D": 0x8B5E, "samplerCube": 0x8B60 }; }, '_splitToWordExps3', function () { return this._splitToWordExps3 = new RegExp("[ \\t=\\+\\-*/&%!<>!%\(\),;\\|]", "g"); }
        ]);
        ShaderCompile.__init$ = function () {
            ShaderNode = (function () {
                function ShaderNode(includefiles) {
                    this.childs = [];
                    this.text = "";
                    this.parent = null;
                    this.name = null;
                    this.noCompile = false;
                    this.includefiles = null;
                    this.condition = null;
                    this.conditionType = 0;
                    this.useFuns = "";
                    this.z = 0;
                    this.src = null;
                    this.includefiles = includefiles;
                }
                __class(ShaderNode, '');
                var __proto = ShaderNode.prototype;
                __proto.setParent = function (parent) {
                    parent.childs.push(this);
                    this.z = parent.z + 1;
                    this.parent = parent;
                };
                __proto.setCondition = function (condition, type) {
                    if (condition) {
                        this.conditionType = type;
                        condition = condition.replace(/(\s*$)/g, "");
                        this.condition = function () {
                            return this[condition];
                        };
                        this.condition.__condition = condition;
                    }
                };
                __proto.toscript = function (def, out, kds_logic_ps_codes) {
                    return this._toscript(def, out, ++ShaderNode.__id, kds_logic_ps_codes);
                };
                __proto._toscript = function (def, out, id, kds_logic_ps_codes) {
                    if (this.childs.length < 1 && !this.text)
                        return out;
                    var outIndex = out.length;
                    if (this.condition) {
                        var ifdef = !!this.condition.call(def);
                        this.conditionType === 2 && (ifdef = !ifdef);
                        if (!ifdef)
                            return out;
                    }
                    // 替换，按照顺序执行
                    if (this.text.indexOf("KDS_PS_SHADER_LOGICS") != -1) {
                        out.push(kds_logic_ps_codes);
                    }
                    else {
                        this.text && out.push(this.text);
                    }
                    this.childs.length > 0 && this.childs.forEach(function (o, index, arr) {
                        o._toscript(def, out, id, kds_logic_ps_codes);
                    });
                    if (this.includefiles.length > 0 && this.useFuns.length > 0) {
                        var funsCode;
                        for (var i = 0, n = this.includefiles.length; i < n; i++) {
                            if (this.includefiles[i].curUseID == id) {
                                continue;
                            }
                            funsCode = this.includefiles[i].file.getFunsScript(this.useFuns);
                            if (funsCode.length > 0) {
                                this.includefiles[i].curUseID = id;
                                out[0] = funsCode + out[0];
                            }
                        }
                    }
                    return out;
                };
                ShaderNode.__id = 1;
                return ShaderNode;
            })();
            InlcudeFile = (function () {
                function InlcudeFile(txt) {
                    this.script = null;
                    this.codes = {};
                    this.funs = {};
                    this.curUseID = -1;
                    this.funnames = "";
                    this.script = txt;
                    var begin = 0, ofs = 0, end = 0;
                    while (true) {
                        begin = txt.indexOf("#begin", begin);
                        if (begin < 0)
                            break;
                        end = begin + 5;
                        while (true) {
                            end = txt.indexOf("#end", end);
                            if (end < 0)
                                break;
                            if (txt.charAt(end + 4) === 'i')
                                end += 5;
                            else
                                break;
                        }
                        if (end < 0) {
                            throw "add include err,no #end:" + txt;
                            return;
                        }
                        ofs = txt.indexOf('\n', begin);
                        var words = ShaderCompile.splitToWords(txt.substr(begin, ofs - begin), null);
                        if (words[1] == 'code') {
                            this.codes[words[2]] = txt.substr(ofs + 1, end - ofs - 1);
                        }
                        else if (words[1] == 'function') {
                            ofs = txt.indexOf("function", begin);
                            ofs += "function".length;
                            this.funs[words[3]] = txt.substr(ofs + 1, end - ofs - 1);
                            this.funnames += words[3] + ";";
                        }
                        begin = end + 1;
                    }
                }
                __class(InlcudeFile, '');
                var __proto = InlcudeFile.prototype;
                __proto.getWith = function (name) {
                    var r = name ? this.codes[name] : this.script;
                    if (!r) {
                        throw "get with error:" + name;
                    }
                    return r;
                };
                __proto.getFunsScript = function (funsdef) {
                    var r = "";
                    for (var i in this.funs) {
                        if (funsdef.indexOf(i + ";") >= 0) {
                            r += this.funs[i];
                        }
                    }
                    return r;
                };
                return InlcudeFile;
            })();
        };
        return ShaderCompile;
    })();
    var WebGL = (function () {
        function WebGL() { }
        __class(WebGL, 'laya.webgl.WebGL');
        WebGL._uint8ArraySlice = function () {
            var _this = this;
            var sz = _this.length;
            var dec = new Uint8Array(_this.length);
            for (var i = 0; i < sz; i++)
                dec[i] = _this[i];
            return dec;
        };
        WebGL._float32ArraySlice = function () {
            var _this = this;
            var sz = _this.length;
            var dec = new Float32Array(_this.length);
            for (var i = 0; i < sz; i++)
                dec[i] = _this[i];
            return dec;
        };
        WebGL._uint16ArraySlice = function (__arg) {
            var arg = arguments;
            var _this = this;
            var sz = 0;
            var dec;
            var i = 0;
            if (arg.length === 0) {
                sz = _this.length;
                dec = new Uint16Array(sz);
                for (i = 0; i < sz; i++)
                    dec[i] = _this[i];
            }
            else if (arg.length === 2) {
                var start = arg[0];
                var end = arg[1];
                if (end > start) {
                    sz = end - start;
                    dec = new Uint16Array(sz);
                    for (i = start; i < end; i++)
                        dec[i - start] = _this[i];
                }
                else {
                    dec = new Uint16Array(0);
                }
            }
            return dec;
        };
        WebGL.expandContext = function () {
            var from = Context.prototype;
            var to = CanvasRenderingContext2D.prototype;
            to.fillTrangles = from.fillTrangles;
            Buffer2D.__int__(null);
            to.setIBVB = function (x, y, ib, vb, numElement, mat, shader, shaderValues, startIndex, offset) {
                (startIndex === void 0) && (startIndex = 0);
                (offset === void 0) && (offset = 0);
                if (ib === null) {
                    this._ib = this._ib || IndexBuffer2D.QuadrangleIB;
                    ib = this._ib;
                    GlUtils.expandIBQuadrangle(ib, (vb._byteLength / (4 * 16) + 8));
                }
                this._setIBVB(x, y, ib, vb, numElement, mat, shader, shaderValues, startIndex, offset);
            };
            to.fillTrangles = function (tex, x, y, points, m) {
                this._curMat = this._curMat || Matrix.create();
                this._vb = this._vb || VertexBuffer2D.create();
                if (!this._ib) {
                    this._ib = IndexBuffer2D.create();
                    GlUtils.fillIBQuadrangle(this._ib, length / 4);
                }
                ;
                var vb = this._vb;
                var length = points.length >> 4;
                GlUtils.fillTranglesVB(vb, x, y, points, m || this._curMat, 0, 0);
                GlUtils.expandIBQuadrangle(this._ib, (vb._byteLength / (4 * 16) + 8));
                var shaderValues = new Value2D(0x01, 0);
                shaderValues.textureHost = tex;
                var sd = new Shader2X("attribute vec2 position; attribute vec2 texcoord; uniform vec2 size; uniform mat4 mmat; varying vec2 v_texcoord; void main() { vec4 p=vec4(position.xy,0.0,1.0);vec4 pos=mmat*p; gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0); v_texcoord = texcoord; }", "precision mediump float; varying vec2 v_texcoord; uniform sampler2D texture; void main() {vec4 color= texture2D(texture, v_texcoord); color.a*=1.0; gl_FragColor= color;}");
                vb._vertType = 3;
                this._setIBVB(x, y, this._ib, vb, length * 6, m, sd, shaderValues, 0, 0);
            };
        };
        WebGL.enable = function () {
            Browser.__init__();
            if (Render.isConchApp) {
                if (!Render.isConchWebGL) {
                    RunDriver.skinAniSprite = function () {
                        var tSkinSprite = new SkinMesh();
                        return tSkinSprite;
                    };
                    WebGL.expandContext();
                    return false;
                }
            }
            RunDriver.getWebGLContext = function getWebGLContext(canvas) {
                var gl;
                var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
                for (var i = 0; i < names.length; i++) {
                    try {
                        gl = canvas.getContext(names[i], { stencil: Config.isStencil, alpha: Config.isAlpha, antialias: Config.isAntialias, premultipliedAlpha: Config.premultipliedAlpha, preserveDrawingBuffer: Config.preserveDrawingBuffer });
                    }
                    catch (e) { }
                    if (gl)
                        return gl;
                }
                return null;
            };
            WebGL.mainContext = RunDriver.getWebGLContext(Render._mainCanvas);
            if (WebGL.mainContext == null)
                return false;
            if (Render.isWebGL)
                return true;
            HTMLImage.create = function (src, def) {
                return new WebGLImage(src, def);
            };
            HTMLSubImage.create = function (canvas, offsetX, offsetY, width, height, atlasImage, src) {
                return new WebGLSubImage(canvas, offsetX, offsetY, width, height, atlasImage, src);
            };
            Render.WebGL = WebGL;
            Render.isWebGL = true;
            DrawText.__init__();
            RunDriver.createRenderSprite = function (type, next) {
                return new RenderSprite3D(type, next);
            };
            RunDriver.createWebGLContext2D = function (c) {
                return new WebGLContext2D(c);
            };
            RunDriver.changeWebGLSize = function (width, height) {
                laya.webgl.WebGL.onStageResize(width, height);
            };
            RunDriver.createGraphics = function () {
                return new GraphicsGL();
            };
            var action = RunDriver.createFilterAction;
            RunDriver.createFilterAction = action ? action : function (type) {
                return new ColorFilterActionGL();
            };
            RunDriver.clear = function (color) {
                RenderState2D.worldScissorTest && laya.webgl.WebGL.mainContext.disable(0x0C11);
                var ctx = Render.context.ctx;
                var c = (ctx._submits._length == 0 || Config.preserveDrawingBuffer) ? Color.create(color)._color : Stage._wgColor;
                if (c)
                    ctx.clearBG(c[0], c[1], c[2], c[3]);
                RenderState2D.clear();
            };
            RunDriver.addToAtlas = function (texture, force) {
                (force === void 0) && (force = false);
                var bitmap = texture.bitmap;
                if (!Render.optimizeTextureMemory(texture.url, texture)) {
                    (bitmap).enableMerageInAtlas = false;
                    return;
                }
                if ((Laya.__typeof(bitmap, 'laya.webgl.resource.IMergeAtlasBitmap')) && ((bitmap).allowMerageInAtlas)) {
                    bitmap.on("recovered", texture, texture.addTextureToAtlas);
                }
            };
            RunDriver.isAtlas = function (bitmap) {
                return (bitmap instanceof laya.webgl.atlas.AtlasWebGLCanvas);
            };
            AtlasResourceManager._enable();
            RunDriver.beginFlush = function () {
                var atlasResourceManager = AtlasResourceManager.instance;
                var count = atlasResourceManager.getAtlaserCount();
                for (var i = 0; i < count; i++) {
                    var atlerCanvas = atlasResourceManager.getAtlaserByIndex(i).texture;
                    (atlerCanvas._flashCacheImageNeedFlush) && (RunDriver.flashFlushImage(atlerCanvas));
                }
            };
            RunDriver.drawToCanvas = function (sprite, _renderType, canvasWidth, canvasHeight, offsetX, offsetY) {
                if (canvasWidth <= 0 || canvasHeight <= 0) {
                    console_log("[error] canvasWidth and canvasHeight should greater than zero");
                }
                offsetX -= sprite.x;
                offsetY -= sprite.y;
                var renderTarget = RenderTarget2D.create(canvasWidth, canvasHeight, 0x1908, 0x1401, 0, false);
                renderTarget.start();
                renderTarget.clear(0, 0, 0, 0);
                Render.context.clear();
                RenderSprite.renders[_renderType]._fun(sprite, Render.context, offsetX, RenderState2D.height - canvasHeight + offsetY);
                Render.context.flush();
                renderTarget.end();
                var pixels = renderTarget.getData(0, 0, renderTarget.width, renderTarget.height);
                renderTarget.recycle();
                var htmlCanvas = new WebGLCanvas();
                htmlCanvas._canvas = Browser.createElement("canvas");
                htmlCanvas.size(canvasWidth, canvasHeight);
                var context = htmlCanvas._canvas.getContext('2d');
                Browser.canvas.size(canvasWidth, canvasHeight);
                var tempContext = Browser.context;
                var imgData = tempContext.createImageData(canvasWidth, canvasHeight);
                imgData.data.set(new Uint8ClampedArray(pixels.buffer));
                htmlCanvas._imgData = imgData;
                tempContext.putImageData(imgData, 0, 0);
                context.save();
                context.translate(0, canvasHeight);
                context.scale(1, -1);
                context.drawImage(Browser.canvas.source, 0, 0);
                context.restore();
                return htmlCanvas;
            };
            RunDriver.createFilterAction = function (type) {
                var action;
                switch (type) {
                    case 0x20:
                        action = new ColorFilterActionGL();
                        break;
                }
                return action;
            };
            RunDriver.addTextureToAtlas = function (texture) {
                texture._uvID++;
                AtlasResourceManager._atlasRestore++;
                ((texture.bitmap).enableMerageInAtlas) && (AtlasResourceManager.instance.addToAtlas(texture));
            };
            RunDriver.getTexturePixels = function (value, x, y, width, height) {
                (Render.context.ctx).clear();
                var tSprite = new Sprite();
                tSprite.graphics.drawTexture(value, -x, -y);
                var tRenderTarget = RenderTarget2D.create(width, height);
                tRenderTarget.start();
                tRenderTarget.clear(0, 0, 0, 0);
                tSprite.render(Render.context, 0, 0);
                (Render.context.ctx).flush();
                tRenderTarget.end();
                var tUint8Array = tRenderTarget.getData(0, 0, width, height);
                var tArray = [];
                var tIndex = 0;
                for (var i = height - 1; i >= 0; i--) {
                    for (var j = 0; j < width; j++) {
                        tIndex = (i * width + j) * 4;
                        tArray.push(tUint8Array[tIndex]);
                        tArray.push(tUint8Array[tIndex + 1]);
                        tArray.push(tUint8Array[tIndex + 2]);
                        tArray.push(tUint8Array[tIndex + 3]);
                    }
                }
                return tArray;
            };
            RunDriver.skinAniSprite = function () {
                var tSkinSprite = new SkinMesh();
                return tSkinSprite;
            };
            HTMLCanvas.create = function (type, canvas) {
                var ret = new WebGLCanvas();
                ret._imgData = canvas;
                ret.flipY = false;
                return ret;
            };
            Filter._filterStart = function (scope, sprite, context, x, y) {
                var b = scope.getValue("bounds");
                var source = RenderTarget2D.create(b.width, b.height);
                source.start();
                source.clear(0, 0, 0, 0);
                scope.addValue("src", source);
                scope.addValue("ScissorTest", RenderState2D.worldScissorTest);
                if (RenderState2D.worldScissorTest) {
                    var tClilpRect = new Rectangle();
                    tClilpRect.copyFrom((context.ctx)._clipRect);
                    scope.addValue("clipRect", tClilpRect);
                    RenderState2D.worldScissorTest = false;
                    laya.webgl.WebGL.mainContext.disable(0x0C11);
                }
            };
            Filter._filterEnd = function (scope, sprite, context, x, y) {
                var b = scope.getValue("bounds");
                var source = scope.getValue("src");
                source.end();
                var out = RenderTarget2D.create(b.width, b.height);
                out.start();
                out.clear(0, 0, 0, 0);
                scope.addValue("out", out);
                sprite._set$P('_filterCache', out);
                sprite._set$P('_isHaveGlowFilter', scope.getValue("_isHaveGlowFilter"));
            };
            Filter._EndTarget = function (scope, context) {
                var source = scope.getValue("src");
                source.recycle();
                var out = scope.getValue("out");
                out.end();
                var b = scope.getValue("ScissorTest");
                if (b) {
                    RenderState2D.worldScissorTest = true;
                    laya.webgl.WebGL.mainContext.enable(0x0C11);
                    context.ctx.save();
                    var tClipRect = scope.getValue("clipRect");
                    (context.ctx).clipRect(tClipRect.x, tClipRect.y, tClipRect.width, tClipRect.height);
                }
            };
            Filter._useSrc = function (scope) {
                var source = scope.getValue("out");
                source.end();
                source = scope.getValue("src");
                source.start();
                source.clear(0, 0, 0, 0);
            };
            Filter._endSrc = function (scope) {
                var source = scope.getValue("src");
                source.end();
            };
            Filter._useOut = function (scope) {
                var source = scope.getValue("src");
                source.end();
                source = scope.getValue("out");
                source.start();
                source.clear(0, 0, 0, 0);
            };
            Filter._endOut = function (scope) {
                var source = scope.getValue("out");
                source.end();
            };
            Filter._recycleScope = function (scope) {
                scope.recycle();
            };
            Filter._filter = function (sprite, context, x, y) {
                var next = this._next;
                if (next) {
                    var filters = sprite.filters, len = filters.length;
                    if (len == 1 && (filters[0].type == 0x20)) {
                        context.ctx.save();
                        context.ctx.setFilters([filters[0]]);
                        next._fun.call(next, sprite, context, x, y);
                        context.ctx.restore();
                        return;
                    }
                    // 自定义shader，平铺+多滤镜会黑，所以该shader保证只有一个即可
                    else if (len == 1 && (filters[0].type == 0x800) && sprite.hasTilingAttribute) {
                        context.ctx.save();
                        context.ctx.setFilters([filters[0]]);
                        next._fun.call(next, sprite, context, x, y);
                        context.ctx.restore();
                        return;
                    }
                    ;
                    var shaderValue;
                    var b;
                    var scope = SubmitCMDScope.create();
                    var p = Point.TEMP;
                    var tMatrix = context.ctx._getTransformMatrix();
                    var mat = Matrix.create();
                    tMatrix.copyTo(mat);
                    var tPadding = 0;
                    var tHalfPadding = 0;
                    var tIsHaveGlowFilter = false;
                    var out = sprite._$P._filterCache ? sprite._$P._filterCache : null;
                    if (!out || sprite._repaint) {
                        tIsHaveGlowFilter = sprite._isHaveGlowFilter();
                        scope.addValue("_isHaveGlowFilter", tIsHaveGlowFilter);
                        if (tIsHaveGlowFilter) {
                            tPadding = 50;
                            tHalfPadding = 25;
                        }
                        b = new Rectangle();
                        b.copyFrom((sprite).getSelfBounds());
                        b.x += (sprite).x;
                        b.y += (sprite).y;
                        b.x -= (sprite).pivotX + 4;
                        b.y -= (sprite).pivotY + 4;
                        var tSX = b.x;
                        var tSY = b.y;
                        b.width += (tPadding + 8);
                        b.height += (tPadding + 8);
                        p.x = b.x * mat.a + b.y * mat.c;
                        p.y = b.y * mat.d + b.x * mat.b;
                        b.x = p.x;
                        b.y = p.y;
                        p.x = b.width * mat.a + b.height * mat.c;
                        p.y = b.height * mat.d + b.width * mat.b;
                        b.width = p.x;
                        b.height = p.y;
                        if (b.width <= 0 || b.height <= 0) {
                            return;
                        }
                        out && out.recycle();
                        scope.addValue("bounds", b);
                        var submit = SubmitCMD.create([scope, sprite, context, 0, 0], Filter._filterStart);
                        context.addRenderObject(submit);
                        (context.ctx)._renderKey = 0;
                        (context.ctx)._shader2D.glTexture = null;
                        var tX = sprite.x - tSX + tHalfPadding;
                        var tY = sprite.y - tSY + tHalfPadding;
                        next._fun.call(next, sprite, context, tX, tY);
                        submit = SubmitCMD.create([scope, sprite, context, 0, 0], Filter._filterEnd);
                        context.addRenderObject(submit);
                        for (var i = 0; i < len; i++) {
                            if (i != 0) {
                                submit = SubmitCMD.create([scope], Filter._useSrc);
                                context.addRenderObject(submit);
                                shaderValue = Value2D.create(0x01, 0);
                                Matrix.TEMP.identity();
                                context.ctx.drawTarget(scope, 0, 0, b.width, b.height, Matrix.TEMP, "out", shaderValue, null, BlendMode.TOINT.overlay);
                                submit = SubmitCMD.create([scope], Filter._useOut);
                                context.addRenderObject(submit);
                            }
                            ;
                            var fil = filters[i];
                            fil.action.apply3d(scope, sprite, context, 0, 0);
                        }
                        submit = SubmitCMD.create([scope, context], Filter._EndTarget);
                        context.addRenderObject(submit);
                    }
                    else {
                        tIsHaveGlowFilter = sprite._$P._isHaveGlowFilter ? sprite._$P._isHaveGlowFilter : false;
                        if (tIsHaveGlowFilter) {
                            tPadding = 50;
                            tHalfPadding = 25;
                        }
                        b = sprite.getBounds();
                        if (b.width <= 0 || b.height <= 0) {
                            return;
                        }
                        b.width += tPadding;
                        b.height += tPadding;
                        p.x = b.x * mat.a + b.y * mat.c;
                        p.y = b.y * mat.d + b.x * mat.b;
                        b.x = p.x;
                        b.y = p.y;
                        p.x = b.width * mat.a + b.height * mat.c;
                        p.y = b.height * mat.d + b.width * mat.b;
                        b.width = p.x;
                        b.height = p.y;
                        scope.addValue("out", out);
                    }
                    x = x - tHalfPadding - sprite.x;
                    y = y - tHalfPadding - sprite.y;
                    p.setTo(x, y);
                    mat.transformPoint(p);
                    x = p.x + b.x;
                    y = p.y + b.y;
                    shaderValue = Value2D.create(0x01, 0);
                    Matrix.TEMP.identity();
                    (context.ctx).drawTarget(scope, x, y, b.width, b.height, Matrix.TEMP, "out", shaderValue, null, BlendMode.TOINT.overlay);
                    submit = SubmitCMD.create([scope], Filter._recycleScope);
                    context.addRenderObject(submit);
                    mat.destroy();
                }
            };
            Float32Array.prototype.slice || (Float32Array.prototype.slice = WebGL._float32ArraySlice);
            Uint16Array.prototype.slice || (Uint16Array.prototype.slice = WebGL._uint16ArraySlice);
            Uint8Array.prototype.slice || (Uint8Array.prototype.slice = WebGL._uint8ArraySlice);
            return true;
        };
        WebGL.onStageResize = function (width, height) {
            if (WebGL.mainContext == null)
                return;
            WebGL.mainContext.viewport(0, 0, width, height);
            RenderState2D.width = width;
            RenderState2D.height = height;
        };
        WebGL.onInvalidGLRes = function () {
            AtlasResourceManager.instance.freeAll();
            ResourceManager.releaseContentManagers(true);
            WebGL.doNodeRepaint(Laya.stage);
            WebGL.mainContext.viewport(0, 0, RenderState2D.width, RenderState2D.height);
            Laya.stage.event("devicelost");
        };
        WebGL.doNodeRepaint = function (sprite) {
            (sprite.numChildren == 0) && (sprite.repaint());
            for (var i = 0; i < sprite.numChildren; i++)
                WebGL.doNodeRepaint(sprite.getChildAt(i));
        };
        WebGL.init = function (canvas, width, height) {
            WebGL.mainCanvas = canvas;
            HTMLCanvas._createContext = function (canvas) {
                return new WebGLContext2D(canvas);
            };
            WebGLCanvas._createContext = function (canvas) {
                return new WebGLContext2D(canvas);
            };
            var gl = laya.webgl.WebGL.mainContext;
            if (gl.getShaderPrecisionFormat != null) {
                var vertexPrecisionFormat = gl.getShaderPrecisionFormat(0x8B31, 0x8DF2);
                var framePrecisionFormat = gl.getShaderPrecisionFormat(0x8B30, 0x8DF2);
                WebGL.shaderHighPrecision = (vertexPrecisionFormat.precision && framePrecisionFormat.precision) ? true : false;
            }
            else {
                WebGL.shaderHighPrecision = false;
            }
            WebGL.compressAstc = gl.getExtension("WEBGL_compressed_texture_astc");
            WebGL.compressAtc = gl.getExtension("WEBGL_compressed_texture_atc");
            WebGL.compressEtc = gl.getExtension("WEBGL_compressed_texture_etc");
            WebGL.compressEtc1 = gl.getExtension("WEBGL_compressed_texture_etc1");
            WebGL.compressPvrtc = gl.getExtension("WEBGL_compressed_texture_pvrtc");
            WebGL.compressS3tc = gl.getExtension("WEBGL_compressed_texture_s3tc");
            WebGL.compressS3tc_srgb = gl.getExtension("WEBGL_compressed_texture_s3tc_srgb");
            gl.deleteTexture1 = gl.deleteTexture;
            gl.deleteTexture = function (t) {
                if (t == WebGLContext.curBindTexValue) {
                    WebGLContext.curBindTexValue = null;
                }
                gl.deleteTexture1(t);
            };
            WebGL.onStageResize(width, height);
            if (WebGL.mainContext == null)
                throw new Error("webGL getContext err!");
            System.__init__();
            AtlasResourceManager.__init__();
            ShaderDefines2D.__init__();
            Submit.__init__();
            WebGLContext2D.__init__();
            Value2D.__init__();
            Shader2D.__init__();
            Buffer2D.__int__(gl);
            BlendMode._init_(gl);
            if (Render.isConchApp) {
                conch.setOnInvalidGLRes(WebGL.onInvalidGLRes);
            }
        };
        WebGL.compressAstc = null;
        WebGL.compressAtc = null;
        WebGL.compressEtc = null;
        WebGL.compressEtc1 = null;
        WebGL.compressPvrtc = null;
        WebGL.compressS3tc = null;
        WebGL.compressS3tc_srgb = null;
        WebGL.mainCanvas = null;
        WebGL.mainContext = null;
        WebGL.antialias = true;
        WebGL.shaderHighPrecision = false;
        WebGL._bg_null = [0, 0, 0, 0];
        return WebGL;
    })();
    var WebGLContext = (function () {
        function WebGLContext() { }
        __class(WebGLContext, 'laya.webgl.WebGLContext');
        WebGLContext.UseProgram = function (program) {
            if (WebGLContext._useProgram === program)
                return false;
            WebGL.mainContext.useProgram(program);
            WebGLContext._useProgram = program;
            return true;
        };
        WebGLContext.setDepthTest = function (gl, value) {
            value !== WebGLContext._depthTest && (WebGLContext._depthTest = value, value ? gl.enable(0x0B71) : gl.disable(0x0B71));
        };
        WebGLContext.setDepthMask = function (gl, value) {
            value !== WebGLContext._depthMask && (WebGLContext._depthMask = value, gl.depthMask(value));
        };
        WebGLContext.setDepthFunc = function (gl, value) {
            value !== WebGLContext._depthFunc && (WebGLContext._depthFunc = value, gl.depthFunc(value));
        };
        WebGLContext.setBlend = function (gl, value) {
            value !== WebGLContext._blend && (WebGLContext._blend = value, value ? gl.enable(0x0BE2) : gl.disable(0x0BE2));
        };
        WebGLContext.setBlendFunc = function (gl, sFactor, dFactor) {
            (sFactor !== WebGLContext._sFactor || dFactor !== WebGLContext._dFactor) && (WebGLContext._sFactor = sFactor, WebGLContext._dFactor = dFactor, gl.blendFunc(sFactor, dFactor));
        };
        WebGLContext.setCullFace = function (gl, value) {
            value !== WebGLContext._cullFace && (WebGLContext._cullFace = value, value ? gl.enable(0x0B44) : gl.disable(0x0B44));
        };
        WebGLContext.setFrontFace = function (gl, value) {
            value !== WebGLContext._frontFace && (WebGLContext._frontFace = value, gl.frontFace(value));
        };
        WebGLContext.bindTexture = function (gl, target, texture) {
            gl.bindTexture(target, texture);
            WebGLContext.curBindTexTarget = target;
            WebGLContext.curBindTexValue = texture;
        };
        WebGLContext.DEPTH_BUFFER_BIT = 0x00000100;
        WebGLContext.STENCIL_BUFFER_BIT = 0x00000400;
        WebGLContext.COLOR_BUFFER_BIT = 0x00004000;
        WebGLContext.POINTS = 0x0000;
        WebGLContext.LINES = 0x0001;
        WebGLContext.LINE_LOOP = 0x0002;
        WebGLContext.LINE_STRIP = 0x0003;
        WebGLContext.TRIANGLES = 0x0004;
        WebGLContext.TRIANGLE_STRIP = 0x0005;
        WebGLContext.TRIANGLE_FAN = 0x0006;
        WebGLContext.ZERO = 0;
        WebGLContext.ONE = 1;
        WebGLContext.SRC_COLOR = 0x0300;
        WebGLContext.ONE_MINUS_SRC_COLOR = 0x0301;
        WebGLContext.SRC_ALPHA = 0x0302;
        WebGLContext.ONE_MINUS_SRC_ALPHA = 0x0303;
        WebGLContext.DST_ALPHA = 0x0304;
        WebGLContext.ONE_MINUS_DST_ALPHA = 0x0305;
        WebGLContext.DST_COLOR = 0x0306;
        WebGLContext.ONE_MINUS_DST_COLOR = 0x0307;
        WebGLContext.SRC_ALPHA_SATURATE = 0x0308;
        WebGLContext.FUNC_ADD = 0x8006;
        WebGLContext.BLEND_EQUATION = 0x8009;
        WebGLContext.BLEND_EQUATION_RGB = 0x8009;
        WebGLContext.BLEND_EQUATION_ALPHA = 0x883D;
        WebGLContext.FUNC_SUBTRACT = 0x800A;
        WebGLContext.FUNC_REVERSE_SUBTRACT = 0x800B;
        WebGLContext.BLEND_DST_RGB = 0x80C8;
        WebGLContext.BLEND_SRC_RGB = 0x80C9;
        WebGLContext.BLEND_DST_ALPHA = 0x80CA;
        WebGLContext.BLEND_SRC_ALPHA = 0x80CB;
        WebGLContext.CONSTANT_COLOR = 0x8001;
        WebGLContext.ONE_MINUS_CONSTANT_COLOR = 0x8002;
        WebGLContext.CONSTANT_ALPHA = 0x8003;
        WebGLContext.ONE_MINUS_CONSTANT_ALPHA = 0x8004;
        WebGLContext.BLEND_COLOR = 0x8005;
        WebGLContext.ARRAY_BUFFER = 0x8892;
        WebGLContext.ELEMENT_ARRAY_BUFFER = 0x8893;
        WebGLContext.ARRAY_BUFFER_BINDING = 0x8894;
        WebGLContext.ELEMENT_ARRAY_BUFFER_BINDING = 0x8895;
        WebGLContext.STREAM_DRAW = 0x88E0;
        WebGLContext.STATIC_DRAW = 0x88E4;
        WebGLContext.DYNAMIC_DRAW = 0x88E8;
        WebGLContext.BUFFER_SIZE = 0x8764;
        WebGLContext.BUFFER_USAGE = 0x8765;
        WebGLContext.CURRENT_VERTEX_ATTRIB = 0x8626;
        WebGLContext.FRONT = 0x0404;
        WebGLContext.BACK = 0x0405;
        WebGLContext.CULL_FACE = 0x0B44;
        WebGLContext.FRONT_AND_BACK = 0x0408;
        WebGLContext.BLEND = 0x0BE2;
        WebGLContext.DITHER = 0x0BD0;
        WebGLContext.STENCIL_TEST = 0x0B90;
        WebGLContext.DEPTH_TEST = 0x0B71;
        WebGLContext.SCISSOR_TEST = 0x0C11;
        WebGLContext.POLYGON_OFFSET_FILL = 0x8037;
        WebGLContext.SAMPLE_ALPHA_TO_COVERAGE = 0x809E;
        WebGLContext.SAMPLE_COVERAGE = 0x80A0;
        WebGLContext.NO_ERROR = 0;
        WebGLContext.INVALID_ENUM = 0x0500;
        WebGLContext.INVALID_VALUE = 0x0501;
        WebGLContext.INVALID_OPERATION = 0x0502;
        WebGLContext.OUT_OF_MEMORY = 0x0505;
        WebGLContext.CW = 0x0900;
        WebGLContext.CCW = 0x0901;
        WebGLContext.LINE_WIDTH = 0x0B21;
        WebGLContext.ALIASED_POINT_SIZE_RANGE = 0x846D;
        WebGLContext.ALIASED_LINE_WIDTH_RANGE = 0x846E;
        WebGLContext.CULL_FACE_MODE = 0x0B45;
        WebGLContext.FRONT_FACE = 0x0B46;
        WebGLContext.DEPTH_RANGE = 0x0B70;
        WebGLContext.DEPTH_WRITEMASK = 0x0B72;
        WebGLContext.DEPTH_CLEAR_VALUE = 0x0B73;
        WebGLContext.DEPTH_FUNC = 0x0B74;
        WebGLContext.STENCIL_CLEAR_VALUE = 0x0B91;
        WebGLContext.STENCIL_FUNC = 0x0B92;
        WebGLContext.STENCIL_FAIL = 0x0B94;
        WebGLContext.STENCIL_PASS_DEPTH_FAIL = 0x0B95;
        WebGLContext.STENCIL_PASS_DEPTH_PASS = 0x0B96;
        WebGLContext.STENCIL_REF = 0x0B97;
        WebGLContext.STENCIL_VALUE_MASK = 0x0B93;
        WebGLContext.STENCIL_WRITEMASK = 0x0B98;
        WebGLContext.STENCIL_BACK_FUNC = 0x8800;
        WebGLContext.STENCIL_BACK_FAIL = 0x8801;
        WebGLContext.STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802;
        WebGLContext.STENCIL_BACK_PASS_DEPTH_PASS = 0x8803;
        WebGLContext.STENCIL_BACK_REF = 0x8CA3;
        WebGLContext.STENCIL_BACK_VALUE_MASK = 0x8CA4;
        WebGLContext.STENCIL_BACK_WRITEMASK = 0x8CA5;
        WebGLContext.VIEWPORT = 0x0BA2;
        WebGLContext.SCISSOR_BOX = 0x0C10;
        WebGLContext.COLOR_CLEAR_VALUE = 0x0C22;
        WebGLContext.COLOR_WRITEMASK = 0x0C23;
        WebGLContext.UNPACK_ALIGNMENT = 0x0CF5;
        WebGLContext.PACK_ALIGNMENT = 0x0D05;
        WebGLContext.MAX_TEXTURE_SIZE = 0x0D33;
        WebGLContext.MAX_VIEWPORT_DIMS = 0x0D3A;
        WebGLContext.SUBPIXEL_BITS = 0x0D50;
        WebGLContext.RED_BITS = 0x0D52;
        WebGLContext.GREEN_BITS = 0x0D53;
        WebGLContext.BLUE_BITS = 0x0D54;
        WebGLContext.ALPHA_BITS = 0x0D55;
        WebGLContext.DEPTH_BITS = 0x0D56;
        WebGLContext.STENCIL_BITS = 0x0D57;
        WebGLContext.POLYGON_OFFSET_UNITS = 0x2A00;
        WebGLContext.POLYGON_OFFSET_FACTOR = 0x8038;
        WebGLContext.TEXTURE_BINDING_2D = 0x8069;
        WebGLContext.SAMPLE_BUFFERS = 0x80A8;
        WebGLContext.SAMPLES = 0x80A9;
        WebGLContext.SAMPLE_COVERAGE_VALUE = 0x80AA;
        WebGLContext.SAMPLE_COVERAGE_INVERT = 0x80AB;
        WebGLContext.NUM_COMPRESSED_TEXTURE_FORMATS = 0x86A2;
        WebGLContext.COMPRESSED_TEXTURE_FORMATS = 0x86A3;
        WebGLContext.DONT_CARE = 0x1100;
        WebGLContext.FASTEST = 0x1101;
        WebGLContext.NICEST = 0x1102;
        WebGLContext.GENERATE_MIPMAP_HINT = 0x8192;
        WebGLContext.BYTE = 0x1400;
        WebGLContext.UNSIGNED_BYTE = 0x1401;
        WebGLContext.SHORT = 0x1402;
        WebGLContext.UNSIGNED_SHORT = 0x1403;
        WebGLContext.INT = 0x1404;
        WebGLContext.UNSIGNED_INT = 0x1405;
        WebGLContext.FLOAT = 0x1406;
        WebGLContext.DEPTH_COMPONENT = 0x1902;
        WebGLContext.ALPHA = 0x1906;
        WebGLContext.RGB = 0x1907;
        WebGLContext.RGBA = 0x1908;
        WebGLContext.LUMINANCE = 0x1909;
        WebGLContext.LUMINANCE_ALPHA = 0x190A;
        WebGLContext.UNSIGNED_SHORT_4_4_4_4 = 0x8033;
        WebGLContext.UNSIGNED_SHORT_5_5_5_1 = 0x8034;
        WebGLContext.UNSIGNED_SHORT_5_6_5 = 0x8363;
        WebGLContext.FRAGMENT_SHADER = 0x8B30;
        WebGLContext.VERTEX_SHADER = 0x8B31;
        WebGLContext.MAX_VERTEX_ATTRIBS = 0x8869;
        WebGLContext.MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;
        WebGLContext.MAX_VARYING_VECTORS = 0x8DFC;
        WebGLContext.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
        WebGLContext.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;
        WebGLContext.MAX_TEXTURE_IMAGE_UNITS = 0x8872;
        WebGLContext.MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;
        WebGLContext.SHADER_TYPE = 0x8B4F;
        WebGLContext.DELETE_STATUS = 0x8B80;
        WebGLContext.LINK_STATUS = 0x8B82;
        WebGLContext.VALIDATE_STATUS = 0x8B83;
        WebGLContext.ATTACHED_SHADERS = 0x8B85;
        WebGLContext.ACTIVE_UNIFORMS = 0x8B86;
        WebGLContext.ACTIVE_ATTRIBUTES = 0x8B89;
        WebGLContext.SHADING_LANGUAGE_VERSION = 0x8B8C;
        WebGLContext.CURRENT_PROGRAM = 0x8B8D;
        WebGLContext.NEVER = 0x0200;
        WebGLContext.LESS = 0x0201;
        WebGLContext.EQUAL = 0x0202;
        WebGLContext.LEQUAL = 0x0203;
        WebGLContext.GREATER = 0x0204;
        WebGLContext.NOTEQUAL = 0x0205;
        WebGLContext.GEQUAL = 0x0206;
        WebGLContext.ALWAYS = 0x0207;
        WebGLContext.KEEP = 0x1E00;
        WebGLContext.REPLACE = 0x1E01;
        WebGLContext.INCR = 0x1E02;
        WebGLContext.DECR = 0x1E03;
        WebGLContext.INVERT = 0x150A;
        WebGLContext.INCR_WRAP = 0x8507;
        WebGLContext.DECR_WRAP = 0x8508;
        WebGLContext.VENDOR = 0x1F00;
        WebGLContext.RENDERER = 0x1F01;
        WebGLContext.VERSION = 0x1F02;
        WebGLContext.NEAREST = 0x2600;
        WebGLContext.LINEAR = 0x2601;
        WebGLContext.NEAREST_MIPMAP_NEAREST = 0x2700;
        WebGLContext.LINEAR_MIPMAP_NEAREST = 0x2701;
        WebGLContext.NEAREST_MIPMAP_LINEAR = 0x2702;
        WebGLContext.LINEAR_MIPMAP_LINEAR = 0x2703;
        WebGLContext.TEXTURE_MAG_FILTER = 0x2800;
        WebGLContext.TEXTURE_MIN_FILTER = 0x2801;
        WebGLContext.TEXTURE_WRAP_S = 0x2802;
        WebGLContext.TEXTURE_WRAP_T = 0x2803;
        WebGLContext.TEXTURE_2D = 0x0DE1;
        WebGLContext.TEXTURE = 0x1702;
        WebGLContext.TEXTURE_CUBE_MAP = 0x8513;
        WebGLContext.TEXTURE_BINDING_CUBE_MAP = 0x8514;
        WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
        WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
        WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
        WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
        WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
        WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;
        WebGLContext.MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;
        WebGLContext.TEXTURE0 = 0x84C0;
        WebGLContext.TEXTURE1 = 0x84C1;
        WebGLContext.TEXTURE2 = 0x84C2;
        WebGLContext.TEXTURE3 = 0x84C3;
        WebGLContext.TEXTURE4 = 0x84C4;
        WebGLContext.TEXTURE5 = 0x84C5;
        WebGLContext.TEXTURE6 = 0x84C6;
        WebGLContext.TEXTURE7 = 0x84C7;
        WebGLContext.TEXTURE8 = 0x84C8;
        WebGLContext.TEXTURE9 = 0x84C9;
        WebGLContext.TEXTURE10 = 0x84CA;
        WebGLContext.TEXTURE11 = 0x84CB;
        WebGLContext.TEXTURE12 = 0x84CC;
        WebGLContext.TEXTURE13 = 0x84CD;
        WebGLContext.TEXTURE14 = 0x84CE;
        WebGLContext.TEXTURE15 = 0x84CF;
        WebGLContext.TEXTURE16 = 0x84D0;
        WebGLContext.TEXTURE17 = 0x84D1;
        WebGLContext.TEXTURE18 = 0x84D2;
        WebGLContext.TEXTURE19 = 0x84D3;
        WebGLContext.TEXTURE20 = 0x84D4;
        WebGLContext.TEXTURE21 = 0x84D5;
        WebGLContext.TEXTURE22 = 0x84D6;
        WebGLContext.TEXTURE23 = 0x84D7;
        WebGLContext.TEXTURE24 = 0x84D8;
        WebGLContext.TEXTURE25 = 0x84D9;
        WebGLContext.TEXTURE26 = 0x84DA;
        WebGLContext.TEXTURE27 = 0x84DB;
        WebGLContext.TEXTURE28 = 0x84DC;
        WebGLContext.TEXTURE29 = 0x84DD;
        WebGLContext.TEXTURE30 = 0x84DE;
        WebGLContext.TEXTURE31 = 0x84DF;
        WebGLContext.ACTIVE_TEXTURE = 0x84E0;
        WebGLContext.REPEAT = 0x2901;
        WebGLContext.CLAMP_TO_EDGE = 0x812F;
        WebGLContext.MIRRORED_REPEAT = 0x8370;
        WebGLContext.FLOAT_VEC2 = 0x8B50;
        WebGLContext.FLOAT_VEC3 = 0x8B51;
        WebGLContext.FLOAT_VEC4 = 0x8B52;
        WebGLContext.INT_VEC2 = 0x8B53;
        WebGLContext.INT_VEC3 = 0x8B54;
        WebGLContext.INT_VEC4 = 0x8B55;
        WebGLContext.BOOL = 0x8B56;
        WebGLContext.BOOL_VEC2 = 0x8B57;
        WebGLContext.BOOL_VEC3 = 0x8B58;
        WebGLContext.BOOL_VEC4 = 0x8B59;
        WebGLContext.FLOAT_MAT2 = 0x8B5A;
        WebGLContext.FLOAT_MAT3 = 0x8B5B;
        WebGLContext.FLOAT_MAT4 = 0x8B5C;
        WebGLContext.SAMPLER_2D = 0x8B5E;
        WebGLContext.SAMPLER_CUBE = 0x8B60;
        WebGLContext.VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;
        WebGLContext.VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;
        WebGLContext.VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;
        WebGLContext.VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;
        WebGLContext.VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;
        WebGLContext.VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;
        WebGLContext.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;
        WebGLContext.COMPILE_STATUS = 0x8B81;
        WebGLContext.LOW_FLOAT = 0x8DF0;
        WebGLContext.MEDIUM_FLOAT = 0x8DF1;
        WebGLContext.HIGH_FLOAT = 0x8DF2;
        WebGLContext.LOW_INT = 0x8DF3;
        WebGLContext.MEDIUM_INT = 0x8DF4;
        WebGLContext.HIGH_INT = 0x8DF5;
        WebGLContext.FRAMEBUFFER = 0x8D40;
        WebGLContext.RENDERBUFFER = 0x8D41;
        WebGLContext.RGBA4 = 0x8056;
        WebGLContext.RGB5_A1 = 0x8057;
        WebGLContext.RGB565 = 0x8D62;
        WebGLContext.DEPTH_COMPONENT16 = 0x81A5;
        WebGLContext.STENCIL_INDEX = 0x1901;
        WebGLContext.STENCIL_INDEX8 = 0x8D48;
        WebGLContext.DEPTH_STENCIL = 0x84F9;
        WebGLContext.RENDERBUFFER_WIDTH = 0x8D42;
        WebGLContext.RENDERBUFFER_HEIGHT = 0x8D43;
        WebGLContext.RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;
        WebGLContext.RENDERBUFFER_RED_SIZE = 0x8D50;
        WebGLContext.RENDERBUFFER_GREEN_SIZE = 0x8D51;
        WebGLContext.RENDERBUFFER_BLUE_SIZE = 0x8D52;
        WebGLContext.RENDERBUFFER_ALPHA_SIZE = 0x8D53;
        WebGLContext.RENDERBUFFER_DEPTH_SIZE = 0x8D54;
        WebGLContext.RENDERBUFFER_STENCIL_SIZE = 0x8D55;
        WebGLContext.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0;
        WebGLContext.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1;
        WebGLContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2;
        WebGLContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;
        WebGLContext.COLOR_ATTACHMENT0 = 0x8CE0;
        WebGLContext.DEPTH_ATTACHMENT = 0x8D00;
        WebGLContext.STENCIL_ATTACHMENT = 0x8D20;
        WebGLContext.DEPTH_STENCIL_ATTACHMENT = 0x821A;
        WebGLContext.NONE = 0;
        WebGLContext.FRAMEBUFFER_COMPLETE = 0x8CD5;
        WebGLContext.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;
        WebGLContext.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
        WebGLContext.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;
        WebGLContext.FRAMEBUFFER_UNSUPPORTED = 0x8CDD;
        WebGLContext.FRAMEBUFFER_BINDING = 0x8CA6;
        WebGLContext.RENDERBUFFER_BINDING = 0x8CA7;
        WebGLContext.MAX_RENDERBUFFER_SIZE = 0x84E8;
        WebGLContext.INVALID_FRAMEBUFFER_OPERATION = 0x0506;
        WebGLContext.UNPACK_FLIP_Y_WEBGL = 0x9240;
        WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
        WebGLContext.CONTEXT_LOST_WEBGL = 0x9242;
        WebGLContext.UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;
        WebGLContext.BROWSER_DEFAULT_WEBGL = 0x9244;
        WebGLContext._useProgram = null;
        WebGLContext._depthTest = true;
        WebGLContext._depthMask = true;
        WebGLContext._blend = false;
        WebGLContext._cullFace = false;
        WebGLContext.curBindTexTarget = null;
        WebGLContext.curBindTexValue = null;
        __static(WebGLContext, ['_depthFunc', function () { return this._depthFunc = 0x0201; }, '_sFactor', function () { return this._sFactor = 1; }, '_dFactor', function () { return this._dFactor = 0; }, '_frontFace', function () { return this._frontFace = 0x0901; }
        ]);
        return WebGLContext;
    })();
    var GraphicsGL = (function (_super) {
        function GraphicsGL() {
            GraphicsGL.__super.call(this);
        }
        __class(GraphicsGL, 'laya.webgl.display.GraphicsGL', _super);
        var __proto = GraphicsGL.prototype;
        __proto.setShader = function (shader) {
            this._saveToCmd(Render.context._setShader, [shader]);
        };
        __proto.setIBVB = function (x, y, ib, vb, numElement, shader) {
            this._saveToCmd(Render.context._setIBVB, [x, y, ib, vb, numElement, shader]);
        };
        __proto.drawParticle = function (x, y, ps) {
            var pt = RunDriver.createParticleTemplate2D(ps);
            pt.x = x;
            pt.y = y;
            this._saveToCmd(Render.context._drawParticle, [pt]);
        };
        return GraphicsGL;
    })(Graphics);
    var WebGLContext2D = (function (_super) {
        var ContextParams;
        function WebGLContext2D(c) {
            this._x = 0;
            this._y = 0;
            this._id = ++WebGLContext2D._COUNT;
            this._path = null;
            this._drawCount = 1;
            this._maxNumEle = 0;
            this._clear = false;
            this._isMain = false;
            this._atlasResourceChange = 0;
            this._submits = null;
            this._curSubmit = null;
            this._ib = null;
            this._vb = null;
            this._nBlendType = 0;
            this._saveMark = null;
            this._shader2D = null;
            this.meshlist = [];
            this.mId = -1;
            this.mHaveKey = false;
            this.mHaveLineKey = false;
            this.mX = 0;
            this.mY = 0;
            WebGLContext2D.__super.call(this);
            this._width = 99999999;
            this._height = 99999999;
            this._clipRect = WebGLContext2D.MAXCLIPRECT;
            this.mOutPoint;
            this._canvas = c;
            WebGLContext2D._contextcount++;
            if (Render.isFlash) {
                this._ib = IndexBuffer2D.create(0x88E4);
                GlUtils.fillIBQuadrangle(this._ib, 16);
            }
            else
                this._ib = IndexBuffer2D.QuadrangleIB;
            this.clear();
        }
        __class(WebGLContext2D, 'laya.webgl.canvas.WebGLContext2D', _super);
        var __proto = WebGLContext2D.prototype;
        __proto.setIsMainContext = function () {
            this._isMain = true;
        };
        __proto.clearBG = function (r, g, b, a) {
            var gl = WebGL.mainContext;
            gl.clearColor(r, g, b, a);
            gl.clear(0x00004000);
        };
        __proto._getSubmits = function () {
            return this._submits;
        };
        __proto._releaseMem = function () {
            if (!this._submits)
                return;
            this._curMat.destroy();
            this._curMat = null;
            this._shader2D.destroy();
            this._shader2D = null;
            for (var i = 0, n = this._submits._length; i < n; i++)
                this._submits[i].releaseRender();
            this._submits.length = 0;
            this._submits._length = 0;
            this._submits = null;
            this._curSubmit = null;
            this._path && this._path.recover();
            this._path = null;
            this._other && (this._other.font = null);
            this._save = null;
            if (this._vb) {
                this._vb.releaseResource();
                this._vb.destroy();
                this._vb.destory();
                this._vb = null;
            }
        };
        __proto.destroy = function () {
            --WebGLContext2D._contextcount;
            this.sprite = null;
            this._releaseMem();
            this._targets && this._targets.destroy();
            this._targets = null;
            this._canvas = null;
            this._ib && (this._ib != IndexBuffer2D.QuadrangleIB) && this._ib.releaseResource();
        };
        __proto.clear = function () {
            if (!this._submits) {
                this._other = ContextParams.DEFAULT;
                this._curMat = Matrix.create();
                this._vb = VertexBuffer2D.create(-1);
                this._submits = [];
                this._save = [SaveMark.Create(this)];
                this._save.length = 10;
                this._shader2D = new Shader2D();
                this._triangleMesh = MeshTexture.getAMesh();
            }
            this._vb.clear();
            this._targets && (this._targets.repaint = true);
            this._other = ContextParams.DEFAULT;
            this._clear = true;
            this._repaint = false;
            this._drawCount = 1;
            this._renderKey = 0;
            this._other.lineWidth = this._shader2D.ALPHA = 1.0;
            this._nBlendType = 0;
            this._clipRect = WebGLContext2D.MAXCLIPRECT;
            this._curSubmit = Submit.RENDERBASE;
            this._shader2D.glTexture = null;
            this._shader2D.fillStyle = this._shader2D.strokeStyle = DrawStyle.DEFAULT;
            for (var i = 0, n = this._submits._length; i < n; i++)
                this._submits[i].releaseRender();
            this._submits._length = 0;
            this._curMat.identity();
            this._other.clear();
            this._saveMark = this._save[0];
            this._save._length = 1;
        };
        __proto.size = function (w, h) {
            if (this._width != w || this._height != h) {
                if (w == 0 || h == 0) {
                    if (this._vb._byteLength != 0) {
                        this._width = w;
                        this._height = h;
                        this._vb.clear();
                        this._vb.upload();
                    }
                    for (var i = 0, n = this._submits._length; i < n; i++)
                        this._submits[i].releaseRender();
                    this._submits.length = 0;
                    this._submits._length = 0;
                    this._curSubmit = null;
                    this._path && this._path.recover();
                    this._path = null;
                    this.sprite = null;
                    this._targets && (this._targets.destroy());
                    this._targets = null;
                }
                else {
                    this._width = w;
                    this._height = h;
                    this._targets && (this._targets.size(w, h));
                    this._canvas.memorySize -= this._canvas.memorySize;
                }
            }
            if (w === 0 && h === 0)
                this._releaseMem();
        };
        __proto._getTransformMatrix = function () {
            return this._curMat;
        };
        __proto.translate = function (x, y) {
            if (x !== 0 || y !== 0) {
                SaveTranslate.save(this);
                if (this._curMat.bTransform) {
                    SaveTransform.save(this);
                    this._curMat.transformPointN(Point.TEMP.setTo(x, y));
                    x = Point.TEMP.x;
                    y = Point.TEMP.y;
                }
                this._x += x;
                this._y += y;
            }
        };
        __proto.save = function () {
            this._save[this._save._length++] = SaveMark.Create(this);
        };
        __proto.restore = function () {
            var sz = this._save._length;
            if (sz < 1)
                return;
            for (var i = sz - 1; i >= 0; i--) {
                var o = this._save[i];
                o.restore(this);
                if (o.isSaveMark()) {
                    this._save._length = i;
                    return;
                }
            }
        };
        __proto._fillText = function (txt, words, x, y, fontStr, color, strokeColor, lineWidth, textAlign, underLine) {
            (underLine === void 0) && (underLine = 0);
            var shader = this._shader2D;
            var curShader = this._curSubmit.shaderValue;
            var font = fontStr ? FontInContext.create(fontStr) : this._other.font;
            if (AtlasResourceManager.enabled) {
                if (shader.ALPHA !== curShader.ALPHA)
                    shader.glTexture = null;
                DrawText.drawText(this, txt, words, this._curMat, font, textAlign || this._other.textAlign, color, strokeColor, lineWidth, x, y, underLine);
            }
            else {
                var preDef = this._shader2D.defines.getValue();
                var colorAdd = color ? Color.create(color)._color : shader.colorAdd;
                if (shader.ALPHA !== curShader.ALPHA || colorAdd !== shader.colorAdd || curShader.colorAdd !== shader.colorAdd) {
                    shader.glTexture = null;
                    shader.colorAdd = colorAdd;
                }
                DrawText.drawText(this, txt, words, this._curMat, font, textAlign || this._other.textAlign, color, strokeColor, lineWidth, x, y, underLine);
            }
        };
        __proto.fillWords = function (words, x, y, fontStr, color, underLine) {
            this._fillText(null, words, x, y, fontStr, color, null, -1, null, underLine);
        };
        __proto.fillBorderWords = function (words, x, y, font, color, borderColor, lineWidth) {
            this._fillBorderText(null, words, x, y, font, color, borderColor, lineWidth, null);
        };
        __proto.fillText = function (txt, x, y, fontStr, color, textAlign) {
            this._fillText(txt, null, x, y, fontStr, color, null, -1, textAlign);
        };
        __proto.strokeText = function (txt, x, y, fontStr, color, lineWidth, textAlign) {
            this._fillText(txt, null, x, y, fontStr, null, color, lineWidth || 1, textAlign);
        };
        __proto.fillBorderText = function (txt, x, y, fontStr, fillColor, borderColor, lineWidth, textAlign) {
            this._fillBorderText(txt, null, x, y, fontStr, fillColor, borderColor, lineWidth, textAlign);
        };
        __proto._fillBorderText = function (txt, words, x, y, fontStr, fillColor, borderColor, lineWidth, textAlign) {
            if (!AtlasResourceManager.enabled) {
                this._fillText(txt, words, x, y, fontStr, null, borderColor, lineWidth || 1, textAlign);
                this._fillText(txt, words, x, y, fontStr, fillColor, null, -1, textAlign);
                return;
            }
            ;
            var shader = this._shader2D;
            var curShader = this._curSubmit.shaderValue;
            if (shader.ALPHA !== curShader.ALPHA)
                shader.glTexture = null;
            var font = fontStr ? (WebGLContext2D._fontTemp.setFont(fontStr), WebGLContext2D._fontTemp) : this._other.font;
            DrawText.drawText(this, txt, words, this._curMat, font, textAlign || this._other.textAlign, fillColor, borderColor, lineWidth || 1, x, y, 0);
        };
        __proto.fillRect = function (x, y, width, height, fillStyle) {
            var vb = this._vb;
            if (GlUtils.fillRectImgVb(vb, this._clipRect, x, y, width, height, Texture.DEF_UV, this._curMat, this._x, this._y, 0, 0)) {
                this._renderKey = 0;
                var pre = this._shader2D.fillStyle;
                fillStyle && (this._shader2D.fillStyle = DrawStyle.create(fillStyle));
                var shader = this._shader2D;
                var curShader = this._curSubmit.shaderValue;
                if (shader.fillStyle !== curShader.fillStyle || shader.ALPHA !== curShader.ALPHA) {
                    shader.glTexture = null;
                    var submit = this._curSubmit = Submit.createSubmit(this, this._ib, vb, ((vb._byteLength - 16 * 4) / 32) * 3, Value2D.create(0x02, 0));
                    submit.shaderValue.color = shader.fillStyle._color._color;
                    submit.shaderValue.ALPHA = shader.ALPHA;
                    this._submits[this._submits._length++] = submit;
                }
                this._curSubmit._numEle += 6;
                this._shader2D.fillStyle = pre;
            }
        };
        __proto.fillTexture = function (texture, x, y, width, height, type, offset, other) {
            if (!(texture.loaded && texture.bitmap && texture.source)) {
                if (this.sprite) {
                    Laya.timer.callLater(this, this._repaintSprite);
                }
                return;
            }
            ;
            var vb = this._vb;
            var w = texture.bitmap.width, h = texture.bitmap.height, uv = texture.uv;
            var ox = offset.x % texture.width, oy = offset.y % texture.height;
            if (w != other.w || h != other.h) {
                if (!other.w && !other.h) {
                    other.oy = other.ox = 0;
                    switch (type) {
                        case "repeat":
                            other.width = width;
                            other.height = height;
                            break;
                        case "no-repeat":
                            other.width = w;
                            other.height = h;
                            break;
                        case "repeat-x":
                            other.width = width;
                            if (oy < 0) {
                                if (texture.height + oy > height) {
                                    other.height = height;
                                }
                                else {
                                    other.height = texture.height + oy;
                                }
                            }
                            else {
                                other.oy = oy;
                                if (texture.height + oy > height) {
                                    other.height = height - oy;
                                }
                                else {
                                    other.height = texture.height;
                                }
                            }
                            break;
                        case "repeat-y":
                            if (ox < 0) {
                                if (texture.width + ox > width) {
                                    other.width = width;
                                }
                                else {
                                    other.width = texture.width + ox;
                                }
                            }
                            else {
                                other.ox = ox;
                                if (texture.width + ox > width) {
                                    other.width = width - ox;
                                }
                                else {
                                    other.width = texture.width;
                                }
                            }
                            other.height = height;
                            break;
                        default:
                            other.width = width;
                            other.height = height;
                            break;
                    }
                }
                other.w = w;
                other.h = h;
                other.uv = [0, 0, other.width / w, 0, other.width / w, other.height / h, 0, other.height / h];
            }
            x += other.ox;
            y += other.oy;
            ox -= other.ox;
            oy -= other.oy;
            if (GlUtils.fillRectImgVb(vb, this._clipRect, x, y, other.width, other.height, other.uv, this._curMat, this._x, this._y, 0, 0)) {
                this._renderKey = 0;
                var submit = SubmitTexture.create(this, this._ib, vb, ((vb._byteLength - 16 * 4) / 32) * 3, Value2D.create(0x100, 0));
                this._submits[this._submits._length++] = submit;
                var shaderValue = submit.shaderValue;
                shaderValue.textureHost = texture;
                var tTextureX = uv[0] * w;
                var tTextureY = uv[1] * h;
                var tTextureW = (uv[2] - uv[0]) * w;
                var tTextureH = (uv[5] - uv[3]) * h;
                var tx = -ox / w;
                var ty = -oy / h;
                shaderValue.u_TexRange[0] = tTextureX / w;
                shaderValue.u_TexRange[1] = tTextureW / w;
                shaderValue.u_TexRange[2] = tTextureY / h;
                shaderValue.u_TexRange[3] = tTextureH / h;
                shaderValue.u_offset[0] = tx;
                shaderValue.u_offset[1] = ty;
                if (AtlasResourceManager.enabled && !this._isMain)
                    submit.addTexture(texture, (vb._byteLength >> 2) - 16);
                this._curSubmit = submit;
                submit._renderType = 10017;
                submit._numEle += 6;
            }
        };
        __proto.setShader = function (shader) {
            SaveBase.save(this, 0x100000, this._shader2D, true);
            this._shader2D.shader = shader;
        };
        __proto.setFilters = function (value) {
            SaveBase.save(this, 0x200000, this._shader2D, true);
            this._shader2D.filters = value;
            this._curSubmit = Submit.RENDERBASE;
            this._renderKey = 0;
            this._drawCount++;
        };
        __proto.drawTexture = function (tex, x, y, width, height, tx, ty) {
            this._drawTextureM(tex, x, y, width, height, tx, ty, null, 1);
        };
        __proto.addTextureVb = function (invb, x, y) {
            var finalVB = this._curSubmit._vb || this._vb;
            var vpos = (finalVB._byteLength >> 2);
            finalVB.byteLength = ((vpos + 16) << 2);
            var vbdata = finalVB.getFloat32Array();
            for (var i = 0, ci = 0; i < 16; i += 4) {
                vbdata[vpos++] = invb[i] + x;
                vbdata[vpos++] = invb[i + 1] + y;
                vbdata[vpos++] = invb[i + 2];
                vbdata[vpos++] = invb[i + 3];
            }
            this._curSubmit._numEle += 6;
            this._maxNumEle = Math.max(this._maxNumEle, this._curSubmit._numEle);
            finalVB._upload = true;
        };
        __proto.willDrawTexture = function (tex, alpha) {
            if (!(tex.loaded && tex.bitmap && tex.source)) {
                if (this.sprite) {
                    Laya.timer.callLater(this, this._repaintSprite);
                }
                return 0;
            }
            ;
            var webGLImg = tex.bitmap;
            var rid = webGLImg.id + this._shader2D.ALPHA * alpha + 10016;
            if (rid == this._renderKey)
                return rid;
            var shader = this._shader2D;
            var preAlpha = shader.ALPHA;
            var curShader = this._curSubmit.shaderValue;
            shader.ALPHA *= alpha;
            this._renderKey = rid;
            this._drawCount++;
            shader.glTexture = webGLImg;
            var vb = this._vb;
            var submit = null;
            var vbSize = (vb._byteLength / 32) * 3;
            submit = SubmitTexture.create(this, this._ib, vb, vbSize, Value2D.create(0x01, 0));
            this._submits[this._submits._length++] = submit;
            submit.shaderValue.textureHost = tex;
            submit._renderType = 10016;
            submit._preIsSameTextureShader = this._curSubmit._renderType === 10016 && shader.ALPHA === curShader.ALPHA;
            this._curSubmit = submit;
            shader.ALPHA = preAlpha;
            return rid;
        };
        __proto.drawTextures = function (tex, pos, tx, ty) {
            if (!(tex.loaded && tex.bitmap && tex.source)) {
                this.sprite && Laya.timer.callLater(this, this._repaintSprite);
                return;
            }
            ;
            var pre = this._clipRect;
            this._clipRect = WebGLContext2D.MAXCLIPRECT;
            if (!this._drawTextureM(tex, pos[0], pos[1], tex.width, tex.height, tx, ty, null, 1)) {
                alert("drawTextures err");
                return;
            }
            this._clipRect = pre;
            Stat.drawCall++;
            if (pos.length < 4)
                return;
            var finalVB = this._curSubmit._vb || this._vb;
            var sx = this._curMat.a, sy = this._curMat.d;
            for (var i = 2, sz = pos.length; i < sz; i += 2) {
                GlUtils.copyPreImgVb(finalVB, (pos[i] - pos[i - 2]) * sx, (pos[i + 1] - pos[i - 1]) * sy);
                this._curSubmit._numEle += 6;
            }
            this._maxNumEle = Math.max(this._maxNumEle, this._curSubmit._numEle);
        };
        __proto._drawTextureM = function (tex, x, y, width, height, tx, ty, m, alpha) {
            if (!(tex.loaded && tex.source)) {
                if (this.sprite) {
                    Laya.timer.callLater(this, this._repaintSprite);
                }
                return false;
            }
            ;
            var finalVB = this._curSubmit._vb || this._vb;
            var webGLImg = tex.bitmap;
            x += tx;
            y += ty;
            this._drawCount++;
            var rid = webGLImg.id + this._shader2D.ALPHA * alpha + 10016;
            if (rid != this._renderKey) {
                this._renderKey = rid;
                var curShader = this._curSubmit.shaderValue;
                var shader = this._shader2D;
                var alphaBack = shader.ALPHA;
                shader.ALPHA *= alpha;
                shader.glTexture = webGLImg;
                var vb = this._vb;
                var submit = null;
                var vbSize = (vb._byteLength / 32) * 3;
                submit = SubmitTexture.create(this, this._ib, vb, vbSize, Value2D.create(0x01, 0));
                this._submits[this._submits._length++] = submit;
                submit.shaderValue.textureHost = tex;
                submit._renderType = 10016;
                submit._preIsSameTextureShader = this._curSubmit._renderType === 10016 && shader.ALPHA === curShader.ALPHA;
                this._curSubmit = submit;
                finalVB = this._curSubmit._vb || this._vb;
                shader.ALPHA = alphaBack;
            }
            if (GlUtils.fillRectImgVb(finalVB, this._clipRect, x, y, width || tex.width, height || tex.height, tex.uv, m || this._curMat, this._x, this._y, 0, 0)) {
                if (AtlasResourceManager.enabled && !this._isMain)
                    (this._curSubmit).addTexture(tex, (finalVB._byteLength >> 2) - 16);
                this._curSubmit._numEle += 6;
                this._maxNumEle = Math.max(this._maxNumEle, this._curSubmit._numEle);
                return true;
            }
            return false;
        };
        __proto._repaintSprite = function () {
            if (this.sprite)
                this.sprite.repaint();
        };
        __proto._drawText = function (tex, x, y, width, height, m, tx, ty, dx, dy) {
            var webGLImg = tex.bitmap;
            this._drawCount++;
            var rid = webGLImg.id + this._shader2D.ALPHA + 10016;
            if (rid != this._renderKey) {
                this._renderKey = rid;
                var curShader = this._curSubmit.shaderValue;
                var shader = this._shader2D;
                shader.glTexture = webGLImg;
                var vb = this._vb;
                var submit = null;
                var submitID = NaN;
                var vbSize = (vb._byteLength / 32) * 3;
                if (AtlasResourceManager.enabled) {
                    submit = SubmitTexture.create(this, this._ib, vb, vbSize, Value2D.create(0x01, 0));
                }
                else {
                    submit = SubmitTexture.create(this, this._ib, vb, vbSize, TextSV.create());
                }
                submit._preIsSameTextureShader = this._curSubmit._renderType === 10016 && shader.ALPHA === curShader.ALPHA;
                this._submits[this._submits._length++] = submit;
                submit.shaderValue.textureHost = tex;
                submit._renderType = 10016;
                this._curSubmit = submit;
            }
            tex.active();
            var finalVB = this._curSubmit._vb || this._vb;
            if (GlUtils.fillRectImgVb(finalVB, this._clipRect, x + tx, y + ty, width || tex.width, height || tex.height, tex.uv, m || this._curMat, this._x, this._y, dx, dy, true)) {
                if (AtlasResourceManager.enabled && !this._isMain) {
                    (this._curSubmit).addTexture(tex, (finalVB._byteLength >> 2) - 16);
                }
                this._curSubmit._numEle += 6;
                this._maxNumEle = Math.max(this._maxNumEle, this._curSubmit._numEle);
            }
        };
        __proto.drawTextureWithTransform = function (tex, x, y, width, height, transform, tx, ty, alpha) {
            if (!transform) {
                this._drawTextureM(tex, x, y, width, height, tx, ty, null, alpha);
                return;
            }
            ;
            var curMat = this._curMat;
            var prex = this._x;
            var prey = this._y;
            (tx !== 0 || ty !== 0) && (this._x = tx * curMat.a + ty * curMat.c, this._y = ty * curMat.d + tx * curMat.b);
            if (transform && curMat.bTransform) {
                Matrix.mul(transform, curMat, WebGLContext2D._tmpMatrix);
                transform = WebGLContext2D._tmpMatrix;
                transform._checkTransform();
            }
            else {
                this._x += curMat.tx;
                this._y += curMat.ty;
            }
            this._drawTextureM(tex, x, y, width, height, 0, 0, transform, alpha);
            this._x = prex;
            this._y = prey;
        };
        __proto.fillQuadrangle = function (tex, x, y, point4, m) {
            var submit = this._curSubmit;
            var vb = this._vb;
            var shader = this._shader2D;
            var curShader = submit.shaderValue;
            this._renderKey = 0;
            if (tex.bitmap) {
                var t_tex = tex.bitmap;
                if (shader.glTexture != t_tex || shader.ALPHA !== curShader.ALPHA) {
                    shader.glTexture = t_tex;
                    submit = this._curSubmit = Submit.createSubmit(this, this._ib, vb, ((vb._byteLength) / 32) * 3, Value2D.create(0x01, 0));
                    submit.shaderValue.glTexture = t_tex;
                    this._submits[this._submits._length++] = submit;
                }
                GlUtils.fillQuadrangleImgVb(vb, x, y, point4, tex.uv, m || this._curMat, this._x, this._y);
            }
            else {
                if (!submit.shaderValue.fillStyle || !submit.shaderValue.fillStyle.equal(tex) || shader.ALPHA !== curShader.ALPHA) {
                    shader.glTexture = null;
                    submit = this._curSubmit = Submit.createSubmit(this, this._ib, vb, ((vb._byteLength) / 32) * 3, Value2D.create(0x02, 0));
                    submit.shaderValue.defines.add(0x02);
                    submit.shaderValue.fillStyle = DrawStyle.create(tex);
                    this._submits[this._submits._length++] = submit;
                }
                GlUtils.fillQuadrangleImgVb(vb, x, y, point4, Texture.DEF_UV, m || this._curMat, this._x, this._y);
            }
            submit._numEle += 6;
        };
        __proto.drawTexture2 = function (x, y, pivotX, pivotY, transform, alpha, blendMode, args) {
            if (alpha == 0)
                return;
            var curMat = this._curMat;
            this._x = x * curMat.a + y * curMat.c;
            this._y = y * curMat.d + x * curMat.b;
            if (transform) {
                if (curMat.bTransform || transform.bTransform) {
                    Matrix.mul(transform, curMat, WebGLContext2D._tmpMatrix);
                    transform = WebGLContext2D._tmpMatrix;
                }
                else {
                    this._x += transform.tx + curMat.tx;
                    this._y += transform.ty + curMat.ty;
                    transform = Matrix.EMPTY;
                }
            }
            if (alpha === 1 && !blendMode)
                this._drawTextureM(args[0], args[1] - pivotX, args[2] - pivotY, args[3], args[4], 0, 0, transform, 1);
            else {
                var preAlpha = this._shader2D.ALPHA;
                var preblendType = this._nBlendType;
                this._shader2D.ALPHA = alpha;
                blendMode && (this._nBlendType = BlendMode.TOINT(blendMode));
                this._drawTextureM(args[0], args[1] - pivotX, args[2] - pivotY, args[3], args[4], 0, 0, transform, 1);
                this._shader2D.ALPHA = preAlpha;
                this._nBlendType = preblendType;
            }
            this._x = this._y = 0;
        };
        __proto.drawCanvas = function (canvas, x, y, width, height) {
            var src = canvas.context;
            this._renderKey = 0;
            if (src._targets) {
                this._submits[this._submits._length++] = SubmitCanvas.create(src, 0, null);
                this._curSubmit = Submit.RENDERBASE;
                src._targets.drawTo(this, x, y, width, height);
            }
            else {
                var submit = this._submits[this._submits._length++] = SubmitCanvas.create(src, this._shader2D.ALPHA, this._shader2D.filters);
                var sx = width / canvas.width;
                var sy = height / canvas.height;
                var mat = submit._matrix;
                this._curMat.copyTo(mat);
                sx != 1 && sy != 1 && mat.scale(sx, sy);
                var tx = mat.tx, ty = mat.ty;
                mat.tx = mat.ty = 0;
                mat.transformPoint(Point.TEMP.setTo(x, y));
                mat.translate(Point.TEMP.x + tx, Point.TEMP.y + ty);
                this._curSubmit = Submit.RENDERBASE;
            }
            if (Config.showCanvasMark) {
                this.save();
                this.lineWidth = 4;
                this.strokeStyle = src._targets ? "yellow" : "green";
                this.strokeRect(x - 1, y - 1, width + 2, height + 2, 1);
                this.strokeRect(x, y, width, height, 1);
                this.restore();
            }
        };
        __proto.drawTarget = function (scope, x, y, width, height, m, proName, shaderValue, uv, blend) {
            (blend === void 0) && (blend = -1);
            var vb = this._vb;
            if (GlUtils.fillRectImgVb(vb, this._clipRect, x, y, width, height, uv || Texture.DEF_UV, m || this._curMat, this._x, this._y, 0, 0)) {
                this._renderKey = 0;
                var shader = this._shader2D;
                shader.glTexture = null;
                var curShader = this._curSubmit.shaderValue;
                var submit = this._curSubmit = SubmitTarget.create(this, this._ib, vb, ((vb._byteLength - 16 * 4) / 32) * 3, shaderValue, proName);
                if (blend == -1) {
                    submit.blendType = this._nBlendType;
                }
                else {
                    submit.blendType = blend;
                }
                submit.scope = scope;
                this._submits[this._submits._length++] = submit;
                this._curSubmit._numEle += 6;
            }
        };
        __proto.mixRGBandAlpha = function (color) {
            return this._mixRGBandAlpha(color, this._shader2D.ALPHA);
        };
        __proto._mixRGBandAlpha = function (color, alpha) {
            var a = ((color & 0xff000000) >>> 24);
            if (a != 0) {
                a *= alpha;
            }
            else {
                a = alpha * 255;
            }
            return (color & 0x00ffffff) | (a << 24);
        };
        __proto.drawTriangles = function (tex, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode) {
            if (!(tex.loaded && tex.source)) {
                if (this.sprite) {
                    Laya.timer.callLater(this, this._repaintSprite);
                }
                return false;
            }
            this._drawCount++;
            var webGLImg = tex.bitmap;
            var rgba = this._mixRGBandAlpha(0xffffffff, alpha);
            var vertNum = vertices.length / 2;
            var eleNum = indices.length;
            this._renderKey = -1;
            var submit = this._curSubmit = SubmitTexture.create(this, this._triangleMesh.getIBR(), this._triangleMesh.getVBR(), this._triangleMesh.indexNum, Value2D.create(0x01, 0));
            submit.shaderValue.textureHost = tex;
            submit._renderType = 10016;
            this._submits[this._submits._length++] = submit;
            if (matrix) {
                WebGLContext2D._tmpMatrix.a = matrix.a;
                WebGLContext2D._tmpMatrix.b = matrix.b;
                WebGLContext2D._tmpMatrix.c = matrix.c;
                WebGLContext2D._tmpMatrix.d = matrix.d;
                WebGLContext2D._tmpMatrix.tx = matrix.tx + x;
                WebGLContext2D._tmpMatrix.ty = matrix.ty + y;
                Matrix.mul(WebGLContext2D._tmpMatrix, this._curMat, WebGLContext2D._tmpMatrix);
            }
            else {
                WebGLContext2D._tmpMatrix.a = this._curMat.a;
                WebGLContext2D._tmpMatrix.b = this._curMat.b;
                WebGLContext2D._tmpMatrix.c = this._curMat.c;
                WebGLContext2D._tmpMatrix.d = this._curMat.d;
                WebGLContext2D._tmpMatrix.tx = this._curMat.tx + x;
                WebGLContext2D._tmpMatrix.ty = this._curMat.ty + y;
            }
            this._triangleMesh.addData(vertices, uvs, indices, WebGLContext2D._tmpMatrix, rgba, this);
            this._curSubmit._numEle += eleNum;
            this._maxNumEle = Math.max(this._maxNumEle, this._curSubmit._numEle);
            return true;
        };
        __proto.transform = function (a, b, c, d, tx, ty) {
            SaveTransform.save(this);
            Matrix.mul(Matrix.TEMP.setTo(a, b, c, d, tx, ty), this._curMat, this._curMat);
            this._curMat._checkTransform();
        };
        __proto.setTransformByMatrix = function (value) {
            value.copyTo(this._curMat);
        };
        __proto.transformByMatrix = function (value) {
            SaveTransform.save(this);
            Matrix.mul(value, this._curMat, this._curMat);
            this._curMat._checkTransform();
        };
        __proto.rotate = function (angle) {
            SaveTransform.save(this);
            this._curMat.rotateEx(angle);
        };
        __proto.scale = function (scaleX, scaleY) {
            SaveTransform.save(this);
            this._curMat.scaleEx(scaleX, scaleY);
        };
        __proto.clipRect = function (x, y, width, height) {
            if (this._curMat.b != 0 || this._curMat.c != 0) {
                this._renderKey = 0;
                var submitStencil0 = SubmitStencil.create(4);
                this.addRenderObject(submitStencil0);
                var vb = this._vb;
                var nPos = (vb._byteLength >> 2);
                if (GlUtils.fillRectImgVb(vb, null, x, y, width, height, Texture.DEF_UV, this._curMat, this._x, this._y, 0, 0)) {
                    var shader = this._shader2D;
                    shader.glTexture = null;
                    var submit = this._curSubmit = Submit.createSubmit(this, this._ib, vb, ((vb._byteLength - 16 * 4) / 32) * 3, Value2D.create(0x02, 0));
                    submit.shaderValue.ALPHA = 1.0;
                    this._submits[this._submits._length++] = submit;
                    this._curSubmit._numEle += 6;
                }
                else {
                    alert("clipRect calc stencil rect error");
                }
                ;
                var submitStencil1 = SubmitStencil.create(5);
                this.addRenderObject(submitStencil1);
                var vbdata = vb.getFloat32Array();
                var minx = Math.min(Math.min(Math.min(vbdata[nPos + 0], vbdata[nPos + 4]), vbdata[nPos + 8]), vbdata[nPos + 12]);
                var maxx = Math.max(Math.max(Math.max(vbdata[nPos + 0], vbdata[nPos + 4]), vbdata[nPos + 8]), vbdata[nPos + 12]);
                var miny = Math.min(Math.min(Math.min(vbdata[nPos + 1], vbdata[nPos + 5]), vbdata[nPos + 9]), vbdata[nPos + 13]);
                var maxy = Math.max(Math.max(Math.max(vbdata[nPos + 1], vbdata[nPos + 5]), vbdata[nPos + 9]), vbdata[nPos + 13]);
                SaveClipRectStencil.save(this, submitStencil1, x, y, width, height, minx, miny, maxx - minx, maxy - miny);
                this._curSubmit = Submit.RENDERBASE;
            }
            else {
                width *= this._curMat.a;
                height *= this._curMat.d;
                var p = Point.TEMP;
                this._curMat.transformPoint(p.setTo(x, y));
                if (width < 0) {
                    p.x = p.x + width;
                    width = -width;
                }
                if (height < 0) {
                    p.y = p.y + height;
                    height = -height;
                }
                this._renderKey = 0;
                var submitSc = this._curSubmit = SubmitScissor.create(this);
                this._submits[this._submits._length++] = submitSc;
                submitSc.submitIndex = this._submits._length;
                submitSc.submitLength = 9999999;
                SaveClipRect.save(this, submitSc);
                var clip = this._clipRect;
                var x1 = clip.x, y1 = clip.y;
                var r = p.x + width, b = p.y + height;
                x1 < p.x && (clip.x = p.x);
                y1 < p.y && (clip.y = p.y);
                clip.width = Math.min(r, x1 + clip.width) - clip.x;
                clip.height = Math.min(b, y1 + clip.height) - clip.y;
                this._shader2D.glTexture = null;
                submitSc.clipRect.copyFrom(clip);
                this._curSubmit = Submit.RENDERBASE;
            }
        };
        __proto.setIBVB = function (x, y, ib, vb, numElement, mat, shader, shaderValues, startIndex, offset, type) {
            (startIndex === void 0) && (startIndex = 0);
            (offset === void 0) && (offset = 0);
            (type === void 0) && (type = 0);
            if (ib === null) {
                if (!Render.isFlash) {
                    ib = this._ib;
                }
                else {
                    var falshVB = vb;
                    (falshVB._selfIB) || (falshVB._selfIB = IndexBuffer2D.create(0x88E4));
                    falshVB._selfIB.clear();
                    ib = falshVB._selfIB;
                }
                GlUtils.expandIBQuadrangle(ib, (vb._byteLength / (4 * vb.vertexStride * 4)));
            }
            if (!shaderValues || !shader)
                throw Error("setIBVB must input:shader shaderValues");
            var submit = SubmitOtherIBVB.create(this, vb, ib, numElement, shader, shaderValues, startIndex, offset, type);
            mat || (mat = Matrix.EMPTY);
            mat.translate(x, y);
            Matrix.mul(mat, this._curMat, submit._mat);
            mat.translate(-x, -y);
            this._submits[this._submits._length++] = submit;
            this._curSubmit = Submit.RENDERBASE;
            this._renderKey = 0;
        };
        __proto.addRenderObject = function (o) {
            this._submits[this._submits._length++] = o;
        };
        __proto.fillTrangles = function (tex, x, y, points, m) {
            var submit = this._curSubmit;
            var vb = this._vb;
            var shader = this._shader2D;
            var curShader = submit.shaderValue;
            var length = points.length >> 4;
            var t_tex = tex.bitmap;
            this._renderKey = 0;
            if (shader.glTexture != t_tex || shader.ALPHA !== curShader.ALPHA) {
                submit = this._curSubmit = Submit.createSubmit(this, this._ib, vb, ((vb._byteLength) / 32) * 3, Value2D.create(0x01, 0));
                submit.shaderValue.textureHost = tex;
                this._submits[this._submits._length++] = submit;
            }
            GlUtils.fillTranglesVB(vb, x, y, points, m || this._curMat, this._x, this._y);
            submit._numEle += length * 6;
        };
        __proto.submitElement = function (start, end) {
            var renderList = this._submits;
            end < 0 && (end = renderList._length);
            while (start < end) {
                start += renderList[start].renderSubmit();
            }
        };
        __proto.finish = function () {
            WebGL.mainContext.finish();
        };
        __proto.flush = function () {
            var maxNum = Math.max(this._vb._byteLength / (4 * 16), this._maxNumEle / 6) + 8;
            if (maxNum > (this._ib.bufferLength / (6 * 2))) {
                GlUtils.expandIBQuadrangle(this._ib, maxNum);
            }
            if (!this._isMain && AtlasResourceManager.enabled && AtlasResourceManager._atlasRestore > this._atlasResourceChange) {
                this._atlasResourceChange = AtlasResourceManager._atlasRestore;
                var renderList = this._submits;
                for (var i = 0, s = renderList._length; i < s; i++) {
                    var submit = renderList[i];
                    if (submit.getRenderType() === 10016)
                        (submit).checkTexture();
                }
            }
            this.submitElement(0, this._submits._length);
            this._path && this._path.reset();
            SkinMeshBuffer.instance && SkinMeshBuffer.getInstance().reset();
            var sz = 0;
            for (i = 0, sz = this.meshlist.length; i < sz; i++) {
                var curm = this.meshlist[i];
                curm.canReuse ? (curm.releaseMesh()) : (curm.destroy());
            }
            this.meshlist.length = 0;
            this._curSubmit = Submit.RENDERBASE;
            this._renderKey = 0;
            this._triangleMesh = MeshTexture.getAMesh();
            this.meshlist.push(this._triangleMesh);
            return this._submits._length;
        };
        __proto.setPathId = function (id) {
            this.mId = id;
            if (this.mId != -1) {
                this.mHaveKey = false;
                var tVGM = VectorGraphManager.getInstance();
                if (tVGM.shapeDic[this.mId]) {
                    this.mHaveKey = true;
                }
                this.mHaveLineKey = false;
                if (tVGM.shapeLineDic[this.mId]) {
                    this.mHaveLineKey = true;
                }
            }
        };
        __proto.movePath = function (x, y) {
            var _x1 = x, _y1 = y;
            x = this._curMat.a * _x1 + this._curMat.c * _y1 + this._curMat.tx;
            y = this._curMat.b * _x1 + this._curMat.d * _y1 + this._curMat.ty;
            this.mX += x;
            this.mY += y;
        };
        __proto.beginPath = function () {
            var tPath = this._getPath();
            tPath.tempArray.length = 0;
            tPath.closePath = false;
            this.mX = 0;
            this.mY = 0;
        };
        __proto.closePath = function () {
            this._path.closePath = true;
        };
        __proto.fill = function (isConvexPolygon) {
            (isConvexPolygon === void 0) && (isConvexPolygon = false);
            var tPath = this._getPath();
            this.drawPoly(0, 0, tPath.tempArray, this.fillStyle._color.numColor, 0, 0, isConvexPolygon);
        };
        __proto.stroke = function () {
            var tPath = this._getPath();
            if (this.lineWidth > 0) {
                if (this.mId == -1) {
                    tPath.drawLine(0, 0, tPath.tempArray, this.lineWidth, this.strokeStyle._color.numColor);
                }
                else {
                    if (this.mHaveLineKey) {
                        var tShapeLine = VectorGraphManager.getInstance().shapeLineDic[this.mId];
                        tShapeLine.rebuild(tPath.tempArray);
                        tPath.setGeomtry(tShapeLine);
                    }
                    else {
                        VectorGraphManager.getInstance().addLine(this.mId, tPath.drawLine(0, 0, tPath.tempArray, this.lineWidth, this.strokeStyle._color.numColor));
                    }
                }
                tPath.update();
                var tPosArray = [this.mX, this.mY];
                var tempSubmit = Submit.createShape(this, tPath.ib, tPath.vb, tPath.count, tPath.offset, Value2D.create(0x04, 0));
                tempSubmit.shaderValue.ALPHA = this._shader2D.ALPHA;
                (tempSubmit.shaderValue).u_pos = tPosArray;
                tempSubmit.shaderValue.u_mmat2 = RenderState2D.TEMPMAT4_ARRAY;
                this._submits[this._submits._length++] = tempSubmit;
            }
        };
        __proto.line = function (fromX, fromY, toX, toY, lineWidth, mat) {
            var submit = this._curSubmit;
            var vb = this._vb;
            if (GlUtils.fillLineVb(vb, this._clipRect, fromX, fromY, toX, toY, lineWidth, mat)) {
                this._renderKey = 0;
                var shader = this._shader2D;
                var curShader = submit.shaderValue;
                if (shader.strokeStyle !== curShader.strokeStyle || shader.ALPHA !== curShader.ALPHA) {
                    shader.glTexture = null;
                    submit = this._curSubmit = Submit.createSubmit(this, this._ib, vb, ((vb._byteLength - 16 * 4) / 32) * 3, Value2D.create(0x02, 0));
                    submit.shaderValue.strokeStyle = shader.strokeStyle;
                    submit.shaderValue.mainID = 0x02;
                    submit.shaderValue.ALPHA = shader.ALPHA;
                    this._submits[this._submits._length++] = submit;
                }
                submit._numEle += 6;
            }
        };
        __proto.moveTo = function (x, y, b) {
            (b === void 0) && (b = true);
            var tPath = this._getPath();
            if (b) {
                var _x1 = x, _y1 = y;
                x = this._curMat.a * _x1 + this._curMat.c * _y1;
                y = this._curMat.b * _x1 + this._curMat.d * _y1;
            }
            tPath.addPoint(x, y);
        };
        __proto.lineTo = function (x, y, b) {
            (b === void 0) && (b = true);
            var tPath = this._getPath();
            if (b) {
                var _x1 = x, _y1 = y;
                x = this._curMat.a * _x1 + this._curMat.c * _y1;
                y = this._curMat.b * _x1 + this._curMat.d * _y1;
            }
            tPath.addPoint(x, y);
        };
        __proto.drawCurves = function (x, y, args) {
            this.setPathId(-1);
            this.beginPath();
            this.strokeStyle = args[3];
            this.lineWidth = args[4];
            var points = args[2];
            x += args[0], y += args[1];
            this.movePath(x, y);
            this.moveTo(points[0], points[1]);
            var i = 2, n = points.length;
            while (i < n) {
                this.quadraticCurveTo(points[i++], points[i++], points[i++], points[i++]);
            }
            this.stroke();
        };
        __proto.arcTo = function (x1, y1, x2, y2, r) {
            if (this.mId != -1) {
                if (this.mHaveKey) {
                    return;
                }
            }
            ;
            var i = 0;
            var x = 0, y = 0;
            var tPath = this._getPath();
            this._curMat.copyTo(WebGLContext2D._tmpMatrix);
            WebGLContext2D._tmpMatrix.tx = WebGLContext2D._tmpMatrix.ty = 0;
            WebGLContext2D._tempPoint.setTo(tPath.getEndPointX(), tPath.getEndPointY());
            WebGLContext2D._tmpMatrix.invertTransformPoint(WebGLContext2D._tempPoint);
            var dx = WebGLContext2D._tempPoint.x - x1;
            var dy = WebGLContext2D._tempPoint.y - y1;
            var len1 = Math.sqrt(dx * dx + dy * dy);
            if (len1 <= 0.000001) {
                return;
            }
            ;
            var ndx = dx / len1;
            var ndy = dy / len1;
            var dx2 = x2 - x1;
            var dy2 = y2 - y1;
            var len22 = dx2 * dx2 + dy2 * dy2;
            var len2 = Math.sqrt(len22);
            if (len2 <= 0.000001) {
                return;
            }
            ;
            var ndx2 = dx2 / len2;
            var ndy2 = dy2 / len2;
            var odx = ndx + ndx2;
            var ody = ndy + ndy2;
            var olen = Math.sqrt(odx * odx + ody * ody);
            if (olen <= 0.000001) {
                return;
            }
            ;
            var nOdx = odx / olen;
            var nOdy = ody / olen;
            var alpha = Math.acos(nOdx * ndx + nOdy * ndy);
            var halfAng = Math.PI / 2 - alpha;
            len1 = r / Math.tan(halfAng);
            var ptx1 = len1 * ndx + x1;
            var pty1 = len1 * ndy + y1;
            var orilen = Math.sqrt(len1 * len1 + r * r);
            var orix = x1 + nOdx * orilen;
            var oriy = y1 + nOdy * orilen;
            var ptx2 = len1 * ndx2 + x1;
            var pty2 = len1 * ndy2 + y1;
            var dir = ndx * ndy2 - ndy * ndx2;
            var fChgAng = 0;
            var sinx = 0.0;
            var cosx = 0.0;
            if (dir >= 0) {
                fChgAng = halfAng * 2;
                var fda = fChgAng / WebGLContext2D.SEGNUM;
                sinx = Math.sin(fda);
                cosx = Math.cos(fda);
            }
            else {
                fChgAng = -halfAng * 2;
                fda = fChgAng / WebGLContext2D.SEGNUM;
                sinx = Math.sin(fda);
                cosx = Math.cos(fda);
            }
            x = this._curMat.a * ptx1 + this._curMat.c * pty1;
            y = this._curMat.b * ptx1 + this._curMat.d * pty1;
            if (x != this._path.getEndPointX() || y != this._path.getEndPointY()) {
                tPath.addPoint(x, y);
            }
            ;
            var cvx = ptx1 - orix;
            var cvy = pty1 - oriy;
            var tx = 0.0;
            var ty = 0.0;
            for (i = 0; i < WebGLContext2D.SEGNUM; i++) {
                var cx = cvx * cosx + cvy * sinx;
                var cy = -cvx * sinx + cvy * cosx;
                x = cx + orix;
                y = cy + oriy;
                x1 = this._curMat.a * x + this._curMat.c * y;
                y1 = this._curMat.b * x + this._curMat.d * y;
                x = x1;
                y = y1;
                if (x != this._path.getEndPointX() || y != this._path.getEndPointY()) {
                    tPath.addPoint(x, y);
                }
                cvx = cx;
                cvy = cy;
            }
        };
        __proto.arc = function (cx, cy, r, startAngle, endAngle, counterclockwise, b) {
            (counterclockwise === void 0) && (counterclockwise = false);
            (b === void 0) && (b = true);
            if (this.mId != -1) {
                var tShape = VectorGraphManager.getInstance().shapeDic[this.mId];
                if (tShape) {
                    if (this.mHaveKey && !tShape.needUpdate(this._curMat))
                        return;
                }
                cx = 0;
                cy = 0;
            }
            ;
            var a = 0, da = 0, hda = 0, kappa = 0;
            var dx = 0, dy = 0, x = 0, y = 0, tanx = 0, tany = 0;
            var px = 0, py = 0, ptanx = 0, ptany = 0;
            var i = 0, ndivs = 0, nvals = 0;
            da = endAngle - startAngle;
            if (!counterclockwise) {
                if (Math.abs(da) >= Math.PI * 2) {
                    da = Math.PI * 2;
                }
                else {
                    while (da < 0.0) {
                        da += Math.PI * 2;
                    }
                }
            }
            else {
                if (Math.abs(da) >= Math.PI * 2) {
                    da = -Math.PI * 2;
                }
                else {
                    while (da > 0.0) {
                        da -= Math.PI * 2;
                    }
                }
            }
            if (r < 101) {
                ndivs = Math.max(10, da * r / 5);
            }
            else if (r < 201) {
                ndivs = Math.max(10, da * r / 20);
            }
            else {
                ndivs = Math.max(10, da * r / 40);
            }
            hda = (da / ndivs) / 2.0;
            kappa = Math.abs(4 / 3 * (1 - Math.cos(hda)) / Math.sin(hda));
            if (counterclockwise)
                kappa = -kappa;
            nvals = 0;
            var tPath = this._getPath();
            var _x1 = NaN, _y1 = NaN;
            for (i = 0; i <= ndivs; i++) {
                a = startAngle + da * (i / ndivs);
                dx = Math.cos(a);
                dy = Math.sin(a);
                x = cx + dx * r;
                y = cy + dy * r;
                if (b) {
                    _x1 = x, _y1 = y;
                    x = this._curMat.a * _x1 + this._curMat.c * _y1;
                    y = this._curMat.b * _x1 + this._curMat.d * _y1;
                }
                if (x != this._path.getEndPointX() || y != this._path.getEndPointY()) {
                    tPath.addPoint(x, y);
                }
            }
            dx = Math.cos(endAngle);
            dy = Math.sin(endAngle);
            x = cx + dx * r;
            y = cy + dy * r;
            if (b) {
                _x1 = x, _y1 = y;
                x = this._curMat.a * _x1 + this._curMat.c * _y1;
                y = this._curMat.b * _x1 + this._curMat.d * _y1;
            }
            if (x != this._path.getEndPointX() || y != this._path.getEndPointY()) {
                tPath.addPoint(x, y);
            }
        };
        __proto.quadraticCurveTo = function (cpx, cpy, x, y) {
            var tBezier = Bezier.I;
            var tResultArray = [];
            var _x1 = x, _y1 = y;
            x = this._curMat.a * _x1 + this._curMat.c * _y1;
            y = this._curMat.b * _x1 + this._curMat.d * _y1;
            _x1 = cpx, _y1 = cpy;
            cpx = this._curMat.a * _x1 + this._curMat.c * _y1;
            cpy = this._curMat.b * _x1 + this._curMat.d * _y1;
            var tArray = tBezier.getBezierPoints([this._path.getEndPointX(), this._path.getEndPointY(), cpx, cpy, x, y], 30, 2);
            for (var i = 0, n = tArray.length / 2; i < n; i++) {
                this.lineTo(tArray[i * 2], tArray[i * 2 + 1], false);
            }
            this.lineTo(x, y, false);
        };
        __proto.rect = function (x, y, width, height) {
            this._other = this._other.make();
            this._other.path || (this._other.path = new Path());
            this._other.path.rect(x, y, width, height);
        };
        __proto.strokeRect = function (x, y, width, height, parameterLineWidth) {
            var tW = parameterLineWidth * 0.5;
            this.line(x - tW, y, x + width + tW, y, parameterLineWidth, this._curMat);
            this.line(x + width, y, x + width, y + height, parameterLineWidth, this._curMat);
            this.line(x, y, x, y + height, parameterLineWidth, this._curMat);
            this.line(x - tW, y + height, x + width + tW, y + height, parameterLineWidth, this._curMat);
        };
        __proto.clip = function () { };
        __proto.drawPoly = function (x, y, points, color, lineWidth, boderColor, isConvexPolygon) {
            (isConvexPolygon === void 0) && (isConvexPolygon = false);
            this._renderKey = 0;
            this._shader2D.glTexture = null;
            var tPath = this._getPath();
            if (this.mId == -1) {
                tPath.polygon(x, y, points, color, lineWidth ? lineWidth : 1, boderColor);
            }
            else {
                if (this.mHaveKey) {
                    var tShape = VectorGraphManager.getInstance().shapeDic[this.mId];
                    tShape.setMatrix(this._curMat);
                    tShape.rebuild(tPath.tempArray);
                    tPath.setGeomtry(tShape);
                }
                else {
                    var t = tPath.polygon(x, y, points, color, lineWidth ? lineWidth : 1, boderColor);
                    VectorGraphManager.getInstance().addShape(this.mId, t);
                    t.setMatrix(this._curMat);
                }
            }
            tPath.update();
            var tPosArray = [this.mX, this.mY];
            var tempSubmit;
            tempSubmit = Submit.createShape(this, tPath.ib, tPath.vb, tPath.count, tPath.offset, Value2D.create(0x04, 0));
            tempSubmit.shaderValue.ALPHA = this._shader2D.ALPHA;
            (tempSubmit.shaderValue).u_pos = tPosArray;
            tempSubmit.shaderValue.u_mmat2 = RenderState2D.EMPTYMAT4_ARRAY;
            this._submits[this._submits._length++] = tempSubmit;
            if (lineWidth > 0) {
                if (this.mHaveLineKey) {
                    var tShapeLine = VectorGraphManager.getInstance().shapeLineDic[this.mId];
                    tShapeLine.rebuild(tPath.tempArray);
                    tPath.setGeomtry(tShapeLine);
                }
                else {
                    VectorGraphManager.getInstance().addShape(this.mId, tPath.drawLine(x, y, points, lineWidth, boderColor));
                }
                tPath.update();
                tempSubmit = Submit.createShape(this, tPath.ib, tPath.vb, tPath.count, tPath.offset, Value2D.create(0x04, 0));
                tempSubmit.shaderValue.ALPHA = this._shader2D.ALPHA;
                tempSubmit.shaderValue.u_mmat2 = RenderState2D.EMPTYMAT4_ARRAY;
                this._submits[this._submits._length++] = tempSubmit;
            }
        };
        __proto.drawParticle = function (x, y, pt) {
            pt.x = x;
            pt.y = y;
            this._submits[this._submits._length++] = pt;
        };
        __proto._getPath = function () {
            return this._path || (this._path = new Path());
        };
        __getset(0, __proto, 'globalCompositeOperation', function () {
            return BlendMode.NAMES[this._nBlendType];
        }, function (value) {
            var n = BlendMode.TOINT[value];
            n == null || (this._nBlendType === n) || (SaveBase.save(this, 0x10000, this, true), this._curSubmit = Submit.RENDERBASE, this._renderKey = 0, this._nBlendType = n);
        });
        __getset(0, __proto, 'strokeStyle', function () {
            return this._shader2D.strokeStyle;
        }, function (value) {
            this._shader2D.strokeStyle.equal(value) || (SaveBase.save(this, 0x200, this._shader2D, false), this._shader2D.strokeStyle = DrawStyle.create(value));
        });
        __getset(0, __proto, 'globalAlpha', function () {
            return this._shader2D.ALPHA;
        }, function (value) {
            value = Math.floor(value * 1000) / 1000;
            if (value != this._shader2D.ALPHA) {
                SaveBase.save(this, 0x1, this._shader2D, true);
                this._shader2D.ALPHA = value;
            }
        });
        __getset(0, __proto, 'asBitmap', null, function (value) {
            if (value) {
                this._targets || (this._targets = new RenderTargetMAX());
                this._targets.repaint = true;
                if (!this._width || !this._height)
                    throw Error("asBitmap no size!");
                this._targets.setSP(this.sprite);
                this._targets.size(this._width, this._height);
            }
            else
                this._targets = null;
        });
        __getset(0, __proto, 'fillStyle', function () {
            return this._shader2D.fillStyle;
        }, function (value) {
            this._shader2D.fillStyle.equal(value) || (SaveBase.save(this, 0x2, this._shader2D, false), this._shader2D.fillStyle = DrawStyle.create(value));
        });
        __getset(0, __proto, 'textAlign', function () {
            return this._other.textAlign;
        }, function (value) {
            (this._other.textAlign === value) || (this._other = this._other.make(), SaveBase.save(this, 0x8000, this._other, false), this._other.textAlign = value);
        });
        __getset(0, __proto, 'lineWidth', function () {
            return this._other.lineWidth;
        }, function (value) {
            (this._other.lineWidth === value) || (this._other = this._other.make(), SaveBase.save(this, 0x100, this._other, false), this._other.lineWidth = value);
        });
        __getset(0, __proto, 'textBaseline', function () {
            return this._other.textBaseline;
        }, function (value) {
            (this._other.textBaseline === value) || (this._other = this._other.make(), SaveBase.save(this, 0x4000, this._other, false), this._other.textBaseline = value);
        });
        __getset(0, __proto, 'font', null, function (str) {
            if (str == this._other.font.toString())
                return;
            this._other = this._other.make();
            SaveBase.save(this, 0x8, this._other, false);
            this._other.font === FontInContext.EMPTY ? (this._other.font = new FontInContext(str)) : (this._other.font.setFont(str));
        });
        WebGLContext2D.__init__ = function () {
            ContextParams.DEFAULT = new ContextParams();
        };
        WebGLContext2D._tempPoint = new Point();
        WebGLContext2D._SUBMITVBSIZE = 32000;
        WebGLContext2D._MAXSIZE = 99999999;
        WebGLContext2D._RECTVBSIZE = 16;
        WebGLContext2D.MAXCLIPRECT = new Rectangle(0, 0, 99999999, 99999999);
        WebGLContext2D._COUNT = 0;
        WebGLContext2D._tmpMatrix = new Matrix();
        WebGLContext2D.SEGNUM = 32;
        WebGLContext2D._contextcount = 0;
        __static(WebGLContext2D, ['_fontTemp', function () { return this._fontTemp = new FontInContext(); }, '_drawStyleTemp', function () { return this._drawStyleTemp = new DrawStyle(null); }
        ]);
        WebGLContext2D.__init$ = function () {
            ContextParams = (function () {
                function ContextParams() {
                    this.lineWidth = 1;
                    this.path = null;
                    this.textAlign = null;
                    this.textBaseline = null;
                    this.font = FontInContext.EMPTY;
                }
                __class(ContextParams, '');
                var __proto = ContextParams.prototype;
                __proto.clear = function () {
                    this.lineWidth = 1;
                    this.path && this.path.clear();
                    this.textAlign = this.textBaseline = null;
                    this.font = FontInContext.EMPTY;
                };
                __proto.make = function () {
                    return this === ContextParams.DEFAULT ? new ContextParams() : this;
                };
                ContextParams.DEFAULT = null;
                return ContextParams;
            })();
        };
        return WebGLContext2D;
    })(Context);
    var Value2D = (function (_super) {
        function Value2D(mainID, subID) {
            this.size = [0, 0];
            this.alpha = 1.0;
            this.ALPHA = 1.0;
            this.subID = 0;
            this._cacheID = 0;
            Value2D.__super.call(this);
            this.defines = new ShaderDefines2D();
            this.position = Value2D._POSITION;
            this.mainID = mainID;
            this.subID = subID;
            this.textureHost = null;
            this.texture = null;
            this.fillStyle = null;
            this.color = null;
            this.strokeStyle = null;
            this.colorAdd = null;
            this.glTexture = null;
            this.u_mmat2 = null;
            this._cacheID = mainID | subID;
            this._inClassCache = Value2D._cache[this._cacheID];
            if (mainID > 0 && !this._inClassCache) {
                this._inClassCache = Value2D._cache[this._cacheID] = [];
                this._inClassCache._length = 0;
            }
            this.clear();
        }
        __class(Value2D, 'laya.webgl.shader.d2.value.Value2D', _super);
        var __proto = Value2D.prototype;
        __proto.setValue = function (value) { };
        __proto.refresh = function () {
            var size = this.size;
            size[0] = RenderState2D.width;
            size[1] = RenderState2D.height;
            this.alpha = this.ALPHA * RenderState2D.worldAlpha;
            this.mmat = RenderState2D.worldMatrix4;
            return this;
        };
        __proto._ShaderWithCompile = function (kdsSetMaterialMacrosID) {
            return Shader.withCompile2D(0, this.mainID, this.defines.toNameDic(this), this.mainID | this.defines._value, Shader2X.create, kdsSetMaterialMacrosID);
        };
        __proto._withWorldShaderDefines = function () {
            var defs = RenderState2D.worldShaderDefines;
            var sd = Shader.sharders[this.mainID | this.defines._value | defs.getValue()];
            if (!sd) {
                var def = {};
                var dic;
                var name;
                dic = this.defines.toNameDic();
                for (name in dic)
                    def[name] = "";
                dic = defs.toNameDic();
                for (name in dic)
                    def[name] = "";
                sd = Shader.withCompile2D(0, this.mainID, def, this.mainID | this.defines._value | defs.getValue(), Shader2X.create);
            }
            ;
            var worldFilters = RenderState2D.worldFilters;
            if (!worldFilters)
                return sd;
            var n = worldFilters.length, f;
            for (var i = 0; i < n; i++) {
                ((f = worldFilters[i])) && f.action.setValue(this);
            }
            return sd;
        };
        __proto.upload = function () {
            var renderstate2d = RenderState2D;
            this.alpha = this.ALPHA * renderstate2d.worldAlpha;
            if (RenderState2D.worldMatrix4 !== RenderState2D.TEMPMAT4_ARRAY)
                this.defines.add(0x80);
            (WebGL.shaderHighPrecision) && (this.defines.add(0x400));
            // 存在使用材质的情况，缓存需要根据材质额外追加计算
            if (this.kdsSetMaterialMacrosID) {
                var mID = (this.mainID | this.defines._value) + "_" + this.kdsSetMaterialMacrosID;
                var sd = ShaderValue.kdsMaterialShaders[mID];
                if (!sd) {
                    // trace("创建使用KDS材质Shader--------------------------------", mID);
                    sd = this._ShaderWithCompile(mID);
                    ShaderValue.kdsMaterialShaders[mID] = sd;
                }
            }
            else {
                var sd = renderstate2d.worldShaderDefines ? this._withWorldShaderDefines() : (Shader.sharders[this.mainID | this.defines._value] || this._ShaderWithCompile());
            }
            var params;
            this.size[0] = renderstate2d.width, this.size[1] = renderstate2d.height;
            this.mmat = renderstate2d.worldMatrix4;
            if (BaseShader.activeShader !== sd) {
                if (sd._shaderValueWidth !== renderstate2d.width || sd._shaderValueHeight !== renderstate2d.height) {
                    sd._shaderValueWidth = renderstate2d.width;
                    sd._shaderValueHeight = renderstate2d.height;
                }
                else {
                    params = sd._params2dQuick2 || sd._make2dQuick2();
                }
                sd.upload(this, params);
            }
            else {
                if (sd._shaderValueWidth !== renderstate2d.width || sd._shaderValueHeight !== renderstate2d.height) {
                    sd._shaderValueWidth = renderstate2d.width;
                    sd._shaderValueHeight = renderstate2d.height;
                }
                else {
                    params = (sd._params2dQuick1) || sd._make2dQuick1();
                }
                sd.upload(this, params);
            }
        };
        __proto.setFilters = function (value) {
            this.filters = value;
            if (!value)
                return;
            var n = value.length, f;
            for (var i = 0; i < n; i++) {
                f = value[i];
                if (f) {
                    this.defines.add(f.type);
                    f.action.setValue(this);
                }
            }
        };
        __proto.clear = function () {
            this.defines.setValue(this.subID);
        };
        __proto.release = function () {
            this._inClassCache[this._inClassCache._length++] = this;
            this.fillStyle = null;
            this.strokeStyle = null;
            this.clear();
        };
        Value2D._initone = function (type, classT) {
            Value2D._typeClass[type] = classT;
            Value2D._cache[type] = [];
            Value2D._cache[type]._length = 0;
        };
        Value2D.__init__ = function () {
            Value2D._POSITION = [2, 0x1406, false, 4 * CONST3D2D.BYTES_PE, 0];
            Value2D._TEXCOORD = [2, 0x1406, false, 4 * CONST3D2D.BYTES_PE, 2 * CONST3D2D.BYTES_PE];
            Value2D._initone(0x02, Color2dSV);
            Value2D._initone(0x04, PrimitiveSV);
            Value2D._initone(0x100, FillTextureSV);
            Value2D._initone(0x200, SkinSV);
            Value2D._initone(0x01, TextureSV);
            Value2D._initone(0x01 | 0x40, TextSV);
            Value2D._initone(0x01 | 0x08, TextureSV);
        };
        Value2D.create = function (mainType, subType) {
            var types = Value2D._cache[mainType | subType];
            if (types._length)
                return types[--types._length];
            else
                return new Value2D._typeClass[mainType | subType](subType);
        };
        Value2D._POSITION = null;
        Value2D._TEXCOORD = null;
        Value2D._cache = [];
        Value2D._typeClass = [];
        Value2D.TEMPMAT4_ARRAY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        return Value2D;
    })(ShaderValue);
    ShaderValue.kdsMaterialShaders = [];
    var RenderSprite3D = (function (_super) {
        function RenderSprite3D(type, next) {
            RenderSprite3D.__super.call(this, type, next);
        }
        __class(RenderSprite3D, 'laya.webgl.utils.RenderSprite3D', _super);
        var __proto = RenderSprite3D.prototype;
        __proto.onCreate = function (type) {
            switch (type) {
                case 0x08:
                    this._fun = this._blend;
                    return;
                case 0x04:
                    this._fun = this._transform;
                    return;
            }
        };
        __proto._mask = function (sprite, context, x, y) {
            var next = this._next;
            var mask = sprite.mask;
            var submitCMD;
            var submitStencil;
            if (mask) {
                context.ctx.save();
                var preBlendMode = (context.ctx).globalCompositeOperation;
                var tRect = new Rectangle();
                tRect.copyFrom(mask.getBounds());
                tRect.width = Math.round(tRect.width);
                tRect.height = Math.round(tRect.height);
                tRect.x = Math.round(tRect.x);
                tRect.y = Math.round(tRect.y);
                if (tRect.width > 0 && tRect.height > 0) {
                    var tf = sprite._style._tf;
                    var scope = SubmitCMDScope.create();
                    scope.addValue("bounds", tRect);
                    submitCMD = SubmitCMD.create([scope, context], laya.webgl.utils.RenderSprite3D.tmpTarget);
                    context.addRenderObject(submitCMD);
                    mask.render(context, -tRect.x, -tRect.y);
                    submitCMD = SubmitCMD.create([scope], laya.webgl.utils.RenderSprite3D.endTmpTarget);
                    context.addRenderObject(submitCMD);
                    context.ctx.save();
                    context.clipRect(x - tf.translateX + tRect.x, y - tf.translateY + tRect.y, tRect.width, tRect.height);
                    next._fun.call(next, sprite, context, x, y);
                    context.ctx.restore();
                    submitStencil = SubmitStencil.create(6);
                    preBlendMode = (context.ctx).globalCompositeOperation;
                    submitStencil.blendMode = "mask";
                    context.addRenderObject(submitStencil);
                    Matrix.TEMP.identity();
                    var shaderValue = Value2D.create(0x01, 0);
                    var uv = Texture.INV_UV;
                    var w = tRect.width;
                    var h = tRect.height;
                    var tempLimit = 32;
                    if (tRect.width < tempLimit || tRect.height < tempLimit) {
                        uv = RenderSprite3D.tempUV;
                        uv[0] = 0;
                        uv[1] = 0;
                        uv[2] = (tRect.width >= 32) ? 1 : tRect.width / tempLimit;
                        uv[3] = 0;
                        uv[4] = (tRect.width >= 32) ? 1 : tRect.width / tempLimit;
                        uv[5] = (tRect.height >= 32) ? 1 : tRect.height / tempLimit;
                        uv[6] = 0;
                        uv[7] = (tRect.height >= 32) ? 1 : tRect.height / tempLimit;
                        tRect.width = (tRect.width >= 32) ? tRect.width : tempLimit;
                        tRect.height = (tRect.height >= 32) ? tRect.height : tempLimit;
                        uv[1] *= -1;
                        uv[3] *= -1;
                        uv[5] *= -1;
                        uv[7] *= -1;
                        uv[1] += 1;
                        uv[3] += 1;
                        uv[5] += 1;
                        uv[7] += 1;
                    }
                    (context.ctx).drawTarget(scope, x + tRect.x - tf.translateX, y + tRect.y - tf.translateY, w, h, Matrix.TEMP, "tmpTarget", shaderValue, uv, 6);
                    submitCMD = SubmitCMD.create([scope], laya.webgl.utils.RenderSprite3D.recycleTarget);
                    context.addRenderObject(submitCMD);
                    submitStencil = SubmitStencil.create(6);
                    submitStencil.blendMode = preBlendMode;
                    context.addRenderObject(submitStencil);
                }
                context.ctx.restore();
            }
            else {
                next._fun.call(next, sprite, context, x, y);
            }
        };
        __proto._blend = function (sprite, context, x, y) {
            var style = sprite._style;
            var next = this._next;
            if (style.blendMode) {
                context.ctx.save();
                context.ctx.globalCompositeOperation = style.blendMode;
                next._fun.call(next, sprite, context, x, y);
                context.ctx.restore();
            }
            else {
                next._fun.call(next, sprite, context, x, y);
            }
        };
        __proto._transform = function (sprite, context, x, y) {
            'use strict';
            var transform = sprite.transform, _next = this._next;
            if (transform && _next != RenderSprite.NORENDER) {
                var ctx = context.ctx;
                var style = sprite._style;
                transform.tx = x;
                transform.ty = y;
                var m2 = ctx._getTransformMatrix();
                var m1 = m2.clone();
                Matrix.mul(transform, m2, m2);
                m2._checkTransform();
                transform.tx = transform.ty = 0;
                _next._fun.call(_next, sprite, context, 0, 0);
                m1.copyTo(m2);
                m1.destroy();
            }
            else {
                _next._fun.call(_next, sprite, context, x, y);
            }
        };
        RenderSprite3D.tmpTarget = function (scope, context) {
            var b = scope.getValue("bounds");
            var tmpTarget = RenderTarget2D.create(b.width, b.height);
            tmpTarget.start();
            tmpTarget.clear(0, 0, 0, 0);
            scope.addValue("tmpTarget", tmpTarget);
        };
        RenderSprite3D.endTmpTarget = function (scope) {
            var tmpTarget = scope.getValue("tmpTarget");
            tmpTarget.end();
        };
        RenderSprite3D.recycleTarget = function (scope) {
            var tmpTarget = scope.getValue("tmpTarget");
            tmpTarget.recycle();
            scope.recycle();
        };
        __static(RenderSprite3D, ['tempUV', function () { return this.tempUV = new Array(8); }
        ]);
        return RenderSprite3D;
    })(RenderSprite);
    var ColorFilterActionGL = (function (_super) {
        function ColorFilterActionGL() {
            this.data = null;
            ColorFilterActionGL.__super.call(this);
        }
        __class(ColorFilterActionGL, 'laya.filters.webgl.ColorFilterActionGL', _super);
        var __proto = ColorFilterActionGL.prototype;
        Laya.imps(__proto, { "laya.filters.IFilterActionGL": true });
        __proto.setValue = function (shader) {
            shader.colorMat = this.data._mat;
            shader.colorAlpha = this.data._alpha;
        };
        __proto.apply3d = function (scope, sprite, context, x, y) {
            var b = scope.getValue("bounds");
            var shaderValue = Value2D.create(0x01, 0);
            shaderValue.setFilters([this.data]);
            var tMatrix = Matrix.TEMP;
            tMatrix.identity();
            context.ctx.drawTarget(scope, 0, 0, b.width, b.height, tMatrix, "src", shaderValue);
        };
        return ColorFilterActionGL;
    })(FilterActionGL);
    var Atlaser = (function (_super) {
        function Atlaser(gridNumX, gridNumY, width, height, atlasID) {
            this._atlasCanvas = null;
            this._inAtlasTextureKey = null;
            this._inAtlasTextureBitmapValue = null;
            this._inAtlasTextureOriUVValue = null;
            this._InAtlasWebGLImagesKey = null;
            this._InAtlasWebGLImagesOffsetValue = null;
            Atlaser.__super.call(this, gridNumX, gridNumY, atlasID);
            this._inAtlasTextureKey = [];
            this._inAtlasTextureBitmapValue = [];
            this._inAtlasTextureOriUVValue = [];
            this._InAtlasWebGLImagesKey = {};
            this._InAtlasWebGLImagesOffsetValue = [];
            this._atlasCanvas = new AtlasWebGLCanvas();
            this._atlasCanvas._atlaser = this;
            this._atlasCanvas.width = width;
            this._atlasCanvas.height = height;
            this._atlasCanvas.activeResource();
            this._atlasCanvas.lock = true;
        }
        __class(Atlaser, 'laya.webgl.atlas.Atlaser', _super);
        var __proto = Atlaser.prototype;
        __proto.computeUVinAtlasTexture = function (texture, oriUV, offsetX, offsetY) {
            var tex = texture;
            var _width = AtlasResourceManager.atlasTextureWidth;
            var _height = AtlasResourceManager.atlasTextureHeight;
            var u1 = offsetX / _width, v1 = offsetY / _height, u2 = (offsetX + texture.bitmap.width) / _width, v2 = (offsetY + texture.bitmap.height) / _height;
            var inAltasUVWidth = texture.bitmap.width / _width, inAltasUVHeight = texture.bitmap.height / _height;
            texture.uv = [u1 + oriUV[0] * inAltasUVWidth, v1 + oriUV[1] * inAltasUVHeight, u2 - (1 - oriUV[2]) * inAltasUVWidth, v1 + oriUV[3] * inAltasUVHeight, u2 - (1 - oriUV[4]) * inAltasUVWidth, v2 - (1 - oriUV[5]) * inAltasUVHeight, u1 + oriUV[6] * inAltasUVWidth, v2 - (1 - oriUV[7]) * inAltasUVHeight];
        };
        __proto.findBitmapIsExist = function (bitmap) {
            if ((bitmap instanceof laya.webgl.resource.WebGLImage)) {
                var webImage = bitmap;
                var sUrl = webImage.url;
                var object = this._InAtlasWebGLImagesKey[sUrl ? sUrl : webImage.id];
                if (object) {
                    return object.offsetInfoID;
                }
            }
            return -1;
        };
        __proto.addToAtlasTexture = function (mergeAtlasBitmap, offsetX, offsetY) {
            if ((mergeAtlasBitmap instanceof laya.webgl.resource.WebGLImage)) {
                var webImage = mergeAtlasBitmap;
                var sUrl = webImage.url;
                this._InAtlasWebGLImagesKey[sUrl ? sUrl : webImage.id] = { bitmap: mergeAtlasBitmap, offsetInfoID: this._InAtlasWebGLImagesOffsetValue.length };
                this._InAtlasWebGLImagesOffsetValue.push([offsetX, offsetY]);
            }
            this._atlasCanvas.texSubImage2D(offsetX, offsetY, mergeAtlasBitmap.atlasSource);
            mergeAtlasBitmap.clearAtlasSource();
        };
        __proto.addToAtlas = function (texture, offsetX, offsetY) {
            texture._atlasID = this._inAtlasTextureKey.length;
            var oriUV = texture.uv.slice();
            var oriBitmap = texture.bitmap;
            this._inAtlasTextureKey.push(texture);
            this._inAtlasTextureOriUVValue.push(oriUV);
            this._inAtlasTextureBitmapValue.push(oriBitmap);
            this.computeUVinAtlasTexture(texture, oriUV, offsetX, offsetY);
            texture.bitmap = this._atlasCanvas;
        };
        __proto.clear = function () {
            for (var i = 0, n = this._inAtlasTextureKey.length; i < n; i++) {
                this._inAtlasTextureKey[i].bitmap = this._inAtlasTextureBitmapValue[i];
                this._inAtlasTextureKey[i].uv = this._inAtlasTextureOriUVValue[i];
                this._inAtlasTextureKey[i]._atlasID = -1;
                this._inAtlasTextureKey[i].bitmap.lock = false;
                this._inAtlasTextureKey[i].bitmap.releaseResource();
            }
            this._inAtlasTextureKey.length = 0;
            this._inAtlasTextureBitmapValue.length = 0;
            this._inAtlasTextureOriUVValue.length = 0;
            this._InAtlasWebGLImagesKey = null;
            this._InAtlasWebGLImagesOffsetValue.length = 0;
        };
        __proto.dispose = function () {
            this.clear();
            this._atlasCanvas.destroy();
        };
        __getset(0, __proto, 'InAtlasWebGLImagesOffsetValue', function () {
            return this._InAtlasWebGLImagesOffsetValue;
        });
        __getset(0, __proto, 'texture', function () {
            return this._atlasCanvas;
        });
        __getset(0, __proto, 'inAtlasWebGLImagesKey', function () {
            return this._InAtlasWebGLImagesKey;
        });
        return Atlaser;
    })(AtlasGrid);
    var ShaderDefines2D = (function (_super) {
        function ShaderDefines2D() {
            ShaderDefines2D.__super.call(this, ShaderDefines2D.__name2int, ShaderDefines2D.__int2name, ShaderDefines2D.__int2nameMap);
        }
        __class(ShaderDefines2D, 'laya.webgl.shader.d2.ShaderDefines2D', _super);
        ShaderDefines2D.__init__ = function () {
            ShaderDefines2D.reg("TEXTURE2D", 0x01);
            ShaderDefines2D.reg("COLOR2D", 0x02);
            ShaderDefines2D.reg("PRIMITIVE", 0x04);
            ShaderDefines2D.reg("GLOW_FILTER", 0x08);
            ShaderDefines2D.reg("BLUR_FILTER", 0x10);
            ShaderDefines2D.reg("COLOR_FILTER", 0x20);
            ShaderDefines2D.reg("COLOR_ADD", 0x40);
            ShaderDefines2D.reg("WORLDMAT", 0x80);
            ShaderDefines2D.reg("FILLTEXTURE", 0x100);
            ShaderDefines2D.reg("FSHIGHPRECISION", 0x400);
        };
        ShaderDefines2D.reg = function (name, value) {
            ShaderDefines._reg(name, value, ShaderDefines2D.__name2int, ShaderDefines2D.__int2name);
        };
        ShaderDefines2D.toText = function (value, int2name, int2nameMap) {
            return ShaderDefines._toText(value, int2name, int2nameMap);
        };
        ShaderDefines2D.toInt = function (names) {
            return ShaderDefines._toInt(names, ShaderDefines2D.__name2int);
        };
        ShaderDefines2D.TEXTURE2D = 0x01;
        ShaderDefines2D.COLOR2D = 0x02;
        ShaderDefines2D.PRIMITIVE = 0x04;
        ShaderDefines2D.FILTERGLOW = 0x08;
        ShaderDefines2D.FILTERBLUR = 0x10;
        ShaderDefines2D.FILTERCOLOR = 0x20;
        ShaderDefines2D.COLORADD = 0x40;
        ShaderDefines2D.WORLDMAT = 0x80;
        ShaderDefines2D.FILLTEXTURE = 0x100;
        ShaderDefines2D.SKINMESH = 0x200;
        ShaderDefines2D.SHADERDEFINE_FSHIGHPRECISION = 0x400;
        ShaderDefines2D.__name2int = {};
        ShaderDefines2D.__int2name = [];
        ShaderDefines2D.__int2nameMap = [];
        return ShaderDefines2D;
    })(ShaderDefines);
    var Ellipse = (function (_super) {
        function Ellipse(x, y, width, height, color, borderWidth, borderColor) {
            Ellipse.__super.call(this, x, y, width, height, 40, color, borderWidth, borderColor);
        }
        __class(Ellipse, 'laya.webgl.shapes.Ellipse', _super);
        return Ellipse;
    })(BasePoly);
    var Line = (function (_super) {
        function Line(x, y, points, borderWidth, color) {
            this._points = [];
            this.rebuild(points);
            Line.__super.call(this, x, y, 0, 0, 0, color, borderWidth, color, 0);
        }
        __class(Line, 'laya.webgl.shapes.Line', _super);
        var __proto = Line.prototype;
        __proto.rebuild = function (points) {
            var len = points.length;
            var preLen = this._points.length;
            if (len != preLen) {
                this.mUint16Array = new Uint16Array((len / 2 - 1) * 6);
                this.mFloat32Array = new Float32Array(len * 5);
            }
            this._points.length = 0;
            var tCurrX = NaN;
            var tCurrY = NaN;
            var tLastX = -1;
            var tLastY = -1;
            var tLen = points.length / 2;
            for (var i = 0; i < tLen; i++) {
                tCurrX = points[i * 2];
                tCurrY = points[i * 2 + 1];
                if (Math.abs(tLastX - tCurrX) > 0.01 || Math.abs(tLastY - tCurrY) > 0.01) {
                    this._points.push(tCurrX, tCurrY);
                }
                tLastX = tCurrX;
                tLastY = tCurrY;
            }
        };
        __proto.getData = function (ib, vb, start) {
            var indices = [];
            var verts = [];
            (this.borderWidth > 0) && this.createLine2(this._points, indices, this.borderWidth, start, verts, this._points.length / 2);
            this.mUint16Array.set(indices, 0);
            this.mFloat32Array.set(verts, 0);
            ib.append(this.mUint16Array);
            vb.append(this.mFloat32Array);
        };
        return Line;
    })(BasePoly);
    var LoopLine = (function (_super) {
        function LoopLine(x, y, points, width, color) {
            this._points = [];
            var tCurrX = NaN;
            var tCurrY = NaN;
            var tLastX = -1;
            var tLastY = -1;
            var tLen = points.length / 2 - 1;
            for (var i = 0; i < tLen; i++) {
                tCurrX = points[i * 2];
                tCurrY = points[i * 2 + 1];
                if (Math.abs(tLastX - tCurrX) > 0.01 || Math.abs(tLastY - tCurrY) > 0.01) {
                    this._points.push(tCurrX, tCurrY);
                }
                tLastX = tCurrX;
                tLastY = tCurrY;
            }
            tCurrX = points[tLen * 2];
            tCurrY = points[tLen * 2 + 1];
            tLastX = this._points[0];
            tLastY = this._points[1];
            if (Math.abs(tLastX - tCurrX) > 0.01 || Math.abs(tLastY - tCurrY) > 0.01) {
                this._points.push(tCurrX, tCurrY);
            }
            LoopLine.__super.call(this, x, y, 0, 0, this._points.length / 2, 0, width, color);
        }
        __class(LoopLine, 'laya.webgl.shapes.LoopLine', _super);
        var __proto = LoopLine.prototype;
        __proto.getData = function (ib, vb, start) {
            if (this.borderWidth > 0) {
                var color = this.color;
                var r = ((color >> 16) & 0x0000ff) / 255, g = ((color >> 8) & 0xff) / 255, b = (color & 0x0000ff) / 255;
                var verts = [];
                var tLastX = -1, tLastY = -1;
                var tCurrX = 0, tCurrY = 0;
                var indices = [];
                var tLen = Math.floor(this._points.length / 2);
                for (var i = 0; i < tLen; i++) {
                    tCurrX = this._points[i * 2];
                    tCurrY = this._points[i * 2 + 1];
                    verts.push(this.x + tCurrX, this.y + tCurrY, r, g, b);
                }
                this.createLoopLine(verts, indices, this.borderWidth, start + verts.length / 5);
                ib.append(new Uint16Array(indices));
                vb.append(new Float32Array(verts));
            }
        };
        __proto.createLoopLine = function (p, indices, lineWidth, len, outVertex, outIndex) {
            var tLen = p.length / 5;
            var points = p.concat();
            var result = outVertex ? outVertex : p;
            var color = this.borderColor;
            var r = ((color >> 16) & 0x0000ff) / 255, g = ((color >> 8) & 0xff) / 255, b = (color & 0x0000ff) / 255;
            var firstPoint = [points[0], points[1]];
            var lastPoint = [points[points.length - 5], points[points.length - 4]];
            var midPointX = lastPoint[0] + (firstPoint[0] - lastPoint[0]) * 0.5;
            var midPointY = lastPoint[1] + (firstPoint[1] - lastPoint[1]) * 0.5;
            points.unshift(midPointX, midPointY, 0, 0, 0);
            points.push(midPointX, midPointY, 0, 0, 0);
            var length = points.length / 5;
            var iStart = len, w = lineWidth / 2;
            var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
            var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
            var a1, b1, c1, a2, b2, c2;
            var denom, pdist, dist;
            p1x = points[0];
            p1y = points[1];
            p2x = points[5];
            p2y = points[6];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt(perpx * perpx + perpy * perpy);
            perpx = perpx / dist * w;
            perpy = perpy / dist * w;
            result.push(p1x - perpx, p1y - perpy, r, g, b, p1x + perpx, p1y + perpy, r, g, b);
            for (var i = 1; i < length - 1; i++) {
                p1x = points[(i - 1) * 5];
                p1y = points[(i - 1) * 5 + 1];
                p2x = points[(i) * 5];
                p2y = points[(i) * 5 + 1];
                p3x = points[(i + 1) * 5];
                p3y = points[(i + 1) * 5 + 1];
                perpx = -(p1y - p2y);
                perpy = p1x - p2x;
                dist = Math.sqrt(perpx * perpx + perpy * perpy);
                perpx = perpx / dist * w;
                perpy = perpy / dist * w;
                perp2x = -(p2y - p3y);
                perp2y = p2x - p3x;
                dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
                perp2x = perp2x / dist * w;
                perp2y = perp2y / dist * w;
                a1 = (-perpy + p1y) - (-perpy + p2y);
                b1 = (-perpx + p2x) - (-perpx + p1x);
                c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
                a2 = (-perp2y + p3y) - (-perp2y + p2y);
                b2 = (-perp2x + p2x) - (-perp2x + p3x);
                c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
                denom = a1 * b2 - a2 * b1;
                if (Math.abs(denom) < 0.1) {
                    denom += 10.1;
                    result.push(p2x - perpx, p2y - perpy, r, g, b, p2x + perpx, p2y + perpy, r, g, b);
                    continue;
                }
                px = (b1 * c2 - b2 * c1) / denom;
                py = (a2 * c1 - a1 * c2) / denom;
                pdist = (px - p2x) * (px - p2x) + (py - p2y) + (py - p2y);
                result.push(px, py, r, g, b, p2x - (px - p2x), p2y - (py - p2y), r, g, b);
            }
            if (outIndex) {
                indices = outIndex;
            }
            ;
            var groupLen = this.edges + 1;
            for (i = 1; i < groupLen; i++) {
                indices.push(iStart + (i - 1) * 2, iStart + (i - 1) * 2 + 1, iStart + i * 2 + 1, iStart + i * 2 + 1, iStart + i * 2, iStart + (i - 1) * 2);
            }
            indices.push(iStart + (i - 1) * 2, iStart + (i - 1) * 2 + 1, iStart + 1, iStart + 1, iStart, iStart + (i - 1) * 2);
            return result;
        };
        return LoopLine;
    })(BasePoly);
    var Polygon = (function (_super) {
        function Polygon(x, y, points, color, borderWidth, borderColor) {
            this._points = null;
            this._start = -1;
            this._repaint = false;
            this.earcutTriangles = null;
            this._mat = Matrix.create();
            this._points = points.slice(0, points.length);
            Polygon.__super.call(this, x, y, 0, 0, this._points.length / 2, color, borderWidth, borderColor);
        }
        __class(Polygon, 'laya.webgl.shapes.Polygon', _super);
        var __proto = Polygon.prototype;
        __proto.rebuild = function (point) {
            if (!this._repaint) {
                this._points.length = 0;
                this._points = this._points.concat(point);
            }
        };
        __proto.setMatrix = function (mat) {
            mat.copyTo(this._mat);
        };
        __proto.needUpdate = function (mat) {
            this._repaint = (this._mat.a == mat.a && this._mat.b == mat.b && this._mat.c == mat.c && this._mat.d == mat.d && this._mat.tx == mat.tx && this._mat.ty == mat.ty);
            return !this._repaint;
        };
        __proto.getData = function (ib, vb, start) {
            var indices, i = 0;
            var tArray = this._points;
            var tLen = 0;
            if (this.mUint16Array && this.mFloat32Array && this._repaint) {
                if (this._start != start) {
                    this._start = start;
                    indices = [];
                    tLen = this.earcutTriangles.length;
                    for (i = 0; i < tLen; i++) {
                        indices.push(this.earcutTriangles[i] + start);
                    }
                    this.mUint16Array = new Uint16Array(indices);
                }
            }
            else {
                this._start = start;
                indices = [];
                var verts = [];
                var vertsEarcut = [];
                var color = this.color;
                var r = ((color >> 16) & 0x0000ff) / 255, g = ((color >> 8) & 0xff) / 255, b = (color & 0x0000ff) / 255;
                tLen = Math.floor(tArray.length / 2);
                for (i = 0; i < tLen; i++) {
                    verts.push(this.x + tArray[i * 2], this.y + tArray[i * 2 + 1], r, g, b);
                    vertsEarcut.push(this.x + tArray[i * 2], this.y + tArray[i * 2 + 1]);
                }
                this.earcutTriangles = Earcut.earcut(vertsEarcut, null, 2);
                tLen = this.earcutTriangles.length;
                for (i = 0; i < tLen; i++) {
                    indices.push(this.earcutTriangles[i] + start);
                }
                this.mUint16Array = new Uint16Array(indices);
                this.mFloat32Array = new Float32Array(verts);
            }
            ib.append(this.mUint16Array);
            vb.append(this.mFloat32Array);
        };
        return Polygon;
    })(BasePoly);
    var SubmitCanvas = (function (_super) {
        function SubmitCanvas() {
            this._matrix = new Matrix();
            this._matrix4 = CONST3D2D.defaultMatrix4.concat();
            SubmitCanvas.__super.call(this, 10000);
            this.shaderValue = new Value2D(0, 0);
        }
        __class(SubmitCanvas, 'laya.webgl.submit.SubmitCanvas', _super);
        var __proto = SubmitCanvas.prototype;
        __proto.renderSubmit = function () {
            if (this._ctx_src._targets) {
                this._ctx_src._targets.flush(this._ctx_src);
                return 1;
            }
            ;
            var preAlpha = RenderState2D.worldAlpha;
            var preMatrix4 = RenderState2D.worldMatrix4;
            var preMatrix = RenderState2D.worldMatrix;
            var preFilters = RenderState2D.worldFilters;
            var preWorldShaderDefines = RenderState2D.worldShaderDefines;
            var v = this.shaderValue;
            var m = this._matrix;
            var m4 = this._matrix4;
            var mout = Matrix.TEMP;
            Matrix.mul(m, preMatrix, mout);
            m4[0] = mout.a;
            m4[1] = mout.b;
            m4[4] = mout.c;
            m4[5] = mout.d;
            m4[12] = mout.tx;
            m4[13] = mout.ty;
            RenderState2D.worldMatrix = mout.clone();
            RenderState2D.worldMatrix4 = m4;
            RenderState2D.worldAlpha = RenderState2D.worldAlpha * v.alpha;
            if (v.filters && v.filters.length) {
                RenderState2D.worldFilters = v.filters;
                RenderState2D.worldShaderDefines = v.defines;
            }
            this._ctx_src.flush();
            RenderState2D.worldAlpha = preAlpha;
            RenderState2D.worldMatrix4 = preMatrix4;
            RenderState2D.worldMatrix.destroy();
            RenderState2D.worldMatrix = preMatrix;
            RenderState2D.worldFilters = preFilters;
            RenderState2D.worldShaderDefines = preWorldShaderDefines;
            return 1;
        };
        __proto.releaseRender = function () {
            var cache = SubmitCanvas._cache;
            this._ctx_src = null;
            cache[cache._length++] = this;
        };
        __proto.getRenderType = function () {
            return 10003;
        };
        SubmitCanvas.create = function (ctx_src, alpha, filters) {
            var o = (!SubmitCanvas._cache._length) ? (new SubmitCanvas()) : SubmitCanvas._cache[--SubmitCanvas._cache._length];
            o._ctx_src = ctx_src;
            var v = o.shaderValue;
            v.alpha = alpha;
            v.defines.setValue(0);
            filters && filters.length && v.setFilters(filters);
            return o;
        };
        SubmitCanvas._cache = (SubmitCanvas._cache = [], SubmitCanvas._cache._length = 0, SubmitCanvas._cache);
        return SubmitCanvas;
    })(Submit);
    var SubmitTexture = (function (_super) {
        function SubmitTexture(renderType) {
            this._preIsSameTextureShader = false;
            this._isSameTexture = true;
            this._texs = new Array;
            this._texsID = new Array;
            this._vbPos = new Array;
            (renderType === void 0) && (renderType = 10000);
            SubmitTexture.__super.call(this, renderType);
        }
        __class(SubmitTexture, 'laya.webgl.submit.SubmitTexture', _super);
        var __proto = SubmitTexture.prototype;
        __proto.releaseRender = function () {
            var cache = SubmitTexture._cache;
            cache[cache._length++] = this;
            this.shaderValue.release();
            this._preIsSameTextureShader = false;
            this._vb = null;
            this._texs.length = 0;
            this._vbPos.length = 0;
            this._isSameTexture = true;
        };
        __proto.addTexture = function (tex, vbpos) {
            this._texsID[this._texs.length] = tex._uvID;
            this._texs.push(tex);
            this._vbPos.push(vbpos);
        };
        __proto.checkTexture = function () {
            if (this._texs.length < 1) {
                this._isSameTexture = true;
                return;
            }
            ;
            var _tex = this.shaderValue.textureHost;
            var webGLImg = _tex.bitmap;
            if (webGLImg === null)
                return;
            var vbdata = this._vb.getFloat32Array();
            for (var i = 0, s = this._texs.length; i < s; i++) {
                var tex = this._texs[i];
                tex.active();
                var newUV = tex.uv;
                if (this._texsID[i] !== tex._uvID) {
                    this._texsID[i] = tex._uvID;
                    var vbPos = this._vbPos[i];
                    vbdata[vbPos + 2] = newUV[0];
                    vbdata[vbPos + 3] = newUV[1];
                    vbdata[vbPos + 6] = newUV[2];
                    vbdata[vbPos + 7] = newUV[3];
                    vbdata[vbPos + 10] = newUV[4];
                    vbdata[vbPos + 11] = newUV[5];
                    vbdata[vbPos + 14] = newUV[6];
                    vbdata[vbPos + 15] = newUV[7];
                    this._vb.setNeedUpload();
                }
                if (tex.bitmap !== webGLImg) {
                    this._isSameTexture = false;
                }
            }
        };
        __proto.renderSubmit = function () {
            if (this._numEle === 0) {
                SubmitTexture._shaderSet = false;
                return 1;
            }
            ;
            var _tex = this.shaderValue.textureHost;
            if (_tex) {
                var source = _tex.source;
                if (!_tex.bitmap || !source) {
                    SubmitTexture._shaderSet = false;
                    return 1;
                }
                this.shaderValue.texture = source;
            }
            this._vb.bind_upload(this._ib);
            var gl = WebGL.mainContext;
            if (BlendMode.activeBlendFunction !== this._blendFn) {
                gl.enable(0x0BE2);
                this._blendFn(gl);
                BlendMode.activeBlendFunction = this._blendFn;
            }
            Stat.drawCall++;
            Stat.trianglesFaces += this._numEle / 3;
            if (this._preIsSameTextureShader && BaseShader.activeShader && SubmitTexture._shaderSet)
                (BaseShader.activeShader).uploadTexture2D(this.shaderValue.texture);
            else
                this.shaderValue.upload();
            SubmitTexture._shaderSet = true;
            if (this._texs.length > 1 && !this._isSameTexture) {
                var webGLImg = _tex.bitmap;
                var index = 0;
                var shader = BaseShader.activeShader;
                for (var i = 0, s = this._texs.length; i < s; i++) {
                    var tex2 = this._texs[i];
                    if (tex2.bitmap !== webGLImg || (i + 1) === s) {
                        shader.uploadTexture2D(tex2.source);
                        gl.drawElements(0x0004, (i - index + 1) * 6, 0x1403, this._startIdx + index * 6 * CONST3D2D.BYTES_PIDX);
                        webGLImg = tex2.bitmap;
                        index = i;
                    }
                }
            }
            else {
                gl.drawElements(0x0004, this._numEle, 0x1403, this._startIdx);
            }
            return 1;
        };
        SubmitTexture.create = function (context, ib, vb, pos, sv) {
            var o = SubmitTexture._cache._length ? SubmitTexture._cache[--SubmitTexture._cache._length] : new SubmitTexture();
            if (vb == null) {
                vb = o._selfVb || (o._selfVb = VertexBuffer2D.create(-1));
                vb.clear();
                pos = 0;
            }
            o._ib = ib;
            o._vb = vb;
            o._startIdx = pos * CONST3D2D.BYTES_PIDX;
            o._numEle = 0;
            var blendType = context._nBlendType;
            o._blendFn = context._targets ? BlendMode.targetFns[blendType] : BlendMode.fns[blendType];
            o.shaderValue = sv;
            o.shaderValue.setValue(context._shader2D);
            var filters = context._shader2D.filters;
            filters && o.shaderValue.setFilters(filters);
            return o;
        };
        SubmitTexture._cache = (SubmitTexture._cache = [], SubmitTexture._cache._length = 0, SubmitTexture._cache);
        SubmitTexture._shaderSet = true;
        return SubmitTexture;
    })(Submit);
    var MeshTexture = (function (_super) {
        function MeshTexture() {
            MeshTexture.__super.call(this, laya.webgl.utils.MeshTexture.const_stride, 0, 0);
            this.canReuse = true;
            this.setAttributes(laya.webgl.utils.MeshTexture._fixattriInfo);
        }
        __class(MeshTexture, 'laya.webgl.utils.MeshTexture', _super);
        var __proto = MeshTexture.prototype;
        __proto.addData = function (vertices, uvs, idx, matrix, rgba, ctx) {
            var sz = vertices.length / 2;
            var startpos = this._vb.needSize(sz * MeshTexture.const_stride);
            var f32pos = startpos >> 2;
            var vbdata = this._vb.getFloat32Array();
            var ci = 0;
            for (var i = 0; i < sz; i++) {
                var x = vertices[ci], y = vertices[ci + 1];
                var x1 = x * matrix.a + y * matrix.c + matrix.tx;
                var y1 = x * matrix.b + y * matrix.d + matrix.ty;
                vbdata[f32pos++] = x1;
                vbdata[f32pos++] = y1;
                vbdata[f32pos++] = uvs[ci];
                vbdata[f32pos++] = uvs[ci + 1];
                ci += 2;
            }
            this._vb.setNeedUpload();
            var vertN = this.vertNum;
            if (vertN > 0) {
                sz = idx.length;
                if (sz > MeshTexture.tmpIdx.length)
                    MeshTexture.tmpIdx = new Uint16Array(sz);
                for (var ii = 0; ii < sz; ii++) {
                    MeshTexture.tmpIdx[ii] = idx[ii] + vertN;
                }
                this._ib.appendU16Array(MeshTexture.tmpIdx, idx.length);
            }
            else {
                this._ib.append(idx);
            }
            this._ib.setNeedUpload();
            this.vertNum += sz;
            this.indexNum += idx.length;
        };
        __proto.releaseMesh = function () {
            this._vb._byteLength = 0;
            this._ib._byteLength = 0;
            this.vertNum = 0;
            this.indexNum = 0;
            laya.webgl.utils.MeshTexture._POOL.push(this);
        };
        __proto.destroy = function () {
            this._ib.destroy();
            this._vb.destroy();
        };
        MeshTexture.getAMesh = function () {
            if (laya.webgl.utils.MeshTexture._POOL.length) {
                return laya.webgl.utils.MeshTexture._POOL.pop();
            }
            return new MeshTexture();
        };
        MeshTexture.const_stride = 16;
        MeshTexture._POOL = [];
        __static(MeshTexture, ['_fixattriInfo', function () {
                return this._fixattriInfo = [
                    0x1406, 2, 0,
                    0x1406, 2, 8
                ];
            }, 'tmpIdx', function () { return this.tmpIdx = new Uint16Array(4); }
        ]);
        return MeshTexture;
    })(Mesh2D);
    var BaseShader = (function (_super) {
        function BaseShader() {
            BaseShader.__super.call(this);
            this.lock = true;
        }
        __class(BaseShader, 'laya.webgl.shader.BaseShader', _super);
        BaseShader.activeShader = null;
        BaseShader.bindShader = null;
        return BaseShader;
    })(Resource);
    var RenderTarget2D = (function (_super) {
        function RenderTarget2D(width, height, surfaceFormat, surfaceType, depthStencilFormat, mipMap, repeat, minFifter, magFifter) {
            this._type = 0;
            this._svWidth = NaN;
            this._svHeight = NaN;
            this._preRenderTarget = null;
            this._alreadyResolved = false;
            this._looked = false;
            this._surfaceFormat = 0;
            this._surfaceType = 0;
            this._depthStencilFormat = 0;
            this._mipMap = false;
            this._repeat = false;
            this._minFifter = 0;
            this._magFifter = 0;
            this._destroy = false;
            (surfaceFormat === void 0) && (surfaceFormat = 0x1908);
            (surfaceType === void 0) && (surfaceType = 0x1401);
            (depthStencilFormat === void 0) && (depthStencilFormat = 0x84F9);
            (mipMap === void 0) && (mipMap = false);
            (repeat === void 0) && (repeat = false);
            (minFifter === void 0) && (minFifter = -1);
            (magFifter === void 0) && (magFifter = -1);
            this._type = 1;
            this._w = width;
            this._h = height;
            this._surfaceFormat = surfaceFormat;
            this._surfaceType = surfaceType;
            this._depthStencilFormat = depthStencilFormat;
            this._mipMap = mipMap;
            this._repeat = repeat;
            this._minFifter = minFifter;
            this._magFifter = magFifter;
            this._createWebGLRenderTarget();
            this.bitmap.lock = true;
            RenderTarget2D.__super.call(this, this.bitmap, Texture.INV_UV);
        }
        __class(RenderTarget2D, 'laya.webgl.resource.RenderTarget2D', _super);
        var __proto = RenderTarget2D.prototype;
        Laya.imps(__proto, { "laya.resource.IDispose": true });
        __proto.getType = function () {
            return this._type;
        };
        __proto.getTexture = function () {
            return this;
        };
        __proto.size = function (w, h) {
            if (this._w == w && this._h == h)
                return;
            this._w = w;
            this._h = h;
            this.release();
            if (this._w != 0 && this._h != 0)
                this._createWebGLRenderTarget();
        };
        __proto.release = function () {
            this.destroy();
        };
        __proto.recycle = function () {
            RenderTarget2D.POOL.push(this);
        };
        __proto.start = function () {
            var gl = WebGL.mainContext;
            this._preRenderTarget = RenderState2D.curRenderTarget;
            RenderState2D.curRenderTarget = this;
            gl.bindFramebuffer(0x8D40, this.bitmap.frameBuffer);
            this._alreadyResolved = false;
            if (this._type == 1) {
                gl.viewport(0, 0, this._w, this._h);
                this._svWidth = RenderState2D.width;
                this._svHeight = RenderState2D.height;
                RenderState2D.width = this._w;
                RenderState2D.height = this._h;
                BaseShader.activeShader = null;
            }
            return this;
        };
        __proto.clear = function (r, g, b, a) {
            (r === void 0) && (r = 0.0);
            (g === void 0) && (g = 0.0);
            (b === void 0) && (b = 0.0);
            (a === void 0) && (a = 1.0);
            var gl = WebGL.mainContext;
            gl.clearColor(r, g, b, a);
            var clearFlag = 0x00004000;
            switch (this._depthStencilFormat) {
                case 0x81A5:
                    clearFlag |= 0x00000100;
                    break;
                case 0x8D48:
                    clearFlag |= 0x00000400;
                    break;
                case 0x84F9:
                    clearFlag |= 0x00000100;
                    clearFlag |= 0x00000400;
                    break;
            }
            gl.clear(clearFlag);
        };
        __proto.end = function () {
            var gl = WebGL.mainContext;
            gl.bindFramebuffer(0x8D40, this._preRenderTarget ? this._preRenderTarget.bitmap.frameBuffer : null);
            this._alreadyResolved = true;
            RenderState2D.curRenderTarget = this._preRenderTarget;
            if (this._type == 1) {
                gl.viewport(0, 0, this._svWidth, this._svHeight);
                RenderState2D.width = this._svWidth;
                RenderState2D.height = this._svHeight;
                BaseShader.activeShader = null;
            }
            else
                gl.viewport(0, 0, Laya.stage.width, Laya.stage.height);
        };
        __proto.getData = function (x, y, width, height) {
            var gl = WebGL.mainContext;
            gl.bindFramebuffer(0x8D40, (this.bitmap).frameBuffer);
            var canRead = (gl.checkFramebufferStatus(0x8D40) === 0x8CD5);
            if (!canRead) {
                gl.bindFramebuffer(0x8D40, null);
                return null;
            }
            ;
            var pixels = new Uint8Array(this._w * this._h * 4);
            gl.readPixels(x, y, width, height, this._surfaceFormat, this._surfaceType, pixels);
            gl.bindFramebuffer(0x8D40, null);
            return pixels;
        };
        __proto.destroy = function (foreDiposeTexture) {
            (foreDiposeTexture === void 0) && (foreDiposeTexture = false);
            if (!this._destroy) {
                this._loaded = false;
                this.bitmap.offAll();
                this.bitmap.disposeResource();
                this.bitmap.dispose();
                this.offAll();
                this.bitmap = null;
                this._alreadyResolved = false;
                this._destroy = true;
                _super.prototype.destroy.call(this);
            }
        };
        __proto.dispose = function () { };
        __proto._createWebGLRenderTarget = function () {
            this.bitmap = new WebGLRenderTarget(this.width, this.height, this._surfaceFormat, this._surfaceType, this._depthStencilFormat, this._mipMap, this._repeat, this._minFifter, this._magFifter);
            this.bitmap.activeResource();
            this._alreadyResolved = true;
            this._destroy = false;
            this._loaded = true;
            this.bitmap.on("recovered", this, function (e) {
                this.event("recovered");
            });
        };
        __getset(0, __proto, 'surfaceFormat', function () {
            return this._surfaceFormat;
        });
        __getset(0, __proto, 'magFifter', function () {
            return this._magFifter;
        });
        __getset(0, __proto, 'surfaceType', function () {
            return this._surfaceType;
        });
        __getset(0, __proto, 'mipMap', function () {
            return this._mipMap;
        });
        __getset(0, __proto, 'depthStencilFormat', function () {
            return this._depthStencilFormat;
        });
        __getset(0, __proto, 'minFifter', function () {
            return this._minFifter;
        });
        __getset(0, __proto, 'source', function () {
            if (this._alreadyResolved)
                return Laya.superGet(Texture, this, 'source');
            return null;
        });
        RenderTarget2D.create = function (w, h, surfaceFormat, surfaceType, depthStencilFormat, mipMap, repeat, minFifter, magFifter) {
            (surfaceFormat === void 0) && (surfaceFormat = 0x1908);
            (surfaceType === void 0) && (surfaceType = 0x1401);
            (depthStencilFormat === void 0) && (depthStencilFormat = 0x84F9);
            (mipMap === void 0) && (mipMap = false);
            (repeat === void 0) && (repeat = false);
            (minFifter === void 0) && (minFifter = -1);
            (magFifter === void 0) && (magFifter = -1);
            var t = RenderTarget2D.POOL.pop();
            t || (t = new RenderTarget2D(w, h));
            if (!t.bitmap || t._w != w || t._h != h || t._surfaceFormat != surfaceFormat || t._surfaceType != surfaceType || t._depthStencilFormat != depthStencilFormat || t._mipMap != mipMap || t._repeat != repeat || t._minFifter != minFifter || t._magFifter != magFifter) {
                t._w = w;
                t._h = h;
                t._surfaceFormat = surfaceFormat;
                t._surfaceType = surfaceType;
                t._depthStencilFormat = depthStencilFormat;
                t._mipMap = mipMap;
                t._repeat = repeat;
                t._minFifter = minFifter;
                t._magFifter = magFifter;
                t.release();
                t._createWebGLRenderTarget();
            }
            return t;
        };
        RenderTarget2D.TYPE2D = 1;
        RenderTarget2D.TYPE3D = 2;
        RenderTarget2D.POOL = [];
        return RenderTarget2D;
    })(Texture);
    var Buffer = (function (_super) {
        function Buffer() {
            this._glBuffer = null;
            this._buffer = null;
            this._bufferType = 0;
            this._bufferUsage = 0;
            this._byteLength = 0;
            Buffer.__super.call(this);
            Buffer._gl = WebGL.mainContext;
        }
        __class(Buffer, 'laya.webgl.utils.Buffer', _super);
        var __proto = Buffer.prototype;
        __proto._bind = function () {
            this.activeResource();
            if (Buffer._bindActive[this._bufferType] !== this._glBuffer) {
                (this._bufferType === 0x8892) && (Buffer._bindVertexBuffer = this._glBuffer);
                Buffer._gl.bindBuffer(this._bufferType, Buffer._bindActive[this._bufferType] = this._glBuffer);
                BaseShader.activeShader = null;
            }
        };
        __proto.recreateResource = function () {
            this._glBuffer || (this._glBuffer = Buffer._gl.createBuffer());
            this.completeCreate();
        };
        __proto.disposeResource = function () {
            if (this._glBuffer) {
                WebGL.mainContext.deleteBuffer(this._glBuffer);
                this._glBuffer = null;
            }
            this.memorySize = 0;
        };
        __getset(0, __proto, 'bufferUsage', function () {
            return this._bufferUsage;
        });
        Buffer._gl = null;
        Buffer._bindActive = {};
        Buffer._bindVertexBuffer = null;
        Buffer._enableAtributes = [];
        return Buffer;
    })(Resource);
    var SkinSV = (function (_super) {
        function SkinSV(type) {
            this.texcoord = null;
            this.offsetX = 300;
            this.offsetY = 0;
            SkinSV.__super.call(this, 0x200, 0);
            var _vlen = 8 * CONST3D2D.BYTES_PE;
            this.position = [2, 0x1406, false, _vlen, 0];
            this.texcoord = [2, 0x1406, false, _vlen, 2 * CONST3D2D.BYTES_PE];
            this.color = [4, 0x1406, false, _vlen, 4 * CONST3D2D.BYTES_PE];
        }
        __class(SkinSV, 'laya.webgl.shader.d2.skinAnishader.SkinSV', _super);
        return SkinSV;
    })(Value2D);
    var Color2dSV = (function (_super) {
        function Color2dSV(args) {
            Color2dSV.__super.call(this, 0x02, 0);
            this.color = [];
        }
        __class(Color2dSV, 'laya.webgl.shader.d2.value.Color2dSV', _super);
        var __proto = Color2dSV.prototype;
        __proto.setValue = function (value) {
            value.fillStyle && (this.color = value.fillStyle._color._color);
            value.strokeStyle && (this.color = value.strokeStyle._color._color);
        };
        return Color2dSV;
    })(Value2D);
    var FillTextureSV = (function (_super) {
        function FillTextureSV(type) {
            this.u_colorMatrix = null;
            this.strength = 0;
            this.colorMat = null;
            this.colorAlpha = null;
            this.u_TexRange = [0, 1, 0, 1];
            this.u_offset = [0, 0];
            this.texcoord = Value2D._TEXCOORD;
            FillTextureSV.__super.call(this, 0x100, 0);
        }
        __class(FillTextureSV, 'laya.webgl.shader.d2.value.FillTextureSV', _super);
        var __proto = FillTextureSV.prototype;
        __proto.setValue = function (vo) {
            this.ALPHA = vo.ALPHA;
            vo.filters && this.setFilters(vo.filters);
        };
        __proto.clear = function () {
            this.texture = null;
            this.shader = null;
            this.defines.setValue(0);
        };
        return FillTextureSV;
    })(Value2D);
    var TextureSV = (function (_super) {
        function TextureSV(subID) {
            this.u_colorMatrix = null;
            this.strength = 0;
            this.blurInfo = null;
            this.colorMat = null;
            this.colorAlpha = null;
            this.texcoord = Value2D._TEXCOORD;
            (subID === void 0) && (subID = 0);
            TextureSV.__super.call(this, 0x01, subID);
        }
        __class(TextureSV, 'laya.webgl.shader.d2.value.TextureSV', _super);
        var __proto = TextureSV.prototype;
        __proto.setValue = function (vo) {
            this.ALPHA = vo.ALPHA;
            vo.filters && this.setFilters(vo.filters);
        };
        __proto.clear = function () {
            this.texture = null;
            this.shader = null;
            this.defines.setValue(0);
        };
        return TextureSV;
    })(Value2D);
    var PrimitiveSV = (function (_super) {
        function PrimitiveSV(args) {
            this.a_color = null;
            this.u_pos = [0, 0];
            PrimitiveSV.__super.call(this, 0x04, 0);
            this.position = [2, 0x1406, false, 5 * CONST3D2D.BYTES_PE, 0];
            this.a_color = [3, 0x1406, false, 5 * CONST3D2D.BYTES_PE, 2 * CONST3D2D.BYTES_PE];
        }
        __class(PrimitiveSV, 'laya.webgl.shader.d2.value.PrimitiveSV', _super);
        return PrimitiveSV;
    })(Value2D);
    var AtlasWebGLCanvas = (function (_super) {
        function AtlasWebGLCanvas() {
            this._atlaser = null;
            this._flashCacheImage = null;
            this._flashCacheImageNeedFlush = false;
            AtlasWebGLCanvas.__super.call(this);
        }
        __class(AtlasWebGLCanvas, 'laya.webgl.atlas.AtlasWebGLCanvas', _super);
        var __proto = AtlasWebGLCanvas.prototype;
        __proto.recreateResource = function () {
            var gl = WebGL.mainContext;
            var glTex = this._source = gl.createTexture();
            var preTarget = WebGLContext.curBindTexTarget;
            var preTexture = WebGLContext.curBindTexValue;
            WebGLContext.bindTexture(gl, 0x0DE1, glTex);
            gl.texImage2D(0x0DE1, 0, 0x1908, this._w, this._h, 0, 0x1908, 0x1401, null);
            gl.texParameteri(0x0DE1, 0x2801, 0x2601);
            gl.texParameteri(0x0DE1, 0x2800, 0x2601);
            gl.texParameteri(0x0DE1, 0x2802, 0x812F);
            gl.texParameteri(0x0DE1, 0x2803, 0x812F);
            (preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
            this.memorySize = this._w * this._h * 4;
            this.completeCreate();
        };
        __proto.disposeResource = function () {
            if (this._source) {
                WebGL.mainContext.deleteTexture(this._source);
                this._source = null;
                this.memorySize = 0;
            }
        };
        __proto.texSubImage2D = function (xoffset, yoffset, bitmap) {
            if (!Render.isFlash) {
                var gl = WebGL.mainContext;
                var preTarget = WebGLContext.curBindTexTarget;
                var preTexture = WebGLContext.curBindTexValue;
                WebGLContext.bindTexture(gl, 0x0DE1, this._source);
                gl.pixelStorei(0x9241, true);
                (xoffset - 1 >= 0) && (gl.texSubImage2D(0x0DE1, 0, xoffset - 1, yoffset, 0x1908, 0x1401, bitmap));
                (xoffset + 1 <= this._w) && (gl.texSubImage2D(0x0DE1, 0, xoffset + 1, yoffset, 0x1908, 0x1401, bitmap));
                (yoffset - 1 >= 0) && (gl.texSubImage2D(0x0DE1, 0, xoffset, yoffset - 1, 0x1908, 0x1401, bitmap));
                (yoffset + 1 <= this._h) && (gl.texSubImage2D(0x0DE1, 0, xoffset, yoffset + 1, 0x1908, 0x1401, bitmap));
                gl.texSubImage2D(0x0DE1, 0, xoffset, yoffset, 0x1908, 0x1401, bitmap);
                gl.pixelStorei(0x9241, false);
                (preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
            }
            else {
                if (!this._flashCacheImage) {
                    this._flashCacheImage = HTMLImage.create("");
                    this._flashCacheImage._image.createCanvas(this._w, this._h);
                }
                ;
                var bmData = bitmap.bitmapdata;
                this._flashCacheImage._image.copyPixels(bmData, 0, 0, bmData.width, bmData.height, xoffset, yoffset);
                (this._flashCacheImageNeedFlush) || (this._flashCacheImageNeedFlush = true);
            }
        };
        __proto.texSubImage2DPixel = function (xoffset, yoffset, width, height, pixel) {
            var gl = WebGL.mainContext;
            var preTarget = WebGLContext.curBindTexTarget;
            var preTexture = WebGLContext.curBindTexValue;
            WebGLContext.bindTexture(gl, 0x0DE1, this._source);
            var pixels = new Uint8Array(pixel.data);
            gl.pixelStorei(0x9241, true);
            gl.texSubImage2D(0x0DE1, 0, xoffset, yoffset, width, height, 0x1908, 0x1401, pixels);
            gl.pixelStorei(0x9241, false);
            (preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
        };
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            this._w = value;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            this._h = value;
        });
        return AtlasWebGLCanvas;
    })(Bitmap);
    var WebGLCanvas = (function (_super) {
        function WebGLCanvas() {
            this.flipY = true;
            this.premulAlpha = false;
            this.alwaysChange = false;
            WebGLCanvas.__super.call(this);
        }
        __class(WebGLCanvas, 'laya.webgl.resource.WebGLCanvas', _super);
        var __proto = WebGLCanvas.prototype;
        __proto.getCanvas = function () {
            return this._canvas;
        };
        __proto.clear = function () {
            this._ctx && this._ctx.clear();
        };
        __proto.destroy = function () {
            this._ctx && this._ctx.destroy();
            this._ctx = null;
            _super.prototype.destroy.call(this);
        };
        __proto._setContext = function (context) {
            this._ctx = context;
        };
        __proto.getContext = function (contextID, other) {
            return this._ctx ? this._ctx : (this._ctx = WebGLCanvas._createContext(this));
        };
        __proto.size = function (w, h) {
            if (this._w != w || this._h != h) {
                this._w = w;
                this._h = h;
                this._ctx && this._ctx.size(w, h);
                this._canvas && (this._canvas.height = h, this._canvas.width = w);
            }
        };
        __proto.activeResource = function (force) {
            (force === void 0) && (force = false);
            if (!this._source) {
                this.recreateResource();
            }
        };
        __proto.recreateResource = function () {
            this.createWebGlTexture();
            this.completeCreate();
        };
        __proto.disposeResource = function () {
            if (this._source && !this.iscpuSource) {
                WebGL.mainContext.deleteTexture(this._source);
                this._source = null;
                this.memorySize = 0;
            }
        };
        __proto.createWebGlTexture = function () {
            var gl = WebGL.mainContext;
            var glTex = this._source = gl.createTexture();
            this.iscpuSource = false;
            var preTarget = WebGLContext.curBindTexTarget;
            var preTexture = WebGLContext.curBindTexValue;
            WebGLContext.bindTexture(gl, 0x0DE1, glTex);
            gl.pixelStorei(0x9240, this.flipY ? 1 : 0);
            this.premulAlpha && gl.pixelStorei(0x9241, true);
            if (this._imgData.width || this._imgData.height || this._imgData.videoWidth || this._imgData.videoHeight) {
                gl.texImage2D(0x0DE1, 0, 0x1908, 0x1908, 0x1401, this._imgData);
            }
            else {
                if (!window['defaultImageData']) {
                    window['defaultImageData'] = new ImageData(1, 1);
                }
                gl.texImage2D(0x0DE1, 0, 0x1908, 0x1908, 0x1401, window['defaultImageData']);
            }
            this.premulAlpha && gl.pixelStorei(0x9241, false);
            gl.texParameteri(0x0DE1, 0x2800, 0x2601);
            gl.texParameteri(0x0DE1, 0x2801, 0x2601);
            gl.texParameteri(0x0DE1, 0x2802, 0x812F);
            gl.texParameteri(0x0DE1, 0x2803, 0x812F);
            gl.pixelStorei(0x9240, 0);
            this.memorySize = this._w * this._h * 4;
            (preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
        };
        __proto.reloadCanvasData = function () {
            var gl = WebGL.mainContext;
            if (!this._source) {
                console.error("reloadCanvasData error, gl texture not created!");
                return;
            }
            var preTarget = WebGLContext.curBindTexTarget;
            var preTexture = WebGLContext.curBindTexValue;
            WebGLContext.bindTexture(gl, 0x0DE1, this._source);
            this.premulAlpha && gl.pixelStorei(0x9241, true);
            if (this._imgData.width || this._imgData.height || this._imgData.videoWidth || this._imgData.videoHeight) {
                gl.texImage2D(0x0DE1, 0, 0x1908, 0x1908, 0x1401, this._imgData);
            }
            else {
                if (!window['defaultImageData']) {
                    window['defaultImageData'] = new ImageData(1, 1);
                }
                gl.texImage2D(0x0DE1, 0, 0x1908, 0x1908, 0x1401, window['defaultImageData']);
            }
            this.premulAlpha && gl.pixelStorei(0x9241, false);
            gl.pixelStorei(0x9240, 0);
            (preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
        };
        __proto.texSubImage2D = function (webglCanvas, xoffset, yoffset) {
            var gl = WebGL.mainContext;
            var preTarget = WebGLContext.curBindTexTarget;
            var preTexture = WebGLContext.curBindTexValue;
            WebGLContext.bindTexture(gl, 0x0DE1, this._source);
            gl.pixelStorei(0x9241, true);
            gl.texSubImage2D(0x0DE1, 0, xoffset, yoffset, 0x1908, 0x1401, webglCanvas._source);
            gl.pixelStorei(0x9241, false);
            (preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
        };
        __proto.toBase64 = function (type, encoderOptions, callBack) {
            var base64Data = null;
            if (this._canvas) {
                base64Data = this._canvas.toDataURL(type, encoderOptions);
            }
            callBack.call(this, base64Data);
        };
        __getset(0, __proto, 'context', function () {
            return this._ctx;
        });
        __getset(0, __proto, 'source', function () {
            if (this.alwaysChange)
                this.reloadCanvasData();
            return this._source;
        });
        __getset(0, __proto, 'asBitmap', null, function (value) {
            this._ctx && (this._ctx.asBitmap = value);
        });
        WebGLCanvas._createContext = null;
        return WebGLCanvas;
    })(Bitmap);
    var WebGLCharImage = (function (_super) {
        function WebGLCharImage(content, drawValue) {
            this.CborderSize = 12;
            WebGLCharImage.__super.call(this);
            this.char = content;
            this.isSpace = content === ' ';
            this.xs = drawValue.scaleX;
            this.ys = drawValue.scaleY;
            this.font = drawValue.font.toString();
            this.fontSize = drawValue.font.size;
            this.fillColor = drawValue.fillColor;
            this.borderColor = drawValue.borderColor;
            this.lineWidth = drawValue.lineWidth;
            this.underLine = drawValue.underLine;
            var bIsConchApp = Render.isConchApp;
            var pCanvas;
            if (bIsConchApp) {
                pCanvas = ConchTextCanvas;
                pCanvas._source = ConchTextCanvas;
                pCanvas._source.canvas = ConchTextCanvas;
            }
            else {
                pCanvas = Browser.canvas.source;
            }
            this.canvas = pCanvas;
            this._enableMerageInAtlas = true;
            if (bIsConchApp) {
                this._ctx = pCanvas;
            }
            else {
                this._ctx = this.canvas.getContext('2d', undefined);
            }
            ;
            var t = Utils.measureText(this.char, this.font);
            this.cw = t.width * this.xs;
            this.ch = (t.height || this.fontSize) * this.ys;
            this.onresize(this.cw + this.CborderSize * 2, this.ch + this.CborderSize * 2);
            this.texture = new Texture(this);
        }
        __class(WebGLCharImage, 'laya.webgl.resource.WebGLCharImage', _super);
        var __proto = WebGLCharImage.prototype;
        Laya.imps(__proto, { "laya.webgl.resource.IMergeAtlasBitmap": true });
        __proto.active = function () {
            this.texture.active();
        };
        __proto.recreateResource = function () {
            var bIsConchApp = Render.isConchApp;
            this.onresize(this.cw + this.CborderSize * 2, this.ch + this.CborderSize * 2);
            this.canvas && (this.canvas.height = this._h, this.canvas.width = this._w);
            if (bIsConchApp) {
                var nFontSize = this.fontSize;
                if (this.xs != 1 || this.ys != 1) {
                    nFontSize = parseInt(nFontSize * ((this.xs > this.ys) ? this.xs : this.ys) + "");
                }
                ;
                var sFont = "normal 100 " + nFontSize + "px Arial";
                if (this.borderColor) {
                    sFont += " 1 " + this.borderColor;
                }
                this._ctx.font = sFont;
                this._ctx.textBaseline = "top";
                this._ctx.fillStyle = this.fillColor;
                this._ctx.fillText(this.char, this.CborderSize, this.CborderSize, null, null, null);
            }
            else {
                this._ctx.save();
                (this._ctx).clearRect(0, 0, this.cw + this.CborderSize * 2, this.ch + this.CborderSize * 2);
                this._ctx.font = this.font;
                if (Text.RightToLeft) {
                    this._ctx.textAlign = "end";
                }
                this._ctx.textBaseline = "top";
                this._ctx.translate(this.CborderSize, this.CborderSize);
                if (this.xs != 1 || this.ys != 1) {
                    this._ctx.scale(this.xs, this.ys);
                }
                if (this.fillColor && this.borderColor) {
                    this._ctx.strokeStyle = this.borderColor;
                    this._ctx.lineWidth = this.lineWidth;
                    this._ctx.strokeText(this.char, 0, 0, null, null, 0, null);
                    this._ctx.fillStyle = this.fillColor;
                    this._ctx.fillText(this.char, 0, 0, null, null, null);
                }
                else {
                    if (this.lineWidth === -1) {
                        this._ctx.fillStyle = this.fillColor ? this.fillColor : "white";
                        this._ctx.fillText(this.char, 0, 0, null, null, null);
                    }
                    else {
                        this._ctx.strokeStyle = this.borderColor ? this.borderColor : 'white';
                        this._ctx.lineWidth = this.lineWidth;
                        this._ctx.strokeText(this.char, 0, 0, null, null, 0, null);
                    }
                }
                if (this.underLine) {
                    this._ctx.lineWidth = 1;
                    this._ctx.strokeStyle = this.fillColor;
                    this._ctx.beginPath();
                    this._ctx.moveTo(0, this.fontSize + 1);
                    var nW = this._ctx.measureText(this.char).width + 1;
                    this._ctx.lineTo(nW, this.fontSize + 1);
                    this._ctx.stroke();
                }
                this._ctx.restore();
            }
            this.borderSize = this.CborderSize;
            this.completeCreate();
        };
        __proto.onresize = function (w, h) {
            this._w = w;
            this._h = h;
            this._allowMerageInAtlas = true;
        };
        __proto.clearAtlasSource = function () { };
        __getset(0, __proto, 'allowMerageInAtlas', function () {
            return this._allowMerageInAtlas;
        });
        __getset(0, __proto, 'atlasSource', function () {
            return this.canvas;
        });
        __getset(0, __proto, 'enableMerageInAtlas', function () {
            return this._enableMerageInAtlas;
        }, function (value) {
            this._enableMerageInAtlas = value;
        });
        WebGLCharImage.createOneChar = function (content, drawValue) {
            var char = new WebGLCharImage(content, drawValue);
            return char;
        };
        return WebGLCharImage;
    })(Bitmap);
    var WebGLRenderTarget = (function (_super) {
        function WebGLRenderTarget(width, height, surfaceFormat, surfaceType, depthStencilFormat, mipMap, repeat, minFifter, magFifter) {
            (surfaceFormat === void 0) && (surfaceFormat = 0x1908);
            (surfaceType === void 0) && (surfaceType = 0x1401);
            (depthStencilFormat === void 0) && (depthStencilFormat = 0x84F9);
            (mipMap === void 0) && (mipMap = false);
            (repeat === void 0) && (repeat = false);
            (minFifter === void 0) && (minFifter = -1);
            (magFifter === void 0) && (magFifter = 1);
            WebGLRenderTarget.__super.call(this);
            this._w = width;
            this._h = height;
            this._surfaceFormat = surfaceFormat;
            this._surfaceType = surfaceType;
            this._depthStencilFormat = depthStencilFormat;
            this._mipMap = mipMap;
            this._repeat = repeat;
            this._minFifter = minFifter;
            this._magFifter = magFifter;
        }
        __class(WebGLRenderTarget, 'laya.webgl.resource.WebGLRenderTarget', _super);
        var __proto = WebGLRenderTarget.prototype;
        __proto.recreateResource = function () {
            var gl = WebGL.mainContext;
            this._frameBuffer || (this._frameBuffer = gl.createFramebuffer());
            this._source || (this._source = gl.createTexture());
            var preTarget = WebGLContext.curBindTexTarget;
            var preTexture = WebGLContext.curBindTexValue;
            WebGLContext.bindTexture(gl, 0x0DE1, this._source);
            gl.texImage2D(0x0DE1, 0, 0x1908, this._w, this._h, 0, this._surfaceFormat, this._surfaceType, null);
            var minFifter = this._minFifter;
            var magFifter = this._magFifter;
            var repeat = this._repeat ? 0x2901 : 0x812F;
            var isPot = Arith.isPOT(this._w, this._h);
            if (isPot) {
                if (this._mipMap)
                    (minFifter !== -1) || (minFifter = 0x2703);
                else
                    (minFifter !== -1) || (minFifter = 0x2601);
                (magFifter !== -1) || (magFifter = 0x2601);
                gl.texParameteri(0x0DE1, 0x2801, minFifter);
                gl.texParameteri(0x0DE1, 0x2800, magFifter);
                gl.texParameteri(0x0DE1, 0x2802, repeat);
                gl.texParameteri(0x0DE1, 0x2803, repeat);
                this._mipMap && gl.generateMipmap(0x0DE1);
            }
            else {
                (minFifter !== -1) || (minFifter = 0x2601);
                (magFifter !== -1) || (magFifter = 0x2601);
                gl.texParameteri(0x0DE1, 0x2801, minFifter);
                gl.texParameteri(0x0DE1, 0x2800, magFifter);
                gl.texParameteri(0x0DE1, 0x2802, 0x812F);
                gl.texParameteri(0x0DE1, 0x2803, 0x812F);
            }
            gl.bindFramebuffer(0x8D40, this._frameBuffer);
            gl.framebufferTexture2D(0x8D40, 0x8CE0, 0x0DE1, this._source, 0);
            if (this._depthStencilFormat) {
                this._depthStencilBuffer || (this._depthStencilBuffer = gl.createRenderbuffer());
                gl.bindRenderbuffer(0x8D41, this._depthStencilBuffer);
                gl.renderbufferStorage(0x8D41, this._depthStencilFormat, this._w, this._h);
                switch (this._depthStencilFormat) {
                    case 0x81A5:
                        gl.framebufferRenderbuffer(0x8D40, 0x8D00, 0x8D41, this._depthStencilBuffer);
                        break;
                    case 0x8D48:
                        gl.framebufferRenderbuffer(0x8D40, 0x8D20, 0x8D41, this._depthStencilBuffer);
                        break;
                    case 0x84F9:
                        gl.framebufferRenderbuffer(0x8D40, 0x821A, 0x8D41, this._depthStencilBuffer);
                        break;
                }
            }
            gl.bindFramebuffer(0x8D40, null);
            (preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
            gl.bindRenderbuffer(0x8D41, null);
            if (isPot && this._mipMap)
                this.memorySize = this._w * this._h * 4 * (1 + 1 / 3);
            else
                this.memorySize = this._w * this._h * 4;
            this.completeCreate();
        };
        __proto.disposeResource = function () {
            if (this._frameBuffer) {
                WebGL.mainContext.deleteTexture(this._source);
                WebGL.mainContext.deleteFramebuffer(this._frameBuffer);
                WebGL.mainContext.deleteRenderbuffer(this._depthStencilBuffer);
                this._source = null;
                this._frameBuffer = null;
                this._depthStencilBuffer = null;
                this.memorySize = 0;
            }
        };
        __getset(0, __proto, 'depthStencilBuffer', function () {
            return this._depthStencilBuffer;
        });
        __getset(0, __proto, 'frameBuffer', function () {
            return this._frameBuffer;
        });
        return WebGLRenderTarget;
    })(Bitmap);
    var WebGLSubImage = (function (_super) {
        function WebGLSubImage(canvas, offsetX, offsetY, width, height, atlasImage, src) {
            this.offsetX = 0;
            this.offsetY = 0;
            WebGLSubImage.__super.call(this);
            this.repeat = true;
            this.mipmap = false;
            this.minFifter = -1;
            this.magFifter = -1;
            this.atlasImage = atlasImage;
            this.canvas = canvas;
            this._ctx = canvas.getContext('2d', undefined);
            this._w = width;
            this._h = height;
            this.offsetX = offsetX;
            this.offsetY = offsetY;
            this.src = src;
            this._enableMerageInAtlas = true;
            (AtlasResourceManager.enabled) && (this._w < AtlasResourceManager.atlasLimitWidth && this._h < AtlasResourceManager.atlasLimitHeight) ? this._allowMerageInAtlas = true : this._allowMerageInAtlas = false;
        }
        __class(WebGLSubImage, 'laya.webgl.resource.WebGLSubImage', _super);
        var __proto = WebGLSubImage.prototype;
        Laya.imps(__proto, { "laya.webgl.resource.IMergeAtlasBitmap": true });
        __proto.size = function (w, h) {
            this._w = w;
            this._h = h;
            this._ctx && this._ctx.size(w, h);
            this.canvas && (this.canvas.height = h, this.canvas.width = w);
        };
        __proto.recreateResource = function () {
            this.size(this._w, this._h);
            this._ctx.drawImage(this.atlasImage, this.offsetX, this.offsetY, this._w, this._h, 0, 0, this._w, this._h);
            (!(this._allowMerageInAtlas && this._enableMerageInAtlas)) ? (this.createWebGlTexture()) : (this.memorySize = 0);
            this.completeCreate();
        };
        __proto.createWebGlTexture = function () {
            var gl = WebGL.mainContext;
            if (!this.canvas) {
                throw "create GLTextur err:no data:" + this.canvas;
            }
            var glTex = this._source = gl.createTexture();
            var preTarget = WebGLContext.curBindTexTarget;
            var preTexture = WebGLContext.curBindTexValue;
            WebGLContext.bindTexture(gl, 0x0DE1, glTex);
            gl.pixelStorei(0x9241, true);
            gl.texImage2D(0x0DE1, 0, 0x1908, 0x1908, 0x1401, this.canvas);
            gl.pixelStorei(0x9241, false);
            var minFifter = this.minFifter;
            var magFifter = this.magFifter;
            var repeat = this.repeat ? 0x2901 : 0x812F;
            var isPOT = Arith.isPOT(this.width, this.height);
            if (isPOT) {
                if (this.mipmap)
                    (minFifter !== -1) || (minFifter = 0x2703);
                else
                    (minFifter !== -1) || (minFifter = 0x2601);
                (magFifter !== -1) || (magFifter = 0x2601);
                gl.texParameteri(0x0DE1, 0x2800, magFifter);
                gl.texParameteri(0x0DE1, 0x2801, minFifter);
                gl.texParameteri(0x0DE1, 0x2802, repeat);
                gl.texParameteri(0x0DE1, 0x2803, repeat);
                this.mipmap && gl.generateMipmap(0x0DE1);
            }
            else {
                (minFifter !== -1) || (minFifter = 0x2601);
                (magFifter !== -1) || (magFifter = 0x2601);
                gl.texParameteri(0x0DE1, 0x2801, minFifter);
                gl.texParameteri(0x0DE1, 0x2800, magFifter);
                gl.texParameteri(0x0DE1, 0x2802, 0x812F);
                gl.texParameteri(0x0DE1, 0x2803, 0x812F);
            }
            (preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
            this.canvas = null;
            if (isPOT && this.mipmap)
                this.memorySize = this._w * this._h * 4 * (1 + 1 / 3);
            else
                this.memorySize = this._w * this._h * 4;
        };
        __proto.disposeResource = function () {
            if (!(AtlasResourceManager.enabled && this._allowMerageInAtlas) && this._source) {
                WebGL.mainContext.deleteTexture(this._source);
                this._source = null;
                this.memorySize = 0;
            }
        };
        __proto.clearAtlasSource = function () { };
        __getset(0, __proto, 'allowMerageInAtlas', function () {
            return this._allowMerageInAtlas;
        });
        __getset(0, __proto, 'atlasSource', function () {
            return this.canvas;
        });
        __getset(0, __proto, 'enableMerageInAtlas', function () {
            return this._allowMerageInAtlas;
        }, function (value) {
            this._allowMerageInAtlas = value;
        });
        return WebGLSubImage;
    })(Bitmap);
    var Shader = (function (_super) {
        function Shader(vs, ps, saveName, nameMap) {
            this.customCompile = false;
            this._curActTexIndex = 0;
            this.tag = {};
            this._program = null;
            this._params = null;
            this._paramsMap = {};
            this._offset = 0;
            Shader.__super.call(this);
            if ((!vs) || (!ps))
                throw "Shader Error";
            if (Render.isConchApp || Render.isFlash) {
                this.customCompile = true;
            }
            this._id = ++Shader._count;
            this._vs = vs;
            this._ps = ps;
            this._nameMap = nameMap ? nameMap : {};
            saveName != null && (Shader.sharders[saveName] = this);
        }
        __class(Shader, 'laya.webgl.shader.Shader', _super);
        var __proto = Shader.prototype;
        __proto.recreateResource = function () {
            this._compile();
            this.completeCreate();
            this.memorySize = 0;
        };
        __proto.disposeResource = function () {
            WebGL.mainContext.deleteShader(this._vshader);
            WebGL.mainContext.deleteShader(this._pshader);
            WebGL.mainContext.deleteProgram(this._program);
            this._vshader = this._pshader = this._program = null;
            this._params = null;
            this._paramsMap = {};
            this.memorySize = 0;
            this._curActTexIndex = 0;
        };
        __proto._compile = function () {
            if (!this._vs || !this._ps || this._params)
                return;
            this._reCompile = true;
            this._params = [];
            var text = [this._vs, this._ps];
            var result;
            if (this.customCompile)
                result = ShaderCompile.preGetParams(this._vs, this._ps);
            var gl = WebGL.mainContext;
            this._program = gl.createProgram();
            this._vshader = Shader._createShader(gl, text[0], 0x8B31);
            this._pshader = Shader._createShader(gl, text[1], 0x8B30);
            gl.attachShader(this._program, this._vshader);
            gl.attachShader(this._program, this._pshader);
            gl.linkProgram(this._program);
            if (!this.customCompile && !gl.getProgramParameter(this._program, 0x8B82)) {
                // throw gl.getProgramInfoLog(this._program);
                console.log("shader error", gl.getProgramInfoLog(this._program));
                return;
            }
            ;
            var one, i = 0, j = 0, n = 0, location;
            var attribNum = this.customCompile ? result.attributes.length : gl.getProgramParameter(this._program, 0x8B89);
            for (i = 0; i < attribNum; i++) {
                var attrib = this.customCompile ? result.attributes[i] : gl.getActiveAttrib(this._program, i);
                location = gl.getAttribLocation(this._program, attrib.name);
                one = { vartype: "attribute", glfun: null, ivartype: 0, attrib: attrib, location: location, name: attrib.name, type: attrib.type, isArray: false, isSame: false, preValue: null, indexOfParams: 0 };
                this._params.push(one);
            }
            ;
            var nUniformNum = this.customCompile ? result.uniforms.length : gl.getProgramParameter(this._program, 0x8B86);
            for (i = 0; i < nUniformNum; i++) {
                var uniform = this.customCompile ? result.uniforms[i] : gl.getActiveUniform(this._program, i);
                location = gl.getUniformLocation(this._program, uniform.name);
                one = { vartype: "uniform", glfun: null, ivartype: 1, attrib: attrib, location: location, name: uniform.name, type: uniform.type, isArray: false, isSame: false, preValue: null, indexOfParams: 0 };
                if (one.name.indexOf('[0]') > 0) {
                    one.name = one.name.substr(0, one.name.length - 3);
                    one.isArray = true;
                    one.location = gl.getUniformLocation(this._program, one.name);
                }
                this._params.push(one);
            }
            for (i = 0, n = this._params.length; i < n; i++) {
                one = this._params[i];
                one.indexOfParams = i;
                one.index = 1;
                one.value = [one.location, null];
                one.codename = one.name;
                one.name = this._nameMap[one.codename] ? this._nameMap[one.codename] : one.codename;
                this._paramsMap[one.name] = one;
                one._this = this;
                one.uploadedValue = [];
                if (one.vartype === "attribute") {
                    one.fun = this._attribute;
                    continue;
                }
                switch (one.type) {
                    case 0x1404:
                        one.fun = one.isArray ? this._uniform1iv : this._uniform1i;
                        break;
                    case 0x1406:
                        one.fun = one.isArray ? this._uniform1fv : this._uniform1f;
                        break;
                    case 0x8B50:
                        one.fun = one.isArray ? this._uniform_vec2v : this._uniform_vec2;
                        break;
                    case 0x8B51:
                        one.fun = one.isArray ? this._uniform_vec3v : this._uniform_vec3;
                        break;
                    case 0x8B52:
                        one.fun = one.isArray ? this._uniform_vec4v : this._uniform_vec4;
                        break;
                    case 0x8B5E:
                        one.fun = this._uniform_sampler2D;
                        break;
                    case 0x8B60:
                        one.fun = this._uniform_samplerCube;
                        break;
                    case 0x8B5C:
                        one.glfun = gl.uniformMatrix4fv;
                        one.fun = this._uniformMatrix4fv;
                        break;
                    case 0x8B56:
                        one.fun = this._uniform1i;
                        break;
                    case 0x8B5A:
                    case 0x8B5B:
                        throw new Error("compile shader err!");
                        break;
                    default:
                        throw new Error("compile shader err!");
                        break;
                }
            }
        };
        __proto.getUniform = function (name) {
            return this._paramsMap[name];
        };
        __proto._attribute = function (one, value) {
            if (value == null)
                return 1;
            var gl = WebGL.mainContext;
            var enableAtributes = Buffer._enableAtributes;
            var location = one.location;
            (enableAtributes[location]) || (gl.enableVertexAttribArray(location));
            gl.vertexAttribPointer(location, value[0], value[1], value[2], value[3], value[4] + this._offset);
            enableAtributes[location] = Buffer._bindVertexBuffer;
            return 1;
        };
        __proto._uniform1f = function (one, value) {
            if (value == null)
                return 0;
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== value) {
                WebGL.mainContext.uniform1f(one.location, uploadedValue[0] = value);
                return 1;
            }
            return 0;
        };
        __proto._uniform1fv = function (one, value) {
            if (value == null)
                return 0;
            if (value.length < 4) {
                var uploadedValue = one.uploadedValue;
                if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
                    WebGL.mainContext.uniform1fv(one.location, value);
                    uploadedValue[0] = value[0];
                    uploadedValue[1] = value[1];
                    uploadedValue[2] = value[2];
                    uploadedValue[3] = value[3];
                    return 1;
                }
                return 0;
            }
            else {
                WebGL.mainContext.uniform1fv(one.location, value);
                return 1;
            }
        };
        __proto._uniform_vec2 = function (one, value) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue && value && (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1])) {
                WebGL.mainContext.uniform2f(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1]);
                return 1;
            }
            return 0;
        };
        __proto._uniform_vec2v = function (one, value) {
            if (value == null)
                return 0;
            if (value.length < 2) {
                var uploadedValue = one.uploadedValue;
                if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
                    WebGL.mainContext.uniform2fv(one.location, value);
                    uploadedValue[0] = value[0];
                    uploadedValue[1] = value[1];
                    uploadedValue[2] = value[2];
                    uploadedValue[3] = value[3];
                    return 1;
                }
                return 0;
            }
            else {
                WebGL.mainContext.uniform2fv(one.location, value);
                return 1;
            }
        };
        __proto._uniform_vec3 = function (one, value) {
            if (value != null) {
                var uploadedValue = one.uploadedValue;
                if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2]) {
                    WebGL.mainContext.uniform3f(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2]);
                    return 1;
                }
            }
            return 0;
        };
        __proto._uniform_vec3v = function (one, value) {
            if (value != null)
                WebGL.mainContext.uniform3fv(one.location, value);
            return 1;
        };
        __proto._uniform_vec4 = function (one, value) {
            if (value != null) {
                var uploadedValue = one.uploadedValue;
                if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
                    WebGL.mainContext.uniform4f(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2], uploadedValue[3] = value[3]);
                    return 1;
                }
            }
            return 0;
        };
        __proto._uniform_vec4v = function (one, value) {
            if (value != null)
                WebGL.mainContext.uniform4fv(one.location, value);
            return 1;
        };
        __proto._uniformMatrix2fv = function (one, value) {
            if (value != null)
                WebGL.mainContext.uniformMatrix2fv(one.location, false, value);
            return 1;
        };
        __proto._uniformMatrix3fv = function (one, value) {
            if (value != null)
                WebGL.mainContext.uniformMatrix3fv(one.location, false, value);
            return 1;
        };
        __proto._uniformMatrix4fv = function (one, value) {
            if (value != null)
                WebGL.mainContext.uniformMatrix4fv(one.location, false, value);
            return 1;
        };
        __proto._uniform1i = function (one, value) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== value) {
                WebGL.mainContext.uniform1i(one.location, uploadedValue[0] = value);
                return 1;
            }
            return 0;
        };
        __proto._uniform1iv = function (one, value) {
            WebGL.mainContext.uniform1iv(one.location, value);
            return 1;
        };
        __proto._uniform_ivec2 = function (one, value) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1]) {
                WebGL.mainContext.uniform2i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1]);
                return 1;
            }
            return 0;
        };
        __proto._uniform_ivec2v = function (one, value) {
            WebGL.mainContext.uniform2iv(one.location, value);
            return 1;
        };
        __proto._uniform_vec3i = function (one, value) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2]) {
                WebGL.mainContext.uniform3i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2]);
                return 1;
            }
            return 0;
        };
        __proto._uniform_vec3vi = function (one, value) {
            WebGL.mainContext.uniform3iv(one.location, value);
            return 1;
        };
        __proto._uniform_vec4i = function (one, value) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
                WebGL.mainContext.uniform4i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2], uploadedValue[3] = value[3]);
                return 1;
            }
            return 0;
        };
        __proto._uniform_vec4vi = function (one, value) {
            WebGL.mainContext.uniform4iv(one.location, value);
            return 1;
        };
        __proto._uniform_sampler2D = function (one, value) {
            var gl = WebGL.mainContext;
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] == null) {
                uploadedValue[0] = this._curActTexIndex;
                gl.uniform1i(one.location, this._curActTexIndex);
                gl.activeTexture(Shader._TEXTURES[this._curActTexIndex]);
                WebGLContext.bindTexture(gl, 0x0DE1, value);
                this._curActTexIndex++;
                return 1;
            }
            else {
                gl.activeTexture(Shader._TEXTURES[uploadedValue[0]]);
                WebGLContext.bindTexture(gl, 0x0DE1, value);
                return 0;
            }
        };
        __proto._uniform_samplerCube = function (one, value) {
            var gl = WebGL.mainContext;
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] == null) {
                uploadedValue[0] = this._curActTexIndex;
                gl.uniform1i(one.location, this._curActTexIndex);
                gl.activeTexture(Shader._TEXTURES[this._curActTexIndex]);
                WebGLContext.bindTexture(gl, 0x8513, value);
                this._curActTexIndex++;
                return 1;
            }
            else {
                gl.activeTexture(Shader._TEXTURES[uploadedValue[0]]);
                WebGLContext.bindTexture(gl, 0x8513, value);
                return 0;
            }
        };
        __proto._noSetValue = function (one) {
            console_log("no....:" + one.name);
        };
        __proto.uploadOne = function (name, value) {
            this.activeResource();
            WebGLContext.UseProgram(this._program);
            var one = this._paramsMap[name];
            one.fun.call(this, one, value);
        };
        __proto.uploadTexture2D = function (value) {
            Stat.shaderCall++;
            var gl = WebGL.mainContext;
            gl.activeTexture(0x84C0);
            WebGLContext.bindTexture(gl, 0x0DE1, value);
        };
        __proto.upload = function (shaderValue, params) {
            BaseShader.activeShader = BaseShader.bindShader = this;
            this._lastUseFrameCount === Stat.loopCount || this.activeResource();
            WebGLContext.UseProgram(this._program);
            if (this._reCompile) {
                params = this._params;
                this._reCompile = false;
            }
            else {
                params = params || this._params;
            }
            ;
            var gl = WebGL.mainContext;
            var one, value, n = params.length, shaderCall = 0;
            for (var i = 0; i < n; i++) {
                one = params[i];
                if ((value = shaderValue[one.name]) !== null)
                    shaderCall += one.fun.call(this, one, value);
            }
            Stat.shaderCall += shaderCall;
        };
        __proto.uploadArray = function (shaderValue, length, _bufferUsage) {
            BaseShader.activeShader = this;
            BaseShader.bindShader = this;
            this.activeResource();
            WebGLContext.UseProgram(this._program);
            var params = this._params, value;
            var one, shaderCall = 0;
            for (var i = length - 2; i >= 0; i -= 2) {
                one = this._paramsMap[shaderValue[i]];
                if (!one)
                    continue;
                value = shaderValue[i + 1];
                if (value != null) {
                    _bufferUsage && _bufferUsage[one.name] && _bufferUsage[one.name].bind();
                    shaderCall += one.fun.call(this, one, value);
                }
            }
            Stat.shaderCall += shaderCall;
        };
        __proto.getParams = function () {
            return this._params;
        };
        Shader.getShader = function (name) {
            return Shader.sharders[name];
        };
        Shader.create = function (vs, ps, saveName, nameMap) {
            return new Shader(vs, ps, saveName, nameMap);
        };
        Shader.withCompile = function (nameID, define, shaderName, createShader) {
            if (shaderName && Shader.sharders[shaderName])
                return Shader.sharders[shaderName];
            var pre = Shader._preCompileShader[0.0002 * nameID];
            if (!pre)
                throw new Error("withCompile shader err!" + nameID);
            return pre.createShader(define, shaderName, createShader);
        };
        Shader.withCompile2D = function (nameID, mainID, define, shaderName, createShader, kdsSetMaterialMacrosID) {
            // 创建
            // var sd = ShaderValue.kdsMaterialShaders[kdsSetMaterialMacrosID]
            // if(sd)return sd;
            // if(ShaderValue){}
            // return 
            if (!kdsSetMaterialMacrosID && shaderName && Shader.sharders[shaderName])
                return Shader.sharders[shaderName];
            var pre = Shader._preCompileShader[0.0002 * nameID + mainID];
            if (!pre)
                throw new Error("withCompile shader err!" + nameID + " " + mainID);
            return pre.createShader(define, shaderName, createShader);
        };
        Shader.addInclude = function (fileName, txt, force) {
            ShaderCompile.addInclude(fileName, txt, force);
        };
        Shader.preCompile = function (nameID, vs, ps, nameMap) {
            var id = 0.0002 * nameID;
            Shader._preCompileShader[id] = new ShaderCompile(id, vs, ps, nameMap);
        };
        Shader.preCompile2D = function (nameID, mainID, vs, ps, nameMap) {
            var id = 0.0002 * nameID + mainID;
            Shader._preCompileShader[id] = new ShaderCompile(id, vs, ps, nameMap);
        };
        Shader._createShader = function (gl, str, type) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, str);
            gl.compileShader(shader);
            return shader;
        };
        Shader._TEXTURES = [0x84C0, 0x84C1, 0x84C2, 0x84C3, 0x84C4, 0x84C5, 0x84C6, , 0x84C7, 0x84C8];
        Shader._count = 0;
        Shader._preCompileShader = {};
        Shader.SHADERNAME2ID = 0.0002;
        Shader.sharders = (Shader.sharders = [], Shader.sharders.length = 0x20, Shader.sharders);
        __static(Shader, ['nameKey', function () { return this.nameKey = new StringKey(); }
        ]);
        return Shader;
    })(BaseShader);
    var Buffer2D = (function (_super) {
        function Buffer2D() {
            this._maxsize = 0;
            this._upload = true;
            this._uploadSize = 0;
            Buffer2D.__super.call(this);
            this.lock = true;
        }
        __class(Buffer2D, 'laya.webgl.utils.Buffer2D', _super);
        var __proto = Buffer2D.prototype;
        __proto.needSize = function (sz) {
            var old = this._byteLength;
            if (sz) {
                var needsz = this._byteLength + sz;
                needsz <= this._buffer.byteLength || (this._resizeBuffer(needsz << 1, true));
                this._byteLength = needsz;
            }
            return old;
        };
        __proto._bufferData = function () {
            this._maxsize = Math.max(this._maxsize, this._byteLength);
            if (Stat.loopCount % 30 == 0) {
                if (this._buffer.byteLength > (this._maxsize + 64)) {
                    this.memorySize = this._buffer.byteLength;
                    this._buffer = this._buffer.slice(0, this._maxsize + 64);
                    this._checkArrayUse();
                }
                this._maxsize = this._byteLength;
            }
            if (this._uploadSize < this._buffer.byteLength) {
                this._uploadSize = this._buffer.byteLength;
                Buffer._gl.bufferData(this._bufferType, this._uploadSize, this._bufferUsage);
                this.memorySize = this._uploadSize;
            }
            Buffer._gl.bufferSubData(this._bufferType, 0, this._buffer);
        };
        __proto._bufferSubData = function (offset, dataStart, dataLength) {
            (offset === void 0) && (offset = 0);
            (dataStart === void 0) && (dataStart = 0);
            (dataLength === void 0) && (dataLength = 0);
            this._maxsize = Math.max(this._maxsize, this._byteLength);
            if (Stat.loopCount % 30 == 0) {
                if (this._buffer.byteLength > (this._maxsize + 64)) {
                    this.memorySize = this._buffer.byteLength;
                    this._buffer = this._buffer.slice(0, this._maxsize + 64);
                    this._checkArrayUse();
                }
                this._maxsize = this._byteLength;
            }
            if (this._uploadSize < this._buffer.byteLength) {
                this._uploadSize = this._buffer.byteLength;
                Buffer._gl.bufferData(this._bufferType, this._uploadSize, this._bufferUsage);
                this.memorySize = this._uploadSize;
            }
            if (dataStart || dataLength) {
                var subBuffer = this._buffer.slice(dataStart, dataLength);
                Buffer._gl.bufferSubData(this._bufferType, offset, subBuffer);
            }
            else {
                Buffer._gl.bufferSubData(this._bufferType, offset, this._buffer);
            }
        };
        __proto._checkArrayUse = function () { };
        __proto._bind_upload = function () {
            if (!this._upload)
                return false;
            this._upload = false;
            this._bind();
            this._bufferData();
            return true;
        };
        __proto._bind_subUpload = function (offset, dataStart, dataLength) {
            (offset === void 0) && (offset = 0);
            (dataStart === void 0) && (dataStart = 0);
            (dataLength === void 0) && (dataLength = 0);
            if (!this._upload)
                return false;
            this._upload = false;
            this._bind();
            this._bufferSubData(offset, dataStart, dataLength);
            return true;
        };
        __proto._resizeBuffer = function (nsz, copy) {
            if (nsz < this._buffer.byteLength)
                return this;
            this.memorySize = nsz;
            if (copy && this._buffer && this._buffer.byteLength > 0) {
                var newbuffer = new ArrayBuffer(nsz);
                var n = new Uint8Array(newbuffer);
                n.set(new Uint8Array(this._buffer), 0);
                this._buffer = newbuffer;
            }
            else
                this._buffer = new ArrayBuffer(nsz);
            this._checkArrayUse();
            this._upload = true;
            return this;
        };
        __proto.append = function (data) {
            this._upload = true;
            var byteLen = 0, n;
            byteLen = data.byteLength;
            if ((data instanceof Uint8Array)) {
                this._resizeBuffer(this._byteLength + byteLen, true);
                n = new Uint8Array(this._buffer, this._byteLength);
            }
            else if ((data instanceof Uint16Array)) {
                this._resizeBuffer(this._byteLength + byteLen, true);
                n = new Uint16Array(this._buffer, this._byteLength);
            }
            else if ((data instanceof Float32Array)) {
                this._resizeBuffer(this._byteLength + byteLen, true);
                n = new Float32Array(this._buffer, this._byteLength);
            }
            n.set(data, 0);
            this._byteLength += byteLen;
            this._checkArrayUse();
        };
        __proto.appendU16Array = function (data, len) {
            this._resizeBuffer(this._byteLength + len * 2, true);
            var u = new Uint16Array(this._buffer, this._byteLength, len);
            for (var i = 0; i < len; i++) {
                u[i] = data[i];
            }
            this._byteLength += len * 2;
            this._checkArrayUse();
        };
        __proto.appendEx = function (data, type) {
            this._upload = true;
            var byteLen = 0, n;
            byteLen = data.byteLength;
            this._resizeBuffer(this._byteLength + byteLen, true);
            n = new type(this._buffer, this._byteLength);
            n.set(data, 0);
            this._byteLength += byteLen;
            this._checkArrayUse();
        };
        __proto.appendEx2 = function (data, type, dataLen, perDataLen) {
            (perDataLen === void 0) && (perDataLen = 1);
            this._upload = true;
            var byteLen = 0, n;
            byteLen = dataLen * perDataLen;
            this._resizeBuffer(this._byteLength + byteLen, true);
            n = new type(this._buffer, this._byteLength);
            var i = 0;
            for (i = 0; i < dataLen; i++) {
                n[i] = data[i];
            }
            this._byteLength += byteLen;
            this._checkArrayUse();
        };
        __proto.getBuffer = function () {
            return this._buffer;
        };
        __proto.setNeedUpload = function () {
            this._upload = true;
        };
        __proto.getNeedUpload = function () {
            return this._upload;
        };
        __proto.upload = function () {
            var scuess = this._bind_upload();
            Buffer._gl.bindBuffer(this._bufferType, null);
            Buffer._bindActive[this._bufferType] = null;
            BaseShader.activeShader = null;
            return scuess;
        };
        __proto.subUpload = function (offset, dataStart, dataLength) {
            (offset === void 0) && (offset = 0);
            (dataStart === void 0) && (dataStart = 0);
            (dataLength === void 0) && (dataLength = 0);
            var scuess = this._bind_subUpload();
            Buffer._gl.bindBuffer(this._bufferType, null);
            Buffer._bindActive[this._bufferType] = null;
            BaseShader.activeShader = null;
            return scuess;
        };
        __proto.disposeResource = function () {
            _super.prototype.disposeResource.call(this);
            this._upload = true;
            this._uploadSize = 0;
        };
        __proto.clear = function () {
            this._byteLength = 0;
            this._upload = true;
        };
        __getset(0, __proto, 'bufferLength', function () {
            return this._buffer.byteLength;
        });
        __getset(0, __proto, 'byteLength', null, function (value) {
            if (this._byteLength === value)
                return;
            value <= this._buffer.byteLength || (this._resizeBuffer(value * 2 + 256, true));
            this._byteLength = value;
        });
        Buffer2D.__int__ = function (gl) {
            IndexBuffer2D.QuadrangleIB = IndexBuffer2D.create(0x88E4);
            GlUtils.fillIBQuadrangle(IndexBuffer2D.QuadrangleIB, 16);
        };
        Buffer2D.FLOAT32 = 4;
        Buffer2D.SHORT = 2;
        return Buffer2D;
    })(Buffer);
    var GlowSV = (function (_super) {
        function GlowSV(args) {
            this.u_blurX = false;
            this.u_color = null;
            this.u_offset = null;
            this.u_strength = NaN;
            this.u_texW = 0;
            this.u_texH = 0;
            GlowSV.__super.call(this, 0x08 | 0x01);
        }
        __class(GlowSV, 'laya.webgl.shader.d2.value.GlowSV', _super);
        var __proto = GlowSV.prototype;
        __proto.setValue = function (vo) {
            _super.prototype.setValue.call(this, vo);
        };
        __proto.clear = function () {
            _super.prototype.clear.call(this);
        };
        return GlowSV;
    })(TextureSV);
    var TextSV = (function (_super) {
        function TextSV(args) {
            TextSV.__super.call(this, 0x40);
            this.defines.add(0x40);
        }
        __class(TextSV, 'laya.webgl.shader.d2.value.TextSV', _super);
        var __proto = TextSV.prototype;
        __proto.release = function () {
            TextSV.pool[TextSV._length++] = this;
            this.clear();
        };
        __proto.clear = function () {
            _super.prototype.clear.call(this);
        };
        TextSV.create = function () {
            if (TextSV._length)
                return TextSV.pool[--TextSV._length];
            else
                return new TextSV(null);
        };
        TextSV.pool = [];
        TextSV._length = 0;
        return TextSV;
    })(TextureSV);
    var Shader2X = (function (_super) {
        function Shader2X(vs, ps, saveName, nameMap) {
            this._params2dQuick1 = null;
            this._params2dQuick2 = null;
            this._shaderValueWidth = NaN;
            this._shaderValueHeight = NaN;
            Shader2X.__super.call(this, vs, ps, saveName, nameMap);
        }
        __class(Shader2X, 'laya.webgl.shader.d2.Shader2X', _super);
        var __proto = Shader2X.prototype;
        __proto.upload2dQuick1 = function (shaderValue) {
            this.upload(shaderValue, this._params2dQuick1 || this._make2dQuick1());
        };
        __proto._make2dQuick1 = function () {
            if (!this._params2dQuick1) {
                this.activeResource();
                this._params2dQuick1 = [];
                var params = this._params, one;
                for (var i = 0, n = params.length; i < n; i++) {
                    one = params[i];
                    if (!Render.isFlash && (one.name === "size" || one.name === "position" || one.name === "texcoord"))
                        continue;
                    this._params2dQuick1.push(one);
                }
            }
            return this._params2dQuick1;
        };
        __proto.disposeResource = function () {
            _super.prototype.disposeResource.call(this);
            this._params2dQuick1 = null;
            this._params2dQuick2 = null;
        };
        __proto.upload2dQuick2 = function (shaderValue) {
            this.upload(shaderValue, this._params2dQuick2 || this._make2dQuick2());
        };
        __proto._make2dQuick2 = function () {
            if (!this._params2dQuick2) {
                this.activeResource();
                this._params2dQuick2 = [];
                var params = this._params, one;
                for (var i = 0, n = params.length; i < n; i++) {
                    one = params[i];
                    if (!Render.isFlash && (one.name === "size"))
                        continue;
                    this._params2dQuick2.push(one);
                }
            }
            return this._params2dQuick2;
        };
        Shader2X.create = function (vs, ps, saveName, nameMap) {
            return new Shader2X(vs, ps, saveName, nameMap);
        };
        return Shader2X;
    })(Shader);
    var IndexBuffer2D = (function (_super) {
        function IndexBuffer2D(bufferUsage) {
            this._uint8Array = null;
            this._uint16Array = null;
            (bufferUsage === void 0) && (bufferUsage = 0x88E4);
            IndexBuffer2D.__super.call(this);
            this._bufferUsage = bufferUsage;
            this._bufferType = 0x8893;
            Render.isFlash || (this._buffer = new ArrayBuffer(8));
        }
        __class(IndexBuffer2D, 'laya.webgl.utils.IndexBuffer2D', _super);
        var __proto = IndexBuffer2D.prototype;
        __proto._checkArrayUse = function () {
            this._uint8Array && (this._uint8Array = new Uint8Array(this._buffer));
            this._uint16Array && (this._uint16Array = new Uint16Array(this._buffer));
        };
        __proto.getUint8Array = function () {
            return this._uint8Array || (this._uint8Array = new Uint8Array(this._buffer));
        };
        __proto.getUint16Array = function () {
            return this._uint16Array || (this._uint16Array = new Uint16Array(this._buffer));
        };
        __proto.destory = function () {
            this._uint16Array = null;
            this._uint8Array = null;
            this._buffer = null;
        };
        IndexBuffer2D.QuadrangleIB = null;
        IndexBuffer2D.create = function (bufferUsage) {
            (bufferUsage === void 0) && (bufferUsage = 0x88E4);
            return new IndexBuffer2D(bufferUsage);
        };
        return IndexBuffer2D;
    })(Buffer2D);
    var VertexBuffer2D = (function (_super) {
        function VertexBuffer2D(vertexStride, bufferUsage) {
            this._floatArray32 = null;
            this._vertexStride = 0;
            VertexBuffer2D.__super.call(this);
            this._vertexStride = vertexStride;
            this._bufferUsage = bufferUsage;
            this._bufferType = 0x8892;
            Render.isFlash || (this._buffer = new ArrayBuffer(8));
            this.getFloat32Array();
        }
        __class(VertexBuffer2D, 'laya.webgl.utils.VertexBuffer2D', _super);
        var __proto = VertexBuffer2D.prototype;
        __proto.getFloat32Array = function () {
            return this._floatArray32 || (this._floatArray32 = new Float32Array(this._buffer));
        };
        __proto.bind = function (ibBuffer) {
            (ibBuffer) && (ibBuffer._bind());
            this._bind();
        };
        __proto.insertData = function (data, pos) {
            var vbdata = this.getFloat32Array();
            vbdata.set(data, pos);
            this._upload = true;
        };
        __proto.bind_upload = function (ibBuffer) {
            (ibBuffer._bind_upload()) || (ibBuffer._bind());
            (this._bind_upload()) || (this._bind());
        };
        __proto._checkArrayUse = function () {
            this._floatArray32 && (this._floatArray32 = new Float32Array(this._buffer));
        };
        __proto.disposeResource = function () {
            _super.prototype.disposeResource.call(this);
            var enableAtributes = Buffer._enableAtributes;
            for (var i = 0; i < 10; i++) {
                WebGL.mainContext.disableVertexAttribArray(i);
                enableAtributes[i] = null;
            }
        };
        __proto.destory = function () {
            this._byteLength = 0;
            this._upload = true;
            this._buffer = null;
            this._floatArray32 = null;
        };
        __getset(0, __proto, 'vertexStride', function () {
            return this._vertexStride;
        });
        VertexBuffer2D.create = function (vertexStride, bufferUsage) {
            (bufferUsage === void 0) && (bufferUsage = 0x88E8);
            return new VertexBuffer2D(vertexStride, bufferUsage);
        };
        return VertexBuffer2D;
    })(Buffer2D);
    var WebGLImage = (function (_super) {
        function WebGLImage(data, def, format, mipmap) {
            this._format = 0;
            this._mipmap = false;
            this._allowMerageInAtlas = false;
            this._enableMerageInAtlas = false;
            this.repeat = false;
            this._image = null;
            this.minFifter = 0;
            this.magFifter = 0;
            (format === void 0) && (format = 0x1908);
            (mipmap === void 0) && (mipmap = true);
            WebGLImage.__super.call(this, data, def);
            this._format = format;
            this._mipmap = mipmap;
            this.repeat = false;
            this.minFifter = -1;
            this.magFifter = -1;
            if ((typeof data == 'string')) {
                this._url = data;
                this._src = data;
                this._image = new Browser.window.Image();
                if (def) {
                    def.onload && (this.onload = def.onload);
                    def.onerror && (this.onerror = def.onerror);
                    def.onCreate && def.onCreate(this);
                }
                this._image.crossOrigin = (data && (data.indexOf("data:") == 0)) ? null : "";
                (data) && (this._image.src = data);
            }
            else if ((data instanceof ArrayBuffer)) {
                this._src = def;
                this._url = this._src;
                var readData = new Byte(data);
                var magicNumber = readData.readUTFBytes(4);
                var version = readData.readUTFBytes(2);
                var dataType = readData.getInt16();
                readData.endian = "bigEndian";
                this._w = readData.getInt16();
                this._h = readData.getInt16();
                var originalWidth = readData.getInt16();
                var originalHeight = readData.getInt16();
                this._image = new Uint8Array(data, readData.pos);
                this._format = WebGL.compressEtc1.COMPRESSED_RGB_ETC1_WEBGL;
                (AtlasResourceManager.enabled) && (this._w < AtlasResourceManager.atlasLimitWidth && this._h < AtlasResourceManager.atlasLimitHeight) ? this._allowMerageInAtlas = true : this._allowMerageInAtlas = false;
            }
            else {
                this._src = def;
                this._url = this._src;
                this._image = data["source"] || data;
                this.onresize();
            }
            this._$5__enableMerageInAtlas = true;
        }
        __class(WebGLImage, 'laya.webgl.resource.WebGLImage', _super);
        var __proto = WebGLImage.prototype;
        Laya.imps(__proto, { "laya.webgl.resource.IMergeAtlasBitmap": true });
        __proto._init_ = function (src, def) { };
        __proto._createWebGlTexture = function () {
            if (!this._image) {
                throw "create GLTextur err:no data:" + this._image;
            }
            var gl = WebGL.mainContext;
            var glTex = this._source = gl.createTexture();
            var preTarget = WebGLContext.curBindTexTarget;
            var preTexture = WebGLContext.curBindTexValue;
            WebGLContext.bindTexture(gl, 0x0DE1, glTex);
            gl.pixelStorei(0x9241, true);
            switch (this._format) {
                case 0x1908:
                    gl.texImage2D(0x0DE1, 0, this._format, 0x1908, 0x1401, this._image);
                    break;
                case WebGL.compressEtc1.COMPRESSED_RGB_ETC1_WEBGL:
                    gl.compressedTexImage2D(0x0DE1, 0, this._format, this._w, this._h, 0, this._image);
                    break;
            }
            gl.pixelStorei(0x9241, false);
            var minFifter = this.minFifter;
            var magFifter = this.magFifter;
            var repeat = this.repeat ? 0x2901 : 0x812F;
            var isPot = Arith.isPOT(this._w, this._h);
            if (isPot) {
                if (this.mipmap)
                    (minFifter !== -1) || (minFifter = 0x2703);
                else
                    (minFifter !== -1) || (minFifter = 0x2601);
                (magFifter !== -1) || (magFifter = 0x2601);
                gl.texParameteri(0x0DE1, 0x2801, minFifter);
                gl.texParameteri(0x0DE1, 0x2800, magFifter);
                gl.texParameteri(0x0DE1, 0x2802, repeat);
                gl.texParameteri(0x0DE1, 0x2803, repeat);
                this.mipmap && gl.generateMipmap(0x0DE1);
            }
            else {
                (minFifter !== -1) || (minFifter = 0x2601);
                (magFifter !== -1) || (magFifter = 0x2601);
                gl.texParameteri(0x0DE1, 0x2801, minFifter);
                gl.texParameteri(0x0DE1, 0x2800, magFifter);
                gl.texParameteri(0x0DE1, 0x2802, 0x812F);
                gl.texParameteri(0x0DE1, 0x2803, 0x812F);
            }
            (preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
            this._image.onload = null;
            this._image = null;
            if (isPot && this.mipmap)
                this.memorySize = this._w * this._h * 4 * (1 + 1 / 3);
            else
                this.memorySize = this._w * this._h * 4;
            this._recreateLock = false;
        };
        __proto.recreateResource = function () {
            var _$this = this;
            if (this._src == null || this._src === "")
                return;
            this._needReleaseAgain = false;
            if (!this._image) {
                this._recreateLock = true;
                var _this = this;
                this._image = new Browser.window.Image();
                this._image.crossOrigin = this._src.indexOf("data:") == 0 ? null : "";
                this._image.onload = function () {
                    if (_this._needReleaseAgain) {
                        _this._needReleaseAgain = false;
                        _this._image.onload = null;
                        _this._image = null;
                        return;
                    }
                    (!(_this._allowMerageInAtlas && _this._enableMerageInAtlas)) ? (_this._createWebGlTexture()) : (_$this.memorySize = 0, _$this._recreateLock = false);
                    _this.completeCreate();
                };
                this._image.src = this._src;
            }
            else {
                if (this._recreateLock) {
                    return;
                }
                (!(this._allowMerageInAtlas && this._$5__enableMerageInAtlas)) ? (this._createWebGlTexture()) : (this.memorySize = 0, this._recreateLock = false);
                this.completeCreate();
            }
        };
        __proto.disposeResource = function () {
            if (this._recreateLock) {
                this._needReleaseAgain = true;
            }
            if (this._source) {
                WebGL.mainContext.deleteTexture(this._source);
                this._source = null;
                this._image = null;
                this.memorySize = 0;
            }
        };
        __proto.onresize = function () {
            this._w = this._image.width;
            this._h = this._image.height;
            (AtlasResourceManager.enabled) && (this._w < AtlasResourceManager.atlasLimitWidth && this._h < AtlasResourceManager.atlasLimitHeight) ? this._allowMerageInAtlas = true : this._allowMerageInAtlas = false;
        };
        __proto.clearAtlasSource = function () {
            this._image = null;
        };
        __getset(0, __proto, 'format', function () {
            return this._format;
        });
        __getset(0, __proto, 'enableMerageInAtlas', function () {
            return this._$5__enableMerageInAtlas;
        }, function (value) {
            this._$5__enableMerageInAtlas = value;
        });
        __getset(0, __proto, 'mipmap', function () {
            return this._mipmap;
        });
        __getset(0, __proto, 'allowMerageInAtlas', function () {
            return this._allowMerageInAtlas;
        });
        __getset(0, __proto, 'atlasSource', function () {
            return this._image;
        });
        __getset(0, __proto, 'onload', null, function (value) {
            var _$this = this;
            this._onload = value;
            this._image && (this._image.onload = this._onload != null ? (function () {
                _$this.onresize();
                _$this._onload();
            }) : null);
        });
        __getset(0, __proto, 'onerror', null, function (value) {
            var _$this = this;
            this._onerror = value;
            this._image && (this._image.onerror = this._onerror != null ? (function () {
                _$this._onerror();
            }) : null);
        });
        return WebGLImage;
    })(HTMLImage);
    Laya.__init([DrawText, AtlasGrid, WebGLContext2D, ShaderCompile]);
})(window, document, Laya);
if (typeof define === 'function' && define.amd) {
    define('laya.core', ['require', "exports"], function (require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
            var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    var Animation = laya.display.Animation, Browser = laya.utils.Browser, ClassUtils = laya.utils.ClassUtils, ColorFilter = laya.filters.ColorFilter;
    var Ease = laya.utils.Ease, Event = laya.events.Event, EventDispatcher = laya.events.EventDispatcher, Font = laya.display.css.Font;
    var FrameAnimation = laya.display.FrameAnimation, Graphics = laya.display.Graphics, Handler = laya.utils.Handler;
    var Input = laya.display.Input, Loader = laya.net.Loader, Node = laya.display.Node, Point = laya.maths.Point, Rectangle = laya.maths.Rectangle;
    var Render = laya.renders.Render, Sprite = laya.display.Sprite, Text = laya.display.Text, Texture = laya.resource.Texture;
    var Tween = laya.utils.Tween, Utils = laya.utils.Utils, WeakObject = laya.utils.WeakObject;
    Laya.interface('laya.ui.IItem');
    Laya.interface('laya.ui.ISelect');
    Laya.interface('laya.ui.IRender');
    Laya.interface('laya.ui.IComponent');
    Laya.interface('laya.ui.IBox', 'IComponent');
    var LayoutStyle = (function () {
        function LayoutStyle() {
            this.enable = false;
            this.top = NaN;
            this.bottom = NaN;
            this.left = NaN;
            this.right = NaN;
            this.centerX = NaN;
            this.centerY = NaN;
            this.anchorX = NaN;
            this.anchorY = NaN;
        }
        __class(LayoutStyle, 'laya.ui.LayoutStyle');
        __static(LayoutStyle, ['EMPTY', function () { return this.EMPTY = new LayoutStyle(); }
        ]);
        return LayoutStyle;
    })();
    var Styles = (function () {
        function Styles() { }
        __class(Styles, 'laya.ui.Styles');
        Styles.labelColor = "#000000";
        Styles.buttonStateNum = 3;
        Styles.scrollBarMinNum = 15;
        Styles.scrollBarDelayTime = 500;
        __static(Styles, ['defaultSizeGrid', function () { return this.defaultSizeGrid = [4, 4, 4, 4, 0]; }, 'labelPadding', function () { return this.labelPadding = [2, 2, 2, 2]; }, 'inputLabelPadding', function () { return this.inputLabelPadding = [1, 1, 1, 3]; }, 'buttonLabelColors', function () { return this.buttonLabelColors = ["#32556b", "#32cc6b", "#ff0000", "#C0C0C0"]; }, 'comboBoxItemColors', function () { return this.comboBoxItemColors = ["#5e95b6", "#ffffff", "#000000", "#8fa4b1", "#ffffff"]; }
        ]);
        return Styles;
    })();
    var UIUtils = (function () {
        function UIUtils() { }
        __class(UIUtils, 'laya.ui.UIUtils');
        UIUtils.fillArray = function (arr, str, type) {
            var temp = arr.concat();
            if (str) {
                var a = str.split(",");
                for (var i = 0, n = Math.min(temp.length, a.length); i < n; i++) {
                    var value = a[i];
                    temp[i] = (value == "true" ? true : (value == "false" ? false : value));
                    if (type != null)
                        temp[i] = type(value);
                }
            }
            return temp;
        };
        UIUtils.toColor = function (color) {
            return Utils.toHexColor(color);
        };
        UIUtils.gray = function (traget, isGray) {
            (isGray === void 0) && (isGray = true);
            if (isGray) {
                UIUtils.addFilter(traget, UIUtils.grayFilter);
            }
            else {
                UIUtils.clearFilter(traget, ColorFilter);
            }
        };
        UIUtils.addFilter = function (target, filter) {
            var filters = target.filters || [];
            filters.push(filter);
            target.filters = filters;
        };
        UIUtils.clearFilter = function (target, filterType) {
            var filters = target.filters;
            if (filters != null && filters.length > 0) {
                for (var i = filters.length - 1; i > -1; i--) {
                    var filter = filters[i];
                    if (Laya.__typeof(filter, filterType))
                        filters.splice(i, 1);
                }
                target.filters = filters;
            }
        };
        UIUtils._getReplaceStr = function (word) {
            return UIUtils.escapeSequence[word];
        };
        UIUtils.adptString = function (str) {
            return str.replace(/\\(\w)/g, UIUtils._getReplaceStr);
        };
        UIUtils.getBindFun = function (value) {
            var fun = UIUtils._funMap.get(value);
            if (fun == null) {
                var temp = "\"" + value + "\"";
                temp = temp.replace(/^"\${|}"$/g, "").replace(/\${/g, "\"+").replace(/}/g, "+\"");
                var str = "(function(data){if(data==null)return;with(data){try{\nreturn " + temp + "\n}catch(e){}}})";
                fun = Browser.window.eval(str);
                UIUtils._funMap.set(value, fun);
            }
            return fun;
        };
        __static(UIUtils, ['grayFilter', function () { return this.grayFilter = new ColorFilter([0.3086, 0.6094, 0.082, 0, 0, 0.3086, 0.6094, 0.082, 0, 0, 0.3086, 0.6094, 0.082, 0, 0, 0, 0, 0, 1, 0]); }, 'escapeSequence', function () { return this.escapeSequence = { "\\n": "\n", "\\t": "\t" }; }, '_funMap', function () { return this._funMap = new WeakObject(); }
        ]);
        return UIUtils;
    })();
    var UIConfig = (function () {
        function UIConfig() { }
        __class(UIConfig, 'UIConfig');
        UIConfig.touchScrollEnable = true;
        UIConfig.mouseWheelEnable = true;
        UIConfig.showButtons = true;
        UIConfig.popupBgColor = "#000000";
        UIConfig.popupBgAlpha = 0.5;
        UIConfig.closeDialogOnSide = true;
        return UIConfig;
    })();
    var AutoBitmap = (function (_super) {
        function AutoBitmap() {
            this.autoCacheCmd = true;
            this._width = 0;
            this._height = 0;
            this._source = null;
            this._sizeGrid = null;
            this._isChanged = false;
            this._offset = null;
            AutoBitmap.__super.call(this);
        }
        __class(AutoBitmap, 'laya.ui.AutoBitmap', _super);
        var __proto = AutoBitmap.prototype;
        __proto.destroy = function () {
            _super.prototype.destroy.call(this);
            this._source = null;
            this._sizeGrid = null;
            this._offset = null;
        };
        __proto._setChanged = function () {
            if (!this._isChanged) {
                this._isChanged = true;
                Laya.timer.callLater(this, this.changeSource);
            }
        };
        __proto.changeSource = function () {
            this._isChanged = false;
            var source = this._source;
            if (!source || !source.bitmap)
                return;
            var width = this.width;
            var height = this.height;
            var sizeGrid = this._sizeGrid;
            var sw = source.sourceWidth;
            var sh = source.sourceHeight;
            if (!sizeGrid || (sw === width && sh === height)) {
                this.cleanByTexture(source, this._offset ? this._offset[0] : 0, this._offset ? this._offset[1] : 0, width, height);
            }
            else {
                source.$_GID || (source.$_GID = Utils.getGID());
                var key = source.$_GID + "." + width + "." + height + "." + sizeGrid.join(".");
                if (Utils.isOKCmdList(WeakObject.I.get(key))) {
                    this.cmds = WeakObject.I.get(key);
                    return;
                }
                this.clear();
                var top = sizeGrid[0];
                var right = sizeGrid[1];
                var bottom = sizeGrid[2];
                var left = sizeGrid[3];
                var repeat = sizeGrid[4];
                var needClip = false;
                if (width == sw) {
                    left = right = 0;
                }
                if (height == sh) {
                    top = bottom = 0;
                }
                if (left + right > width) {
                    var clipWidth = width;
                    needClip = true;
                    width = left + right;
                    this.save();
                    this.clipRect(0, 0, clipWidth, height);
                }
                left && top && this.drawTexture(AutoBitmap.getTexture(source, 0, 0, left, top), 0, 0, left, top);
                right && top && this.drawTexture(AutoBitmap.getTexture(source, sw - right, 0, right, top), width - right, 0, right, top);
                left && bottom && this.drawTexture(AutoBitmap.getTexture(source, 0, sh - bottom, left, bottom), 0, height - bottom, left, bottom);
                right && bottom && this.drawTexture(AutoBitmap.getTexture(source, sw - right, sh - bottom, right, bottom), width - right, height - bottom, right, bottom);
                top && this.drawBitmap(repeat, AutoBitmap.getTexture(source, left, 0, sw - left - right, top), left, 0, width - left - right, top);
                bottom && this.drawBitmap(repeat, AutoBitmap.getTexture(source, left, sh - bottom, sw - left - right, bottom), left, height - bottom, width - left - right, bottom);
                left && this.drawBitmap(repeat, AutoBitmap.getTexture(source, 0, top, left, sh - top - bottom), 0, top, left, height - top - bottom);
                right && this.drawBitmap(repeat, AutoBitmap.getTexture(source, sw - right, top, right, sh - top - bottom), width - right, top, right, height - top - bottom);
                this.drawBitmap(repeat, AutoBitmap.getTexture(source, left, top, sw - left - right, sh - top - bottom), left, top, width - left - right, height - top - bottom);
                if (needClip)
                    this.restore();
                if (this.autoCacheCmd && !Render.isConchApp)
                    WeakObject.I.set(key, this.cmds);
            }
            this._repaint();
        };
        __proto.drawBitmap = function (repeat, tex, x, y, width, height) {
            (width === void 0) && (width = 0);
            (height === void 0) && (height = 0);
            if (!tex)
                return;
            if (width < 0.1 || height < 0.1)
                return;
            if (repeat && (tex.width != width || tex.height != height))
                this.fillTexture(tex, x, y, width, height);
            else
                this.drawTexture(tex, x, y, width, height);
        };
        __proto.clear = function (recoverCmds) {
            (recoverCmds === void 0) && (recoverCmds = true);
            _super.prototype.clear.call(this, false);
        };
        __getset(0, __proto, 'sizeGrid', function () {
            return this._sizeGrid;
        }, function (value) {
            this._sizeGrid = value;
            this._setChanged();
        });
        __getset(0, __proto, 'width', function () {
            if (this._width)
                return this._width;
            if (this._source)
                return this._source.sourceWidth;
            return 0;
        }, function (value) {
            if (this._width != value) {
                this._width = value;
                this._setChanged();
            }
        });
        __getset(0, __proto, 'height', function () {
            if (this._height)
                return this._height;
            if (this._source)
                return this._source.sourceHeight;
            return 0;
        }, function (value) {
            if (this._height != value) {
                this._height = value;
                this._setChanged();
            }
        });
        __getset(0, __proto, 'source', function () {
            return this._source;
        }, function (value) {
            if (value) {
                this._source = value;
                this._setChanged();
            }
            else {
                this._source = null;
                this.clear();
            }
        });
        AutoBitmap.getTexture = function (tex, x, y, width, height) {
            if (width <= 0)
                width = 1;
            if (height <= 0)
                height = 1;
            tex.$_GID || (tex.$_GID = Utils.getGID());
            var key = tex.$_GID + "." + x + "." + y + "." + width + "." + height;
            var texture = WeakObject.I.get(key);
            if (!texture || !texture.source) {
                texture = Texture.createFromTexture(tex, x, y, width, height);
                WeakObject.I.set(key, texture);
            }
            return texture;
        };
        return AutoBitmap;
    })(Graphics);
    var UIEvent = (function (_super) {
        function UIEvent() {
            UIEvent.__super.call(this);
            ;
        }
        __class(UIEvent, 'laya.ui.UIEvent', _super);
        UIEvent.SHOW_TIP = "showtip";
        UIEvent.HIDE_TIP = "hidetip";
        return UIEvent;
    })(Event);
    var Component = (function (_super) {
        function Component() {
            this._comXml = null;
            this._dataSource = null;
            this._toolTip = null;
            this._tag = null;
            this._disabled = false;
            this._gray = false;
            this.layoutEnabled = true;
            Component.__super.call(this);
            this._layout = LayoutStyle.EMPTY;
            this.preinitialize();
            this.createChildren();
            this.initialize();
        }
        __class(Component, 'laya.ui.Component', _super);
        var __proto = Component.prototype;
        Laya.imps(__proto, { "laya.ui.IComponent": true });
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._dataSource = this._layout = null;
            this._tag = null;
            this._toolTip = null;
        };
        __proto.preinitialize = function () { };
        __proto.createChildren = function () { };
        __proto.initialize = function () { };
        __proto.callLater = function (method, args) {
            Laya.timer.callLater(this, method, args);
        };
        __proto.runCallLater = function (method) {
            Laya.timer.runCallLater(this, method);
        };
        __proto.commitMeasure = function () { };
        __proto.changeSize = function () {
            this.event("resize");
        };
        __proto.getLayout = function () {
            this._layout === LayoutStyle.EMPTY && (this._layout = new LayoutStyle());
            return this._layout;
        };
        __proto._setLayoutEnabled = function (value) {
            if (this._layout && this._layout.enable != value) {
                this._layout.enable = value;
                this.on("added", this, this.onAdded);
                this.on("removed", this, this.onRemoved);
                if (this.parent) {
                    this.onAdded();
                }
            }
        };
        __proto.onRemoved = function () {
            this.parent.off("resize", this, this.onCompResize);
        };
        __proto.onAdded = function () {
            this.parent.on("resize", this, this.onCompResize);
            this.resetLayoutX();
            this.resetLayoutY();
        };
        __proto.onCompResize = function () {
            if (this._layout && this._layout.enable) {
                this.resetLayoutX();
                this.resetLayoutY();
            }
        };
        __proto.resetLayoutX = function () {
            var layout = this._layout;
            if (!isNaN(layout.anchorX))
                this.pivotX = layout.anchorX * this.width;
            if (!this.layoutEnabled)
                return;
            var parent = this.parent;
            if (parent) {
                if (!isNaN(layout.centerX)) {
                    this.x = Math.round((parent.width - this.displayWidth) * 0.5 + layout.centerX + this.pivotX * this.scaleX);
                }
                else if (!isNaN(layout.left)) {
                    this.x = Math.round(layout.left + this.pivotX * this.scaleX);
                    if (!isNaN(layout.right)) {
                        this.width = (parent._width - layout.left - layout.right) / (this.scaleX || 0.01);
                    }
                }
                else if (!isNaN(layout.right)) {
                    this.x = Math.round(parent.width - this.displayWidth - layout.right + this.pivotX * this.scaleX);
                }
            }
        };
        __proto.resetLayoutY = function () {
            var layout = this._layout;
            if (!isNaN(layout.anchorY))
                this.pivotY = layout.anchorY * this.height;
            if (!this.layoutEnabled)
                return;
            var parent = this.parent;
            if (parent) {
                if (!isNaN(layout.centerY)) {
                    this.y = Math.round((parent.height - this.displayHeight) * 0.5 + layout.centerY + this.pivotY * this.scaleY);
                }
                else if (!isNaN(layout.top)) {
                    this.y = Math.round(layout.top + this.pivotY * this.scaleY);
                    if (!isNaN(layout.bottom)) {
                        this.height = (parent._height - layout.top - layout.bottom) / (this.scaleY || 0.01);
                    }
                }
                else if (!isNaN(layout.bottom)) {
                    this.y = Math.round(parent.height - this.displayHeight - layout.bottom + this.pivotY * this.scaleY);
                }
            }
        };
        __proto.onMouseOver = function (e) {
            Laya.stage.event("showtip", this._toolTip);
        };
        __proto.onMouseOut = function (e) {
            Laya.stage.event("hidetip", this._toolTip);
        };
        __getset(0, __proto, 'displayWidth', function () {
            return this.width * this.scaleX;
        });
        __getset(0, __proto, 'width', function () {
            if (this._width)
                return this._width;
            return this.measureWidth;
        }, function (value) {
            if (this._width != value) {
                this._width = value;
                this.conchModel && this.conchModel.size(this._width, this._height);
                this.callLater(this.changeSize);
                if (this._layout.enable && (!isNaN(this._layout.centerX) || !isNaN(this._layout.right) || !isNaN(this._layout.anchorX)))
                    this.resetLayoutX();
            }
        });
        __getset(0, __proto, 'measureWidth', function () {
            var max = 0;
            this.commitMeasure();
            for (var i = this.numChildren - 1; i > -1; i--) {
                var comp = this.getChildAt(i);
                if (comp.visible) {
                    max = Math.max(comp.x + comp.width * comp.scaleX, max);
                }
            }
            return max;
        });
        __getset(0, __proto, 'displayHeight', function () {
            return this.height * this.scaleY;
        });
        __getset(0, __proto, 'height', function () {
            if (this._height)
                return this._height;
            return this.measureHeight;
        }, function (value) {
            if (this._height != value) {
                this._height = value;
                this.conchModel && this.conchModel.size(this._width, this._height);
                this.callLater(this.changeSize);
                if (this._layout.enable && (!isNaN(this._layout.centerY) || !isNaN(this._layout.bottom) || !isNaN(this._layout.anchorY)))
                    this.resetLayoutY();
            }
        });
        __getset(0, __proto, 'dataSource', function () {
            return this._dataSource;
        }, function (value) {
            this._dataSource = value;
            for (var prop in this._dataSource) {
                if (this.hasOwnProperty(prop) && !((typeof (this[prop]) == 'function'))) {
                    this[prop] = this._dataSource[prop];
                }
            }
        });
        __getset(0, __proto, 'scaleY', _super.prototype._$get_scaleY, function (value) {
            if (Laya.superGet(Sprite, this, 'scaleY') != value) {
                Laya.superSet(Sprite, this, 'scaleY', value);
                this.callLater(this.changeSize);
                this._layout.enable && this.resetLayoutY();
            }
        });
        __getset(0, __proto, 'measureHeight', function () {
            var max = 0;
            this.commitMeasure();
            for (var i = this.numChildren - 1; i > -1; i--) {
                var comp = this.getChildAt(i);
                if (comp.visible) {
                    max = Math.max(comp.y + comp.height * comp.scaleY, max);
                }
            }
            return max;
        });
        __getset(0, __proto, 'scaleX', _super.prototype._$get_scaleX, function (value) {
            if (Laya.superGet(Sprite, this, 'scaleX') != value) {
                Laya.superSet(Sprite, this, 'scaleX', value);
                this.callLater(this.changeSize);
                this._layout.enable && this.resetLayoutX();
            }
        });
        __getset(0, __proto, 'top', function () {
            return this._layout.top;
        }, function (value) {
            if (value != this._layout.top) {
                this.getLayout().top = value;
                this._setLayoutEnabled(true);
            }
            this.resetLayoutY();
        });
        __getset(0, __proto, 'bottom', function () {
            return this._layout.bottom;
        }, function (value) {
            if (value != this._layout.bottom) {
                this.getLayout().bottom = value;
                this._setLayoutEnabled(true);
            }
            this.resetLayoutY();
        });
        __getset(0, __proto, 'left', function () {
            return this._layout.left;
        }, function (value) {
            if (value != this._layout.left) {
                this.getLayout().left = value;
                this._setLayoutEnabled(true);
            }
            this.resetLayoutX();
        });
        __getset(0, __proto, 'right', function () {
            return this._layout.right;
        }, function (value) {
            if (value != this._layout.right) {
                this.getLayout().right = value;
                this._setLayoutEnabled(true);
            }
            this.resetLayoutX();
        });
        __getset(0, __proto, 'centerX', function () {
            return this._layout.centerX;
        }, function (value) {
            if (value != this._layout.centerX) {
                this.getLayout().centerX = value;
                this._setLayoutEnabled(true);
            }
            this.resetLayoutX();
        });
        __getset(0, __proto, 'centerY', function () {
            return this._layout.centerY;
        }, function (value) {
            if (value != this._layout.centerY) {
                this.getLayout().centerY = value;
                this._setLayoutEnabled(true);
            }
            this.resetLayoutY();
        });
        __getset(0, __proto, 'anchorX', function () {
            return this._layout.anchorX;
        }, function (value) {
            if (value != this._layout.anchorX) {
                this.getLayout().anchorX = value;
                this._setLayoutEnabled(true);
            }
            this.resetLayoutX();
        });
        __getset(0, __proto, 'anchorY', function () {
            return this._layout.anchorY;
        }, function (value) {
            if (value != this._layout.anchorY) {
                this.getLayout().anchorY = value;
                this._setLayoutEnabled(true);
            }
            this.resetLayoutY();
        });
        __getset(0, __proto, 'tag', function () {
            return this._tag;
        }, function (value) {
            this._tag = value;
        });
        __getset(0, __proto, 'toolTip', function () {
            return this._toolTip;
        }, function (value) {
            if (this._toolTip != value) {
                this._toolTip = value;
                if (value != null) {
                    this.on("mouseover", this, this.onMouseOver);
                    this.on("mouseout", this, this.onMouseOut);
                }
                else {
                    this.off("mouseover", this, this.onMouseOver);
                    this.off("mouseout", this, this.onMouseOut);
                }
            }
        });
        __getset(0, __proto, 'comXml', function () {
            return this._comXml;
        }, function (value) {
            this._comXml = value;
        });
        __getset(0, __proto, 'gray', function () {
            return this._gray;
        }, function (value) {
            if (value !== this._gray) {
                this._gray = value;
                UIUtils.gray(this, value);
            }
        });
        __getset(0, __proto, 'disabled', function () {
            return this._disabled;
        }, function (value) {
            if (value !== this._disabled) {
                this.gray = this._disabled = value;
                this.mouseEnabled = !value;
            }
        });
        return Component;
    })(Sprite);
    var DialogManager = (function (_super) {
        function DialogManager() {
            this.lockLayer = null;
            this.popupEffect = function (dialog) {
                dialog.scale(1, 1);
                Tween.from(dialog, { x: Laya.stage.width / 2, y: Laya.stage.height / 2, scaleX: 0, scaleY: 0 }, 300, Ease.backOut, Handler.create(this, this.doOpen, [dialog]));
            };
            this.closeEffect = function (dialog, type) {
                Tween.to(dialog, { x: Laya.stage.width / 2, y: Laya.stage.height / 2, scaleX: 0, scaleY: 0 }, 300, Ease.strongOut, Handler.create(this, this.doClose, [dialog, type]));
            };
            DialogManager.__super.call(this);
            this.maskLayer = new Sprite();
            this.popupEffectHandler = new Handler(this, this.popupEffect);
            this.closeEffectHandler = new Handler(this, this.closeEffect);
            this.mouseEnabled = this.maskLayer.mouseEnabled = true;
            this.zOrder = 1000;
            Laya.stage.addChild(this);
            Laya.stage.on("resize", this, this._onResize);
            if (UIConfig.closeDialogOnSide)
                this.maskLayer.on("click", this, this._closeOnSide);
            this._onResize(null);
        }
        __class(DialogManager, 'laya.ui.DialogManager', _super);
        var __proto = DialogManager.prototype;
        __proto._closeOnSide = function () {
            var dialog = this.getChildAt(this.numChildren - 1);
            if ((dialog instanceof laya.ui.Dialog))
                dialog.close("side");
        };
        __proto.setLockView = function (value) {
            if (!this.lockLayer) {
                this.lockLayer = new Box();
                this.lockLayer.mouseEnabled = true;
                this.lockLayer.size(Laya.stage.width, Laya.stage.height);
            }
            this.lockLayer.removeChildren();
            if (value) {
                value.centerX = value.centerY = 0;
                this.lockLayer.addChild(value);
            }
        };
        __proto._onResize = function (e) {
            var width = this.maskLayer.width = Laya.stage.width;
            var height = this.maskLayer.height = Laya.stage.height;
            if (this.lockLayer)
                this.lockLayer.size(width, height);
            this.maskLayer.graphics.clear();
            this.maskLayer.graphics.drawRect(0, 0, width, height, UIConfig.popupBgColor);
            this.maskLayer.alpha = UIConfig.popupBgAlpha;
            for (var i = this.numChildren - 1; i > -1; i--) {
                var item = this.getChildAt(i);
                if (item.popupCenter)
                    this._centerDialog(item);
            }
        };
        __proto._centerDialog = function (dialog) {
            dialog.x = Math.round(((Laya.stage.width - dialog.width) >> 1) + dialog.pivotX);
            dialog.y = Math.round(((Laya.stage.height - dialog.height) >> 1) + dialog.pivotY);
        };
        __proto.open = function (dialog, closeOther, showEffect) {
            (closeOther === void 0) && (closeOther = false);
            (showEffect === void 0) && (showEffect = false);
            if (closeOther)
                this._closeAll();
            if (dialog.popupCenter)
                this._centerDialog(dialog);
            this.addChild(dialog);
            if (dialog.isModal || this._$P["hasZorder"])
                this.timer.callLater(this, this._checkMask);
            if (showEffect && dialog.popupEffect != null)
                dialog.popupEffect.runWith(dialog);
            else
                this.doOpen(dialog);
            this.event("open");
        };
        __proto.doOpen = function (dialog) {
            dialog.onOpened();
        };
        __proto.lock = function (value) {
            if (this.lockLayer) {
                if (value)
                    this.addChild(this.lockLayer);
                else
                    this.lockLayer.removeSelf();
            }
        };
        __proto.close = function (dialog, type, showEffect) {
            (showEffect === void 0) && (showEffect = false);
            if (showEffect && dialog.closeEffect != null)
                dialog.closeEffect.runWith([dialog, type]);
            else
                this.doClose(dialog, type);
            this.event("close");
        };
        __proto.doClose = function (dialog, type) {
            dialog.removeSelf();
            dialog.isModal && this._checkMask();
            dialog.closeHandler && dialog.closeHandler.runWith(type);
            dialog.onClosed(type);
        };
        __proto.closeAll = function () {
            this._closeAll();
            this.event("close");
        };
        __proto._closeAll = function () {
            for (var i = this.numChildren - 1; i > -1; i--) {
                var item = this.getChildAt(i);
                if (item && item.close != null) {
                    this.doClose(item);
                }
            }
        };
        __proto.getDialogsByGroup = function (group) {
            var arr = [];
            for (var i = this.numChildren - 1; i > -1; i--) {
                var item = this.getChildAt(i);
                if (item && item.group === group) {
                    arr.push(item);
                }
            }
            return arr;
        };
        __proto.closeByGroup = function (group) {
            var arr = [];
            for (var i = this.numChildren - 1; i > -1; i--) {
                var item = this.getChildAt(i);
                if (item && item.group === group) {
                    item.close();
                    arr.push(item);
                }
            }
            return arr;
        };
        __proto._checkMask = function () {
            this.maskLayer.removeSelf();
            for (var i = this.numChildren - 1; i > -1; i--) {
                var dialog = this.getChildAt(i);
                if (dialog && dialog.isModal) {
                    this.addChildAt(this.maskLayer, i);
                    return;
                }
            }
        };
        return DialogManager;
    })(Sprite);
    var Box = (function (_super) {
        function Box() {
            Box.__super.call(this);
            ;
        }
        __class(Box, 'laya.ui.Box', _super);
        var __proto = Box.prototype;
        Laya.imps(__proto, { "laya.ui.IBox": true });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            for (var name in value) {
                var comp = this.getChildByName(name);
                if (comp)
                    comp.dataSource = value[name];
                else if (this.hasOwnProperty(name) && !((typeof (this[name]) == 'function')))
                    this[name] = value[name];
            }
        });
        return Box;
    })(Component);
    var Button = (function (_super) {
        function Button(skin, label) {
            this.toggle = false;
            this._bitmap = null;
            this._text = null;
            this._strokeColors = null;
            this._state = 0;
            this._selected = false;
            this._skin = null;
            this._autoSize = true;
            this._sources = null;
            this._clickHandler = null;
            this._stateChanged = false;
            Button.__super.call(this);
            this._labelColors = Styles.buttonLabelColors;
            this._stateNum = Styles.buttonStateNum;
            (label === void 0) && (label = "");
            this.skin = skin;
            this.label = label;
        }
        __class(Button, 'laya.ui.Button', _super);
        var __proto = Button.prototype;
        Laya.imps(__proto, { "laya.ui.ISelect": true });
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._bitmap && this._bitmap.destroy();
            this._text && this._text.destroy(destroyChild);
            this._bitmap = null;
            this._text = null;
            this._clickHandler = null;
            this._labelColors = this._sources = this._strokeColors = null;
        };
        __proto.createChildren = function () {
            this.graphics = this._bitmap = new AutoBitmap();
        };
        __proto.createText = function () {
            if (!this._text) {
                this._text = new Text();
                this._text.overflow = Text.HIDDEN;
                this._text.align = "center";
                this._text.valign = "middle";
                this._text.width = this._width;
                this._text.height = this._height;
            }
        };
        __proto.initialize = function () {
            if (this._mouseEnableState !== 1) {
                this.mouseEnabled = true;
                this._setBit(0x2, true);
            }
            this._createListener("mouseover", this, this.onMouse, null, false, false);
            this._createListener("mouseout", this, this.onMouse, null, false, false);
            this._createListener("mousedown", this, this.onMouse, null, false, false);
            this._createListener("mouseup", this, this.onMouse, null, false, false);
            this._createListener("click", this, this.onMouse, null, false, false);
        };
        __proto.onMouse = function (e) {
            if (this.toggle === false && this._selected)
                return;
            if (e.type === "click") {
                this.toggle && (this.selected = !this._selected);
                this._clickHandler && this._clickHandler.run();
                return;
            }
            !this._selected && (this.state = Button.stateMap[e.type]);
        };
        __proto.changeClips = function () {
            var img = Loader.getRes(this._skin);
            if (!img) {
                return;
            }
            ;
            var width = img.sourceWidth;
            var height = img.sourceHeight / this._stateNum;
            img.$_GID || (img.$_GID = Utils.getGID());
            var key = img.$_GID + "-" + this._stateNum;
            var clips = WeakObject.I.get(key);
            if (!Utils.isOkTextureList(clips)) {
                clips = null;
            }
            if (clips)
                this._sources = clips;
            else {
                this._sources = [];
                if (this._stateNum === 1) {
                    this._sources.push(img);
                }
                else {
                    for (var i = 0; i < this._stateNum; i++) {
                        this._sources.push(Texture.createFromTexture(img, 0, height * i, width, height));
                    }
                }
                WeakObject.I.set(key, this._sources);
            }
            if (this._autoSize) {
                this._bitmap.width = this._width || width;
                this._bitmap.height = this._height || height;
                if (this._text) {
                    this._text.width = this._bitmap.width;
                    this._text.height = this._bitmap.height;
                }
            }
            else {
                this._text && (this._text.x = width);
            }
        };
        __proto.changeState = function () {
            this._stateChanged = false;
            this.runCallLater(this.changeClips);
            var index = this._state < this._stateNum ? this._state : this._stateNum - 1;
            this._sources && (this._bitmap.source = this._sources[index]);
            if (this.label) {
                this._text.color = this._labelColors[index];
                if (this._strokeColors)
                    this._text.strokeColor = this._strokeColors[index];
            }
        };
        __proto._setStateChanged = function () {
            if (!this._stateChanged) {
                this._stateChanged = true;
                this.callLater(this.changeState);
            }
        };
        __getset(0, __proto, 'labelStrokeColor', function () {
            this.createText();
            return this._text.strokeColor;
        }, function (value) {
            this.createText();
            this._text.strokeColor = value;
        });
        __getset(0, __proto, 'measureHeight', function () {
            this.runCallLater(this.changeClips);
            return this._text ? Math.max(this._bitmap.height, this._text.height) : this._bitmap.height;
        });
        __getset(0, __proto, 'skin', function () {
            return this._skin;
        }, function (value) {
            if (this._skin != value) {
                this._skin = value;
                this.callLater(this.changeClips);
                this._setStateChanged();
            }
        });
        __getset(0, __proto, 'state', function () {
            return this._state;
        }, function (value) {
            if (this._state != value) {
                this._state = value;
                this._setStateChanged();
            }
        });
        __getset(0, __proto, 'text', function () {
            this.createText();
            return this._text;
        });
        __getset(0, __proto, 'stateNum', function () {
            return this._stateNum;
        }, function (value) {
            if ((typeof value == 'string')) {
                value = parseInt(value);
            }
            if (this._stateNum != value) {
                this._stateNum = value < 1 ? 1 : value > 3 ? 3 : value;
                this.callLater(this.changeClips);
            }
        });
        __getset(0, __proto, 'strokeColors', function () {
            return this._strokeColors ? this._strokeColors.join(",") : "";
        }, function (value) {
            this._strokeColors = UIUtils.fillArray(Styles.buttonLabelColors, value, String);
            this._setStateChanged();
        });
        __getset(0, __proto, 'labelColors', function () {
            return this._labelColors.join(",");
        }, function (value) {
            this._labelColors = UIUtils.fillArray(Styles.buttonLabelColors, value, String);
            this._setStateChanged();
        });
        __getset(0, __proto, 'measureWidth', function () {
            this.runCallLater(this.changeClips);
            if (this._autoSize)
                return this._bitmap.width;
            this.runCallLater(this.changeState);
            return this._bitmap.width + (this._text ? this._text.width : 0);
        });
        __getset(0, __proto, 'label', function () {
            return this._text ? this._text.text : null;
        }, function (value) {
            if (!this._text && !value)
                return;
            this.createText();
            if (this._text.text != value) {
                value && !this._text.parent && this.addChild(this._text);
                this._text.text = (value + "").replace(/\\n/g, "\n");
                this._setStateChanged();
            }
        });
        __getset(0, __proto, 'selected', function () {
            return this._selected;
        }, function (value) {
            if (this._selected != value) {
                this._selected = value;
                this.state = this._selected ? 2 : 0;
                this.event("change");
            }
        });
        __getset(0, __proto, 'labelPadding', function () {
            this.createText();
            return this._text.padding.join(",");
        }, function (value) {
            this.createText();
            this._text.padding = UIUtils.fillArray(Styles.labelPadding, value, Number);
        });
        __getset(0, __proto, 'labelSize', function () {
            this.createText();
            return this._text.fontSize;
        }, function (value) {
            this.createText();
            this._text.fontSize = value;
        });
        __getset(0, __proto, 'labelStroke', function () {
            this.createText();
            return this._text.stroke;
        }, function (value) {
            this.createText();
            this._text.stroke = value;
        });
        __getset(0, __proto, 'labelBold', function () {
            this.createText();
            return this._text.bold;
        }, function (value) {
            this.createText();
            this._text.bold = value;
        });
        __getset(0, __proto, 'labelFont', function () {
            this.createText();
            return this._text.font;
        }, function (value) {
            this.createText();
            this._text.font = value;
        });
        __getset(0, __proto, 'labelAlign', function () {
            this.createText();
            return this._text.align;
        }, function (value) {
            this.createText();
            this._text.align = value;
        });
        __getset(0, __proto, 'clickHandler', function () {
            return this._clickHandler;
        }, function (value) {
            this._clickHandler = value;
        });
        __getset(0, __proto, 'sizeGrid', function () {
            if (this._bitmap.sizeGrid)
                return this._bitmap.sizeGrid.join(",");
            return null;
        }, function (value) {
            this._bitmap.sizeGrid = UIUtils.fillArray(Styles.defaultSizeGrid, value, Number);
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            Laya.superSet(Component, this, 'width', value);
            if (this._autoSize) {
                this._bitmap.width = value;
                this._text && (this._text.width = value);
            }
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(Component, this, 'height', value);
            if (this._autoSize) {
                this._bitmap.height = value;
                this._text && (this._text.height = value);
            }
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if ((typeof value == 'number') || (typeof value == 'string'))
                this.label = value + "";
            else
                Laya.superSet(Component, this, 'dataSource', value);
        });
        __getset(0, __proto, 'iconOffset', function () {
            return this._bitmap._offset ? this._bitmap._offset.join(",") : null;
        }, function (value) {
            if (value)
                this._bitmap._offset = UIUtils.fillArray([1, 1], value, Number);
            else
                this._bitmap._offset = [];
        });
        __static(Button, ['stateMap', function () { return this.stateMap = { "mouseup": 0, "mouseover": 1, "mousedown": 2, "mouseout": 0 }; }
        ]);
        return Button;
    })(Component);
    var Clip = (function (_super) {
        function Clip(url, clipX, clipY) {
            this._sources = null;
            this._bitmap = null;
            this._skin = null;
            this._clipX = 1;
            this._clipY = 1;
            this._clipWidth = 0;
            this._clipHeight = 0;
            this._autoPlay = false;
            this._interval = 50;
            this._complete = null;
            this._isPlaying = false;
            this._index = 0;
            this._clipChanged = false;
            this._group = null;
            this._toIndex = -1;
            Clip.__super.call(this);
            (clipX === void 0) && (clipX = 1);
            (clipY === void 0) && (clipY = 1);
            this._clipX = clipX;
            this._clipY = clipY;
            this.skin = url;
        }
        __class(Clip, 'laya.ui.Clip', _super);
        var __proto = Clip.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, true);
            this._bitmap && this._bitmap.destroy();
            this._bitmap = null;
            this._sources = null;
        };
        __proto.dispose = function () {
            this.destroy(true);
            Laya.loader.clearRes(this._skin);
        };
        __proto.createChildren = function () {
            this.graphics = this._bitmap = new AutoBitmap();
        };
        __proto._onDisplay = function (e) {
            if (this._isPlaying) {
                if (this._displayedInStage)
                    this.play();
                else
                    this.stop();
            }
            else if (this._autoPlay) {
                this.play();
            }
        };
        __proto.changeClip = function () {
            this._clipChanged = false;
            if (!this._skin)
                return;
            var img = Loader.getRes(this._skin);
            if (img) {
                this.loadComplete(this._skin, img);
            }
            else {
                Laya.loader.load(this._skin, Handler.create(this, this.loadComplete, [this._skin]));
            }
        };
        __proto.loadComplete = function (url, img) {
            if (url === this._skin && img) {
                var w = this._clipWidth || Math.ceil(img.sourceWidth / this._clipX);
                var h = this._clipHeight || Math.ceil(img.sourceHeight / this._clipY);
                var key = this._skin + w + h;
                var clips = WeakObject.I.get(key);
                if (!Utils.isOkTextureList(clips)) {
                    clips = null;
                }
                if (clips)
                    this._sources = clips;
                else {
                    this._sources = [];
                    for (var i = 0; i < this._clipY; i++) {
                        for (var j = 0; j < this._clipX; j++) {
                            this._sources.push(Texture.createFromTexture(img, w * j, h * i, w, h));
                        }
                    }
                    WeakObject.I.set(key, this._sources);
                }
                this.index = this._index;
                this.event("loaded");
                this.onCompResize();
            }
        };
        __proto.play = function (from, to) {
            (from === void 0) && (from = 0);
            (to === void 0) && (to = -1);
            this._isPlaying = true;
            this.index = from;
            this._toIndex = to;
            this._index++;
            Laya.timer.loop(this.interval, this, this._loop);
            this.on("display", this, this._onDisplay);
            this.on("undisplay", this, this._onDisplay);
        };
        __proto._loop = function () {
            if (this._style.visible && this._sources) {
                this._index++;
                if (this._toIndex > -1 && this._index >= this._toIndex)
                    this.stop();
                else if (this._index >= this._sources.length)
                    this._index = 0;
                this.index = this._index;
            }
        };
        __proto.stop = function () {
            this._isPlaying = false;
            Laya.timer.clear(this, this._loop);
            this.event("complete");
        };
        __proto._setClipChanged = function () {
            if (!this._clipChanged) {
                this._clipChanged = true;
                this.callLater(this.changeClip);
            }
        };
        __getset(0, __proto, 'interval', function () {
            return this._interval;
        }, function (value) {
            if (this._interval != value) {
                this._interval = value;
                if (this._isPlaying)
                    this.play();
            }
        });
        __getset(0, __proto, 'skin', function () {
            return this._skin;
        }, function (value) {
            if (this._skin != value) {
                this._skin = value;
                if (value) {
                    this._setClipChanged();
                }
                else {
                    this._bitmap.source = null;
                }
            }
        });
        __getset(0, __proto, 'sources', function () {
            return this._sources;
        }, function (value) {
            this._sources = value;
            this.index = this._index;
            this.event("loaded");
        });
        __getset(0, __proto, 'clipX', function () {
            return this._clipX;
        }, function (value) {
            this._clipX = value || 1;
            this._setClipChanged();
        });
        __getset(0, __proto, 'clipY', function () {
            return this._clipY;
        }, function (value) {
            this._clipY = value || 1;
            this._setClipChanged();
        });
        __getset(0, __proto, 'total', function () {
            this.runCallLater(this.changeClip);
            return this._sources ? this._sources.length : 0;
        });
        __getset(0, __proto, 'clipWidth', function () {
            return this._clipWidth;
        }, function (value) {
            this._clipWidth = value;
            this._setClipChanged();
        });
        __getset(0, __proto, 'sizeGrid', function () {
            if (this._bitmap.sizeGrid)
                return this._bitmap.sizeGrid.join(",");
            return null;
        }, function (value) {
            this._bitmap.sizeGrid = UIUtils.fillArray(Styles.defaultSizeGrid, value, Number);
        });
        __getset(0, __proto, 'group', function () {
            return this._group;
        }, function (value) {
            if (value && this._skin)
                Loader.setGroup(this._skin, value);
            this._group = value;
        });
        __getset(0, __proto, 'clipHeight', function () {
            return this._clipHeight;
        }, function (value) {
            this._clipHeight = value;
            this._setClipChanged();
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            Laya.superSet(Component, this, 'width', value);
            this._bitmap.width = value;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(Component, this, 'height', value);
            this._bitmap.height = value;
        });
        __getset(0, __proto, 'measureWidth', function () {
            this.runCallLater(this.changeClip);
            return this._bitmap.width;
        });
        __getset(0, __proto, 'measureHeight', function () {
            this.runCallLater(this.changeClip);
            return this._bitmap.height;
        });
        __getset(0, __proto, 'index', function () {
            return this._index;
        }, function (value) {
            this._index = value;
            this._bitmap && this._sources && (this._bitmap.source = this._sources[value]);
            this.event("change");
        });
        __getset(0, __proto, 'autoPlay', function () {
            return this._autoPlay;
        }, function (value) {
            if (this._autoPlay != value) {
                this._autoPlay = value;
                value ? this.play() : this.stop();
            }
        });
        __getset(0, __proto, 'isPlaying', function () {
            return this._isPlaying;
        }, function (value) {
            this._isPlaying = value;
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if (((typeof value == 'number') && Math.floor(value) == value) || (typeof value == 'string'))
                this.index = parseInt(value);
            else
                Laya.superSet(Component, this, 'dataSource', value);
        });
        __getset(0, __proto, 'bitmap', function () {
            return this._bitmap;
        });
        return Clip;
    })(Component);
    var ColorPicker = (function (_super) {
        function ColorPicker() {
            this.changeHandler = null;
            this._gridSize = 11;
            this._bgColor = "#ffffff";
            this._borderColor = "#000000";
            this._inputColor = "#000000";
            this._inputBgColor = "#efefef";
            this._colorPanel = null;
            this._colorTiles = null;
            this._colorBlock = null;
            this._colorInput = null;
            this._colorButton = null;
            this._colors = [];
            this._selectedColor = "#000000";
            this._panelChanged = false;
            ColorPicker.__super.call(this);
        }
        __class(ColorPicker, 'laya.ui.ColorPicker', _super);
        var __proto = ColorPicker.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._colorPanel && this._colorPanel.destroy(destroyChild);
            this._colorButton && this._colorButton.destroy(destroyChild);
            this._colorPanel = null;
            this._colorTiles = null;
            this._colorBlock = null;
            this._colorInput = null;
            this._colorButton = null;
            this._colors = null;
            this.changeHandler = null;
        };
        __proto.createChildren = function () {
            this.addChild(this._colorButton = new Button());
            this._colorPanel = new Box();
            this._colorPanel.size(230, 166);
            this._colorPanel.addChild(this._colorTiles = new Sprite());
            this._colorPanel.addChild(this._colorBlock = new Sprite());
            this._colorPanel.addChild(this._colorInput = new Input());
        };
        __proto.initialize = function () {
            this._colorButton.on("click", this, this.onColorButtonClick);
            this._colorBlock.pos(5, 5);
            this._colorInput.pos(60, 5);
            this._colorInput.size(60, 20);
            this._colorInput.on("change", this, this.onColorInputChange);
            this._colorInput.on("keydown", this, this.onColorFieldKeyDown);
            this._colorTiles.pos(5, 30);
            this._colorTiles.on("mousemove", this, this.onColorTilesMouseMove);
            this._colorTiles.on("click", this, this.onColorTilesClick);
            this._colorTiles.size(20 * this._gridSize, 12 * this._gridSize);
            this._colorPanel.on("mousedown", this, this.onPanelMouseDown);
            this.bgColor = this._bgColor;
        };
        __proto.onPanelMouseDown = function (e) {
            e.stopPropagation();
        };
        __proto.changePanel = function () {
            this._panelChanged = false;
            var g = this._colorPanel.graphics;
            g.clear();
            g.drawRect(0, 0, 230, 166, this._bgColor, this._borderColor);
            this.drawBlock(this._selectedColor);
            this._colorInput.borderColor = this._borderColor;
            this._colorInput.bgColor = this._inputBgColor;
            this._colorInput.color = this._inputColor;
            g = this._colorTiles.graphics;
            g.clear();
            var mainColors = [0x000000, 0x333333, 0x666666, 0x999999, 0xCCCCCC, 0xFFFFFF, 0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0x00FFFF, 0xFF00FF];
            for (var i = 0; i < 12; i++) {
                for (var j = 0; j < 20; j++) {
                    var color = 0;
                    if (j === 0)
                        color = mainColors[i];
                    else if (j === 1)
                        color = 0x000000;
                    else
                        color = (((i * 3 + j / 6) % 3 << 0) + ((i / 6) << 0) * 3) * 0x33 << 16 | j % 6 * 0x33 << 8 | (i << 0) % 6 * 0x33;
                    var strColor = UIUtils.toColor(color);
                    this._colors.push(strColor);
                    var x = j * this._gridSize;
                    var y = i * this._gridSize;
                    g.drawRect(x, y, this._gridSize, this._gridSize, strColor, "#000000");
                }
            }
        };
        __proto.onColorButtonClick = function (e) {
            if (this._colorPanel.parent)
                this.close();
            else
                this.open();
        };
        __proto.open = function () {
            var p = this.localToGlobal(new Point());
            var px = p.x + this._colorPanel.width <= Laya.stage.width ? p.x : Laya.stage.width - this._colorPanel.width;
            var py = p.y + this._colorButton.height;
            py = py + this._colorPanel.height <= Laya.stage.height ? py : p.y - this._colorPanel.height;
            this._colorPanel.pos(px, py);
            this._colorPanel.zOrder = 1001;
            Laya._currentStage.addChild(this._colorPanel);
            Laya.stage.on("mousedown", this, this.removeColorBox);
        };
        __proto.close = function () {
            Laya.stage.off("mousedown", this, this.removeColorBox);
            this._colorPanel.removeSelf();
        };
        __proto.removeColorBox = function (e) {
            this.close();
        };
        __proto.onColorFieldKeyDown = function (e) {
            if (e.keyCode == 13) {
                if (this._colorInput.text)
                    this.selectedColor = this._colorInput.text;
                else
                    this.selectedColor = null;
                this.close();
                e.stopPropagation();
            }
        };
        __proto.onColorInputChange = function (e) {
            if (this._colorInput.text)
                this.drawBlock(this._colorInput.text);
            else
                this.drawBlock("#FFFFFF");
        };
        __proto.onColorTilesClick = function (e) {
            this.selectedColor = this.getColorByMouse();
            this.close();
        };
        __proto.onColorTilesMouseMove = function (e) {
            this._colorInput.focus = false;
            var color = this.getColorByMouse();
            this._colorInput.text = color;
            this.drawBlock(color);
        };
        __proto.getColorByMouse = function () {
            var point = this._colorTiles.getMousePoint();
            var x = Math.floor(point.x / this._gridSize);
            var y = Math.floor(point.y / this._gridSize);
            return this._colors[y * 20 + x];
        };
        __proto.drawBlock = function (color) {
            var g = this._colorBlock.graphics;
            g.clear();
            var showColor = color ? color : "#ffffff";
            g.drawRect(0, 0, 50, 20, showColor, this._borderColor);
            color || g.drawLine(0, 0, 50, 20, "#ff0000");
        };
        __proto.changeColor = function () {
            var g = this.graphics;
            g.clear();
            var showColor = this._selectedColor || "#000000";
            g.drawRect(0, 0, this._colorButton.width, this._colorButton.height, showColor);
        };
        __proto._setPanelChanged = function () {
            if (!this._panelChanged) {
                this._panelChanged = true;
                this.callLater(this.changePanel);
            }
        };
        __getset(0, __proto, 'inputBgColor', function () {
            return this._inputBgColor;
        }, function (value) {
            this._inputBgColor = value;
            this._setPanelChanged();
        });
        __getset(0, __proto, 'selectedColor', function () {
            return this._selectedColor;
        }, function (value) {
            if (this._selectedColor != value) {
                this._selectedColor = this._colorInput.text = value;
                this.drawBlock(value);
                this.changeColor();
                this.changeHandler && this.changeHandler.runWith(this._selectedColor);
                this.event("change", Event.EMPTY.setTo("change", this, this));
            }
        });
        __getset(0, __proto, 'skin', function () {
            return this._colorButton.skin;
        }, function (value) {
            this._colorButton.skin = value;
            this.changeColor();
        });
        __getset(0, __proto, 'bgColor', function () {
            return this._bgColor;
        }, function (value) {
            this._bgColor = value;
            this._setPanelChanged();
        });
        __getset(0, __proto, 'borderColor', function () {
            return this._borderColor;
        }, function (value) {
            this._borderColor = value;
            this._setPanelChanged();
        });
        __getset(0, __proto, 'inputColor', function () {
            return this._inputColor;
        }, function (value) {
            this._inputColor = value;
            this._setPanelChanged();
        });
        return ColorPicker;
    })(Component);
    var ComboBox = (function (_super) {
        function ComboBox(skin, labels) {
            this._visibleNum = 6;
            this._button = null;
            this._list = null;
            this._isOpen = false;
            this._itemSize = 12;
            this._labels = [];
            this._selectedIndex = -1;
            this._selectHandler = null;
            this._itemHeight = NaN;
            this._listHeight = NaN;
            this._listChanged = false;
            this._itemChanged = false;
            this._scrollBarSkin = null;
            this._isCustomList = false;
            this.itemRender = null;
            ComboBox.__super.call(this);
            this._itemColors = Styles.comboBoxItemColors;
            this.skin = skin;
            this.labels = labels;
        }
        __class(ComboBox, 'laya.ui.ComboBox', _super);
        var __proto = ComboBox.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._button && this._button.destroy(destroyChild);
            this._list && this._list.destroy(destroyChild);
            this._button = null;
            this._list = null;
            this._itemColors = null;
            this._labels = null;
            this._selectHandler = null;
        };
        __proto.createChildren = function () {
            this.addChild(this._button = new Button());
            this._button.text.align = "left";
            this._button.labelPadding = "0,0,0,5";
            this._button.on("mousedown", this, this.onButtonMouseDown);
        };
        __proto._createList = function () {
            this._list = new List();
            if (this._scrollBarSkin)
                this._list.vScrollBarSkin = this._scrollBarSkin;
            this._setListEvent(this._list);
        };
        __proto._setListEvent = function (list) {
            this._list.selectEnable = true;
            this._list.on("mousedown", this, this.onListDown);
            this._list.mouseHandler = Handler.create(this, this.onlistItemMouse, null, false);
            if (this._list.scrollBar)
                this._list.scrollBar.on("mousedown", this, this.onScrollBarDown);
        };
        __proto.onListDown = function (e) {
            e.stopPropagation();
        };
        __proto.onScrollBarDown = function (e) {
            e.stopPropagation();
        };
        __proto.onButtonMouseDown = function (e) {
            this.callLater(this.switchTo, [!this._isOpen]);
        };
        __proto.changeList = function () {
            this._listChanged = false;
            var labelWidth = this.width - 2;
            var labelColor = this._itemColors[2];
            this._itemHeight = this._itemSize + 6;
            this._list.itemRender = this.itemRender || { type: "Box", child: [{ type: "Label", props: { name: "label", x: 1, padding: "3,3,3,3", width: labelWidth, height: this._itemHeight, fontSize: this._itemSize, color: labelColor } }] };
            this._list.repeatY = this._visibleNum;
            this._list.refresh();
        };
        __proto.onlistItemMouse = function (e, index) {
            var type = e.type;
            if (type === "mouseover" || type === "mouseout") {
                if (this._isCustomList)
                    return;
                var box = this._list.getCell(index);
                if (!box)
                    return;
                var label = box.getChildByName("label");
                if (label) {
                    if (type === "mouseover") {
                        label.bgColor = this._itemColors[0];
                        label.color = this._itemColors[1];
                    }
                    else {
                        label.bgColor = null;
                        label.color = this._itemColors[2];
                    }
                }
            }
            else if (type === "click") {
                this.selectedIndex = index;
                this.isOpen = false;
            }
        };
        __proto.switchTo = function (value) {
            this.isOpen = value;
        };
        __proto.changeOpen = function () {
            this.isOpen = !this._isOpen;
        };
        __proto.changeItem = function () {
            this._itemChanged = false;
            this._listHeight = this._labels.length > 0 ? Math.min(this._visibleNum, this._labels.length) * this._itemHeight : this._itemHeight;
            if (!this._isCustomList) {
                var g = this._list.graphics;
                g.clear();
                g.drawRect(0, 0, this.width - 1, this._listHeight, this._itemColors[4], this._itemColors[3]);
            }
            ;
            var a = this._list.array || [];
            a.length = 0;
            for (var i = 0, n = this._labels.length; i < n; i++) {
                a.push({ label: this._labels[i] });
            }
            this._list.height = this._listHeight;
            this._list.array = a;
        };
        __proto.changeSelected = function () {
            this._button.label = this.selectedLabel;
        };
        __proto._onStageMouseWheel = function (e) {
            if (!this._list || this._list.contains(e.target))
                return;
            this.removeList(null);
        };
        __proto.removeList = function (e) {
            Laya.stage.off("mousedown", this, this.removeList);
            Laya.stage.off("mousewheel", this, this._onStageMouseWheel);
            this.isOpen = false;
        };
        __getset(0, __proto, 'selectedIndex', function () {
            return this._selectedIndex;
        }, function (value) {
            if (this._selectedIndex != value) {
                this._selectedIndex = value;
                if (this._labels.length > 0)
                    this.changeSelected();
                else
                    this.callLater(this.changeSelected);
                this.event("change", [Event.EMPTY.setTo("change", this, this)]);
                this._selectHandler && this._selectHandler.runWith(this._selectedIndex);
            }
        });
        __getset(0, __proto, 'measureHeight', function () {
            return this._button.height;
        });
        __getset(0, __proto, 'skin', function () {
            return this._button.skin;
        }, function (value) {
            if (this._button.skin != value) {
                this._button.skin = value;
                this._listChanged = true;
            }
        });
        __getset(0, __proto, 'measureWidth', function () {
            return this._button.width;
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            Laya.superSet(Component, this, 'width', value);
            this._button.width = this._width;
            this._itemChanged = true;
            this._listChanged = true;
        });
        __getset(0, __proto, 'selectedLabel', function () {
            return this._selectedIndex > -1 && this._selectedIndex < this._labels.length ? this._labels[this._selectedIndex] : "";
        }, function (value) {
            this.selectedIndex = this._labels.indexOf(value);
        });
        __getset(0, __proto, 'labels', function () {
            return this._labels.join(",");
        }, function (value) {
            if (this._labels.length > 0)
                this.selectedIndex = -1;
            if (value)
                this._labels = value.split(",");
            else
                this._labels.length = 0;
            this._itemChanged = true;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(Component, this, 'height', value);
            this._button.height = this._height;
        });
        __getset(0, __proto, 'selectHandler', function () {
            return this._selectHandler;
        }, function (value) {
            this._selectHandler = value;
        });
        __getset(0, __proto, 'visibleNum', function () {
            return this._visibleNum;
        }, function (value) {
            this._visibleNum = value;
            this._listChanged = true;
        });
        __getset(0, __proto, 'labelBold', function () {
            return this._button.text.bold;
        }, function (value) {
            this._button.text.bold = value;
        });
        __getset(0, __proto, 'itemColors', function () {
            return String(this._itemColors);
        }, function (value) {
            this._itemColors = UIUtils.fillArray(this._itemColors, value, String);
            this._listChanged = true;
        });
        __getset(0, __proto, 'itemSize', function () {
            return this._itemSize;
        }, function (value) {
            this._itemSize = value;
            this._listChanged = true;
        });
        __getset(0, __proto, 'scrollBar', function () {
            return this.list.scrollBar;
        });
        __getset(0, __proto, 'isOpen', function () {
            return this._isOpen;
        }, function (value) {
            if (this._isOpen != value) {
                this._isOpen = value;
                if (!this._button)
                    return;
                this._button.selected = this._isOpen;
                if (this._isOpen) {
                    this._list || this._createList();
                    this._listChanged && !this._isCustomList && this.changeList();
                    this._itemChanged && this.changeItem();
                    var p = this.localToGlobal(Point.TEMP.setTo(0, 0));
                    var py = p.y + this._button.height;
                    py = py + this._listHeight <= Laya.stage.height ? py : p.y - this._listHeight;
                    this._list.pos(p.x, py);
                    this._list.zOrder = 1001;
                    Laya._currentStage.addChild(this._list);
                    Laya.stage.once("mousedown", this, this.removeList);
                    Laya.stage.on("mousewheel", this, this._onStageMouseWheel);
                    this._list.selectedIndex = this._selectedIndex;
                }
                else {
                    this._list && this._list.removeSelf();
                }
                ComboBox.isOpen = value;
            }
        });
        __getset(0, __proto, 'scrollBarSkin', function () {
            return this._scrollBarSkin;
        }, function (value) {
            this._scrollBarSkin = value;
        });
        __getset(0, __proto, 'sizeGrid', function () {
            return this._button.sizeGrid;
        }, function (value) {
            this._button.sizeGrid = value;
        });
        __getset(0, __proto, 'button', function () {
            return this._button;
        });
        __getset(0, __proto, 'list', function () {
            this._list || this._createList();
            return this._list;
        }, function (value) {
            if (value) {
                value.removeSelf();
                this._isCustomList = true;
                this._list = value;
                this._setListEvent(value);
                this._itemHeight = value.getCell(0).height + value.spaceY;
            }
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if (((typeof value == 'number') && Math.floor(value) == value) || (typeof value == 'string'))
                this.selectedIndex = parseInt(value);
            else if ((value instanceof Array))
                this.labels = (value).join(",");
            else
                Laya.superSet(Component, this, 'dataSource', value);
        });
        __getset(0, __proto, 'labelColors', function () {
            return this._button.labelColors;
        }, function (value) {
            if (this._button.labelColors != value) {
                this._button.labelColors = value;
            }
        });
        __getset(0, __proto, 'labelPadding', function () {
            return this._button.text.padding.join(",");
        }, function (value) {
            this._button.text.padding = UIUtils.fillArray(Styles.labelPadding, value, Number);
        });
        __getset(0, __proto, 'labelSize', function () {
            return this._button.text.fontSize;
        }, function (value) {
            this._button.text.fontSize = value;
        });
        __getset(0, __proto, 'labelFont', function () {
            return this._button.text.font;
        }, function (value) {
            this._button.text.font = value;
        });
        __getset(0, __proto, 'stateNum', function () {
            return this._button.stateNum;
        }, function (value) {
            this._button.stateNum = value;
        });
        return ComboBox;
    })(Component);
    var ScrollBar = (function (_super) {
        function ScrollBar(skin) {
            this.rollRatio = 0.95;
            this.changeHandler = null;
            this.scaleBar = true;
            this.autoHide = false;
            this.elasticDistance = 0;
            this.elasticBackTime = 500;
            this.upButton = null;
            this.downButton = null;
            this.slider = null;
            this._scrollSize = 1;
            this._skin = null;
            this._thumbPercent = 1;
            this._target = null;
            this._lastPoint = null;
            this._lastOffset = 0;
            this._checkElastic = false;
            this._isElastic = false;
            this._value = NaN;
            this._hide = false;
            this._clickOnly = true;
            this._offsets = null;
            ScrollBar.__super.call(this);
            this._showButtons = UIConfig.showButtons;
            this._touchScrollEnable = UIConfig.touchScrollEnable;
            this._mouseWheelEnable = UIConfig.mouseWheelEnable;
            this.skin = skin;
            this.max = 1;
        }
        __class(ScrollBar, 'laya.ui.ScrollBar', _super);
        var __proto = ScrollBar.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            this.stopScroll();
            this.target = null;
            _super.prototype.destroy.call(this, destroyChild);
            this.upButton && this.upButton.destroy(destroyChild);
            this.downButton && this.downButton.destroy(destroyChild);
            this.slider && this.slider.destroy(destroyChild);
            this.upButton = this.downButton = null;
            this.slider = null;
            this.changeHandler = null;
            this._offsets = null;
        };
        __proto.createChildren = function () {
            this.addChild(this.slider = new Slider());
            this.addChild(this.upButton = new Button());
            this.addChild(this.downButton = new Button());
        };
        __proto.initialize = function () {
            this.slider.showLabel = false;
            this.slider.on("change", this, this.onSliderChange);
            this.slider.setSlider(0, 0, 0);
            this.upButton.on("mousedown", this, this.onButtonMouseDown);
            this.downButton.on("mousedown", this, this.onButtonMouseDown);
        };
        __proto.onSliderChange = function () {
            if (this._value != this.slider.value)
                this.value = this.slider.value;
        };
        __proto.onButtonMouseDown = function (e) {
            var isUp = e.currentTarget === this.upButton;
            this.slide(isUp);
            Laya.timer.once(Styles.scrollBarDelayTime, this, this.startLoop, [isUp]);
            Laya.stage.once("mouseup", this, this.onStageMouseUp);
        };
        __proto.startLoop = function (isUp) {
            Laya.timer.frameLoop(1, this, this.slide, [isUp]);
        };
        __proto.slide = function (isUp) {
            if (isUp)
                this.value -= this._scrollSize;
            else
                this.value += this._scrollSize;
        };
        __proto.onStageMouseUp = function (e) {
            Laya.timer.clear(this, this.startLoop);
            Laya.timer.clear(this, this.slide);
        };
        __proto.changeScrollBar = function () {
            this.upButton.visible = this._showButtons;
            this.downButton.visible = this._showButtons;
            if (this._showButtons) {
                this.upButton.skin = this._skin.replace(".png", "$up.png");
                this.downButton.skin = this._skin.replace(".png", "$down.png");
            }
            if (this.slider.isVertical)
                this.slider.y = this._showButtons ? this.upButton.height : 0;
            else
                this.slider.x = this._showButtons ? this.upButton.width : 0;
            this.resetPositions();
            this.repaint();
        };
        __proto.changeSize = function () {
            _super.prototype.changeSize.call(this);
            this.repaint();
            this.resetPositions();
            this.event("change");
            this.changeHandler && this.changeHandler.runWith(this.value);
        };
        __proto.resetPositions = function () {
            if (this.slider.isVertical)
                this.slider.height = this.height - (this._showButtons ? (this.upButton.height + this.downButton.height) : 0);
            else
                this.slider.width = this.width - (this._showButtons ? (this.upButton.width + this.downButton.width) : 0);
            this.resetButtonPosition();
        };
        __proto.resetButtonPosition = function () {
            if (this.slider.isVertical)
                this.downButton.y = this.slider.y + this.slider.height;
            else
                this.downButton.x = this.slider.x + this.slider.width;
        };
        __proto.setScroll = function (min, max, value) {
            this.runCallLater(this.changeSize);
            this.slider.setSlider(min, max, value);
            this.slider.bar.visible = max > 0;
            if (!this._hide && this.autoHide)
                this.visible = false;
        };
        __proto.onTargetMouseWheel = function (e) {
            this.value -= e.delta * this._scrollSize;
            this.target = this._target;
        };
        __proto.onTargetMouseDown = function (e) {
            this._clickOnly = true;
            this._lastOffset = 0;
            this._checkElastic = false;
            this._lastPoint || (this._lastPoint = new Point());
            this._lastPoint.setTo(Laya.stage.mouseX, Laya.stage.mouseY);
            Laya.timer.clear(this, this.tweenMove);
            Tween.clearTween(this);
            Laya.stage.once("mouseup", this, this.onStageMouseUp2);
            Laya.stage.once("mouseout", this, this.onStageMouseUp2);
            Laya.timer.frameLoop(1, this, this.loop);
        };
        __proto.loop = function () {
            var mouseY = Laya.stage.mouseY;
            var mouseX = Laya.stage.mouseX;
            this._lastOffset = this.isVertical ? (mouseY - this._lastPoint.y) : (mouseX - this._lastPoint.x);
            if (this._clickOnly) {
                if (Math.abs(this._lastOffset * (this.isVertical ? Laya.stage._canvasTransform.getScaleY() : Laya.stage._canvasTransform.getScaleX())) > 1) {
                    this._clickOnly = false;
                    this._offsets || (this._offsets = []);
                    this._offsets.length = 0;
                    this._target.mouseEnabled = false;
                    if (!this.hide && this.autoHide) {
                        this.alpha = 1;
                        this.visible = true;
                    }
                    this.event("start");
                }
                else
                    return;
            }
            this._offsets.push(this._lastOffset);
            this._lastPoint.x = mouseX;
            this._lastPoint.y = mouseY;
            if (this._lastOffset === 0)
                return;
            if (!this._checkElastic) {
                if (this.elasticDistance > 0) {
                    if (!this._checkElastic && this._lastOffset != 0) {
                        if ((this._lastOffset > 0 && this._value <= this.min) || (this._lastOffset < 0 && this._value >= this.max)) {
                            this._isElastic = true;
                            this._checkElastic = true;
                        }
                        else {
                            this._isElastic = false;
                        }
                    }
                }
                else {
                    this._checkElastic = true;
                }
            }
            if (this._isElastic) {
                if (this._value <= this.min) {
                    this.value -= this._lastOffset * Math.max(0, (1 - ((this.min - this._value) / this.elasticDistance)));
                }
                else if (this._value >= this.max) {
                    this.value -= this._lastOffset * Math.max(0, (1 - ((this._value - this.max) / this.elasticDistance)));
                }
            }
            else {
                this.value -= this._lastOffset;
            }
        };
        __proto.onStageMouseUp2 = function (e) {
            Laya.stage.off("mouseup", this, this.onStageMouseUp2);
            Laya.stage.off("mouseout", this, this.onStageMouseUp2);
            Laya.timer.clear(this, this.loop);
            if (this._clickOnly) {
                if (this._value >= this.min && this._value <= this.max)
                    return;
            }
            this._target.mouseEnabled = true;
            if (this._isElastic) {
                if (this._value < this.min) {
                    Tween.to(this, { value: this.min }, this.elasticBackTime, Ease.sineOut, Handler.create(this, this.elasticOver));
                }
                else if (this._value > this.max) {
                    Tween.to(this, { value: this.max }, this.elasticBackTime, Ease.sineOut, Handler.create(this, this.elasticOver));
                }
            }
            else {
                if (!this._offsets)
                    return;
                if (this._offsets.length < 1) {
                    this._offsets[0] = this.isVertical ? Laya.stage.mouseY - this._lastPoint.y : Laya.stage.mouseX - this._lastPoint.x;
                }
                ;
                var offset = 0;
                var n = Math.min(this._offsets.length, 3);
                for (var i = 0; i < n; i++) {
                    offset += this._offsets[this._offsets.length - 1 - i];
                }
                this._lastOffset = offset / n;
                offset = Math.abs(this._lastOffset);
                if (offset < 2) {
                    this.event("end");
                    return;
                }
                if (offset > 60)
                    this._lastOffset = this._lastOffset > 0 ? 60 : -60;
                var dis = Math.round(Math.abs(this.elasticDistance * (this._lastOffset / 240)));
                Laya.timer.frameLoop(1, this, this.tweenMove, [dis]);
            }
        };
        __proto.elasticOver = function () {
            this._isElastic = false;
            if (!this.hide && this.autoHide) {
                Tween.to(this, { alpha: 0 }, 500);
            }
            this.event("end");
        };
        __proto.tweenMove = function (maxDistance) {
            this._lastOffset *= this.rollRatio;
            var tarSpeed = NaN;
            if (maxDistance > 0) {
                if (this._lastOffset > 0 && this.value <= this.min) {
                    this._isElastic = true;
                    tarSpeed = -(this.min - maxDistance - this.value) * 0.5;
                    if (this._lastOffset > tarSpeed)
                        this._lastOffset = tarSpeed;
                }
                else if (this._lastOffset < 0 && this.value >= this.max) {
                    this._isElastic = true;
                    tarSpeed = -(this.max + maxDistance - this.value) * 0.5;
                    if (this._lastOffset < tarSpeed)
                        this._lastOffset = tarSpeed;
                }
            }
            this.value -= this._lastOffset;
            if (Math.abs(this._lastOffset) < 1) {
                Laya.timer.clear(this, this.tweenMove);
                if (this._isElastic) {
                    if (this._value < this.min) {
                        Tween.to(this, { value: this.min }, this.elasticBackTime, Ease.sineOut, Handler.create(this, this.elasticOver));
                    }
                    else if (this._value > this.max) {
                        Tween.to(this, { value: this.max }, this.elasticBackTime, Ease.sineOut, Handler.create(this, this.elasticOver));
                    }
                    else {
                        this.elasticOver();
                    }
                    return;
                }
                this.event("end");
                if (!this.hide && this.autoHide) {
                    Tween.to(this, { alpha: 0 }, 500);
                }
            }
        };
        __proto.stopScroll = function () {
            this.onStageMouseUp2(null);
            Laya.timer.clear(this, this.tweenMove);
            Tween.clearTween(this);
        };
        __getset(0, __proto, 'measureHeight', function () {
            if (this.slider.isVertical)
                return 100;
            return this.slider.height;
        });
        __getset(0, __proto, 'skin', function () {
            return this._skin;
        }, function (value) {
            if (this._skin != value) {
                this._skin = value;
                this.slider.skin = this._skin;
                this.callLater(this.changeScrollBar);
            }
        });
        __getset(0, __proto, 'max', function () {
            return this.slider.max;
        }, function (value) {
            this.slider.max = value;
        });
        __getset(0, __proto, 'showButtons', function () {
            return this._showButtons;
        }, function (value) {
            this._showButtons = value;
            this.callLater(this.changeScrollBar);
        });
        __getset(0, __proto, 'measureWidth', function () {
            if (this.slider.isVertical)
                return this.slider.width;
            return 100;
        });
        __getset(0, __proto, 'min', function () {
            return this.slider.min;
        }, function (value) {
            this.slider.min = value;
        });
        __getset(0, __proto, 'value', function () {
            return this._value;
        }, function (v) {
            if (v !== this._value) {
                this._value = v;
                if (!this._isElastic) {
                    if (this.slider._value != v) {
                        this.slider._value = v;
                        this.slider.changeValue();
                    }
                    this._value = this.slider._value;
                }
                this.event("change");
                this.changeHandler && this.changeHandler.runWith(this._value);
            }
        });
        __getset(0, __proto, 'isVertical', function () {
            return this.slider.isVertical;
        }, function (value) {
            this.slider.isVertical = value;
        });
        __getset(0, __proto, 'sizeGrid', function () {
            return this.slider.sizeGrid;
        }, function (value) {
            this.slider.sizeGrid = value;
        });
        __getset(0, __proto, 'scrollSize', function () {
            return this._scrollSize;
        }, function (value) {
            this._scrollSize = value;
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if ((typeof value == 'number') || (typeof value == 'string'))
                this.value = Number(value);
            else
                Laya.superSet(Component, this, 'dataSource', value);
        });
        __getset(0, __proto, 'thumbPercent', function () {
            return this._thumbPercent;
        }, function (value) {
            this.runCallLater(this.changeScrollBar);
            this.runCallLater(this.changeSize);
            value = value >= 1 ? 0.99 : value;
            this._thumbPercent = value;
            if (this.scaleBar) {
                if (this.slider.isVertical) {
                    this.slider.bar.height = Math.max(this.slider.height * value, Styles.scrollBarMinNum);
                    this.slider.bar.height = Math.min(this.slider.bar.height, this.slider.height);
                }
                else {
                    this.slider.bar.width = Math.max(this.slider.width * value, Styles.scrollBarMinNum);
                    this.slider.bar.width = Math.min(this.slider.bar.width, this.slider.width);
                }
            }
        });
        __getset(0, __proto, 'target', function () {
            return this._target;
        }, function (value) {
            if (this._target) {
                this._target.off("mousewheel", this, this.onTargetMouseWheel);
                this._target.off("mousedown", this, this.onTargetMouseDown);
            }
            this._target = value;
            if (value) {
                this._mouseWheelEnable && this._target.on("mousewheel", this, this.onTargetMouseWheel);
                this._touchScrollEnable && this._target.on("mousedown", this, this.onTargetMouseDown);
            }
        });
        __getset(0, __proto, 'hide', function () {
            return this._hide;
        }, function (value) {
            this._hide = value;
            this.visible = !value;
        });
        __getset(0, __proto, 'touchScrollEnable', function () {
            return this._touchScrollEnable;
        }, function (value) {
            this._touchScrollEnable = value;
            this.target = this._target;
        });
        __getset(0, __proto, 'mouseWheelEnable', function () {
            return this._mouseWheelEnable;
        }, function (value) {
            this._mouseWheelEnable = value;
        });
        __getset(0, __proto, 'tick', function () {
            return this.slider.tick;
        }, function (value) {
            this.slider.tick = value;
        });
        return ScrollBar;
    })(Component);
    var Slider = (function (_super) {
        function Slider(skin) {
            this.changeHandler = null;
            this.isVertical = true;
            this.showLabel = true;
            this._allowClickBack = false;
            this._max = 100;
            this._min = 0;
            this._tick = 1;
            this._value = 0;
            this._skin = null;
            this._bg = null;
            this._progress = null;
            this._bar = null;
            this._tx = NaN;
            this._ty = NaN;
            this._maxMove = NaN;
            this._globalSacle = null;
            Slider.__super.call(this);
            this.skin = skin;
        }
        __class(Slider, 'laya.ui.Slider', _super);
        var __proto = Slider.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._bg && this._bg.destroy(destroyChild);
            this._bar && this._bar.destroy(destroyChild);
            this._progress && this._progress.destroy(destroyChild);
            this._bg = null;
            this._bar = null;
            this._progress = null;
            this.changeHandler = null;
        };
        __proto.createChildren = function () {
            this.addChild(this._bg = new Image());
            this.addChild(this._bar = new Button());
        };
        __proto.initialize = function () {
            this._bar.on("mousedown", this, this.onBarMouseDown);
            // this._bg.sizeGrid = this._bar.sizeGrid = "4,4,4,4,0";
            this._bg.sizeGrid = this._bar.sizeGrid = "0,0,0,0,0";
            if (this._progress)
                this._progress.sizeGrid = this._bar.sizeGrid;
            this.allowClickBack = true;
        };
        __proto.onBarMouseDown = function (e) {
            this._globalSacle || (this._globalSacle = new Point());
            this._globalSacle.setTo(this.globalScaleX || 0.01, this.globalScaleY || 0.01);
            this._maxMove = this.isVertical ? (this.height - this._bar.height) : (this.width - this._bar.width);
            this._tx = Laya.stage.mouseX;
            this._ty = Laya.stage.mouseY;
            Laya.stage.on("mousemove", this, this.mouseMove);
            Laya.stage.once("mouseup", this, this.mouseUp);
            Laya.stage.once("mouseout", this, this.mouseUp);
            this.showValueText();
        };
        __proto.showValueText = function () {
            if (this.showLabel) {
                var label = laya.ui.Slider.label;
                this.addChild(label);
                label.textField.changeText(this._value + "");
                if (this.isVertical) {
                    label.x = this._bar.x + 20;
                    label.y = (this._bar.height - label.height) * 0.5 + this._bar.y;
                }
                else {
                    label.y = this._bar.y - 20;
                    label.x = (this._bar.width - label.width) * 0.5 + this._bar.x;
                }
            }
        };
        __proto.hideValueText = function () {
            laya.ui.Slider.label && laya.ui.Slider.label.removeSelf();
        };
        __proto.mouseUp = function (e) {
            Laya.stage.off("mousemove", this, this.mouseMove);
            Laya.stage.off("mouseup", this, this.mouseUp);
            Laya.stage.off("mouseout", this, this.mouseUp);
            this.sendChangeEvent("changed");
            this.hideValueText();
        };
        __proto.mouseMove = function (e) {
            var oldValue = this._value;
            if (this.isVertical) {
                this._bar.y += (Laya.stage.mouseY - this._ty) / this._globalSacle.y;
                if (this._bar.y > this._maxMove)
                    this._bar.y = this._maxMove;
                else if (this._bar.y < 0)
                    this._bar.y = 0;
                this._value = this._bar.y / this._maxMove * (this._max - this._min) + this._min;
                if (this._progress)
                    this._progress.height = this._bar.y + 0.5 * this._bar.height;
            }
            else {
                this._bar.x += (Laya.stage.mouseX - this._tx) / this._globalSacle.x;
                if (this._bar.x > this._maxMove)
                    this._bar.x = this._maxMove;
                else if (this._bar.x < 0)
                    this._bar.x = 0;
                this._value = this._bar.x / this._maxMove * (this._max - this._min) + this._min;
                if (this._progress)
                    this._progress.width = this._bar.x + 0.5 * this._bar.width;
            }
            this._tx = Laya.stage.mouseX;
            this._ty = Laya.stage.mouseY;
            var pow = Math.pow(10, (this._tick + "").length - 1);
            this._value = Math.round(Math.round(this._value / this._tick) * this._tick * pow) / pow;
            if (this._value != oldValue) {
                this.sendChangeEvent();
            }
            this.showValueText();
        };
        __proto.sendChangeEvent = function (type) {
            (type === void 0) && (type = "change");
            this.event(type);
            this.changeHandler && this.changeHandler.runWith(this._value);
        };
        __proto.setBarPoint = function () {
            if (this.isVertical)
                this._bar.x = Math.round((this._bg.width - this._bar.width) * 0.5);
            else
                this._bar.y = Math.round((this._bg.height - this._bar.height) * 0.5);
        };
        __proto.changeSize = function () {
            _super.prototype.changeSize.call(this);
            if (this.isVertical)
                this._bg.height = this.height;
            else
                this._bg.width = this.width;
            this.setBarPoint();
            this.changeValue();
        };
        __proto.setSlider = function (min, max, value) {
            this._value = -1;
            this._min = min;
            this._max = max > min ? max : min;
            this.value = value < min ? min : value > max ? max : value;
        };
        __proto.changeValue = function () {
            var pow = Math.pow(10, (this._tick + "").length - 1);
            this._value = Math.round(Math.round(this._value / this._tick) * this._tick * pow) / pow;
            this._value = this._value > this._max ? this._max : this._value < this._min ? this._min : this._value;
            var num = this._max - this._min;
            if (num === 0)
                num = 1;
            if (this.isVertical) {
                this._bar.y = (this._value - this._min) / num * (this.height - this._bar.height);
                if (this._progress)
                    this._progress.height = this._bar.y + 0.5 * this._bar.height;
            }
            else {
                this._bar.x = (this._value - this._min) / num * (this.width - this._bar.width);
                if (this._progress)
                    this._progress.width = this._bar.x + 0.5 * this._bar.width;
            }
        };
        __proto.onBgMouseDown = function (e) {
            var point = this._bg.getMousePoint();
            if (this.isVertical)
                this.value = point.y / (this.height - this._bar.height) * (this._max - this._min) + this._min;
            else
                this.value = point.x / (this.width - this._bar.width) * (this._max - this._min) + this._min;
        };
        __getset(0, __proto, 'measureHeight', function () {
            return Math.max(this._bg.height, this._bar.height);
        });
        __getset(0, __proto, 'skin', function () {
            return this._skin;
        }, function (value) {
            if (this._skin != value) {
                this._skin = value;
                this._bg.skin = this._skin;
                this._bar.skin = this._skin.replace(".png", "$bar.png");
                var progressSkin = this._skin.replace(".png", "$progress.png");
                if (Loader.getRes(progressSkin)) {
                    if (!this._progress) {
                        this.addChild(this._progress = new Image());
                        this._progress.sizeGrid = this._bar.sizeGrid;
                        this.setChildIndex(this._progress, 1);
                    }
                    this._progress.skin = progressSkin;
                }
                this.setBarPoint();
                this.callLater(this.changeValue);
            }
        });
        __getset(0, __proto, 'allowClickBack', function () {
            return this._allowClickBack;
        }, function (value) {
            if (this._allowClickBack != value) {
                this._allowClickBack = value;
                if (value)
                    this._bg.on("mousedown", this, this.onBgMouseDown);
                else
                    this._bg.off("mousedown", this, this.onBgMouseDown);
            }
        });
        __getset(0, __proto, 'max', function () {
            return this._max;
        }, function (value) {
            if (this._max != value) {
                this._max = value;
                this.callLater(this.changeValue);
            }
        });
        __getset(0, __proto, 'measureWidth', function () {
            return Math.max(this._bg.width, this._bar.width);
        });
        __getset(0, __proto, 'tick', function () {
            return this._tick;
        }, function (value) {
            if (this._tick != value) {
                this._tick = value;
                this.callLater(this.changeValue);
            }
        });
        __getset(0, __proto, 'sizeGrid', function () {
            return this._bg.sizeGrid;
        }, function (value) {
            this._bg.sizeGrid = value;
            this._bar.sizeGrid = value;
            if (this._progress)
                this._progress.sizeGrid = this._bar.sizeGrid;
        });
        __getset(0, __proto, 'min', function () {
            return this._min;
        }, function (value) {
            if (this._min != value) {
                this._min = value;
                this.callLater(this.changeValue);
            }
        });
        __getset(0, __proto, 'value', function () {
            return this._value;
        }, function (num) {
            if (this._value != num) {
                var oldValue = this._value;
                this._value = num;
                this.changeValue();
                if (this._value != oldValue) {
                    this.sendChangeEvent();
                }
            }
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if ((typeof value == 'number') || (typeof value == 'string'))
                this.value = Number(value);
            else
                Laya.superSet(Component, this, 'dataSource', value);
        });
        __getset(0, __proto, 'bar', function () {
            return this._bar;
        });
        __static(Slider, ['label', function () { return this.label = new Label(); }
        ]);
        return Slider;
    })(Component);
    var Image = (function (_super) {
        function Image(skin) {
            this._bitmap = null;
            this._skin = null;
            this._group = null;
            Image.__super.call(this);
            this.skin = skin;
        }
        __class(Image, 'laya.ui.Image', _super);
        var __proto = Image.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, true);
            this._bitmap && this._bitmap.destroy();
            this._bitmap = null;
        };
        __proto.dispose = function () {
            this.destroy(true);
            Laya.loader.clearRes(this._skin);
        };
        __proto.createChildren = function () {
            this.graphics = this._bitmap = new AutoBitmap();
            this._bitmap.autoCacheCmd = false;
        };
        __proto.setSource = function (url, img) {
            if (url === this._skin && img) {
                this.source = img;
                this.onCompResize();
            }
        };
        __getset(0, __proto, 'source', function () {
            return this._bitmap.source;
        }, function (value) {
            if (!this._bitmap)
                return;
            this._bitmap.source = value;
            this.event("loaded");
            this.repaint();
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if ((typeof value == 'string'))
                this.skin = value;
            else
                Laya.superSet(Component, this, 'dataSource', value);
        });
        __getset(0, __proto, 'measureHeight', function () {
            return this._bitmap.height;
        });
        __getset(0, __proto, 'skin', function () {
            return this._skin;
        }, function (value) {
            if (this._skin != value) {
                this._skin = value;
                if (value) {
                    var source = Loader.getRes(value);
                    if (source) {
                        this.source = source;
                        this.onCompResize();
                    }
                    else
                        Laya.loader.load(this._skin, Handler.create(this, this.setSource, [this._skin]), null, "image", 1, true, this._group);
                }
                else {
                    this.source = null;
                }
            }
        });
        __getset(0, __proto, 'group', function () {
            return this._group;
        }, function (value) {
            if (value && this._skin)
                Loader.setGroup(this._skin, value);
            this._group = value;
        });
        __getset(0, __proto, 'sizeGrid', function () {
            if (this._bitmap.sizeGrid)
                return this._bitmap.sizeGrid.join(",");
            return null;
        }, function (value) {
            this._bitmap.sizeGrid = UIUtils.fillArray(Styles.defaultSizeGrid, value, Number);
        });
        __getset(0, __proto, 'measureWidth', function () {
            return this._bitmap.width;
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            Laya.superSet(Component, this, 'width', value);
            this._bitmap.width = value == 0 ? 0.0000001 : value;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(Component, this, 'height', value);
            this._bitmap.height = value == 0 ? 0.0000001 : value;
        });
        return Image;
    })(Component);
    var Label = (function (_super) {
        function Label(text) {
            this._tf = null;
            Label.__super.call(this);
            (text === void 0) && (text = "");
            Font.defaultColor = Styles.labelColor;
            this.text = text;
        }
        __class(Label, 'laya.ui.Label', _super);
        var __proto = Label.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._tf = null;
        };
        __proto.createChildren = function () {
            this.addChild(this._tf = new Text());
        };
        __proto.changeText = function (text) {
            this._tf.changeText(text);
        };
        __getset(0, __proto, 'padding', function () {
            return this._tf.padding.join(",");
        }, function (value) {
            this._tf.padding = UIUtils.fillArray(Styles.labelPadding, value, Number);
        });
        __getset(0, __proto, 'bold', function () {
            return this._tf.bold;
        }, function (value) {
            this._tf.bold = value;
        });
        __getset(0, __proto, 'align', function () {
            return this._tf.align;
        }, function (value) {
            this._tf.align = value;
        });
        __getset(0, __proto, 'text', function () {
            return this._tf.text;
        }, function (value) {
            if (this._tf.text != value) {
                if (value)
                    value = UIUtils.adptString(value + "");
                this._tf.text = value;
                this.event("change");
                if (!this._width || !this._height)
                    this.onCompResize();
            }
        });
        __getset(0, __proto, 'italic', function () {
            return this._tf.italic;
        }, function (value) {
            this._tf.italic = value;
        });
        __getset(0, __proto, 'wordWrap', function () {
            return this._tf.wordWrap;
        }, function (value) {
            this._tf.wordWrap = value;
        });
        __getset(0, __proto, 'font', function () {
            return this._tf.font;
        }, function (value) {
            this._tf.font = value;
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if ((typeof value == 'number') || (typeof value == 'string'))
                this.text = value + "";
            else
                Laya.superSet(Component, this, 'dataSource', value);
        });
        __getset(0, __proto, 'color', function () {
            return this._tf.color;
        }, function (value) {
            this._tf.color = value;
        });
        __getset(0, __proto, 'valign', function () {
            return this._tf.valign;
        }, function (value) {
            this._tf.valign = value;
        });
        __getset(0, __proto, 'leading', function () {
            return this._tf.leading;
        }, function (value) {
            this._tf.leading = value;
        });
        __getset(0, __proto, 'letterSpacing', function () {
            return this._tf.letterSpacing;
        }, function (value) {
            this._tf.letterSpacing = value;
        });
        __getset(0, __proto, 'fontSize', function () {
            return this._tf.fontSize;
        }, function (value) {
            this._tf.fontSize = value;
        });
        __getset(0, __proto, 'bgColor', function () {
            return this._tf.bgColor;
        }, function (value) {
            this._tf.bgColor = value;
        });
        __getset(0, __proto, 'borderColor', function () {
            return this._tf.borderColor;
        }, function (value) {
            this._tf.borderColor = value;
        });
        __getset(0, __proto, 'stroke', function () {
            return this._tf.stroke;
        }, function (value) {
            this._tf.stroke = value;
        });
        __getset(0, __proto, 'strokeColor', function () {
            return this._tf.strokeColor;
        }, function (value) {
            this._tf.strokeColor = value;
        });
        __getset(0, __proto, 'textField', function () {
            return this._tf;
        });
        __getset(0, __proto, 'measureWidth', function () {
            return this._tf.width;
        });
        __getset(0, __proto, 'measureHeight', function () {
            return this._tf.height;
        });
        __getset(0, __proto, 'width', function () {
            if (this._width || this._tf.text) {
                return Laya.superGet(Component, this, 'width');
            }
            return 0;
        }, function (value) {
            Laya.superSet(Component, this, 'width', value);
            this._tf.width = value;
        });
        __getset(0, __proto, 'height', function () {
            if (this._height || this._tf.text) {
                return Laya.superGet(Component, this, 'height');
            }
            return 0;
        }, function (value) {
            Laya.superSet(Component, this, 'height', value);
            this._tf.height = value;
        });
        __getset(0, __proto, 'overflow', function () {
            return this._tf.overflow;
        }, function (value) {
            this._tf.overflow = value;
        });
        __getset(0, __proto, 'underline', function () {
            return this._tf.underline;
        }, function (value) {
            this._tf.underline = value;
        });
        __getset(0, __proto, 'underlineColor', function () {
            return this._tf.underlineColor;
        }, function (value) {
            this._tf.underlineColor = value;
        });
        return Label;
    })(Component);
    var ProgressBar = (function (_super) {
        function ProgressBar(skin) {
            this.changeHandler = null;
            this._bg = null;
            this._bar = null;
            this._skin = null;
            this._value = 0.5;
            ProgressBar.__super.call(this);
            this.skin = skin;
        }
        __class(ProgressBar, 'laya.ui.ProgressBar', _super);
        var __proto = ProgressBar.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._bg && this._bg.destroy(destroyChild);
            this._bar && this._bar.destroy(destroyChild);
            this._bg = this._bar = null;
            this.changeHandler = null;
        };
        __proto.createChildren = function () {
            this.addChild(this._bg = new Image());
            this.addChild(this._bar = new Image());
            this._bar._bitmap.autoCacheCmd = false;
        };
        __proto.changeValue = function () {
            if (this.sizeGrid) {
                var grid = this.sizeGrid.split(",");
                var left = Number(grid[3]);
                var right = Number(grid[1]);
                var max = this.width - left - right;
                var sw = max * this._value;
                this._bar.width = left + right + sw;
                this._bar.visible = this._bar.width > left + right;
            }
            else {
                this._bar.width = this.width * this._value;
            }
        };
        __getset(0, __proto, 'measureHeight', function () {
            return this._bg.height;
        });
        __getset(0, __proto, 'skin', function () {
            return this._skin;
        }, function (value) {
            if (this._skin != value) {
                this._skin = value;
                this._bg.skin = this._skin;
                this._bar.skin = this._skin.replace(".png", "$bar.png");
                this.callLater(this.changeValue);
            }
        });
        __getset(0, __proto, 'measureWidth', function () {
            return this._bg.width;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(Component, this, 'height', value);
            this._bg.height = this._height;
            this._bar.height = this._height;
        });
        __getset(0, __proto, 'bar', function () {
            return this._bar;
        });
        __getset(0, __proto, 'value', function () {
            return this._value;
        }, function (num) {
            if (this._value != num) {
                num = num > 1 ? 1 : num < 0 ? 0 : num;
                this._value = num;
                this.callLater(this.changeValue);
                this.event("change");
                this.changeHandler && this.changeHandler.runWith(num);
            }
        });
        __getset(0, __proto, 'bg', function () {
            return this._bg;
        });
        __getset(0, __proto, 'sizeGrid', function () {
            return this._bg.sizeGrid;
        }, function (value) {
            this._bg.sizeGrid = this._bar.sizeGrid = value;
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            Laya.superSet(Component, this, 'width', value);
            this._bg.width = this._width;
            this.callLater(this.changeValue);
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if ((typeof value == 'number') || (typeof value == 'string'))
                this.value = Number(value);
            else
                Laya.superSet(Component, this, 'dataSource', value);
        });
        return ProgressBar;
    })(Component);
    var TipManager = (function (_super) {
        function TipManager() {
            this._tipBox = null;
            this._tipText = null;
            this._defaultTipHandler = null;
            TipManager.__super.call(this);
            this._tipBox = new Component();
            this._tipBox.addChild(this._tipText = new Text());
            this._tipText.x = this._tipText.y = 5;
            this._tipText.color = TipManager.tipTextColor;
            this._defaultTipHandler = this._showDefaultTip;
            Laya.stage.on("showtip", this, this._onStageShowTip);
            Laya.stage.on("hidetip", this, this._onStageHideTip);
            this.zOrder = 1100;
        }
        __class(TipManager, 'laya.ui.TipManager', _super);
        var __proto = TipManager.prototype;
        __proto._onStageHideTip = function (e) {
            Laya.timer.clear(this, this._showTip);
            this.closeAll();
            this.removeSelf();
        };
        __proto._onStageShowTip = function (data) {
            Laya.timer.once(TipManager.tipDelay, this, this._showTip, [data], true);
        };
        __proto._showTip = function (tip) {
            if ((typeof tip == 'string')) {
                var text = String(tip);
                if (Boolean(text)) {
                    this._defaultTipHandler(text);
                }
            }
            else if ((tip instanceof laya.utils.Handler)) {
                (tip).run();
            }
            else if ((typeof tip == 'function')) {
                (tip).apply();
            }
            if (true) {
                Laya.stage.on("mousemove", this, this._onStageMouseMove);
                Laya.stage.on("mousedown", this, this._onStageMouseDown);
            }
            this._onStageMouseMove(null);
        };
        __proto._onStageMouseDown = function (e) {
            this.closeAll();
        };
        __proto._onStageMouseMove = function (e) {
            this._showToStage(this, TipManager.offsetX, TipManager.offsetY);
        };
        __proto._showToStage = function (dis, offX, offY) {
            (offX === void 0) && (offX = 0);
            (offY === void 0) && (offY = 0);
            var rec = dis.getBounds();
            dis.x = Laya.stage.mouseX + offX;
            dis.y = Laya.stage.mouseY + offY;
            if (dis.x + rec.width > Laya.stage.width) {
                dis.x -= rec.width + offX;
            }
            if (dis.y + rec.height > Laya.stage.height) {
                dis.y -= rec.height + offY;
            }
        };
        __proto.closeAll = function () {
            Laya.timer.clear(this, this._showTip);
            Laya.stage.off("mousemove", this, this._onStageMouseMove);
            Laya.stage.off("mousedown", this, this._onStageMouseDown);
            this.removeChildren();
        };
        __proto.showDislayTip = function (tip) {
            this.addChild(tip);
            this._showToStage(this);
            Laya._currentStage.addChild(this);
        };
        __proto._showDefaultTip = function (text) {
            this._tipText.text = text;
            var g = this._tipBox.graphics;
            g.clear();
            g.drawRect(0, 0, this._tipText.width + 10, this._tipText.height + 10, TipManager.tipBackColor);
            this.addChild(this._tipBox);
            this._showToStage(this);
            Laya._currentStage.addChild(this);
        };
        __getset(0, __proto, 'defaultTipHandler', function () {
            return this._defaultTipHandler;
        }, function (value) {
            this._defaultTipHandler = value;
        });
        TipManager.offsetX = 10;
        TipManager.offsetY = 15;
        TipManager.tipTextColor = "#ffffff";
        TipManager.tipBackColor = "#111111";
        TipManager.tipDelay = 200;
        return TipManager;
    })(Component);
    var View = (function (_super) {
        var DataWatcher;
        function View() {
            this._idMap = null;
            this._aniList = null;
            this._watchMap = {};
            View.__super.call(this);
        }
        __class(View, 'laya.ui.View', _super);
        var __proto = View.prototype;
        __proto.createView = function (uiView) {
            if (uiView.animations && !this._idMap)
                this._idMap = {};
            View.createComp(uiView, this, this);
            if (uiView.animations) {
                var anilist = [];
                var animations = uiView.animations;
                var i = 0, len = animations.length;
                var tAni;
                var tAniO;
                for (i = 0; i < len; i++) {
                    tAni = new FrameAnimation();
                    tAniO = animations[i];
                    tAni._setUp(this._idMap, tAniO);
                    this[tAniO.name] = tAni;
                    tAni._setControlNode(this);
                    switch (tAniO.action) {
                        case 1:
                            tAni.play(0, false);
                            break;
                        case 2:
                            tAni.play(0, true);
                            break;
                    }
                    anilist.push(tAni);
                }
                this._aniList = anilist;
            }
            if (this._width > 0 && uiView.props.hitTestPrior == null && !this.mouseThrough)
                this.hitTestPrior = true;
        };
        __proto.onEvent = function (type, event) { };
        __proto.loadUI = function (path) {
            var uiView = View.uiMap[path];
            uiView && this.createView(uiView);
        };
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            if (this._aniList)
                this._aniList.length = 0;
            this._idMap = null;
            this._aniList = null;
            this._watchMap = null;
            laya.ui.Component.prototype.destroy.call(this, destroyChild);
        };
        __proto.changeData = function (key) {
            var arr = this._watchMap[key];
            if (!arr)
                return;
            console_log("change", key);
            for (var i = 0, n = arr.length; i < n; i++) {
                var watcher = arr[i];
                watcher.exe(this);
            }
        };
        View._regs = function () {
            for (var key in View.uiClassMap) {
                ClassUtils.regClass(key, View.uiClassMap[key]);
            }
        };
        View.createComp = function (uiView, comp, view, dataMap) {
            comp = comp || View.getCompInstance(uiView);
            if (!comp) {
                console_warn("can not create:" + uiView.type);
                return null;
            }
            ;
            var child = uiView.child;
            if (child) {
                var isList = (comp instanceof laya.ui.List);
                for (var i = 0, n = child.length; i < n; i++) {
                    var node = child[i];
                    if (comp.hasOwnProperty("itemRender") && (node.props.name == "render" || node.props.renderType === "render")) {
                        (comp).itemRender = node;
                    }
                    else if (node.type == "Graphic") {
                        ClassUtils.addGraphicsToSprite(node, comp);
                    }
                    else if (ClassUtils.isDrawType(node.type)) {
                        ClassUtils.addGraphicToSprite(node, comp, true);
                    }
                    else {
                        if (isList) {
                            var arr = [];
                            var tChild = View.createComp(node, null, view, arr);
                            if (arr.length)
                                tChild["_$bindData"] = arr;
                        }
                        else {
                            tChild = View.createComp(node, null, view, dataMap);
                        }
                        if (node.type == "Script") {
                            if ("owner" in tChild) {
                                tChild["owner"] = comp;
                            }
                            else if ("target" in tChild) {
                                tChild["target"] = comp;
                            }
                        }
                        else if (node.props.renderType == "mask" || node.props.name == "mask") {
                            comp.mask = tChild;
                        }
                        else {
                            (tChild instanceof laya.display.Sprite) && comp.addChild(tChild);
                        }
                    }
                }
            }
            ;
            var props = uiView.props;
            for (var prop in props) {
                var value = props[prop];
                if (View.eventDic[prop]) {
                    if (value && view) {
                        (comp).on(prop, view, view.onEvent, [value]);
                    }
                }
                else
                    View.setCompValue(comp, prop, value, view, dataMap);
            }
            if (Laya.__typeof(comp, 'laya.ui.IItem'))
                (comp).initItems();
            if (uiView.compId && view && view._idMap) {
                view._idMap[uiView.compId] = comp;
            }
            return comp;
        };
        View.setCompValue = function (comp, prop, value, view, dataMap) {
            if ((typeof value == 'string') && value.indexOf("${") > -1) {
                View._sheet || (View._sheet = ClassUtils.getClass("laya.data.Table"));
                if (!View._sheet) {
                    console_warn("Can not find class Sheet");
                    return;
                }
                if (dataMap) {
                    dataMap.push(comp, prop, value);
                }
                else if (view) {
                    if (value.indexOf("].") == -1) {
                        value = value.replace(".", "[0].");
                    }
                    ;
                    var watcher = new DataWatcher(comp, prop, value);
                    watcher.exe(view);
                    var one, temp;
                    var str = value.replace(/\[.*?\]\./g, ".");
                    while ((one = View._parseWatchData.exec(str)) != null) {
                        var key1 = one[1];
                        while ((temp = View._parseKeyWord.exec(key1)) != null) {
                            var key2 = temp[0];
                            var arr = (view._watchMap[key2] || (view._watchMap[key2] = []));
                            arr.push(watcher);
                            View._sheet.I.notifer.on(key2, view, view.changeData, [key2]);
                        }
                        arr = (view._watchMap[key1] || (view._watchMap[key1] = []));
                        arr.push(watcher);
                        View._sheet.I.notifer.on(key1, view, view.changeData, [key1]);
                    }
                }
                return;
            }
            if (prop === "var" && view) {
                view[value] = comp;
            }
            else if (prop == "onClick") {
                var fun = Browser.window.eval("(function(){" + value + "})");
                comp.on("click", view, fun);
            }
            else {
                comp[prop] = (value === "true" ? true : (value === "false" ? false : value));
            }
        };
        View.getCompInstance = function (json) {
            var runtime = json.props ? json.props.runtime : null;
            var compClass;
            compClass = runtime ? (View.viewClassMap[runtime] || View.uiClassMap[runtime] || Laya["__classmap"][runtime]) : View.uiClassMap[json.type];
            if (json.props && json.props.hasOwnProperty("renderType") && json.props["renderType"] == "instance")
                return compClass["instance"];
            return compClass ? new compClass() : null;
        };
        View.regComponent = function (key, compClass) {
            View.uiClassMap[key] = compClass;
            ClassUtils.regClass(key, compClass);
        };
        View.regViewRuntime = function (key, compClass) {
            View.viewClassMap[key] = compClass;
        };
        View.uiMap = {};
        View.viewClassMap = {};
        View._sheet = null;
        __static(View, ['uiClassMap', function () { return this.uiClassMap = { "ViewStack": ViewStack, "LinkButton": Button, "TextArea": TextArea, "ColorPicker": ColorPicker, "Box": Box, "Button": Button, "CheckBox": CheckBox, "Clip": Clip, "ComboBox": ComboBox, "Component": Component, "HScrollBar": HScrollBar, "HSlider": HSlider, "Image": Image, "Label": Label, "List": List, "Panel": Panel, "ProgressBar": ProgressBar, "Radio": Radio, "RadioGroup": RadioGroup, "ScrollBar": ScrollBar, "Slider": Slider, "Tab": Tab, "TextInput": TextInput, "View": View, "VScrollBar": VScrollBar, "VSlider": VSlider, "Tree": Tree, "HBox": HBox, "VBox": VBox, "Sprite": Sprite, "Animation": Animation, "Text": Text, "FontClip": FontClip }; }, 'eventDic', function () { return this.eventDic = { "mousedown": true, "mouseup": true, "mousemove": true, "mouseover": true, "mouseout": true, "click": true, "doubleclick": true, "rightmousedown": true, "rightmouseup": true, "rightclick": true }; }, '_parseWatchData', function () { return this._parseWatchData = /\${(.*?)}/g; }, '_parseKeyWord', function () { return this._parseKeyWord = /[a-zA-Z_][a-zA-Z0-9_]*(?:(?:\.[a-zA-Z_][a-zA-Z0-9_]*)+)/g; }
        ]);
        View.__init$ = function () {
            View._regs();
            DataWatcher = (function () {
                function DataWatcher(comp, prop, value) {
                    this.comp = null;
                    this.prop = null;
                    this.value = null;
                    this.comp = comp;
                    this.prop = prop;
                    this.value = value;
                }
                __class(DataWatcher, '');
                var __proto = DataWatcher.prototype;
                __proto.exe = function (view) {
                    var fun = UIUtils.getBindFun(this.value);
                    this.comp[this.prop] = fun.call(this, view);
                };
                return DataWatcher;
            })();
        };
        return View;
    })(Box);
    var CheckBox = (function (_super) {
        function CheckBox(skin, label) {
            (label === void 0) && (label = "");
            CheckBox.__super.call(this, skin, label);
        }
        __class(CheckBox, 'laya.ui.CheckBox', _super);
        var __proto = CheckBox.prototype;
        __proto.preinitialize = function () {
            laya.ui.Component.prototype.preinitialize.call(this);
            this.toggle = true;
            this._autoSize = false;
        };
        __proto.initialize = function () {
            _super.prototype.initialize.call(this);
            this.createText();
            this._text.align = "left";
            this._text.valign = "top";
            this._text.width = 0;
        };
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if ((typeof value == 'boolean'))
                this.selected = value;
            else if ((typeof value == 'string'))
                this.selected = value === "true";
            else
                Laya.superSet(Button, this, 'dataSource', value);
        });
        return CheckBox;
    })(Button);
    var LayoutBox = (function (_super) {
        function LayoutBox() {
            this._space = 0;
            this._align = "none";
            this._itemChanged = false;
            LayoutBox.__super.call(this);
        }
        __class(LayoutBox, 'laya.ui.LayoutBox', _super);
        var __proto = LayoutBox.prototype;
        __proto.addChild = function (child) {
            child.on("resize", this, this.onResize);
            this._setItemChanged();
            return laya.display.Node.prototype.addChild.call(this, child);
        };
        __proto.onResize = function (e) {
            this._setItemChanged();
        };
        __proto.addChildAt = function (child, index) {
            child.on("resize", this, this.onResize);
            this._setItemChanged();
            return laya.display.Node.prototype.addChildAt.call(this, child, index);
        };
        __proto.removeChild = function (child) {
            child.off("resize", this, this.onResize);
            this._setItemChanged();
            return laya.display.Node.prototype.removeChild.call(this, child);
        };
        __proto.removeChildAt = function (index) {
            this.getChildAt(index).off("resize", this, this.onResize);
            this._setItemChanged();
            return laya.display.Node.prototype.removeChildAt.call(this, index);
        };
        __proto.refresh = function () {
            this._setItemChanged();
        };
        __proto.changeItems = function () {
            this._itemChanged = false;
        };
        __proto.sortItem = function (items) {
            if (items)
                items.sort(function (a, b) { return a.y - b.y; });
        };
        __proto._setItemChanged = function () {
            if (!this._itemChanged) {
                this._itemChanged = true;
                this.callLater(this.changeItems);
            }
        };
        __getset(0, __proto, 'space', function () {
            return this._space;
        }, function (value) {
            this._space = value;
            this._setItemChanged();
        });
        __getset(0, __proto, 'align', function () {
            return this._align;
        }, function (value) {
            this._align = value;
            this._setItemChanged();
        });
        return LayoutBox;
    })(Box);
    var FontClip = (function (_super) {
        function FontClip(skin, sheet) {
            this._valueArr = null;
            this._indexMap = null;
            this._sheet = null;
            this._direction = "horizontal";
            this._spaceX = 0;
            this._spaceY = 0;
            this._align = "left";
            this._wordsW = 0;
            this._wordsH = 0;
            FontClip.__super.call(this);
            if (skin)
                this.skin = skin;
            if (sheet)
                this.sheet = sheet;
        }
        __class(FontClip, 'laya.ui.FontClip', _super);
        var __proto = FontClip.prototype;
        __proto.createChildren = function () {
            this._bitmap = new AutoBitmap();
            this.on("loaded", this, this._onClipLoaded);
        };
        __proto._onClipLoaded = function () {
            this.callLater(this.changeValue);
        };
        __proto.changeValue = function () {
            if (!this._sources)
                return;
            if (!this._valueArr)
                return;
            this.graphics.clear(true);
            var texture;
            texture = this._sources[0];
            if (!texture)
                return;
            var isHorizontal = (this._direction === "horizontal");
            if (isHorizontal) {
                this._wordsW = this._valueArr.length * (texture.sourceWidth + this.spaceX);
                this._wordsH = texture.sourceHeight;
            }
            else {
                this._wordsW = texture.sourceWidth;
                this._wordsH = (texture.sourceHeight + this.spaceY) * this._valueArr.length;
            }
            ;
            var dX = 0;
            if (this._width) {
                switch (this._align) {
                    case "center":
                        dX = 0.5 * (this._width - this._wordsW);
                        break;
                    case "right":
                        dX = this._width - this._wordsW;
                        break;
                    default:
                        dX = 0;
                }
            }
            for (var i = 0, sz = this._valueArr.length; i < sz; i++) {
                var index = this._indexMap[this._valueArr.charAt(i)];
                if (!this.sources[index])
                    continue;
                texture = this.sources[index];
                if (isHorizontal)
                    this.graphics.drawTexture(texture, dX + i * (texture.sourceWidth + this.spaceX), 0, texture.sourceWidth, texture.sourceHeight);
                else
                    this.graphics.drawTexture(texture, 0 + dX, i * (texture.sourceHeight + this.spaceY), texture.sourceWidth, texture.sourceHeight);
            }
            if (!this._width) {
                this.resetLayoutX();
                this.callLater(this.changeSize);
            }
            if (!this._height) {
                this.resetLayoutY();
                this.callLater(this.changeSize);
            }
        };
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            this._valueArr = null;
            this._indexMap = null;
            this.graphics.clear(true);
            this.removeSelf();
            this.off("loaded", this, this._onClipLoaded);
            _super.prototype.destroy.call(this, destroyChild);
        };
        __getset(0, __proto, 'sheet', function () {
            return this._sheet;
        }, function (value) {
            value += "";
            this._sheet = value;
            var arr = value.split(" ");
            this._clipX = String(arr[0]).length;
            this.clipY = arr.length;
            this._indexMap = {};
            for (var i = 0; i < this._clipY; i++) {
                var line = arr[i].split("");
                for (var j = 0, n = line.length; j < n; j++) {
                    this._indexMap[line[j]] = i * this._clipX + j;
                }
            }
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(Clip, this, 'height', value);
            this.callLater(this.changeValue);
        });
        __getset(0, __proto, 'direction', function () {
            return this._direction;
        }, function (value) {
            this._direction = value;
            this.callLater(this.changeValue);
        });
        __getset(0, __proto, 'value', function () {
            if (!this._valueArr)
                return "";
            return this._valueArr;
        }, function (value) {
            value += "";
            this._valueArr = value;
            this.callLater(this.changeValue);
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            Laya.superSet(Clip, this, 'width', value);
            this.callLater(this.changeValue);
        });
        __getset(0, __proto, 'spaceX', function () {
            return this._spaceX;
        }, function (value) {
            this._spaceX = value;
            if (this._direction === "horizontal")
                this.callLater(this.changeValue);
        });
        __getset(0, __proto, 'spaceY', function () {
            return this._spaceY;
        }, function (value) {
            this._spaceY = value;
            if (!(this._direction === "horizontal"))
                this.callLater(this.changeValue);
        });
        __getset(0, __proto, 'align', function () {
            return this._align;
        }, function (v) {
            this._align = v;
            this.callLater(this.changeValue);
        });
        __getset(0, __proto, 'measureWidth', function () {
            return this._wordsW;
        });
        __getset(0, __proto, 'measureHeight', function () {
            return this._wordsH;
        });
        return FontClip;
    })(Clip);
    var List = (function (_super) {
        function List() {
            this.selectHandler = null;
            this.renderHandler = null;
            this.mouseHandler = null;
            this.selectEnable = false;
            this.totalPage = 0;
            this._content = null;
            this._scrollBar = null;
            this._itemRender = null;
            this._repeatX = 0;
            this._repeatY = 0;
            this._repeatX2 = 0;
            this._repeatY2 = 0;
            this._spaceX = 0;
            this._spaceY = 0;
            this._array = null;
            this._startIndex = 0;
            this._selectedIndex = -1;
            this._page = 0;
            this._isVertical = true;
            this._cellSize = 20;
            this._cellOffset = 0;
            this._isMoved = false;
            this.cacheContent = false;
            this._createdLine = 0;
            this._cellChanged = false;
            List.__super.call(this);
            this._cells = [];
            this._offset = new Point();
        }
        __class(List, 'laya.ui.List', _super);
        var __proto = List.prototype;
        Laya.imps(__proto, { "laya.ui.IRender": true, "laya.ui.IItem": true });
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            this._content && this._content.destroy(destroyChild);
            this._scrollBar && this._scrollBar.destroy(destroyChild);
            laya.ui.Component.prototype.destroy.call(this, destroyChild);
            this._content = null;
            this._scrollBar = null;
            this._itemRender = null;
            this._cells = null;
            this._array = null;
            this.selectHandler = this.renderHandler = this.mouseHandler = null;
        };
        __proto.createChildren = function () {
            this.addChild(this._content = new Box());
        };
        __proto.onScrollStart = function () {
            this._$P.cacheAs || (this._$P.cacheAs = Laya.superGet(Box, this, 'cacheAs'));
            Laya.superSet(Box, this, 'cacheAs', "none");
            this._scrollBar.once("end", this, this.onScrollEnd);
        };
        __proto.onScrollEnd = function () {
            Laya.superSet(Box, this, 'cacheAs', this._$P.cacheAs);
        };
        __proto._removePreScrollBar = function () {
            var preNode = this.removeChildByName("scrollBar");
            if (preNode)
                preNode.destroy(true);
        };
        __proto.changeCells = function () {
            this._cellChanged = false;
            if (this._itemRender) {
                this.scrollBar = this.getChildByName("scrollBar");
                var cell = this._getOneCell();
                var cellWidth = (cell.width + this._spaceX) || 1;
                var cellHeight = (cell.height + this._spaceY) || 1;
                if (this._width > 0)
                    this._repeatX2 = this._isVertical ? Math.round(this._width / cellWidth) : Math.ceil(this._width / cellWidth);
                if (this._height > 0)
                    this._repeatY2 = this._isVertical ? Math.ceil(this._height / cellHeight) : Math.round(this._height / cellHeight);
                var listWidth = this._width ? this._width : (cellWidth * this.repeatX - this._spaceX);
                var listHeight = this._height ? this._height : (cellHeight * this.repeatY - this._spaceY);
                this._cellSize = this._isVertical ? cellHeight : cellWidth;
                this._cellOffset = this._isVertical ? (cellHeight * Math.max(this._repeatY2, this._repeatY) - listHeight - this._spaceY + this._offset.y) : (cellWidth * Math.max(this._repeatX2, this._repeatX) - listWidth - this._spaceX + this._offset.x);
                if (this._isVertical && this._scrollBar)
                    this._scrollBar.height = listHeight;
                else if (!this._isVertical && this._scrollBar)
                    this._scrollBar.width = listWidth;
                if (this._scrollBar)
                    this._scrollBar.thumbPercent = 1;
                this.setContentSize(listWidth, listHeight);
                var numX = this._isVertical ? this.repeatX : this.repeatY;
                var numY = (this._isVertical ? this.repeatY : this.repeatX) + (this._scrollBar ? 1 : 0);
                this._createItems(0, numX, numY);
                this._createdLine = numY;
                if (this._array) {
                    this.array = this._array;
                    this.runCallLater(this.renderItems);
                }
                if (this._scrollBar)
                    this._scrollBar.right = 0;
            }
        };
        __proto._getOneCell = function () {
            if (this._cells.length === 0) {
                var item = this.createItem();
                this._offset.setTo(item.x, item.y);
                if (this.cacheContent)
                    return item;
                this._cells.push(item);
            }
            return this._cells[0];
        };
        __proto._createItems = function (startY, numX, numY) {
            var box = this._content;
            var cell = this._getOneCell();
            var cellWidth = cell.width + this._spaceX;
            var cellHeight = cell.height + this._spaceY;
            if (this.cacheContent) {
                var cacheBox = new Box();
                cacheBox.cacheAsBitmap = true;
                cacheBox.pos((this._isVertical ? 0 : startY) * cellWidth, (this._isVertical ? startY : 0) * cellHeight);
                this._content.addChild(cacheBox);
                this._content.optimizeScrollRect = true;
                box = cacheBox;
            }
            else {
                var arr = [];
                for (var i = this._cells.length - 1; i > -1; i--) {
                    var item = this._cells[i];
                    item.removeSelf();
                    arr.push(item);
                }
                this._cells.length = 0;
            }
            for (var k = startY; k < numY; k++) {
                for (var l = 0; l < numX; l++) {
                    if (arr && arr.length) {
                        cell = arr.pop();
                    }
                    else {
                        cell = this.createItem();
                    }
                    cell.x = (this._isVertical ? l : k) * cellWidth - box.x;
                    cell.y = (this._isVertical ? k : l) * cellHeight - box.y;
                    cell.name = "item" + (k * numX + l);
                    box.addChild(cell);
                    this.addCell(cell);
                }
            }
        };
        __proto.createItem = function () {
            var arr = [];
            if ((typeof this._itemRender == 'function')) {
                var box = new this._itemRender();
            }
            else {
                box = View.createComp(this._itemRender, null, null, arr);
            }
            if (arr.length == 0 && box._watchMap) {
                var watchMap = box._watchMap;
                for (var name in watchMap) {
                    var a = watchMap[name];
                    for (var i = 0; i < a.length; i++) {
                        var watcher = a[i];
                        arr.push(watcher.comp, watcher.prop, watcher.value);
                    }
                }
            }
            if (arr.length)
                box["_$bindData"] = arr;
            return box;
        };
        __proto.addCell = function (cell) {
            cell.on("click", this, this.onCellMouse);
            cell.on("rightclick", this, this.onCellMouse);
            cell.on("mouseover", this, this.onCellMouse);
            cell.on("mouseout", this, this.onCellMouse);
            cell.on("mousedown", this, this.onCellMouse);
            cell.on("mouseup", this, this.onCellMouse);
            this._cells.push(cell);
        };
        __proto.initItems = function () {
            if (!this._itemRender && this.getChildByName("item0") != null) {
                this.repeatX = 1;
                var count = 0;
                count = 0;
                for (var i = 0; i < 10000; i++) {
                    var cell = this.getChildByName("item" + i);
                    if (cell) {
                        this.addCell(cell);
                        count++;
                        continue;
                    }
                    break;
                }
                this.repeatY = count;
            }
        };
        __proto.setContentSize = function (width, height) {
            this._content.width = width;
            this._content.height = height;
            if (this._scrollBar || this._offset.x != 0 || this._offset.y != 0) {
                this._content.scrollRect || (this._content.scrollRect = new Rectangle());
                this._content.scrollRect.setTo(-this._offset.x, -this._offset.y, width, height);
                this._content.scrollRect = this._content.scrollRect;
            }
            this.event("resize");
        };
        __proto.onCellMouse = function (e) {
            if (e.type === "mousedown")
                this._isMoved = false;
            var cell = e.currentTarget;
            var index = this._startIndex + this._cells.indexOf(cell);
            if (index < 0)
                return;
            if (e.type === "click" || e.type === "rightclick") {
                if (this.selectEnable && !this._isMoved)
                    this.selectedIndex = index;
                else
                    this.changeCellState(cell, true, 0);
            }
            else if ((e.type === "mouseover" || e.type === "mouseout") && this._selectedIndex !== index) {
                this.changeCellState(cell, e.type === "mouseover", 0);
            }
            this.mouseHandler && this.mouseHandler.runWith([e, index]);
        };
        __proto.changeCellState = function (cell, visable, index) {
            var selectBox = cell.getChildByName("selectBox");
            if (selectBox) {
                this.selectEnable = true;
                selectBox.visible = visable;
                selectBox.index = index;
            }
        };
        __proto.changeSize = function () {
            laya.ui.Component.prototype.changeSize.call(this);
            this.setContentSize(this.width, this.height);
            if (this._scrollBar)
                this.callLater(this.onScrollBarChange);
        };
        __proto.onScrollBarChange = function (e) {
            this.runCallLater(this.changeCells);
            var scrollValue = this._scrollBar.value;
            var lineX = (this._isVertical ? this.repeatX : this.repeatY);
            var lineY = (this._isVertical ? this.repeatY : this.repeatX);
            var scrollLine = Math.floor(scrollValue / this._cellSize);
            if (!this.cacheContent) {
                var index = scrollLine * lineX;
                var num = 0;
                if (index > this._startIndex) {
                    num = index - this._startIndex;
                    var down = true;
                    var toIndex = this._startIndex + lineX * (lineY + 1);
                    this._isMoved = true;
                }
                else if (index < this._startIndex) {
                    num = this._startIndex - index;
                    down = false;
                    toIndex = this._startIndex - 1;
                    this._isMoved = true;
                }
                for (var i = 0; i < num; i++) {
                    if (down) {
                        var cell = this._cells.shift();
                        this._cells[this._cells.length] = cell;
                        var cellIndex = toIndex + i;
                    }
                    else {
                        cell = this._cells.pop();
                        this._cells.unshift(cell);
                        cellIndex = toIndex - i;
                    }
                    ;
                    var pos = Math.floor(cellIndex / lineX) * this._cellSize;
                    this._isVertical ? cell.y = pos : cell.x = pos;
                    this.renderItem(cell, cellIndex);
                }
                this._startIndex = index;
                this.changeSelectStatus();
            }
            else {
                num = (lineY + 1);
                if (this._createdLine - scrollLine < num) {
                    this._createItems(this._createdLine, lineX, this._createdLine + num);
                    this.renderItems(this._createdLine * lineX, 0);
                    this._createdLine += num;
                }
            }
            var r = this._content.scrollRect;
            if (!r)
                return;
            if (this._isVertical) {
                r.y = scrollValue - this._offset.y;
                r.x = -this._offset.x;
            }
            else {
                r.y = -this._offset.y;
                r.x = scrollValue - this._offset.x;
            }
            this._content.scrollRect = r;
        };
        __proto.posCell = function (cell, cellIndex) {
            if (!this._scrollBar)
                return;
            var lineX = (this._isVertical ? this.repeatX : this.repeatY);
            var lineY = (this._isVertical ? this.repeatY : this.repeatX);
            var pos = Math.floor(cellIndex / lineX) * this._cellSize;
            this._isVertical ? cell.y = pos : cell.x = pos;
        };
        __proto.changeSelectStatus = function () {
            for (var i = 0, n = this._cells.length; i < n; i++) {
                this.changeCellState(this._cells[i], this._selectedIndex === this._startIndex + i, 1);
            }
        };
        __proto.renderItems = function (from, to) {
            (from === void 0) && (from = 0);
            (to === void 0) && (to = 0);
            for (var i = from, n = to || this._cells.length; i < n; i++) {
                this.renderItem(this._cells[i], this._startIndex + i);
            }
            this.changeSelectStatus();
        };
        __proto.renderItem = function (cell, index) {
            if (this._array && index >= 0 && index < this._array.length) {
                cell.visible = true;
                if (cell._$bindData) {
                    cell._dataSource = this._array[index];
                    this._bindData(cell, this._array[index]);
                }
                else
                    cell.dataSource = this._array[index];
                if (!this.cacheContent) {
                    this.posCell(cell, index);
                }
                if (this.hasListener("render"))
                    this.event("render", [cell, index]);
                if (this.renderHandler)
                    this.renderHandler.runWith([cell, index]);
            }
            else {
                cell.visible = false;
                cell.dataSource = null;
            }
        };
        __proto._bindData = function (cell, data) {
            var arr = cell._$bindData;
            for (var i = 0, n = arr.length; i < n; i++) {
                var ele = arr[i++];
                var prop = arr[i++];
                var value = arr[i];
                var fun = UIUtils.getBindFun(value);
                ele[prop] = fun.call(this, data);
            }
        };
        __proto.refresh = function () {
            this.array = this._array;
        };
        __proto.getItem = function (index) {
            if (index > -1 && index < this._array.length) {
                return this._array[index];
            }
            return null;
        };
        __proto.changeItem = function (index, source) {
            if (index > -1 && index < this._array.length) {
                this._array[index] = source;
                if (index >= this._startIndex && index < this._startIndex + this._cells.length) {
                    this.renderItem(this.getCell(index), index);
                }
            }
        };
        __proto.setItem = function (index, source) {
            this.changeItem(index, source);
        };
        __proto.addItem = function (souce) {
            this._array.push(souce);
            this.array = this._array;
        };
        __proto.addItemAt = function (souce, index) {
            this._array.splice(index, 0, souce);
            this.array = this._array;
        };
        __proto.deleteItem = function (index) {
            this._array.splice(index, 1);
            this.array = this._array;
        };
        __proto.getCell = function (index) {
            this.runCallLater(this.changeCells);
            if (index > -1 && this._cells) {
                return this._cells[(index - this._startIndex) % this._cells.length];
            }
            return null;
        };
        __proto.scrollTo = function (index) {
            if (this._scrollBar) {
                var numX = this._isVertical ? this.repeatX : this.repeatY;
                this._scrollBar.value = Math.floor(index / numX) * this._cellSize;
            }
            else {
                this.startIndex = index;
            }
        };
        __proto.tweenTo = function (index, time, complete) {
            (time === void 0) && (time = 200);
            if (this._scrollBar) {
                var numX = this._isVertical ? this.repeatX : this.repeatY;
                Tween.to(this._scrollBar, { value: Math.floor(index / numX) * this._cellSize }, time, null, complete, 0, true);
            }
            else {
                this.startIndex = index;
                if (complete)
                    complete.run();
            }
        };
        __proto._setCellChanged = function () {
            if (!this._cellChanged) {
                this._cellChanged = true;
                this.callLater(this.changeCells);
            }
        };
        __proto.commitMeasure = function () {
            this.runCallLater(this.changeCells);
        };
        __getset(0, __proto, 'cacheAs', _super.prototype._$get_cacheAs, function (value) {
            Laya.superSet(Box, this, 'cacheAs', value);
            if (this._scrollBar) {
                this._$P.cacheAs = null;
                if (value !== "none")
                    this._scrollBar.on("start", this, this.onScrollStart);
                else
                    this._scrollBar.off("start", this, this.onScrollStart);
            }
        });
        __getset(0, __proto, 'content', function () {
            return this._content;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            if (value != this._height) {
                Laya.superSet(Box, this, 'height', value);
                this._setCellChanged();
            }
        });
        __getset(0, __proto, 'itemRender', function () {
            return this._itemRender;
        }, function (value) {
            if (this._itemRender != value) {
                this._itemRender = value;
                for (var i = this._cells.length - 1; i > -1; i--) {
                    this._cells[i].destroy();
                }
                this._cells.length = 0;
                this._setCellChanged();
            }
        });
        __getset(0, __proto, 'vScrollBarSkin', function () {
            return this._scrollBar ? this._scrollBar.skin : null;
        }, function (value) {
            this._removePreScrollBar();
            var scrollBar = new VScrollBar();
            scrollBar.name = "scrollBar";
            scrollBar.right = 0;
            if (value && value != " ")
                scrollBar.skin = value;
            this.scrollBar = scrollBar;
            this.addChild(scrollBar);
            this._setCellChanged();
        });
        __getset(0, __proto, 'page', function () {
            return this._page;
        }, function (value) {
            this._page = value;
            if (this._array) {
                this._page = value > 0 ? value : 0;
                this._page = this._page < this.totalPage ? this._page : this.totalPage - 1;
                this.startIndex = this._page * this.repeatX * this.repeatY;
            }
        });
        __getset(0, __proto, 'hScrollBarSkin', function () {
            return this._scrollBar ? this._scrollBar.skin : null;
        }, function (value) {
            this._removePreScrollBar();
            var scrollBar = new HScrollBar();
            scrollBar.name = "scrollBar";
            scrollBar.bottom = 0;
            if (value && value != " ")
                scrollBar.skin = value;
            this.scrollBar = scrollBar;
            this.addChild(scrollBar);
            this._setCellChanged();
        });
        __getset(0, __proto, 'repeatX', function () {
            return this._repeatX > 0 ? this._repeatX : this._repeatX2 > 0 ? this._repeatX2 : 1;
        }, function (value) {
            this._repeatX = value;
            this._setCellChanged();
        });
        __getset(0, __proto, 'scrollBar', function () {
            return this._scrollBar;
        }, function (value) {
            if (this._scrollBar != value) {
                this._scrollBar = value;
                if (value) {
                    this._isVertical = this._scrollBar.isVertical;
                    this.addChild(this._scrollBar);
                    this._scrollBar.on("change", this, this.onScrollBarChange);
                }
            }
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            if (value != this._width) {
                Laya.superSet(Box, this, 'width', value);
                this._setCellChanged();
            }
        });
        __getset(0, __proto, 'repeatY', function () {
            return this._repeatY > 0 ? this._repeatY : this._repeatY2 > 0 ? this._repeatY2 : 1;
        }, function (value) {
            this._repeatY = value;
            this._setCellChanged();
        });
        __getset(0, __proto, 'spaceX', function () {
            return this._spaceX;
        }, function (value) {
            this._spaceX = value;
            this._setCellChanged();
        });
        __getset(0, __proto, 'spaceY', function () {
            return this._spaceY;
        }, function (value) {
            this._spaceY = value;
            this._setCellChanged();
        });
        __getset(0, __proto, 'selectedIndex', function () {
            return this._selectedIndex;
        }, function (value) {
            if (this._selectedIndex != value) {
                this._selectedIndex = value;
                this.changeSelectStatus();
                this.event("change");
                this.selectHandler && this.selectHandler.runWith(value);
                this.startIndex = this._startIndex;
            }
        });
        __getset(0, __proto, 'selectedItem', function () {
            return this._selectedIndex != -1 ? this._array[this._selectedIndex] : null;
        }, function (value) {
            this.selectedIndex = this._array.indexOf(value);
        });
        __getset(0, __proto, 'length', function () {
            return this._array ? this._array.length : 0;
        });
        __getset(0, __proto, 'selection', function () {
            return this.getCell(this._selectedIndex);
        }, function (value) {
            this.selectedIndex = this._startIndex + this._cells.indexOf(value);
        });
        __getset(0, __proto, 'startIndex', function () {
            return this._startIndex;
        }, function (value) {
            this._startIndex = value > 0 ? value : 0;
            this.callLater(this.renderItems);
        });
        __getset(0, __proto, 'array', function () {
            return this._array;
        }, function (value) {
            this.runCallLater(this.changeCells);
            this._array = value || [];
            var length = this._array.length;
            this.totalPage = Math.ceil(length / (this.repeatX * this.repeatY));
            this._selectedIndex = this._selectedIndex < length ? this._selectedIndex : length - 1;
            this.startIndex = this._startIndex;
            if (this._scrollBar) {
                this._scrollBar.stopScroll();
                var numX = this._isVertical ? this.repeatX : this.repeatY;
                var numY = this._isVertical ? this.repeatY : this.repeatX;
                var lineCount = Math.ceil(length / numX);
                var total = this._cellOffset > 0 ? this.totalPage + 1 : this.totalPage;
                if (total > 1) {
                    this._scrollBar.scrollSize = this._cellSize;
                    this._scrollBar.thumbPercent = numY / lineCount;
                    this._scrollBar.setScroll(0, (lineCount - numY) * this._cellSize + this._cellOffset + 1, this._scrollBar.value);
                    this._scrollBar.target = this._content;
                }
                else {
                    this._scrollBar.setScroll(0, 0, 0);
                    this._scrollBar.target = this._content;
                }
            }
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if (((typeof value == 'number') && Math.floor(value) == value) || (typeof value == 'string'))
                this.selectedIndex = parseInt(value);
            else if ((value instanceof Array))
                this.array = value;
            else
                Laya.superSet(Box, this, 'dataSource', value);
        });
        __getset(0, __proto, 'cells', function () {
            this.runCallLater(this.changeCells);
            return this._cells;
        });
        return List;
    })(Box);
    var HScrollBar = (function (_super) {
        function HScrollBar() {
            HScrollBar.__super.call(this);
            ;
        }
        __class(HScrollBar, 'laya.ui.HScrollBar', _super);
        var __proto = HScrollBar.prototype;
        __proto.initialize = function () {
            _super.prototype.initialize.call(this);
            this.slider.isVertical = false;
        };
        return HScrollBar;
    })(ScrollBar);
    var Panel = (function (_super) {
        function Panel() {
            this._content = null;
            this._vScrollBar = null;
            this._hScrollBar = null;
            this._scrollChanged = false;
            Panel.__super.call(this);
            this.width = this.height = 100;
        }
        __class(Panel, 'laya.ui.Panel', _super);
        var __proto = Panel.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            laya.ui.Component.prototype.destroy.call(this, destroyChild);
            this._content && this._content.destroy(destroyChild);
            this._vScrollBar && this._vScrollBar.destroy(destroyChild);
            this._hScrollBar && this._hScrollBar.destroy(destroyChild);
            this._vScrollBar = null;
            this._hScrollBar = null;
            this._content = null;
        };
        __proto.destroyChildren = function () {
            this._content.destroyChildren();
        };
        __proto.createChildren = function () {
            laya.display.Node.prototype.addChild.call(this, this._content = new Box());
        };
        __proto.addChild = function (child) {
            child.on("resize", this, this.onResize);
            this._setScrollChanged();
            return this._content.addChild(child);
        };
        __proto.onResize = function () {
            this._setScrollChanged();
        };
        __proto.addChildAt = function (child, index) {
            child.on("resize", this, this.onResize);
            this._setScrollChanged();
            return this._content.addChildAt(child, index);
        };
        __proto.removeChild = function (child) {
            child.off("resize", this, this.onResize);
            this._setScrollChanged();
            return this._content.removeChild(child);
        };
        __proto.removeChildAt = function (index) {
            this.getChildAt(index).off("resize", this, this.onResize);
            this._setScrollChanged();
            return this._content.removeChildAt(index);
        };
        __proto.removeChildren = function (beginIndex, endIndex) {
            (beginIndex === void 0) && (beginIndex = 0);
            (endIndex === void 0) && (endIndex = 0x7fffffff);
            for (var i = this._content.numChildren - 1; i > -1; i--) {
                this._content.removeChildAt(i);
            }
            this._setScrollChanged();
            return this;
        };
        __proto.getChildAt = function (index) {
            return this._content.getChildAt(index);
        };
        __proto.getChildByName = function (name) {
            return this._content.getChildByName(name);
        };
        __proto.getChildIndex = function (child) {
            return this._content.getChildIndex(child);
        };
        __proto.changeScroll = function () {
            this._scrollChanged = false;
            var vscroll = this._vScrollBar;
            var hscroll = this._hScrollBar;
            if (this._width <= 0 || this._height <= 0) {
                if (vscroll)
                    vscroll.visible = false;
                if (hscroll)
                    hscroll.visible = false;
                return;
            }
            if (vscroll)
                vscroll.visible = true;
            if (hscroll)
                hscroll.visible = true;
            var contentW = this.contentWidth || 1;
            var contentH = this.contentHeight || 1;
            var vShow = vscroll && contentH > this._height;
            var hShow = hscroll && contentW > this._width;
            var showWidth = vShow ? this._width - vscroll.width : this._width;
            var showHeight = hShow ? this._height - hscroll.height : this._height;
            if (vscroll) {
                vscroll.x = this._width - vscroll.width;
                vscroll.y = 0;
                vscroll.height = this._height - (hShow ? hscroll.height : 0);
                vscroll.scrollSize = Math.max(this._height * 0.033, 1);
                vscroll.thumbPercent = showHeight / contentH;
                vscroll.setScroll(0, contentH - showHeight, vscroll.value);
            }
            if (hscroll) {
                hscroll.x = 0;
                hscroll.y = this._height - hscroll.height;
                hscroll.width = this._width - (vShow ? vscroll.width : 0);
                hscroll.scrollSize = Math.max(this._width * 0.033, 1);
                hscroll.thumbPercent = showWidth / contentW;
                hscroll.setScroll(0, contentW - showWidth, hscroll.value);
            }
        };
        __proto.changeSize = function () {
            laya.ui.Component.prototype.changeSize.call(this);
            this.setContentSize(this._width, this._height);
        };
        __proto.setContentSize = function (width, height) {
            var content = this._content;
            content.width = width;
            content.height = height;
            content.scrollRect || (content.scrollRect = new Rectangle());
            content.scrollRect.width = width;
            content.scrollRect.height = height;
            var contentW = this.contentWidth || 1;
            var contentH = this.contentHeight || 1;
            var vscroll = this._vScrollBar;
            var hscroll = this._hScrollBar;
            var vShow = vscroll && contentH > this._height;
            var hShow = hscroll && contentW > this._width;
            var showWidth = vShow ? this._width - vscroll.width : this._width;
            var showHeight = hShow ? this._height - hscroll.height : this._height;
            if (vscroll && vShow) {
                if (contentH - showHeight >= vscroll.value)
                    return;
            }
            if (hscroll && hShow) {
                if (contentW - showWidth >= hscroll.value)
                    return;
            }
            content.scrollRect.x = 0;
            content.scrollRect.y = 0;
            content.scrollRect = content.scrollRect;
        };
        __proto.onScrollBarChange = function (scrollBar) {
            var rect = this._content.scrollRect;
            if (rect) {
                var start = Math.round(scrollBar.value);
                scrollBar.isVertical ? rect.y = start : rect.x = start;
                this._content.scrollRect = rect;
            }
        };
        __proto.scrollTo = function (x, y) {
            (x === void 0) && (x = 0);
            (y === void 0) && (y = 0);
            if (this.vScrollBar)
                this.vScrollBar.value = y;
            if (this.hScrollBar)
                this.hScrollBar.value = x;
        };
        __proto.refresh = function () {
            this.changeScroll();
        };
        __proto.onScrollStart = function () {
            this._$P.cacheAs || (this._$P.cacheAs = Laya.superGet(Box, this, 'cacheAs'));
            Laya.superSet(Box, this, 'cacheAs', "none");
            this._hScrollBar && this._hScrollBar.once("end", this, this.onScrollEnd);
            this._vScrollBar && this._vScrollBar.once("end", this, this.onScrollEnd);
        };
        __proto.onScrollEnd = function () {
            Laya.superSet(Box, this, 'cacheAs', this._$P.cacheAs);
        };
        __proto._setScrollChanged = function () {
            if (!this._scrollChanged) {
                this._scrollChanged = true;
                this.callLater(this.changeScroll);
            }
        };
        __getset(0, __proto, 'numChildren', function () {
            return this._content.numChildren;
        });
        __getset(0, __proto, 'hScrollBarSkin', function () {
            return this._hScrollBar ? this._hScrollBar.skin : null;
        }, function (value) {
            if (this._hScrollBar == null) {
                laya.display.Node.prototype.addChild.call(this, this._hScrollBar = new HScrollBar());
                this._hScrollBar.on("change", this, this.onScrollBarChange, [this._hScrollBar]);
                this._hScrollBar.target = this._content;
                this._setScrollChanged();
            }
            this._hScrollBar.skin = value;
        });
        __getset(0, __proto, 'contentWidth', function () {
            var max = 0;
            for (var i = this._content.numChildren - 1; i > -1; i--) {
                var comp = this._content.getChildAt(i);
                if (!comp.visible)
                    continue;
                max = Math.max(comp.x + comp.width * comp.scaleX, max);
            }
            return max;
        });
        __getset(0, __proto, 'contentHeight', function () {
            var max = 0;
            for (var i = this._content.numChildren - 1; i > -1; i--) {
                var comp = this._content.getChildAt(i);
                if (!comp.visible)
                    continue;
                max = Math.max(comp.y + comp.height * comp.scaleY, max);
            }
            return max;
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            Laya.superSet(Box, this, 'width', value);
            this._setScrollChanged();
        });
        __getset(0, __proto, 'hScrollBar', function () {
            return this._hScrollBar;
        });
        __getset(0, __proto, 'content', function () {
            return this._content;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(Box, this, 'height', value);
            this._setScrollChanged();
        });
        __getset(0, __proto, 'vScrollBarSkin', function () {
            return this._vScrollBar ? this._vScrollBar.skin : null;
        }, function (value) {
            if (this._vScrollBar == null) {
                laya.display.Node.prototype.addChild.call(this, this._vScrollBar = new VScrollBar());
                this._vScrollBar.on("change", this, this.onScrollBarChange, [this._vScrollBar]);
                this._vScrollBar.target = this._content;
                this._setScrollChanged();
            }
            this._vScrollBar.skin = value;
        });
        __getset(0, __proto, 'vScrollBar', function () {
            return this._vScrollBar;
        });
        __getset(0, __proto, 'cacheAs', _super.prototype._$get_cacheAs, function (value) {
            Laya.superSet(Box, this, 'cacheAs', value);
            this._$P.cacheAs = null;
            if (value !== "none") {
                this._hScrollBar && this._hScrollBar.on("start", this, this.onScrollStart);
                this._vScrollBar && this._vScrollBar.on("start", this, this.onScrollStart);
            }
            else {
                this._hScrollBar && this._hScrollBar.off("start", this, this.onScrollStart);
                this._vScrollBar && this._vScrollBar.off("start", this, this.onScrollStart);
            }
        });
        return Panel;
    })(Box);
    var UIGroup = (function (_super) {
        function UIGroup(labels, skin) {
            this.selectHandler = null;
            this._items = null;
            this._selectedIndex = -1;
            this._skin = null;
            this._direction = "horizontal";
            this._space = 0;
            this._labels = null;
            this._labelColors = null;
            this._labelFont = null;
            this._labelStrokeColor = null;
            this._strokeColors = null;
            this._labelStroke = NaN;
            this._labelSize = 0;
            this._labelBold = false;
            this._labelPadding = null;
            this._labelAlign = null;
            this._stateNum = 0;
            this._labelChanged = false;
            UIGroup.__super.call(this);
            this.skin = skin;
            this.labels = labels;
        }
        __class(UIGroup, 'laya.ui.UIGroup', _super);
        var __proto = UIGroup.prototype;
        Laya.imps(__proto, { "laya.ui.IItem": true });
        __proto.preinitialize = function () {
            this.mouseEnabled = true;
        };
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            laya.ui.Component.prototype.destroy.call(this, destroyChild);
            this._items && (this._items.length = 0);
            this._items = null;
            this.selectHandler = null;
        };
        __proto.addItem = function (item, autoLayOut) {
            (autoLayOut === void 0) && (autoLayOut = true);
            var display = item;
            var index = this._items.length;
            display.name = "item" + index;
            this.addChild(display);
            this.initItems();
            if (autoLayOut && index > 0) {
                var preItem = this._items[index - 1];
                if (this._direction == "horizontal") {
                    display.x = preItem.x + preItem.width + this._space;
                }
                else {
                    display.y = preItem.y + preItem.height + this._space;
                }
            }
            else {
                if (autoLayOut) {
                    display.x = 0;
                    display.y = 0;
                }
            }
            return index;
        };
        __proto.delItem = function (item, autoLayOut) {
            (autoLayOut === void 0) && (autoLayOut = true);
            var index = this._items.indexOf(item);
            if (index != -1) {
                var display = item;
                this.removeChild(display);
                for (var i = index + 1, n = this._items.length; i < n; i++) {
                    var child = this._items[i];
                    child.name = "item" + (i - 1);
                    if (autoLayOut) {
                        if (this._direction == "horizontal") {
                            child.x -= display.width + this._space;
                        }
                        else {
                            child.y -= display.height + this._space;
                        }
                    }
                }
                this.initItems();
                if (this._selectedIndex > -1) {
                    var newIndex = 0;
                    newIndex = this._selectedIndex < this._items.length ? this._selectedIndex : (this._selectedIndex - 1);
                    this._selectedIndex = -1;
                    this.selectedIndex = newIndex;
                }
            }
        };
        __proto.initItems = function () {
            this._items || (this._items = []);
            this._items.length = 0;
            for (var i = 0; i < 10000; i++) {
                var item = this.getChildByName("item" + i);
                if (item == null)
                    break;
                this._items.push(item);
                item.selected = (i === this._selectedIndex);
                item.clickHandler = Handler.create(this, this.itemClick, [i], false);
            }
        };
        __proto.itemClick = function (index) {
            this.selectedIndex = index;
        };
        __proto.setSelect = function (index, selected) {
            if (this._items && index > -1 && index < this._items.length)
                this._items[index].selected = selected;
        };
        __proto.createItem = function (skin, label) {
            return null;
        };
        __proto.changeLabels = function () {
            this._labelChanged = false;
            if (this._items) {
                var left = 0;
                for (var i = 0, n = this._items.length; i < n; i++) {
                    var btn = this._items[i];
                    this._skin && (btn.skin = this._skin);
                    this._labelColors && (btn.labelColors = this._labelColors);
                    this._labelSize && (btn.labelSize = this._labelSize);
                    this._labelStroke && (btn.labelStroke = this._labelStroke);
                    this._labelStrokeColor && (btn.labelStrokeColor = this._labelStrokeColor);
                    this._strokeColors && (btn.strokeColors = this._strokeColors);
                    this._labelBold && (btn.labelBold = this._labelBold);
                    this._labelPadding && (btn.labelPadding = this._labelPadding);
                    this._labelAlign && (btn.labelAlign = this._labelAlign);
                    this._stateNum && (btn.stateNum = this._stateNum);
                    this._labelFont && (btn.labelFont = this._labelFont);
                    if (this._direction === "horizontal") {
                        btn.y = 0;
                        btn.x = left;
                        left += btn.width + this._space;
                    }
                    else {
                        btn.x = 0;
                        btn.y = left;
                        left += btn.height + this._space;
                    }
                }
            }
            this.changeSize();
        };
        __proto.commitMeasure = function () {
            this.runCallLater(this.changeLabels);
        };
        __proto._setLabelChanged = function () {
            if (!this._labelChanged) {
                this._labelChanged = true;
                this.callLater(this.changeLabels);
            }
        };
        __getset(0, __proto, 'labelStrokeColor', function () {
            return this._labelStrokeColor;
        }, function (value) {
            if (this._labelStrokeColor != value) {
                this._labelStrokeColor = value;
                this._setLabelChanged();
            }
        });
        __getset(0, __proto, 'skin', function () {
            return this._skin;
        }, function (value) {
            if (this._skin != value) {
                this._skin = value;
                this._setLabelChanged();
            }
        });
        __getset(0, __proto, 'selectedIndex', function () {
            return this._selectedIndex;
        }, function (value) {
            if (this._selectedIndex != value) {
                this.setSelect(this._selectedIndex, false);
                this._selectedIndex = value;
                this.setSelect(value, true);
                this.event("change");
                this.selectHandler && this.selectHandler.runWith(this._selectedIndex);
            }
        });
        __getset(0, __proto, 'labels', function () {
            return this._labels;
        }, function (value) {
            if (this._labels != value) {
                this._labels = value;
                this.removeChildren();
                this._setLabelChanged();
                if (this._labels) {
                    var a = this._labels.split(",");
                    for (var i = 0, n = a.length; i < n; i++) {
                        var item = this.createItem(this._skin, a[i]);
                        item.name = "item" + i;
                        this.addChild(item);
                    }
                }
                this.initItems();
            }
        });
        __getset(0, __proto, 'strokeColors', function () {
            return this._strokeColors;
        }, function (value) {
            if (this._strokeColors != value) {
                this._strokeColors = value;
                this._setLabelChanged();
            }
        });
        __getset(0, __proto, 'labelColors', function () {
            return this._labelColors;
        }, function (value) {
            if (this._labelColors != value) {
                this._labelColors = value;
                this._setLabelChanged();
            }
        });
        __getset(0, __proto, 'labelStroke', function () {
            return this._labelStroke;
        }, function (value) {
            if (this._labelStroke != value) {
                this._labelStroke = value;
                this._setLabelChanged();
            }
        });
        __getset(0, __proto, 'labelSize', function () {
            return this._labelSize;
        }, function (value) {
            if (this._labelSize != value) {
                this._labelSize = value;
                this._setLabelChanged();
            }
        });
        __getset(0, __proto, 'stateNum', function () {
            return this._stateNum;
        }, function (value) {
            if (this._stateNum != value) {
                this._stateNum = value;
                this._setLabelChanged();
            }
        });
        __getset(0, __proto, 'labelBold', function () {
            return this._labelBold;
        }, function (value) {
            if (this._labelBold != value) {
                this._labelBold = value;
                this._setLabelChanged();
            }
        });
        __getset(0, __proto, 'labelFont', function () {
            return this._labelFont;
        }, function (value) {
            if (this._labelFont != value) {
                this._labelFont = value;
                this._setLabelChanged();
            }
        });
        __getset(0, __proto, 'labelPadding', function () {
            return this._labelPadding;
        }, function (value) {
            if (this._labelPadding != value) {
                this._labelPadding = value;
                this._setLabelChanged();
            }
        });
        __getset(0, __proto, 'direction', function () {
            return this._direction;
        }, function (value) {
            this._direction = value;
            this._setLabelChanged();
        });
        __getset(0, __proto, 'space', function () {
            return this._space;
        }, function (value) {
            this._space = value;
            this._setLabelChanged();
        });
        __getset(0, __proto, 'items', function () {
            return this._items;
        });
        __getset(0, __proto, 'selection', function () {
            return this._selectedIndex > -1 && this._selectedIndex < this._items.length ? this._items[this._selectedIndex] : null;
        }, function (value) {
            this.selectedIndex = this._items.indexOf(value);
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if (((typeof value == 'number') && Math.floor(value) == value) || (typeof value == 'string'))
                this.selectedIndex = parseInt(value);
            else if ((value instanceof Array))
                this.labels = (value).join(",");
            else
                Laya.superSet(Box, this, 'dataSource', value);
        });
        return UIGroup;
    })(Box);
    var HSlider = (function (_super) {
        function HSlider(skin) {
            HSlider.__super.call(this, skin);
            this.isVertical = false;
        }
        __class(HSlider, 'laya.ui.HSlider', _super);
        return HSlider;
    })(Slider);
    var Radio = (function (_super) {
        function Radio(skin, label) {
            this._value = null;
            (label === void 0) && (label = "");
            Radio.__super.call(this, skin, label);
        }
        __class(Radio, 'laya.ui.Radio', _super);
        var __proto = Radio.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._value = null;
        };
        __proto.preinitialize = function () {
            laya.ui.Component.prototype.preinitialize.call(this);
            this.toggle = false;
            this._autoSize = false;
        };
        __proto.initialize = function () {
            _super.prototype.initialize.call(this);
            this.createText();
            this._text.align = "left";
            this._text.valign = "top";
            this._text.width = 0;
            this.on("click", this, this.onClick);
        };
        __proto.onClick = function (e) {
            this.selected = true;
        };
        __getset(0, __proto, 'value', function () {
            return this._value != null ? this._value : this.label;
        }, function (obj) {
            this._value = obj;
        });
        return Radio;
    })(Button);
    var Tree = (function (_super) {
        function Tree() {
            this._list = null;
            this._source = null;
            this._renderHandler = null;
            this._spaceLeft = 10;
            this._spaceBottom = 0;
            this._keepStatus = true;
            Tree.__super.call(this);
            this.width = this.height = 200;
        }
        __class(Tree, 'laya.ui.Tree', _super);
        var __proto = Tree.prototype;
        Laya.imps(__proto, { "laya.ui.IRender": true });
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            laya.ui.Component.prototype.destroy.call(this, destroyChild);
            this._list && this._list.destroy(destroyChild);
            this._list = null;
            this._source = null;
            this._renderHandler = null;
        };
        __proto.createChildren = function () {
            this.addChild(this._list = new List());
            this._list.renderHandler = Handler.create(this, this.renderItem, null, false);
            this._list.repeatX = 1;
            this._list.on("change", this, this.onListChange);
        };
        __proto.onListChange = function (e) {
            this.event("change");
        };
        __proto.getArray = function () {
            var arr = [];
            var item;
            for (var $each_item in this._source) {
                item = this._source[$each_item];
                if (this.getParentOpenStatus(item)) {
                    item.x = this._spaceLeft * this.getDepth(item);
                    arr.push(item);
                }
            }
            return arr;
        };
        __proto.getDepth = function (item, num) {
            (num === void 0) && (num = 0);
            if (item.nodeParent == null)
                return num;
            else
                return this.getDepth(item.nodeParent, num + 1);
        };
        __proto.getParentOpenStatus = function (item) {
            var parent = item.nodeParent;
            if (parent == null) {
                return true;
            }
            else {
                if (parent.isOpen) {
                    if (parent.nodeParent != null)
                        return this.getParentOpenStatus(parent);
                    else
                        return true;
                }
                else {
                    return false;
                }
            }
        };
        __proto.renderItem = function (cell, index) {
            var item = cell.dataSource;
            if (item) {
                cell.left = item.x;
                var arrow = cell.getChildByName("arrow");
                if (arrow) {
                    if (item.hasChild) {
                        arrow.visible = true;
                        arrow.index = item.isOpen ? 1 : 0;
                        arrow.tag = index;
                        arrow.off("click", this, this.onArrowClick);
                        arrow.on("click", this, this.onArrowClick);
                    }
                    else {
                        arrow.visible = false;
                    }
                }
                ;
                var folder = cell.getChildByName("folder");
                if (folder) {
                    if (folder.clipY == 2) {
                        folder.index = item.isDirectory ? 0 : 1;
                    }
                    else {
                        folder.index = item.isDirectory ? item.isOpen ? 1 : 0 : 2;
                    }
                }
                this._renderHandler && this._renderHandler.runWith([cell, index]);
            }
        };
        __proto.onArrowClick = function (e) {
            var arrow = e.currentTarget;
            var index = arrow.tag;
            this._list.array[index].isOpen = !this._list.array[index].isOpen;
            this.event("open");
            this._list.array = this.getArray();
        };
        __proto.setItemState = function (index, isOpen) {
            if (!this._list.array[index])
                return;
            this._list.array[index].isOpen = isOpen;
            this._list.array = this.getArray();
        };
        __proto.fresh = function () {
            this._list.array = this.getArray();
            this.repaint();
        };
        __proto.parseXml = function (xml, source, nodeParent, isRoot) {
            var obj;
            var list = xml.childNodes;
            var childCount = list.length;
            if (!isRoot) {
                obj = {};
                var list2 = xml.attributes;
                var attrs;
                for (var $each_attrs in list2) {
                    attrs = list2[$each_attrs];
                    var prop = attrs.nodeName;
                    var value = attrs.nodeValue;
                    obj[prop] = value == "true" ? true : value == "false" ? false : value;
                }
                obj.nodeParent = nodeParent;
                if (childCount > 0)
                    obj.isDirectory = true;
                obj.hasChild = childCount > 0;
                source.push(obj);
            }
            for (var i = 0; i < childCount; i++) {
                var node = list[i];
                this.parseXml(node, source, obj, false);
            }
        };
        __proto.parseOpenStatus = function (oldSource, newSource) {
            for (var i = 0, n = newSource.length; i < n; i++) {
                var newItem = newSource[i];
                if (newItem.isDirectory) {
                    for (var j = 0, m = oldSource.length; j < m; j++) {
                        var oldItem = oldSource[j];
                        if (oldItem.isDirectory && this.isSameParent(oldItem, newItem) && newItem.label == oldItem.label) {
                            if (!newItem.isOpen)
                                newItem.isOpen = oldItem.isOpen;
                            break;
                        }
                    }
                }
            }
        };
        __proto.isSameParent = function (item1, item2) {
            if (item1.nodeParent == null && item2.nodeParent == null)
                return true;
            else if (item1.nodeParent == null || item2.nodeParent == null)
                return false;
            else {
                if (item1.nodeParent.label == item2.nodeParent.label)
                    return this.isSameParent(item1.nodeParent, item2.nodeParent);
                else
                    return false;
            }
        };
        __proto.filter = function (key) {
            if (Boolean(key)) {
                var result = [];
                this.getFilterSource(this._source, result, key);
                this._list.array = result;
            }
            else {
                this._list.array = this.getArray();
            }
        };
        __proto.getFilterSource = function (array, result, key) {
            key = key.toLocaleLowerCase();
            var item;
            for (var $each_item in array) {
                item = array[$each_item];
                if (!item.isDirectory && String(item.label).toLowerCase().indexOf(key) > -1) {
                    item.x = 0;
                    result.push(item);
                }
                if (item.child && item.child.length > 0) {
                    this.getFilterSource(item.child, result, key);
                }
            }
        };
        __getset(0, __proto, 'spaceBottom', function () {
            return this._list.spaceY;
        }, function (value) {
            this._list.spaceY = value;
        });
        __getset(0, __proto, 'keepStatus', function () {
            return this._keepStatus;
        }, function (value) {
            this._keepStatus = value;
        });
        __getset(0, __proto, 'itemRender', function () {
            return this._list.itemRender;
        }, function (value) {
            this._list.itemRender = value;
        });
        __getset(0, __proto, 'array', function () {
            return this._list.array;
        }, function (value) {
            if (this._keepStatus && this._list.array && value) {
                this.parseOpenStatus(this._list.array, value);
            }
            this._source = value;
            this._list.array = this.getArray();
        });
        __getset(0, __proto, 'mouseHandler', function () {
            return this._list.mouseHandler;
        }, function (value) {
            this._list.mouseHandler = value;
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            Laya.superSet(Box, this, 'dataSource', value);
        });
        __getset(0, __proto, 'source', function () {
            return this._source;
        });
        __getset(0, __proto, 'scrollBar', function () {
            return this._list.scrollBar;
        });
        __getset(0, __proto, 'list', function () {
            return this._list;
        });
        __getset(0, __proto, 'scrollBarSkin', function () {
            return this._list.vScrollBarSkin;
        }, function (value) {
            this._list.vScrollBarSkin = value;
        });
        __getset(0, __proto, 'renderHandler', function () {
            return this._renderHandler;
        }, function (value) {
            this._renderHandler = value;
        });
        __getset(0, __proto, 'selectedIndex', function () {
            return this._list.selectedIndex;
        }, function (value) {
            this._list.selectedIndex = value;
        });
        __getset(0, __proto, 'spaceLeft', function () {
            return this._spaceLeft;
        }, function (value) {
            this._spaceLeft = value;
        });
        __getset(0, __proto, 'selectedItem', function () {
            return this._list.selectedItem;
        }, function (value) {
            this._list.selectedItem = value;
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            Laya.superSet(Box, this, 'width', value);
            this._list.width = value;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(Box, this, 'height', value);
            this._list.height = value;
        });
        __getset(0, __proto, 'xml', null, function (value) {
            var arr = [];
            this.parseXml(value.childNodes[0], arr, null, true);
            this.array = arr;
        });
        __getset(0, __proto, 'selectedPath', function () {
            if (this._list.selectedItem) {
                return this._list.selectedItem.path;
            }
            return null;
        });
        return Tree;
    })(Box);
    var ViewStack = (function (_super) {
        function ViewStack() {
            this._items = null;
            this._selectedIndex = 0;
            ViewStack.__super.call(this);
            this._setIndexHandler = Handler.create(this, this.setIndex, null, false);
        }
        __class(ViewStack, 'laya.ui.ViewStack', _super);
        var __proto = ViewStack.prototype;
        Laya.imps(__proto, { "laya.ui.IItem": true });
        __proto.setItems = function (views) {
            this.removeChildren();
            var index = 0;
            for (var i = 0, n = views.length; i < n; i++) {
                var item = views[i];
                if (item) {
                    item.name = "item" + index;
                    this.addChild(item);
                    index++;
                }
            }
            this.initItems();
        };
        __proto.addItem = function (view) {
            view.name = "item" + this._items.length;
            this.addChild(view);
            this.initItems();
        };
        __proto.initItems = function () {
            this._items = [];
            for (var i = 0; i < 10000; i++) {
                var item = this.getChildByName("item" + i);
                if (item == null) {
                    break;
                }
                this._items.push(item);
                item.visible = (i == this._selectedIndex);
            }
        };
        __proto.setSelect = function (index, selected) {
            if (this._items && index > -1 && index < this._items.length) {
                this._items[index].visible = selected;
            }
        };
        __proto.setIndex = function (index) {
            this.selectedIndex = index;
        };
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if (((typeof value == 'number') && Math.floor(value) == value) || (typeof value == 'string')) {
                this.selectedIndex = parseInt(value);
            }
            else {
                for (var prop in this._dataSource) {
                    if (this.hasOwnProperty(prop)) {
                        this[prop] = this._dataSource[prop];
                    }
                }
            }
        });
        __getset(0, __proto, 'selectedIndex', function () {
            return this._selectedIndex;
        }, function (value) {
            if (this._selectedIndex != value) {
                this.setSelect(this._selectedIndex, false);
                this._selectedIndex = value;
                this.setSelect(this._selectedIndex, true);
            }
        });
        __getset(0, __proto, 'selection', function () {
            return this._selectedIndex > -1 && this._selectedIndex < this._items.length ? this._items[this._selectedIndex] : null;
        }, function (value) {
            this.selectedIndex = this._items.indexOf(value);
        });
        __getset(0, __proto, 'items', function () {
            return this._items;
        });
        __getset(0, __proto, 'setIndexHandler', function () {
            return this._setIndexHandler;
        }, function (value) {
            this._setIndexHandler = value;
        });
        return ViewStack;
    })(Box);
    var VScrollBar = (function (_super) {
        function VScrollBar() {
            VScrollBar.__super.call(this);
            ;
        }
        __class(VScrollBar, 'laya.ui.VScrollBar', _super);
        return VScrollBar;
    })(ScrollBar);
    var TextInput = (function (_super) {
        function TextInput(text) {
            this._bg = null;
            this._skin = null;
            TextInput.__super.call(this);
            (text === void 0) && (text = "");
            this.text = text;
            this.skin = this.skin;
        }
        __class(TextInput, 'laya.ui.TextInput', _super);
        var __proto = TextInput.prototype;
        __proto.preinitialize = function () {
            this.mouseEnabled = true;
        };
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._bg && this._bg.destroy();
            this._bg = null;
        };
        __proto.createChildren = function () {
            this.addChild(this._tf = new Input());
            this._tf.padding = Styles.inputLabelPadding;
            this._tf.on("input", this, this._onInput);
            this._tf.on("enter", this, this._onEnter);
            this._tf.on("blur", this, this._onBlur);
            this._tf.on("focus", this, this._onFocus);
        };
        __proto._onFocus = function () {
            this.event("focus", this);
        };
        __proto._onBlur = function () {
            this.event("blur", this);
        };
        __proto._onInput = function () {
            this.event("input", this);
        };
        __proto._onEnter = function () {
            this.event("enter", this);
        };
        __proto.initialize = function () {
            this.width = 128;
            this.height = 22;
        };
        __proto.select = function () {
            (this._tf).select();
        };
        __proto.setSelection = function (startIndex, endIndex) {
            (this._tf).setSelection(startIndex, endIndex);
        };
        __getset(0, __proto, 'text', _super.prototype._$get_text, function (value) {
            if (this._tf.text != value) {
                value = value + "";
                this._tf.text = value;
                this.event("change");
            }
        });
        __getset(0, __proto, 'bg', function () {
            return this._bg;
        }, function (value) {
            this.graphics = this._bg = value;
        });
        __getset(0, __proto, 'inputElementYAdjuster', function () {
            return (this._tf).inputElementYAdjuster;
        }, function (value) {
            (this._tf).inputElementYAdjuster = value;
        });
        __getset(0, __proto, 'multiline', function () {
            return (this._tf).multiline;
        }, function (value) {
            (this._tf).multiline = value;
        });
        __getset(0, __proto, 'skin', function () {
            return this._skin;
        }, function (value) {
            if (this._skin != value) {
                this._skin = value;
                this._bg || (this.graphics = this._bg = new AutoBitmap());
                this._bg.source = Loader.getRes(this._skin);
                this._width && (this._bg.width = this._width);
                this._height && (this._bg.height = this._height);
            }
        });
        __getset(0, __proto, 'sizeGrid', function () {
            return this._bg && this._bg.sizeGrid ? this._bg.sizeGrid.join(",") : null;
        }, function (value) {
            this._bg || (this.graphics = this._bg = new AutoBitmap());
            this._bg.sizeGrid = UIUtils.fillArray(Styles.defaultSizeGrid, value, Number);
        });
        __getset(0, __proto, 'inputElementXAdjuster', function () {
            return (this._tf).inputElementXAdjuster;
        }, function (value) {
            (this._tf).inputElementXAdjuster = value;
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            Laya.superSet(Label, this, 'width', value);
            this._bg && (this._bg.width = value);
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(Label, this, 'height', value);
            this._bg && (this._bg.height = value);
        });
        __getset(0, __proto, 'editable', function () {
            return (this._tf).editable;
        }, function (value) {
            (this._tf).editable = value;
        });
        __getset(0, __proto, 'restrict', function () {
            return (this._tf).restrict;
        }, function (pattern) {
            (this._tf).restrict = pattern;
        });
        __getset(0, __proto, 'prompt', function () {
            return (this._tf).prompt;
        }, function (value) {
            (this._tf).prompt = value;
        });
        __getset(0, __proto, 'promptColor', function () {
            return (this._tf).promptColor;
        }, function (value) {
            (this._tf).promptColor = value;
        });
        __getset(0, __proto, 'maxChars', function () {
            return (this._tf).maxChars;
        }, function (value) {
            (this._tf).maxChars = value;
        });
        __getset(0, __proto, 'focus', function () {
            return (this._tf).focus;
        }, function (value) {
            (this._tf).focus = value;
        });
        __getset(0, __proto, 'type', function () {
            return (this._tf).type;
        }, function (value) {
            (this._tf).type = value;
        });
        __getset(0, __proto, 'asPassword', function () {
            return (this._tf).asPassword;
        }, function (value) {
            (this._tf).asPassword = value;
        });
        return TextInput;
    })(Label);
    var VSlider = (function (_super) {
        function VSlider() {
            VSlider.__super.call(this);
            ;
        }
        __class(VSlider, 'laya.ui.VSlider', _super);
        return VSlider;
    })(Slider);
    var Dialog = (function (_super) {
        function Dialog() {
            this.popupCenter = true;
            this.closeHandler = null;
            this.popupEffect = null;
            this.closeEffect = null;
            this.group = null;
            this.isModal = false;
            this._dragArea = null;
            Dialog.__super.call(this);
        }
        __class(Dialog, 'laya.ui.Dialog', _super);
        var __proto = Dialog.prototype;
        __proto.initialize = function () {
            this.popupEffect = Dialog.manager.popupEffectHandler;
            this.closeEffect = Dialog.manager.closeEffectHandler;
            this._dealDragArea();
            this.on("click", this, this._onClick);
        };
        __proto._dealDragArea = function () {
            var dragTarget = this.getChildByName("drag");
            if (dragTarget) {
                this.dragArea = dragTarget.x + "," + dragTarget.y + "," + dragTarget.width + "," + dragTarget.height;
                dragTarget.removeSelf();
            }
        };
        __proto._onClick = function (e) {
            var btn = e.target;
            if (btn) {
                switch (btn.name) {
                    case "close":
                    case "cancel":
                    case "sure":
                    case "no":
                    case "ok":
                    case "yes":
                        this.close(btn.name);
                        break;
                }
            }
        };
        __proto.show = function (closeOther, showEffect) {
            (closeOther === void 0) && (closeOther = false);
            (showEffect === void 0) && (showEffect = true);
            this._open(false, closeOther, showEffect);
        };
        __proto.popup = function (closeOther, showEffect) {
            (closeOther === void 0) && (closeOther = false);
            (showEffect === void 0) && (showEffect = true);
            this._open(true, closeOther, showEffect);
        };
        __proto._open = function (modal, closeOther, showEffect) {
            Dialog.manager.lock(false);
            this.isModal = modal;
            Dialog.manager.open(this, closeOther, showEffect);
        };
        __proto.onOpened = function () { };
        __proto.close = function (type, showEffect) {
            (showEffect === void 0) && (showEffect = true);
            Dialog.manager.close(this, type, showEffect);
        };
        __proto.onClosed = function (type) { };
        __proto._onMouseDown = function (e) {
            var point = this.getMousePoint();
            if (this._dragArea.contains(point.x, point.y))
                this.startDrag();
            else
                this.stopDrag();
        };
        __getset(0, __proto, 'dragArea', function () {
            if (this._dragArea)
                return this._dragArea.toString();
            return null;
        }, function (value) {
            if (value) {
                var a = UIUtils.fillArray([0, 0, 0, 0], value, Number);
                this._dragArea = new Rectangle(a[0], a[1], a[2], a[3]);
                this.on("mousedown", this, this._onMouseDown);
            }
            else {
                this._dragArea = null;
                this.off("mousedown", this, this._onMouseDown);
            }
        });
        __getset(0, __proto, 'isPopup', function () {
            return this.parent != null;
        });
        __getset(0, __proto, 'zOrder', _super.prototype._$get_zOrder, function (value) {
            Laya.superSet(View, this, 'zOrder', value);
            Dialog.manager._checkMask();
        });
        __getset(1, Dialog, 'manager', function () {
            return Dialog._manager = Dialog._manager || new DialogManager();
        }, function (value) {
            Dialog._manager = value;
        });
        Dialog.setLockView = function (view) {
            Dialog.manager.setLockView(view);
        };
        Dialog.lock = function (value) {
            Dialog.manager.lock(value);
        };
        Dialog.closeAll = function () {
            Dialog.manager.closeAll();
        };
        Dialog.getDialogsByGroup = function (group) {
            return Dialog.manager.getDialogsByGroup(group);
        };
        Dialog.closeByGroup = function (group) {
            return Dialog.manager.closeByGroup(group);
        };
        Dialog.CLOSE = "close";
        Dialog.CANCEL = "cancel";
        Dialog.SURE = "sure";
        Dialog.NO = "no";
        Dialog.OK = "ok";
        Dialog.YES = "yes";
        Dialog._manager = null;
        return Dialog;
    })(View);
    var HBox = (function (_super) {
        function HBox() {
            HBox.__super.call(this);
            ;
        }
        __class(HBox, 'laya.ui.HBox', _super);
        var __proto = HBox.prototype;
        __proto.sortItem = function (items) {
            if (items)
                items.sort(function (a, b) { return a.x - b.x; });
        };
        __proto.changeItems = function () {
            this._itemChanged = false;
            var items = [];
            var maxHeight = 0;
            for (var i = 0, n = this.numChildren; i < n; i++) {
                var item = this.getChildAt(i);
                if (item && item.layoutEnabled) {
                    items.push(item);
                    maxHeight = this._height ? this._height : Math.max(maxHeight, item.height * item.scaleY);
                }
            }
            this.sortItem(items);
            var left = 0;
            for (i = 0, n = items.length; i < n; i++) {
                item = items[i];
                item.x = left;
                left += item.width * item.scaleX + this._space;
                if (this._align == "top") {
                    item.y = 0;
                }
                else if (this._align == "middle") {
                    item.y = (maxHeight - item.height * item.scaleY) * 0.5;
                }
                else if (this._align == "bottom") {
                    item.y = maxHeight - item.height * item.scaleY;
                }
            }
            this.changeSize();
        };
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            if (this._height != value) {
                Laya.superSet(LayoutBox, this, 'height', value);
                this.callLater(this.changeItems);
            }
        });
        HBox.NONE = "none";
        HBox.TOP = "top";
        HBox.MIDDLE = "middle";
        HBox.BOTTOM = "bottom";
        return HBox;
    })(LayoutBox);
    var VBox = (function (_super) {
        function VBox() {
            VBox.__super.call(this);
            ;
        }
        __class(VBox, 'laya.ui.VBox', _super);
        var __proto = VBox.prototype;
        __proto.changeItems = function () {
            this._itemChanged = false;
            var items = [];
            var maxWidth = 0;
            for (var i = 0, n = this.numChildren; i < n; i++) {
                var item = this.getChildAt(i);
                if (item && item.layoutEnabled) {
                    items.push(item);
                    maxWidth = this._width ? this._width : Math.max(maxWidth, item.width * item.scaleX);
                }
            }
            this.sortItem(items);
            var top = 0;
            for (i = 0, n = items.length; i < n; i++) {
                item = items[i];
                item.y = top;
                top += item.height * item.scaleY + this._space;
                if (this._align == "left") {
                    item.x = 0;
                }
                else if (this._align == "center") {
                    item.x = (maxWidth - item.width * item.scaleX) * 0.5;
                }
                else if (this._align == "right") {
                    item.x = maxWidth - item.width * item.scaleX;
                }
            }
            this.changeSize();
        };
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            if (this._width != value) {
                Laya.superSet(LayoutBox, this, 'width', value);
                this.callLater(this.changeItems);
            }
        });
        VBox.NONE = "none";
        VBox.LEFT = "left";
        VBox.CENTER = "center";
        VBox.RIGHT = "right";
        return VBox;
    })(LayoutBox);
    var RadioGroup = (function (_super) {
        function RadioGroup() {
            RadioGroup.__super.call(this);
            ;
        }
        __class(RadioGroup, 'laya.ui.RadioGroup', _super);
        var __proto = RadioGroup.prototype;
        __proto.createItem = function (skin, label) {
            return new Radio(skin, label);
        };
        return RadioGroup;
    })(UIGroup);
    var Tab = (function (_super) {
        function Tab() {
            Tab.__super.call(this);
            ;
        }
        __class(Tab, 'laya.ui.Tab', _super);
        var __proto = Tab.prototype;
        __proto.createItem = function (skin, label) {
            return new Button(skin, label);
        };
        return Tab;
    })(UIGroup);
    var TextArea = (function (_super) {
        function TextArea(text) {
            this._vScrollBar = null;
            this._hScrollBar = null;
            (text === void 0) && (text = "");
            TextArea.__super.call(this, text);
        }
        __class(TextArea, 'laya.ui.TextArea', _super);
        var __proto = TextArea.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._vScrollBar && this._vScrollBar.destroy();
            this._hScrollBar && this._hScrollBar.destroy();
            this._vScrollBar = null;
            this._hScrollBar = null;
        };
        __proto.initialize = function () {
            this.width = 180;
            this.height = 150;
            this._tf.wordWrap = true;
            this.multiline = true;
        };
        __proto.onVBarChanged = function (e) {
            if (this._tf.scrollY != this._vScrollBar.value) {
                this._tf.scrollY = this._vScrollBar.value;
            }
        };
        __proto.onHBarChanged = function (e) {
            if (this._tf.scrollX != this._hScrollBar.value) {
                this._tf.scrollX = this._hScrollBar.value;
            }
        };
        __proto.changeScroll = function () {
            var vShow = this._vScrollBar && this._tf.maxScrollY > 0;
            var hShow = this._hScrollBar && this._tf.maxScrollX > 0;
            var showWidth = vShow ? this._width - this._vScrollBar.width : this._width;
            var showHeight = hShow ? this._height - this._hScrollBar.height : this._height;
            var padding = this._tf.padding || Styles.labelPadding;
            this._tf.width = showWidth;
            this._tf.height = showHeight;
            if (this._vScrollBar) {
                this._vScrollBar.x = this._width - this._vScrollBar.width - padding[2];
                this._vScrollBar.y = padding[1];
                this._vScrollBar.height = this._height - (hShow ? this._hScrollBar.height : 0) - padding[1] - padding[3];
                this._vScrollBar.scrollSize = 1;
                this._vScrollBar.thumbPercent = showHeight / Math.max(this._tf.textHeight, showHeight);
                this._vScrollBar.setScroll(1, this._tf.maxScrollY, this._tf.scrollY);
                this._vScrollBar.visible = vShow;
            }
            if (this._hScrollBar) {
                this._hScrollBar.x = padding[0];
                this._hScrollBar.y = this._height - this._hScrollBar.height - padding[3];
                this._hScrollBar.width = this._width - (vShow ? this._vScrollBar.width : 0) - padding[0] - padding[2];
                this._hScrollBar.scrollSize = Math.max(showWidth * 0.033, 1);
                this._hScrollBar.thumbPercent = showWidth / Math.max(this._tf.textWidth, showWidth);
                this._hScrollBar.setScroll(0, this.maxScrollX, this.scrollX);
                this._hScrollBar.visible = hShow;
            }
        };
        __proto.scrollTo = function (y) {
            this.commitMeasure();
            this._tf.scrollY = y;
        };
        __getset(0, __proto, 'scrollY', function () {
            return this._tf.scrollY;
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            Laya.superSet(TextInput, this, 'width', value);
            this.callLater(this.changeScroll);
        });
        __getset(0, __proto, 'hScrollBar', function () {
            return this._hScrollBar;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(TextInput, this, 'height', value);
            this.callLater(this.changeScroll);
        });
        __getset(0, __proto, 'maxScrollX', function () {
            return this._tf.maxScrollX;
        });
        __getset(0, __proto, 'vScrollBarSkin', function () {
            return this._vScrollBar ? this._vScrollBar.skin : null;
        }, function (value) {
            if (this._vScrollBar == null) {
                this.addChild(this._vScrollBar = new VScrollBar());
                this._vScrollBar.on("change", this, this.onVBarChanged);
                this._vScrollBar.target = this._tf;
                this.callLater(this.changeScroll);
            }
            this._vScrollBar.skin = value;
        });
        __getset(0, __proto, 'hScrollBarSkin', function () {
            return this._hScrollBar ? this._hScrollBar.skin : null;
        }, function (value) {
            if (this._hScrollBar == null) {
                this.addChild(this._hScrollBar = new HScrollBar());
                this._hScrollBar.on("change", this, this.onHBarChanged);
                this._hScrollBar.mouseWheelEnable = false;
                this._hScrollBar.target = this._tf;
                this.callLater(this.changeScroll);
            }
            this._hScrollBar.skin = value;
        });
        __getset(0, __proto, 'vScrollBar', function () {
            return this._vScrollBar;
        });
        __getset(0, __proto, 'maxScrollY', function () {
            return this._tf.maxScrollY;
        });
        __getset(0, __proto, 'scrollX', function () {
            return this._tf.scrollX;
        });
        return TextArea;
    })(TextInput);
    var AsynDialog = (function (_super) {
        function AsynDialog() {
            this._uiView = null;
            this.isCloseOther = false;
            AsynDialog.__super.call(this);
        }
        __class(AsynDialog, 'laya.ui.AsynDialog', _super);
        var __proto = AsynDialog.prototype;
        __proto.createView = function (uiView) {
            this._uiView = uiView;
        };
        __proto._open = function (modal, closeOther, showEffect) {
            this.isModal = modal;
            this.isCloseOther = closeOther;
            Dialog.manager.lock(true);
            if (this._uiView)
                this.onCreated();
            else
                this.onOpen();
        };
        __proto.onCreated = function () {
            this.createUI();
            this.onOpen();
        };
        __proto.createUI = function () {
            laya.ui.View.prototype.createView.call(this, this._uiView);
            this._uiView = null;
            this._dealDragArea();
        };
        __proto.onOpen = function () {
            Dialog.manager.open(this, this.isCloseOther);
            Dialog.manager.lock(false);
        };
        __proto.close = function (type, showEffect) {
            (showEffect === void 0) && (showEffect = true);
            Dialog.manager.close(this);
            this.onClose();
        };
        __proto.onClose = function () { };
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            laya.ui.View.prototype.destroy.call(this, destroyChild);
            this._uiView = null;
            this.onDestroy();
        };
        __proto.onDestroy = function () { };
        return AsynDialog;
    })(Dialog);
    Laya.__init([View]);
})(window, document, Laya);
if (typeof define === 'function' && define.amd) {
    define('laya.core', ['require', "exports"], function (require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
            var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    var Browser = laya.utils.Browser, Color = laya.utils.Color, ColorFilterAction = laya.filters.ColorFilterAction;
    var ColorFilterActionGL = laya.filters.webgl.ColorFilterActionGL, Filter = laya.filters.Filter, FilterActionGL = laya.filters.webgl.FilterActionGL;
    var Matrix = laya.maths.Matrix, Rectangle = laya.maths.Rectangle, Render = laya.renders.Render, RenderContext = laya.renders.RenderContext;
    var RenderTarget2D = laya.webgl.resource.RenderTarget2D, RunDriver = laya.utils.RunDriver, ShaderDefines2D = laya.webgl.shader.d2.ShaderDefines2D;
    var Sprite = laya.display.Sprite, Texture = laya.resource.Texture, Value2D = laya.webgl.shader.d2.value.Value2D;
    var FilterAction = (function () {
        function FilterAction() {
            this.data = null;
        }
        __class(FilterAction, 'laya.filters.FilterAction');
        var __proto = FilterAction.prototype;
        Laya.imps(__proto, { "laya.filters.IFilterAction": true });
        __proto.apply = function (data) {
            return null;
        };
        return FilterAction;
    })();
    var WebGLFilter = (function () {
        function WebGLFilter() { }
        __class(WebGLFilter, 'laya.filters.WebGLFilter');
        WebGLFilter.enable = function () {
            if (WebGLFilter.isInit)
                return;
            WebGLFilter.isInit = true;
            if (!Render.isWebGL)
                return;
            RunDriver.createFilterAction = function (type) {
                var action;
                switch (type) {
                    case 0x20:
                        action = new ColorFilterActionGL();
                        break;
                    case 0x10:
                        action = new BlurFilterActionGL();
                        break;
                    // case 0x800:
                    //     action = new BlurFilterActionGL2();
                    //     break;
                    case 0x08:
                        action = new GlowFilterActionGL();
                        break;
                }
                return action;
            };
        };
        WebGLFilter.isInit = false;
        WebGLFilter.__init$ = function () {
            BlurFilterActionGL;
            // BlurFilterActionGL2;
            ColorFilterActionGL;
            GlowFilterActionGL;
            Render;
            RunDriver;
            {
                RunDriver.createFilterAction = function (type) {
                    var action;
                    switch (type) {
                        case 0x10:
                            action = new FilterAction();
                            break;
                        // case 0x800:
                        // action = new FilterAction();
                        // break;
                        case 0x08:
                            action = new FilterAction();
                            break;
                        case 0x20:
                            action = new ColorFilterAction();
                            break;
                    }
                    return action;
                };
            }
        };
        return WebGLFilter;
    })();
    var BlurFilter = (function (_super) {
        function BlurFilter(strength) {
            this.strength = NaN;
            this.strength_sig2_2sig2_gauss1 = [];
            BlurFilter.__super.call(this);
            (strength === void 0) && (strength = 4);
            if (Render.isWebGL)
                WebGLFilter.enable();
            this.strength = strength;
            this._action = RunDriver.createFilterAction(0x10);
            this._action.data = this;
        }
        __class(BlurFilter, 'laya.filters.BlurFilter', _super);
        var __proto = BlurFilter.prototype;
        __proto.callNative = function (sp) {
            sp.conchModel && sp.conchModel.blurFilter && sp.conchModel.blurFilter(this.strength);
        };
        __getset(0, __proto, 'action', function () {
            return this._action;
        });
        __getset(0, __proto, 'type', function () {
            return 0x10;
        });
        return BlurFilter;
    })(Filter);
    var GlowFilter = (function (_super) {
        function GlowFilter(color, blur, offX, offY) {
            this._color = null;
            GlowFilter.__super.call(this);
            this._elements = new Float32Array(9);
            (blur === void 0) && (blur = 4);
            (offX === void 0) && (offX = 6);
            (offY === void 0) && (offY = 6);
            if (Render.isWebGL) {
                WebGLFilter.enable();
            }
            this._color = new Color(color);
            this.blur = Math.min(blur, 20);
            this.offX = offX;
            this.offY = offY;
            this._action = RunDriver.createFilterAction(0x08);
            this._action.data = this;
        }
        __class(GlowFilter, 'laya.filters.GlowFilter', _super);
        var __proto = GlowFilter.prototype;
        __proto.getColor = function () {
            return this._color._color;
        };
        __proto.callNative = function (sp) {
            sp.conchModel && sp.conchModel.glowFilter && sp.conchModel.glowFilter(this._color.strColor, this._elements[4], this._elements[5], this._elements[6]);
        };
        __getset(0, __proto, 'type', function () {
            return 0x08;
        });
        __getset(0, __proto, 'action', function () {
            return this._action;
        });
        __getset(0, __proto, 'offY', function () {
            return this._elements[6];
        }, function (value) {
            this._elements[6] = value;
        });
        __getset(0, __proto, 'offX', function () {
            return this._elements[5];
        }, function (value) {
            this._elements[5] = value;
        });
        __getset(0, __proto, 'blur', function () {
            return this._elements[4];
        }, function (value) {
            this._elements[4] = value;
        });
        return GlowFilter;
    })(Filter);
    var BlurFilterActionGL = (function (_super) {
        function BlurFilterActionGL() {
            this.data = null;
            BlurFilterActionGL.__super.call(this);
        }
        __class(BlurFilterActionGL, 'laya.filters.webgl.BlurFilterActionGL', _super);
        var __proto = BlurFilterActionGL.prototype;
        __proto.setValueMix = function (shader) {
            shader.defines.add(this.data.type);
            var o = shader;
        };
        __proto.apply3d = function (scope, sprite, context, x, y) {
            var b = scope.getValue("bounds");
            var shaderValue = Value2D.create(0x01, 0);
            shaderValue.setFilters([this.data]);
            var tMatrix = Matrix.EMPTY;
            tMatrix.identity();
            context.ctx.drawTarget(scope, 0, 0, b.width, b.height, Matrix.EMPTY, "src", shaderValue);
            shaderValue.setFilters(null);
        };
        __proto.setValue = function (shader) {
            shader.strength = this.data.strength;
            var sigma = this.data.strength / 3.0;
            var sigma2 = sigma * sigma;
            this.data.strength_sig2_2sig2_gauss1[0] = this.data.strength;
            this.data.strength_sig2_2sig2_gauss1[1] = sigma2;
            this.data.strength_sig2_2sig2_gauss1[2] = 2.0 * sigma2;
            this.data.strength_sig2_2sig2_gauss1[3] = 1.0 / (2.0 * Math.PI * sigma2);
            shader.strength_sig2_2sig2_gauss1 = this.data.strength_sig2_2sig2_gauss1;
        };
        __getset(0, __proto, 'typeMix', function () { return 0x10; });
        return BlurFilterActionGL;
    })(FilterActionGL);
    var GlowFilterActionGL = (function (_super) {
        function GlowFilterActionGL() {
            this.data = null;
            this._initKey = false;
            this._textureWidth = 0;
            this._textureHeight = 0;
            GlowFilterActionGL.__super.call(this);
        }
        __class(GlowFilterActionGL, 'laya.filters.webgl.GlowFilterActionGL', _super);
        var __proto = GlowFilterActionGL.prototype;
        Laya.imps(__proto, { "laya.filters.IFilterActionGL": true });
        __proto.setValueMix = function (shader) { };
        __proto.apply3d = function (scope, sprite, context, x, y) {
            var b = scope.getValue("bounds");
            scope.addValue("color", this.data.getColor());
            var w = b.width, h = b.height;
            this._textureWidth = w;
            this._textureHeight = h;
            var shaderValue;
            var mat = Matrix.TEMP;
            mat.identity();
            shaderValue = Value2D.create(0x01, 0);
            shaderValue.setFilters([this.data]);
            context.ctx.drawTarget(scope, 0, 0, this._textureWidth, this._textureHeight, mat, "src", shaderValue, null);
            shaderValue = Value2D.create(0x01, 0);
            context.ctx.drawTarget(scope, 0, 0, this._textureWidth, this._textureHeight, mat, "src", shaderValue);
            return null;
        };
        __proto.setSpriteWH = function (sprite) {
            this._textureWidth = sprite.width;
            this._textureHeight = sprite.height;
        };
        __proto.setValue = function (shader) {
            shader.u_offsetX = this.data.offX;
            shader.u_offsetY = -this.data.offY;
            shader.u_strength = 1.0;
            shader.u_blurX = this.data.blur;
            shader.u_blurY = this.data.blur;
            shader.u_textW = this._textureWidth;
            shader.u_textH = this._textureHeight;
            shader.u_color = this.data.getColor();
        };
        __getset(0, __proto, 'typeMix', function () { return 0x08; });
        GlowFilterActionGL.tmpTarget = function (scope, sprite, context, x, y) {
            var b = scope.getValue("bounds");
            var out = scope.getValue("out");
            out.end();
            var tmpTarget = RenderTarget2D.create(b.width, b.height);
            tmpTarget.start();
            var color = scope.getValue("color");
            if (color) {
                tmpTarget.clear(color[0], color[1], color[2], 0);
            }
            scope.addValue("tmpTarget", tmpTarget);
        };
        GlowFilterActionGL.startOut = function (scope, sprite, context, x, y) {
            var tmpTarget = scope.getValue("tmpTarget");
            tmpTarget.end();
            var out = scope.getValue("out");
            out.start();
            var color = scope.getValue("color");
            if (color) {
                out.clear(color[0], color[1], color[2], 0);
            }
        };
        GlowFilterActionGL.recycleTarget = function (scope, sprite, context, x, y) {
            var src = scope.getValue("src");
            var tmpTarget = scope.getValue("tmpTarget");
            tmpTarget.recycle();
        };
        return GlowFilterActionGL;
    })(FilterActionGL);
    Laya.__init([WebGLFilter]);
})(window, document, Laya);
if (typeof define === 'function' && define.amd) {
    define('laya.core', ['require', "exports"], function (require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
            var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    var Browser = laya.utils.Browser, CSSStyle = laya.display.css.CSSStyle, ClassUtils = laya.utils.ClassUtils;
    var Event = laya.events.Event, HTMLChar = laya.utils.HTMLChar, Loader = laya.net.Loader, Node = laya.display.Node, Rectangle = laya.maths.Rectangle;
    var Render = laya.renders.Render, RenderContext = laya.renders.RenderContext, RenderSprite = laya.renders.RenderSprite;
    var Sprite = laya.display.Sprite, Stat = laya.utils.Stat, Text = laya.display.Text, Texture = laya.resource.Texture;
    var URL = laya.net.URL, Utils = laya.utils.Utils;
    var HTMLParse = (function () {
        function HTMLParse() { }
        __class(HTMLParse, 'laya.html.utils.HTMLParse');
        HTMLParse.parse = function (ower, xmlString, url) {
            xmlString = xmlString.replace(/<br>/g, "<br/>");
            xmlString = "<root>" + xmlString + "</root>";
            xmlString = xmlString.replace(HTMLParse.spacePattern, HTMLParse.char255);
            var xml = Utils.parseXMLFromString(xmlString);
            HTMLParse._parseXML(ower, xml.childNodes[0].childNodes, url);
        };
        HTMLParse._parseXML = function (parent, xml, url, href) {
            var i = 0, n = 0;
            if (xml.join || xml.item) {
                for (i = 0, n = xml.length; i < n; ++i) {
                    HTMLParse._parseXML(parent, xml[i], url, href);
                }
            }
            else {
                var node;
                var nodeName;
                if (xml.nodeType == 3) {
                    var txt;
                    if ((parent instanceof laya.html.dom.HTMLDivElement)) {
                        if (xml.nodeName == null) {
                            xml.nodeName = "#text";
                        }
                        nodeName = xml.nodeName.toLowerCase();
                        txt = xml.textContent.replace(/^\s+|\s+$/g, '');
                        if (txt.length > 0) {
                            node = ClassUtils.getInstance(nodeName);
                            if (node) {
                                parent.addChild(node);
                                ((node).innerTEXT = txt.replace(HTMLParse.char255AndOneSpacePattern, " "));
                            }
                        }
                    }
                    else {
                        txt = xml.textContent.replace(/^\s+|\s+$/g, '');
                        if (txt.length > 0) {
                            ((parent).innerTEXT = txt.replace(HTMLParse.char255AndOneSpacePattern, " "));
                        }
                    }
                    return;
                }
                else {
                    nodeName = xml.nodeName.toLowerCase();
                    if (nodeName == "#comment")
                        return;
                    node = ClassUtils.getInstance(nodeName);
                    if (node) {
                        node = parent.addChild(node);
                        (node).URI = url;
                        (node).href = href;
                        var attributes = xml.attributes;
                        if (attributes && attributes.length > 0) {
                            for (i = 0, n = attributes.length; i < n; ++i) {
                                var attribute = attributes[i];
                                var attrName = attribute.nodeName;
                                var value = attribute.value;
                                node._setAttributes(attrName, value);
                            }
                        }
                        HTMLParse._parseXML(node, xml.childNodes, url, (node).href);
                    }
                    else {
                        HTMLParse._parseXML(parent, xml.childNodes, url, href);
                    }
                }
            }
        };
        HTMLParse.char255 = String.fromCharCode(255);
        HTMLParse.spacePattern = /&nbsp;|&#160;/g;
        HTMLParse.char255AndOneSpacePattern = new RegExp(String.fromCharCode(255) + "|(\\s+)", "g");
        return HTMLParse;
    })();
    var Layout = (function () {
        function Layout() { }
        __class(Layout, 'laya.html.utils.Layout');
        Layout.later = function (element) {
            if (Layout._will == null) {
                Layout._will = [];
                Laya.stage.frameLoop(1, null, function () {
                    if (Layout._will.length < 1)
                        return;
                    for (var i = 0; i < Layout._will.length; i++) {
                        laya.html.utils.Layout.layout(Layout._will[i]);
                    }
                    Layout._will.length = 0;
                });
            }
            Layout._will.push(element);
        };
        Layout.layout = function (element) {
            if (!element || !element._style)
                return null;
            if ((element._style._type & 0x200) === 0)
                return null;
            element.getStyle()._type &= ~0x200;
            var arr = Layout._multiLineLayout(element);
            if (Render.isConchApp && element["the3outCallNative"]) {
                (element).the3outCallNative();
            }
            return arr;
        };
        Layout._multiLineLayout = function (element) {
            if (Text.RightToLeft)
                return Layout._multiLineLayout2(element);
            var elements = new Array;
            element._addChildsToLayout(elements);
            var i = 0, n = elements.length, j = 0;
            var style = element._getCSSStyle();
            var letterSpacing = style.letterSpacing;
            var leading = style.leading;
            var lineHeight = style.lineHeight;
            var widthAuto = style._widthAuto() || !style.wordWrap;
            var width = widthAuto ? 999999 : element.width;
            var height = element.height;
            var maxWidth = 0;
            var exWidth = style.italic ? style.fontSize / 3 : 0;
            var align = style._getAlign();
            var valign = style._getValign();
            var endAdjust = valign !== 0 || align !== 0 || lineHeight != 0;
            var oneLayout;
            var x = 0;
            var y = 0;
            var w = 0;
            var h = 0;
            var tBottom = 0;
            var lines = new Array;
            var curStyle;
            var curPadding;
            var curLine = lines[0] = new LayoutLine();
            var newLine = false, nextNewline = false;
            var htmlWord;
            var sprite;
            curLine.h = 0;
            if (style.italic)
                width -= style.fontSize / 3;
            var tWordWidth = 0;
            var tLineFirstKey = true;
            function addLine() {
                curLine.y = y;
                y += curLine.h + leading;
                if (curLine.h == 0)
                    y += lineHeight;
                curLine.mWidth = tWordWidth;
                tWordWidth = 0;
                curLine = new LayoutLine();
                lines.push(curLine);
                curLine.h = 0;
                x = 0;
                tLineFirstKey = true;
                newLine = false;
            }
            for (i = 0; i < n; i++) {
                oneLayout = elements[i];
                if (oneLayout == null) {
                    if (!tLineFirstKey) {
                        x += Layout.DIV_ELEMENT_PADDING;
                    }
                    curLine.wordStartIndex = curLine.elements.length;
                    continue;
                }
                tLineFirstKey = false;
                if ((oneLayout instanceof laya.html.dom.HTMLBrElement)) {
                    addLine();
                    curLine.y = y;
                    continue;
                }
                else if (oneLayout._isChar()) {
                    htmlWord = oneLayout;
                    if (!htmlWord.isWord) {
                        if (lines.length > 0 && (x + w) > width && curLine.wordStartIndex > 0) {
                            var tLineWord = 0;
                            tLineWord = curLine.elements.length - curLine.wordStartIndex + 1;
                            curLine.elements.length = curLine.wordStartIndex;
                            i -= tLineWord;
                            addLine();
                            continue;
                        }
                        newLine = false;
                        tWordWidth += htmlWord.width;
                    }
                    else {
                        newLine = nextNewline || (htmlWord.char === '\n');
                        curLine.wordStartIndex = curLine.elements.length;
                    }
                    w = htmlWord.width + letterSpacing;
                    h = htmlWord.height;
                    nextNewline = false;
                    newLine = newLine || ((x + w) > width);
                    newLine && addLine();
                    curLine.minTextHeight = Math.min(curLine.minTextHeight, oneLayout.height);
                }
                else {
                    curStyle = oneLayout._getCSSStyle();
                    sprite = oneLayout;
                    curPadding = curStyle.padding;
                    curStyle._getCssFloat() === 0 || (endAdjust = true);
                    newLine = nextNewline || curStyle.lineElement;
                    w = sprite.width * sprite._style._tf.scaleX + curPadding[1] + curPadding[3] + letterSpacing;
                    h = sprite.height * sprite._style._tf.scaleY + curPadding[0] + curPadding[2];
                    nextNewline = curStyle.lineElement;
                    newLine = newLine || ((x + w) > width && curStyle.wordWrap);
                    newLine && addLine();
                }
                curLine.elements.push(oneLayout);
                curLine.h = Math.max(curLine.h, h);
                oneLayout.x = x;
                oneLayout.y = y;
                x += w;
                curLine.w = x - letterSpacing;
                curLine.y = y;
                maxWidth = Math.max(x + exWidth, maxWidth);
            }
            y = curLine.y + curLine.h;
            if (endAdjust) {
                var tY = 0;
                var tWidth = width;
                if (widthAuto && element.width > 0) {
                    tWidth = element.width;
                }
                for (i = 0, n = lines.length; i < n; i++) {
                    lines[i].updatePos(0, tWidth, i, tY, align, valign, lineHeight);
                    tY += Math.max(lineHeight, lines[i].h + leading);
                }
                y = tY;
            }
            widthAuto && (element.width = maxWidth);
            (y > element.height) && (element.height = y);
            return [maxWidth, y];
        };
        Layout._multiLineLayout2 = function (element) {
            var elements = new Array;
            element._addChildsToLayout(elements);
            var i = 0, n = elements.length, j = 0;
            var style = element._getCSSStyle();
            var letterSpacing = style.letterSpacing;
            var leading = style.leading;
            var lineHeight = style.lineHeight;
            var widthAuto = style._widthAuto() || !style.wordWrap;
            var width = widthAuto ? 999999 : element.width;
            var height = element.height;
            var maxWidth = 0;
            var exWidth = style.italic ? style.fontSize / 3 : 0;
            var align = 2 - style._getAlign();
            var valign = style._getValign();
            var endAdjust = valign !== 0 || align !== 0 || lineHeight != 0;
            var oneLayout;
            var x = 0;
            var y = 0;
            var w = 0;
            var h = 0;
            var tBottom = 0;
            var lines = new Array;
            var curStyle;
            var curPadding;
            var curLine = lines[0] = new LayoutLine();
            var newLine = false, nextNewline = false;
            var htmlWord;
            var sprite;
            curLine.h = 0;
            if (style.italic)
                width -= style.fontSize / 3;
            var tWordWidth = 0;
            var tLineFirstKey = true;
            function addLine() {
                curLine.y = y;
                y += curLine.h + leading;
                if (curLine.h == 0)
                    y += lineHeight;
                curLine.mWidth = tWordWidth;
                tWordWidth = 0;
                curLine = new LayoutLine();
                lines.push(curLine);
                curLine.h = 0;
                x = 0;
                tLineFirstKey = true;
                newLine = false;
            }
            for (i = 0; i < n; i++) {
                oneLayout = elements[i];
                if (oneLayout == null) {
                    if (!tLineFirstKey) {
                        x += Layout.DIV_ELEMENT_PADDING;
                    }
                    curLine.wordStartIndex = curLine.elements.length;
                    continue;
                }
                tLineFirstKey = false;
                if ((oneLayout instanceof laya.html.dom.HTMLBrElement)) {
                    addLine();
                    curLine.y = y;
                    continue;
                }
                else if (oneLayout._isChar()) {
                    htmlWord = oneLayout;
                    if (!htmlWord.isWord) {
                        if (lines.length > 0 && (x + w) > width && curLine.wordStartIndex > 0) {
                            var tLineWord = 0;
                            tLineWord = curLine.elements.length - curLine.wordStartIndex + 1;
                            curLine.elements.length = curLine.wordStartIndex;
                            i -= tLineWord;
                            addLine();
                            continue;
                        }
                        newLine = false;
                        tWordWidth += htmlWord.width;
                    }
                    else {
                        newLine = nextNewline || (htmlWord.char === '\n');
                        curLine.wordStartIndex = curLine.elements.length;
                    }
                    w = htmlWord.width + letterSpacing;
                    h = htmlWord.height;
                    nextNewline = false;
                    newLine = newLine || ((x + w) > width);
                    newLine && addLine();
                    curLine.minTextHeight = Math.min(curLine.minTextHeight, oneLayout.height);
                }
                else {
                    curStyle = oneLayout._getCSSStyle();
                    sprite = oneLayout;
                    curPadding = curStyle.padding;
                    curStyle._getCssFloat() === 0 || (endAdjust = true);
                    newLine = nextNewline || curStyle.lineElement;
                    w = sprite.width * sprite._style._tf.scaleX + curPadding[1] + curPadding[3] + letterSpacing;
                    h = sprite.height * sprite._style._tf.scaleY + curPadding[0] + curPadding[2];
                    nextNewline = curStyle.lineElement;
                    newLine = newLine || ((x + w) > width && curStyle.wordWrap);
                    newLine && addLine();
                }
                curLine.elements.push(oneLayout);
                curLine.h = Math.max(curLine.h, h);
                oneLayout.x = x;
                oneLayout.y = y;
                x += w;
                curLine.w = x - letterSpacing;
                curLine.y = y;
                maxWidth = Math.max(x + exWidth, maxWidth);
            }
            y = curLine.y + curLine.h;
            if (endAdjust) {
                var tY = 0;
                var tWidth = width;
                for (i = 0, n = lines.length; i < n; i++) {
                    lines[i].updatePos(0, tWidth, i, tY, align, valign, lineHeight);
                    tY += Math.max(lineHeight, lines[i].h + leading);
                }
                y = tY;
            }
            widthAuto && (element.width = maxWidth);
            (y > element.height) && (element.height = y);
            for (i = 0, n = lines.length; i < n; i++) {
                lines[i].revertOrder(width);
            }
            return [maxWidth, y];
        };
        Layout._will = null;
        Layout.DIV_ELEMENT_PADDING = 0;
        return Layout;
    })();
    var LayoutLine = (function () {
        function LayoutLine() {
            this.x = 0;
            this.y = 0;
            this.w = 0;
            this.h = 0;
            this.wordStartIndex = 0;
            this.minTextHeight = 99999;
            this.mWidth = 0;
            this.elements = new Array;
        }
        __class(LayoutLine, 'laya.html.utils.LayoutLine');
        var __proto = LayoutLine.prototype;
        __proto.updatePos = function (left, width, lineNum, dy, align, valign, lineHeight) {
            var w = 0;
            var one;
            if (this.elements.length > 0) {
                one = this.elements[this.elements.length - 1];
                w = one.x + one.width - this.elements[0].x;
            }
            ;
            var dx = 0, ddy = NaN;
            align === 1 && (dx = (width - w) / 2);
            align === 2 && (dx = (width - w));
            lineHeight === 0 || valign != 0 || (valign = 1);
            for (var i = 0, n = this.elements.length; i < n; i++) {
                one = this.elements[i];
                var tCSSStyle = one._getCSSStyle();
                dx !== 0 && (one.x += dx);
                switch (tCSSStyle._getValign()) {
                    case 0:
                        one.y = dy;
                        break;
                    case 1:
                        ;
                        var tMinTextHeight = 0;
                        if (this.minTextHeight != 99999) {
                            tMinTextHeight = this.minTextHeight;
                        }
                        ;
                        var tBottomLineY = (tMinTextHeight + lineHeight) / 2;
                        tBottomLineY = Math.max(tBottomLineY, this.h);
                        if ((one instanceof laya.html.dom.HTMLImageElement)) {
                            ddy = dy + tBottomLineY - one.height;
                        }
                        else {
                            ddy = dy + tBottomLineY - one.height;
                        }
                        one.y = ddy;
                        break;
                    case 2:
                        one.y = dy + (lineHeight - one.height);
                        break;
                }
            }
        };
        __proto.revertOrder = function (width) {
            var one;
            if (this.elements.length > 0) {
                var i = 0, len = 0;
                len = this.elements.length;
                for (i = 0; i < len; i++) {
                    one = this.elements[i];
                    one.x = width - one.x - one.width;
                }
            }
        };
        return LayoutLine;
    })();
    var HTMLElement = (function (_super) {
        function HTMLElement() {
            this.URI = null;
            this._href = null;
            HTMLElement.__super.call(this);
            this._text = HTMLElement._EMPTYTEXT;
            this.setStyle(new CSSStyle(this));
            this._getCSSStyle().valign = "middle";
            this.mouseEnabled = true;
        }
        __class(HTMLElement, 'laya.html.dom.HTMLElement', _super);
        var __proto = HTMLElement.prototype;
        __proto.the3outCallNative = function () {
            var n = 0;
            if (this._childs && (n = this._childs.length) > 0) {
                for (var i = 0; i < n; i++) {
                    this._childs[i].the3outCallNative && this._childs[i].the3outCallNative();
                }
            }
            ;
            var word = this._getWords();
            word ? laya.html.dom.HTMLElement.fillWords(this, word, 0, 0, this.style.font, this.style.color, this.style.underLine) : this.graphics.clear();
        };
        __proto.appendChild = function (c) {
            return this.addChild(c);
        };
        __proto._getWords2 = function () {
            var txt = this._text.text;
            if (!txt || txt.length === 0)
                return null;
            var i = 0, n = 0;
            var realWords;
            var drawWords;
            if (!this._text.drawWords) {
                realWords = txt.split(" ");
                n = realWords.length - 1;
                drawWords = [];
                for (i = 0; i < n; i++) {
                    drawWords.push(realWords[i], " ");
                }
                if (n >= 0)
                    drawWords.push(realWords[n]);
                this._text.drawWords = drawWords;
            }
            else {
                drawWords = this._text.drawWords;
            }
            ;
            var words = this._text.words;
            if (words && words.length === drawWords.length)
                return words;
            words === null && (this._text.words = words = []);
            words.length = drawWords.length;
            var size;
            var style = this.style;
            var fontStr = style.font;
            for (i = 0, n = drawWords.length; i < n; i++) {
                size = Utils.measureText(drawWords[i], fontStr);
                var tHTMLChar = words[i] = new HTMLChar(drawWords[i], size.width, size.height || style.fontSize, style);
                if (tHTMLChar.char.length > 1) {
                    tHTMLChar.charNum = tHTMLChar.char;
                }
                if (this.href) {
                    var tSprite = new Sprite();
                    this.addChild(tSprite);
                    tHTMLChar.setSprite(tSprite);
                }
            }
            return words;
        };
        __proto._getWords = function () {
            if (!Text.CharacterCache)
                return this._getWords2();
            var txt = this._text.text;
            if (!txt || txt.length === 0)
                return null;
            var words = this._text.words;
            if (words && words.length === txt.length)
                return words;
            words === null && (this._text.words = words = []);
            words.length = txt.length;
            var size;
            var style = this.style;
            var fontStr = style.font;
            var startX = 0;
            for (var i = 0, n = txt.length; i < n; i++) {
                size = Utils.measureText(txt.charAt(i), fontStr);
                var tHTMLChar = words[i] = new HTMLChar(txt.charAt(i), size.width, size.height || style.fontSize, style);
                if (this.href) {
                    var tSprite = new Sprite();
                    this.addChild(tSprite);
                    tHTMLChar.setSprite(tSprite);
                }
            }
            return words;
        };
        __proto.showLinkSprite = function () {
            var words = this._text.words;
            if (words) {
                var tLinkSpriteList = [];
                var tSprite;
                var tHtmlChar;
                for (var i = 0; i < words.length; i++) {
                    tHtmlChar = words[i];
                    tSprite = new Sprite();
                    tSprite.graphics.drawRect(0, 0, tHtmlChar.width, tHtmlChar.height, "#ff0000");
                    tSprite.width = tHtmlChar.width;
                    tSprite.height = tHtmlChar.height;
                    this.addChild(tSprite);
                    tLinkSpriteList.push(tSprite);
                }
            }
        };
        __proto._layoutLater = function () {
            var style = this.style;
            if ((style._type & 0x200))
                return;
            if (style.widthed(this) && (this._childs.length > 0 || this._getWords() != null) && style.block) {
                Layout.later(this);
                style._type |= 0x200;
            }
            else {
                this.parent && (this.parent)._layoutLater();
            }
        };
        __proto._setAttributes = function (name, value) {
            switch (name) {
                case 'style':
                    this.style.cssText(value);
                    return;
                case 'class':
                    this.className = value;
                    return;
            }
            _super.prototype._setAttributes.call(this, name, value);
        };
        __proto.updateHref = function () {
            if (this._href != null) {
                var words = this._getWords();
                if (words) {
                    var tHTMLChar;
                    var tSprite;
                    for (var i = 0; i < words.length; i++) {
                        tHTMLChar = words[i];
                        tSprite = tHTMLChar.getSprite();
                        if (tSprite) {
                            tSprite.size(tHTMLChar.width, tHTMLChar.height);
                            tSprite.on("click", this, this.onLinkHandler);
                        }
                    }
                }
            }
        };
        __proto.onLinkHandler = function (e) {
            switch (e.type) {
                case "click":
                    ;
                    var target = this;
                    while (target) {
                        target.event("link", [this.href]);
                        target = target.parent;
                    }
                    break;
            }
        };
        __proto.formatURL = function (url) {
            if (!this.URI)
                return url;
            return URL.formatURL(url, this.URI ? this.URI.path : null);
        };
        __getset(0, __proto, 'href', function () {
            return this._href;
        }, function (url) {
            this._href = url;
            if (url != null) {
                this._getCSSStyle().underLine = 1;
                this.updateHref();
            }
        });
        __getset(0, __proto, 'color', null, function (value) {
            this.style.color = value;
        });
        __getset(0, __proto, 'onClick', null, function (value) {
            var fn;
            Laya._runScript("fn=function(event){" + value + ";}");
            this.on("click", this, fn);
        });
        __getset(0, __proto, 'id', null, function (value) {
            HTMLDocument.document.setElementById(value, this);
        });
        __getset(0, __proto, 'innerTEXT', function () {
            return this._text.text;
        }, function (value) {
            this.text = value;
        });
        __getset(0, __proto, 'style', function () {
            return this._style;
        });
        __getset(0, __proto, 'text', function () {
            return this._text.text;
        }, function (value) {
            if (this._text == HTMLElement._EMPTYTEXT) {
                this._text = { text: value, words: null };
            }
            else {
                this._text.text = value;
                this._text.words && (this._text.words.length = 0);
            }
            Render.isConchApp && this.the3outCallNative();
            this._renderType |= 0x800;
            this.repaint();
            this.updateHref();
        });
        __getset(0, __proto, 'parent', _super.prototype._$get_parent, function (value) {
            if ((value instanceof laya.html.dom.HTMLElement)) {
                var p = value;
                this.URI || (this.URI = p.URI);
                this.style.inherit(p.style);
            }
            Laya.superSet(Sprite, this, 'parent', value);
        });
        __getset(0, __proto, 'className', null, function (value) {
            this.style.attrs(HTMLDocument.document.styleSheets['.' + value]);
        });
        HTMLElement.fillWords = function (ele, words, x, y, font, color, underLine) {
            ele.graphics.clear();
            for (var i = 0, n = words.length; i < n; i++) {
                var a = words[i];
                ele.graphics.fillText(a.char, a.x + x, a.y + y, font, color, 'left', underLine);
            }
        };
        HTMLElement._EMPTYTEXT = { text: null, words: null };
        return HTMLElement;
    })(Sprite);
    var HTMLBrElement = (function (_super) {
        function HTMLBrElement() {
            HTMLBrElement.__super.call(this);
            this.style.lineElement = true;
            this.style.block = true;
        }
        __class(HTMLBrElement, 'laya.html.dom.HTMLBrElement', _super);
        return HTMLBrElement;
    })(HTMLElement);
    var HTMLDivElement = (function (_super) {
        function HTMLDivElement() {
            this.contextHeight = NaN;
            this.contextWidth = NaN;
            HTMLDivElement.__super.call(this);
            this.style.block = true;
            this.style.lineElement = true;
            this.style.width = 200;
            this.style.height = 200;
            HTMLStyleElement;
        }
        __class(HTMLDivElement, 'laya.html.dom.HTMLDivElement', _super);
        var __proto = HTMLDivElement.prototype;
        __proto.appendHTML = function (text) {
            HTMLParse.parse(this, text, this.URI);
            this.layout();
        };
        __proto._addChildsToLayout = function (out) {
            var words = this._getWords();
            if (words == null && this._childs.length == 0)
                return false;
            words && words.forEach(function (o) {
                out.push(o);
            });
            var tFirstKey = true;
            for (var i = 0, len = this._childs.length; i < len; i++) {
                var o = this._childs[i];
                if (tFirstKey) {
                    tFirstKey = false;
                }
                else {
                    out.push(null);
                }
                o._addToLayout(out);
            }
            return true;
        };
        __proto._addToLayout = function (out) {
            this.layout();
        };
        __proto.layout = function () {
            if (!this.style)
                return;
            this.style._type |= 0x200;
            var tArray = Layout.layout(this);
            if (tArray) {
                if (!this._$P.mHtmlBounds)
                    this._set$P("mHtmlBounds", new Rectangle());
                var tRectangle = this._$P.mHtmlBounds;
                tRectangle.x = tRectangle.y = 0;
                tRectangle.width = this.contextWidth = tArray[0];
                tRectangle.height = this.contextHeight = tArray[1];
                this.setBounds(tRectangle);
            }
        };
        __getset(0, __proto, 'height', function () {
            if (this._height)
                return this._height;
            return this.contextHeight;
        }, _super.prototype._$set_height);
        __getset(0, __proto, 'innerHTML', null, function (text) {
            this.destroyChildren();
            this.appendHTML(text);
        });
        __getset(0, __proto, 'width', function () {
            if (this._width)
                return this._width;
            return this.contextWidth;
        }, function (value) {
            var changed = false;
            if (value === 0) {
                changed = value != this._width;
            }
            else {
                changed = value != this.width;
            }
            Laya.superSet(HTMLElement, this, 'width', value);
            if (changed)
                this.layout();
        });
        return HTMLDivElement;
    })(HTMLElement);
    var HTMLImageElement = (function (_super) {
        function HTMLImageElement() {
            this._tex = null;
            this._url = null;
            this._renderArgs = [];
            HTMLImageElement.__super.call(this);
            this.style.block = true;
        }
        __class(HTMLImageElement, 'laya.html.dom.HTMLImageElement', _super);
        var __proto = HTMLImageElement.prototype;
        __proto._addToLayout = function (out) {
            !this._style.absolute && out.push(this);
        };
        __proto.render = function (context, x, y) {
            if (!this._tex || !this._tex.loaded || !this._tex.loaded || this._width < 1 || this._height < 1)
                return;
            Stat.spriteCount++;
            this._renderArgs[0] = this._tex;
            this._renderArgs[1] = this.x;
            this._renderArgs[2] = this.y;
            this._renderArgs[3] = this.width || this._tex.width;
            this._renderArgs[4] = this.height || this._tex.height;
            context.ctx.drawTexture2(x, y, this.style.translateX, this.style.translateY, this.transform, this.style.alpha, this.style.blendMode, this._renderArgs);
        };
        __proto.the3outCallNative = function () {
            var n = 0;
            if (this._childs && (n = this._childs.length) > 0) {
                for (var i = 0; i < n; i++) {
                    this._childs[i].the3outCallNative && this._childs[i].the3outCallNative();
                }
            }
        };
        __getset(0, __proto, 'src', null, function (url) {
            var _$this = this;
            url = this.formatURL(url);
            if (this._url == url)
                return;
            this._url = url;
            var tex = this._tex = Loader.getRes(url);
            if (!tex) {
                this._tex = tex = new Texture();
                tex.load(url);
                Loader.cacheRes(url, tex);
            }
            function onloaded() {
                if (_$this.destroyed)
                    return;
                var style = _$this._style;
                var w = style.widthed(_$this) ? -1 : _$this._tex.width;
                var h = style.heighted(_$this) ? -1 : _$this._tex.height;
                if (!style.widthed(_$this) && _$this._width != _$this._tex.width) {
                    _$this.width = _$this._tex.width;
                    _$this.parent && (_$this.parent)._layoutLater();
                }
                if (!style.heighted(_$this) && _$this._height != _$this._tex.height) {
                    _$this.height = _$this._tex.height;
                    _$this.parent && (_$this.parent)._layoutLater();
                }
                if (Render.isConchApp) {
                    _$this._renderArgs[0] = _$this._tex;
                    _$this._renderArgs[1] = _$this.x;
                    _$this._renderArgs[2] = _$this.y;
                    _$this._renderArgs[3] = _$this.width || _$this._tex.width;
                    _$this._renderArgs[4] = _$this.height || _$this._tex.height;
                    _$this.graphics.drawTexture(_$this._tex, 0, 0, _$this._renderArgs[3], _$this._renderArgs[4]);
                }
                _$this.repaint();
                _$this.parentRepaint();
            }
            tex.loaded ? onloaded() : tex.on("loaded", null, onloaded);
        });
        return HTMLImageElement;
    })(HTMLElement);
})(window, document, Laya);
if (typeof define === 'function' && define.amd) {
    define('laya.core', ['require', "exports"], function (require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
            var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    var DiagonalMovement = (function () {
        function DiagonalMovement() { }
        __class(DiagonalMovement, 'PathFinding.core.DiagonalMovement');
        DiagonalMovement.Always = 1;
        DiagonalMovement.Never = 2;
        DiagonalMovement.IfAtMostOneObstacle = 3;
        DiagonalMovement.OnlyWhenNoObstacles = 4;
        return DiagonalMovement;
    })();
    var Grid = (function () {
        function Grid(width_or_matrix, height, matrix) {
            this.width = 0;
            this.height = 0;
            this.nodes = null;
            var width = 0;
            if ((typeof width_or_matrix == 'number')) {
                width = width_or_matrix;
            }
            else {
                height = width_or_matrix.length;
                width = width_or_matrix[0].length;
                matrix = width_or_matrix;
            }
            this.width = width;
            this.height = height;
            this.nodes = this._buildNodes(width, height, matrix);
        }
        __class(Grid, 'PathFinding.core.Grid');
        var __proto = Grid.prototype;
        __proto._buildNodes = function (width, height, matrix) {
            var i = 0, j = 0, nodes = [];
            for (i = 0; i < height; ++i) {
                nodes[i] = [];
                for (j = 0; j < width; ++j) {
                    nodes[i][j] = new Node$1(j, i);
                }
            }
            if (matrix == null) {
                return nodes;
            }
            if (matrix.length != height || matrix[0].length != width) {
                throw new Error('Matrix size does not fit');
            }
            for (i = 0; i < height; ++i) {
                for (j = 0; j < width; ++j) {
                    if (matrix[i][j]) {
                        nodes[i][j].walkable = false;
                    }
                }
            }
            return nodes;
        };
        __proto.getNodeAt = function (x, y) {
            return this.nodes[y][x];
        };
        __proto.isWalkableAt = function (x, y) {
            return this.isInside(x, y) && this.nodes[y][x].walkable;
        };
        __proto.isInside = function (x, y) {
            return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);
        };
        __proto.setWalkableAt = function (x, y, walkable) {
            this.nodes[y][x].walkable = walkable;
        };
        __proto.getNeighbors = function (node, diagonalMovement) {
            var x = node.x, y = node.y, neighbors = [], s0 = false, d0 = false, s1 = false, d1 = false, s2 = false, d2 = false, s3 = false, d3 = false, nodes = this.nodes;
            if (this.isWalkableAt(x, y - 1)) {
                neighbors.push(nodes[y - 1][x]);
                s0 = true;
            }
            if (this.isWalkableAt(x + 1, y)) {
                neighbors.push(nodes[y][x + 1]);
                s1 = true;
            }
            if (this.isWalkableAt(x, y + 1)) {
                neighbors.push(nodes[y + 1][x]);
                s2 = true;
            }
            if (this.isWalkableAt(x - 1, y)) {
                neighbors.push(nodes[y][x - 1]);
                s3 = true;
            }
            if (diagonalMovement == DiagonalMovement.Never) {
                return neighbors;
            }
            if (diagonalMovement == DiagonalMovement.OnlyWhenNoObstacles) {
                d0 = s3 && s0;
                d1 = s0 && s1;
                d2 = s1 && s2;
                d3 = s2 && s3;
            }
            else if (diagonalMovement == DiagonalMovement.IfAtMostOneObstacle) {
                d0 = s3 || s0;
                d1 = s0 || s1;
                d2 = s1 || s2;
                d3 = s2 || s3;
            }
            else if (diagonalMovement == DiagonalMovement.Always) {
                d0 = true;
                d1 = true;
                d2 = true;
                d3 = true;
            }
            else {
                throw new Error('Incorrect value of diagonalMovement');
            }
            if (d0 && this.isWalkableAt(x - 1, y - 1)) {
                neighbors.push(nodes[y - 1][x - 1]);
            }
            if (d1 && this.isWalkableAt(x + 1, y - 1)) {
                neighbors.push(nodes[y - 1][x + 1]);
            }
            if (d2 && this.isWalkableAt(x + 1, y + 1)) {
                neighbors.push(nodes[y + 1][x + 1]);
            }
            if (d3 && this.isWalkableAt(x - 1, y + 1)) {
                neighbors.push(nodes[y + 1][x - 1]);
            }
            return neighbors;
        };
        __proto.clone = function () {
            var i = 0, j = 0, width = this.width, height = this.height, thisNodes = this.nodes, newGrid = new Grid(width, height), newNodes = [];
            for (i = 0; i < height; ++i) {
                newNodes[i] = [];
                for (j = 0; j < width; ++j) {
                    newNodes[i][j] = new Node$1(j, i, thisNodes[i][j].walkable);
                }
            }
            newGrid.nodes = newNodes;
            return newGrid;
        };
        __proto.reset = function () {
            var _node;
            for (var i = 0; i < this.height; ++i) {
                for (var j = 0; j < this.width; ++j) {
                    _node = this.nodes[i][j];
                    _node.g = 0;
                    _node.f = 0;
                    _node.h = 0;
                    _node.by = 0;
                    _node.parent = null;
                    _node.opened = null;
                    _node.closed = null;
                    _node.tested = null;
                }
            }
        };
        Grid.createGridFromAStarMap = function (texture) {
            var textureWidth = texture.width;
            var textureHeight = texture.height;
            var pixelsInfo = texture.getPixels();
            var aStarArr = [];
            var index = 0;
            for (var w = 0; w < textureWidth; w++) {
                var colaStarArr = aStarArr[w] = [];
                for (var h = 0; h < textureHeight; h++) {
                    var r = pixelsInfo[index++];
                    var g = pixelsInfo[index++];
                    var b = pixelsInfo[index++];
                    var a = pixelsInfo[index++];
                    if (r == 255 && g == 255 && b == 255 && a == 255)
                        colaStarArr[h] = 1;
                    else {
                        colaStarArr[h] = 0;
                    }
                }
            }
            ;
            var gird = new Grid(textureWidth, textureHeight, aStarArr);
            return gird;
        };
        return Grid;
    })();
    var Heuristic = (function () {
        function Heuristic() { }
        __class(Heuristic, 'PathFinding.core.Heuristic');
        Heuristic.manhattan = function (dx, dy) {
            return dx + dy;
        };
        Heuristic.euclidean = function (dx, dy) {
            return Math.sqrt(dx * dx + dy * dy);
        };
        Heuristic.octile = function (dx, dy) {
            var F = Math.SQRT2 - 1;
            return (dx < dy) ? F * dx + dy : F * dy + dx;
        };
        Heuristic.chebyshev = function (dx, dy) {
            return Math.max(dx, dy);
        };
        return Heuristic;
    })();
    var Node$1 = (function () {
        function Node(x, y, walkable) {
            this.x = 0;
            this.y = 0;
            this.g = 0;
            this.f = 0;
            this.h = 0;
            this.by = 0;
            this.parent = null;
            this.opened = null;
            this.closed = null;
            this.tested = null;
            this.retainCount = null;
            this.walkable = false;
            (walkable === void 0) && (walkable = true);
            this.x = x;
            this.y = y;
            this.walkable = walkable;
        }
        __class(Node, 'PathFinding.core.Node', null, 'Node$1');
        return Node;
    })();
    var Util = (function () {
        function Util() { }
        __class(Util, 'PathFinding.core.Util');
        Util.backtrace = function (node) {
            var path = [[node.x, node.y]];
            while (node.parent) {
                node = node.parent;
                path.push([node.x, node.y]);
            }
            return path.reverse();
        };
        Util.biBacktrace = function (nodeA, nodeB) {
            var pathA = Util.backtrace(nodeA), pathB = Util.backtrace(nodeB);
            return pathA.concat(pathB.reverse());
        };
        Util.pathLength = function (path) {
            var i = 0, sum = 0, a = 0, b = 0, dx = 0, dy = 0;
            for (i = 1; i < path.length; ++i) {
                a = path[i - 1];
                b = path[i];
                dx = a[0] - b[0];
                dy = a[1] - b[1];
                sum += Math.sqrt(dx * dx + dy * dy);
            }
            return sum;
        };
        Util.interpolate = function (x0, y0, x1, y1) {
            var abs = Math.abs, line = [], sx = 0, sy = 0, dx = 0, dy = 0, err = 0, e2 = 0;
            dx = abs(x1 - x0);
            dy = abs(y1 - y0);
            sx = (x0 < x1) ? 1 : -1;
            sy = (y0 < y1) ? 1 : -1;
            err = dx - dy;
            while (true) {
                line.push([x0, y0]);
                if (x0 == x1 && y0 == y1) {
                    break;
                }
                e2 = 2 * err;
                if (e2 > -dy) {
                    err = err - dy;
                    x0 = x0 + sx;
                }
                if (e2 < dx) {
                    err = err + dx;
                    y0 = y0 + sy;
                }
            }
            return line;
        };
        Util.expandPath = function (path) {
            var expanded = [], len = path.length, coord0, coord1, interpolated, interpolatedLen = 0, i = 0, j = 0;
            if (len < 2) {
                return expanded;
            }
            for (i = 0; i < len - 1; ++i) {
                coord0 = path[i];
                coord1 = path[i + 1];
                interpolated = Util.interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);
                interpolatedLen = interpolated.length;
                for (j = 0; j < interpolatedLen - 1; ++j) {
                    expanded.push(interpolated[j]);
                }
            }
            expanded.push(path[len - 1]);
            return expanded;
        };
        Util.smoothenPath = function (grid, path) {
            var len = path.length, x0 = path[0][0], y0 = path[0][1], x1 = path[len - 1][0], y1 = path[len - 1][1], sx = 0, sy = 0, ex = 0, ey = 0, newPath, i = 0, j = 0, coord, line, testCoord, blocked = false, lastValidCoord;
            sx = x0;
            sy = y0;
            newPath = [[sx, sy]];
            for (i = 2; i < len; ++i) {
                coord = path[i];
                ex = coord[0];
                ey = coord[1];
                line = Util.interpolate(sx, sy, ex, ey);
                blocked = false;
                for (j = 1; j < line.length; ++j) {
                    testCoord = line[j];
                    if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {
                        blocked = true;
                        break;
                    }
                }
                if (blocked) {
                    lastValidCoord = path[i - 1];
                    newPath.push(lastValidCoord);
                    sx = lastValidCoord[0];
                    sy = lastValidCoord[1];
                }
            }
            newPath.push([x1, y1]);
            return newPath;
        };
        Util.compressPath = function (path) {
            if (path.length < 3) {
                return path;
            }
            ;
            var compressed = [], sx = path[0][0], sy = path[0][1], px = path[1][0], py = path[1][1], dx = px - sx, dy = py - sy, lx = 0, ly = 0, ldx = 0, ldy = 0, sq = NaN, i = 0;
            sq = Math.sqrt(dx * dx + dy * dy);
            dx /= sq;
            dy /= sq;
            compressed.push([sx, sy]);
            for (i = 2; i < path.length; i++) {
                lx = px;
                ly = py;
                ldx = dx;
                ldy = dy;
                px = path[i][0];
                py = path[i][1];
                dx = px - lx;
                dy = py - ly;
                sq = Math.sqrt(dx * dx + dy * dy);
                dx /= sq;
                dy /= sq;
                if (dx !== ldx || dy !== ldy) {
                    compressed.push([lx, ly]);
                }
            }
            compressed.push([px, py]);
            return compressed;
        };
        return Util;
    })();
    var AStarFinder = (function () {
        function AStarFinder(opt) {
            this.allowDiagonal = false;
            this.dontCrossCorners = false;
            this.heuristic = null;
            this.weight = 0;
            this.diagonalMovement = 0;
            opt = opt || {};
            this.allowDiagonal = opt.allowDiagonal;
            this.dontCrossCorners = opt.dontCrossCorners;
            this.heuristic = opt.heuristic || Heuristic.manhattan;
            this.weight = opt.weight || 1;
            this.diagonalMovement = opt.diagonalMovement;
            if (!this.diagonalMovement) {
                if (!this.allowDiagonal) {
                    this.diagonalMovement = DiagonalMovement.Never;
                }
                else {
                    if (this.dontCrossCorners) {
                        this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
                    }
                    else {
                        this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
                    }
                }
            }
            if (this.diagonalMovement === DiagonalMovement.Never) {
                this.heuristic = opt.heuristic || Heuristic.manhattan;
            }
            else {
                this.heuristic = opt.heuristic || Heuristic.octile;
            }
        }
        __class(AStarFinder, 'PathFinding.finders.AStarFinder');
        var __proto = AStarFinder.prototype;
        __proto.findPath = function (startX, startY, endX, endY, grid) {
            var openList = new Heap(function (nodeA, nodeB) {
                return nodeA.f - nodeB.f;
            }), startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), heuristic = this.heuristic, diagonalMovement = this.diagonalMovement, weight = this.weight, abs = Math.abs, SQRT2 = Math.SQRT2, node, neighbors, neighbor, i = 0, l = 0, x = 0, y = 0, ng = 0;
            startNode.g = 0;
            startNode.f = 0;
            openList.push(startNode);
            startNode.opened = true;
            while (!openList.empty()) {
                node = openList.pop();
                node.closed = true;
                if (node === endNode) {
                    return Util.backtrace(endNode);
                }
                neighbors = grid.getNeighbors(node, diagonalMovement);
                for (i = 0, l = neighbors.length; i < l; ++i) {
                    neighbor = neighbors[i];
                    if (neighbor.closed) {
                        continue;
                    }
                    x = neighbor.x;
                    y = neighbor.y;
                    ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);
                    if (!neighbor.opened || ng < neighbor.g) {
                        neighbor.g = ng;
                        neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));
                        neighbor.f = neighbor.g + neighbor.h;
                        neighbor.parent = node;
                        if (!neighbor.opened) {
                            openList.push(neighbor);
                            neighbor.opened = true;
                        }
                        else {
                            openList.updateItem(neighbor);
                        }
                    }
                }
            }
            return [];
        };
        return AStarFinder;
    })();
    var BiAStarFinder = (function () {
        function BiAStarFinder(opt) {
            this.allowDiagonal = false;
            this.dontCrossCorners = false;
            this.diagonalMovement = 0;
            this.heuristic = null;
            this.weight = 0;
            opt = opt || {};
            this.allowDiagonal = opt.allowDiagonal;
            this.dontCrossCorners = opt.dontCrossCorners;
            this.diagonalMovement = opt.diagonalMovement;
            this.heuristic = opt.heuristic || Heuristic.manhattan;
            this.weight = opt.weight || 1;
            if (!this.diagonalMovement) {
                if (!this.allowDiagonal) {
                    this.diagonalMovement = DiagonalMovement.Never;
                }
                else {
                    if (this.dontCrossCorners) {
                        this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
                    }
                    else {
                        this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
                    }
                }
            }
            if (this.diagonalMovement == DiagonalMovement.Never) {
                this.heuristic = opt.heuristic || Heuristic.manhattan;
            }
            else {
                this.heuristic = opt.heuristic || Heuristic.octile;
            }
        }
        __class(BiAStarFinder, 'PathFinding.finders.BiAStarFinder');
        var __proto = BiAStarFinder.prototype;
        __proto.findPath = function (startX, startY, endX, endY, grid) {
            var cmp = function (nodeA, nodeB) {
                return nodeA.f - nodeB.f;
            };
            var startOpenList = new Heap(cmp), endOpenList = new Heap(cmp), startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), heuristic = this.heuristic, diagonalMovement = this.diagonalMovement, weight = this.weight, abs = Math.abs, SQRT2 = Math.SQRT2, node, neighbors, neighbor, i = 0, l = 0, x = 0, y = 0, ng = 0, BY_START = 1, BY_END = 2;
            startNode.g = 0;
            startNode.f = 0;
            startOpenList.push(startNode);
            startNode.opened = BY_START;
            endNode.g = 0;
            endNode.f = 0;
            endOpenList.push(endNode);
            endNode.opened = BY_END;
            while (!startOpenList.empty() && !endOpenList.empty()) {
                node = startOpenList.pop();
                node.closed = true;
                neighbors = grid.getNeighbors(node, diagonalMovement);
                for (i = 0, l = neighbors.length; i < l; ++i) {
                    neighbor = neighbors[i];
                    if (neighbor.closed) {
                        continue;
                    }
                    if (neighbor.opened === BY_END) {
                        return Util.biBacktrace(node, neighbor);
                    }
                    x = neighbor.x;
                    y = neighbor.y;
                    ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);
                    if (!neighbor.opened || ng < neighbor.g) {
                        neighbor.g = ng;
                        neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));
                        neighbor.f = neighbor.g + neighbor.h;
                        neighbor.parent = node;
                        if (!neighbor.opened) {
                            startOpenList.push(neighbor);
                            neighbor.opened = BY_START;
                        }
                        else {
                            startOpenList.updateItem(neighbor);
                        }
                    }
                }
                node = endOpenList.pop();
                node.closed = true;
                neighbors = grid.getNeighbors(node, diagonalMovement);
                for (i = 0, l = neighbors.length; i < l; ++i) {
                    neighbor = neighbors[i];
                    if (neighbor.closed) {
                        continue;
                    }
                    if (neighbor.opened === BY_START) {
                        return Util.biBacktrace(neighbor, node);
                    }
                    x = neighbor.x;
                    y = neighbor.y;
                    ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);
                    if (!neighbor.opened || ng < neighbor.g) {
                        neighbor.g = ng;
                        neighbor.h = neighbor.h || weight * heuristic(abs(x - startX), abs(y - startY));
                        neighbor.f = neighbor.g + neighbor.h;
                        neighbor.parent = node;
                        if (!neighbor.opened) {
                            endOpenList.push(neighbor);
                            neighbor.opened = BY_END;
                        }
                        else {
                            endOpenList.updateItem(neighbor);
                        }
                    }
                }
            }
            return [];
        };
        return BiAStarFinder;
    })();
    var BiBreadthFirstFinder = (function () {
        function BiBreadthFirstFinder(opt) {
            this.allowDiagonal = false;
            this.dontCrossCorners = false;
            this.heuristic = null;
            this.weight = 0;
            this.diagonalMovement = 0;
            opt = opt || {};
            this.allowDiagonal = opt.allowDiagonal;
            this.dontCrossCorners = opt.dontCrossCorners;
            this.diagonalMovement = opt.diagonalMovement;
            if (!this.diagonalMovement) {
                if (!this.allowDiagonal) {
                    this.diagonalMovement = DiagonalMovement.Never;
                }
                else {
                    if (this.dontCrossCorners) {
                        this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
                    }
                    else {
                        this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
                    }
                }
            }
        }
        __class(BiBreadthFirstFinder, 'PathFinding.finders.BiBreadthFirstFinder');
        var __proto = BiBreadthFirstFinder.prototype;
        __proto.findPath = function (startX, startY, endX, endY, grid) {
            var startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), startOpenList = [], endOpenList = [], neighbors, neighbor, node, diagonalMovement = this.diagonalMovement, BY_START = 0, BY_END = 1, i = 0, l = 0;
            startOpenList.push(startNode);
            startNode.opened = true;
            startNode.by = BY_START;
            endOpenList.push(endNode);
            endNode.opened = true;
            endNode.by = BY_END;
            while (startOpenList.length && endOpenList.length) {
                node = startOpenList.shift();
                node.closed = true;
                neighbors = grid.getNeighbors(node, diagonalMovement);
                for (i = 0, l = neighbors.length; i < l; ++i) {
                    neighbor = neighbors[i];
                    if (neighbor.closed) {
                        continue;
                    }
                    if (neighbor.opened) {
                        if (neighbor.by === BY_END) {
                            return Util.biBacktrace(node, neighbor);
                        }
                        continue;
                    }
                    startOpenList.push(neighbor);
                    neighbor.parent = node;
                    neighbor.opened = true;
                    neighbor.by = BY_START;
                }
                node = endOpenList.shift();
                node.closed = true;
                neighbors = grid.getNeighbors(node, diagonalMovement);
                for (i = 0, l = neighbors.length; i < l; ++i) {
                    neighbor = neighbors[i];
                    if (neighbor.closed) {
                        continue;
                    }
                    if (neighbor.opened) {
                        if (neighbor.by === BY_START) {
                            return Util.biBacktrace(neighbor, node);
                        }
                        continue;
                    }
                    endOpenList.push(neighbor);
                    neighbor.parent = node;
                    neighbor.opened = true;
                    neighbor.by = BY_END;
                }
            }
            return [];
        };
        return BiBreadthFirstFinder;
    })();
    var BreadthFirstFinder = (function () {
        function BreadthFirstFinder(opt) {
            this.allowDiagonal = false;
            this.dontCrossCorners = false;
            this.heuristic = null;
            this.weight = 0;
            this.diagonalMovement = 0;
            opt = opt || {};
            this.allowDiagonal = opt.allowDiagonal;
            this.dontCrossCorners = opt.dontCrossCorners;
            this.diagonalMovement = opt.diagonalMovement;
            if (!this.diagonalMovement) {
                if (!this.allowDiagonal) {
                    this.diagonalMovement = DiagonalMovement.Never;
                }
                else {
                    if (this.dontCrossCorners) {
                        this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
                    }
                    else {
                        this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
                    }
                }
            }
        }
        __class(BreadthFirstFinder, 'PathFinding.finders.BreadthFirstFinder');
        var __proto = BreadthFirstFinder.prototype;
        __proto.findPath = function (startX, startY, endX, endY, grid) {
            var openList = [], diagonalMovement = this.diagonalMovement, startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), neighbors, neighbor, node, i = 0, l = 0;
            openList.push(startNode);
            startNode.opened = true;
            while (openList.length) {
                node = openList.shift();
                node.closed = true;
                if (node === endNode) {
                    return Util.backtrace(endNode);
                }
                neighbors = grid.getNeighbors(node, diagonalMovement);
                for (i = 0, l = neighbors.length; i < l; ++i) {
                    neighbor = neighbors[i];
                    if (neighbor.closed || neighbor.opened) {
                        continue;
                    }
                    openList.push(neighbor);
                    neighbor.opened = true;
                    neighbor.parent = node;
                }
            }
            return [];
        };
        return BreadthFirstFinder;
    })();
    var IDAStarFinder = (function () {
        function IDAStarFinder(opt) {
            this.allowDiagonal = false;
            this.dontCrossCorners = false;
            this.heuristic = null;
            this.weight = 0;
            this.diagonalMovement = 0;
            this.trackRecursion = false;
            this.timeLimit = NaN;
            opt = opt || {};
            this.allowDiagonal = opt.allowDiagonal;
            this.dontCrossCorners = opt.dontCrossCorners;
            this.diagonalMovement = opt.diagonalMovement;
            this.heuristic = opt.heuristic || Heuristic.manhattan;
            this.weight = opt.weight || 1;
            this.trackRecursion = opt.trackRecursion || false;
            this.timeLimit = opt.timeLimit || Infinity;
            if (!this.diagonalMovement) {
                if (!this.allowDiagonal) {
                    this.diagonalMovement = DiagonalMovement.Never;
                }
                else {
                    if (this.dontCrossCorners) {
                        this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
                    }
                    else {
                        this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
                    }
                }
            }
            if (this.diagonalMovement === DiagonalMovement.Never) {
                this.heuristic = opt.heuristic || Heuristic.manhattan;
            }
            else {
                this.heuristic = opt.heuristic || Heuristic.octile;
            }
        }
        __class(IDAStarFinder, 'PathFinding.finders.IDAStarFinder');
        var __proto = IDAStarFinder.prototype;
        __proto.findPath = function (startX, startY, endX, endY, grid) {
            var _$this = this;
            var nodesVisited = 0;
            var startTime = new Date().getTime();
            var h = function (a, b) {
                return _$this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));
            };
            var cost = function (a, b) {
                return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;
            };
            var search = function (node, g, cutoff, route, depth) {
                nodesVisited++;
                if (_$this.timeLimit > 0 && new Date().getTime() - startTime > _$this.timeLimit * 1000) {
                    return Infinity;
                }
                ;
                var f = g + h(node, end) * _$this.weight;
                if (f > cutoff) {
                    return f;
                }
                if (node == end) {
                    route[depth] = [node.x, node.y];
                    return node;
                }
                ;
                var min = 0, t = 0, k = 0, neighbour;
                var neighbours = grid.getNeighbors(node, _$this.diagonalMovement);
                for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {
                    if (_$this.trackRecursion) {
                        neighbour.retainCount = neighbour.retainCount + 1 || 1;
                        if (neighbour.tested != true) {
                            neighbour.tested = true;
                        }
                    }
                    t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);
                    if ((t instanceof PathFinding.core.Node)) {
                        route[depth] = [node.x, node.y];
                        return t;
                    }
                    if (_$this.trackRecursion && (--neighbour.retainCount) === 0) {
                        neighbour.tested = false;
                    }
                    if (t < min) {
                        min = t;
                    }
                }
                return min;
            };
            var start = grid.getNodeAt(startX, startY);
            var end = grid.getNodeAt(endX, endY);
            var cutOff = h(start, end);
            var j = 0, route, t = 0;
            for (j = 0; true; ++j) {
                route = [];
                t = search(start, 0, cutOff, route, 0);
                if (t == Infinity) {
                    route = [];
                    break;
                }
                if ((t instanceof PathFinding.core.Node)) {
                    break;
                }
                cutOff = t;
            }
            return route;
        };
        return IDAStarFinder;
    })();
    var JumpPointFinderBase = (function () {
        function JumpPointFinderBase(opt) {
            this.grid = null;
            this.openList = null;
            this.startNode = null;
            this.endNode = null;
            this.heuristic = null;
            this.trackJumpRecursion = false;
            opt = opt || {};
            this.heuristic = opt.heuristic || Heuristic.manhattan;
            this.trackJumpRecursion = opt.trackJumpRecursion || false;
        }
        __class(JumpPointFinderBase, 'PathFinding.finders.JumpPointFinderBase');
        var __proto = JumpPointFinderBase.prototype;
        __proto.findPath = function (startX, startY, endX, endY, grid) {
            var openList = this.openList = new Heap(function (nodeA, nodeB) {
                return nodeA.f - nodeB.f;
            }), startNode = this.startNode = grid.getNodeAt(startX, startY), endNode = this.endNode = grid.getNodeAt(endX, endY), node;
            this.grid = grid;
            startNode.g = 0;
            startNode.f = 0;
            openList.push(startNode);
            startNode.opened = true;
            while (!openList.empty()) {
                node = openList.pop();
                node.closed = true;
                if (node == endNode) {
                    return Util.expandPath(Util.backtrace(endNode));
                }
                this._identifySuccessors(node);
            }
            return [];
        };
        __proto._identifySuccessors = function (node) {
            var grid = this.grid, heuristic = this.heuristic, openList = this.openList, endX = this.endNode.x, endY = this.endNode.y, neighbors, neighbor, jumpPoint, i = 0, l = 0, x = node.x, y = node.y, jx = 0, jy = 0, dx = 0, dy = 0, d = 0, ng = 0, jumpNode, abs = Math.abs, max = Math.max;
            neighbors = this._findNeighbors(node);
            for (i = 0, l = neighbors.length; i < l; ++i) {
                neighbor = neighbors[i];
                jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);
                if (jumpPoint) {
                    jx = jumpPoint[0];
                    jy = jumpPoint[1];
                    jumpNode = grid.getNodeAt(jx, jy);
                    if (jumpNode.closed) {
                        continue;
                    }
                    d = Heuristic.octile(abs(jx - x), abs(jy - y));
                    ng = node.g + d;
                    if (!jumpNode.opened || ng < jumpNode.g) {
                        jumpNode.g = ng;
                        jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));
                        jumpNode.f = jumpNode.g + jumpNode.h;
                        jumpNode.parent = node;
                        if (!jumpNode.opened) {
                            openList.push(jumpNode);
                            jumpNode.opened = true;
                        }
                        else {
                            openList.updateItem(jumpNode);
                        }
                    }
                }
            }
        };
        __proto._jump = function (x, y, px, py) {
            return [];
        };
        __proto._findNeighbors = function (node) {
            return [];
        };
        return JumpPointFinderBase;
    })();
    var JumpPointFinder = (function () {
        function JumpPointFinder(opt) { }
        __class(JumpPointFinder, 'PathFinding.finders.JumpPointFinder');
        return JumpPointFinder;
    })();
    var TraceFinder = (function () {
        function TraceFinder(opt) {
            this.allowDiagonal = false;
            this.dontCrossCorners = false;
            this.diagonalMovement = 0;
            this.heuristic = null;
            opt = opt || {};
            this.allowDiagonal = opt.allowDiagonal;
            this.dontCrossCorners = opt.dontCrossCorners;
            this.heuristic = opt.heuristic || Heuristic.manhattan;
            this.diagonalMovement = opt.diagonalMovement;
            if (!this.diagonalMovement) {
                if (!this.allowDiagonal) {
                    this.diagonalMovement = DiagonalMovement.Never;
                }
                else {
                    if (this.dontCrossCorners) {
                        this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
                    }
                    else {
                        this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
                    }
                }
            }
            if (this.diagonalMovement == DiagonalMovement.Never) {
                this.heuristic = opt.heuristic || Heuristic.manhattan;
            }
            else {
                this.heuristic = opt.heuristic || Heuristic.octile;
            }
        }
        __class(TraceFinder, 'PathFinding.finders.TraceFinder');
        var __proto = TraceFinder.prototype;
        __proto.findPath = function (startX, startY, endX, endY, grid) {
            var openList = new Heap(function (nodeA, nodeB) {
                return nodeA.f - nodeB.f;
            }), startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), heuristic = this.heuristic, allowDiagonal = this.allowDiagonal, dontCrossCorners = this.dontCrossCorners, abs = Math.abs, SQRT2 = Math.SQRT2, node, neighbors, neighbor, i = 0, l = 0, x = 0, y = 0, ng = 0;
            startNode.g = 0;
            startNode.f = 0;
            openList.push(startNode);
            startNode.opened = true;
            while (!openList.empty()) {
                node = openList.pop();
                node.closed = true;
                if (node === endNode) {
                    return Util.backtrace(endNode);
                }
                neighbors = grid.getNeighbors(node, this.diagonalMovement);
                for (i = 0, l = neighbors.length; i < l; ++i) {
                    neighbor = neighbors[i];
                    if (neighbor.closed) {
                        continue;
                    }
                    x = neighbor.x;
                    y = neighbor.y;
                    ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);
                    if (!neighbor.opened || ng < neighbor.g) {
                        neighbor.g = ng * l / 9;
                        neighbor.h = neighbor.h || heuristic(abs(x - endX), abs(y - endY));
                        neighbor.f = neighbor.g + neighbor.h;
                        neighbor.parent = node;
                        if (!neighbor.opened) {
                            openList.push(neighbor);
                            neighbor.opened = true;
                        }
                        else {
                            openList.updateItem(neighbor);
                        }
                    }
                }
            }
            return [];
        };
        return TraceFinder;
    })();
    var Heap = (function () {
        function Heap(cmp) {
            this.cmp = null;
            this.nodes = null;
            this.heapFunction = new HeapFunction();
            this.cmp = cmp != null ? cmp : this.heapFunction.defaultCmp;
            this.nodes = [];
        }
        __class(Heap, 'PathFinding.libs.Heap');
        var __proto = Heap.prototype;
        __proto.push = function (x) {
            return this.heapFunction.heappush(this.nodes, x, this.cmp);
        };
        __proto.pop = function () {
            return this.heapFunction.heappop(this.nodes, this.cmp);
        };
        __proto.peek = function () {
            return this.nodes[0];
        };
        __proto.contains = function (x) {
            return this.nodes.indexOf(x) !== -1;
        };
        __proto.replace = function (x) {
            return this.heapFunction.heapreplace(this.nodes, x, this.cmp);
        };
        __proto.pushpop = function (x) {
            return this.heapFunction.heappushpop(this.nodes, x, this.cmp);
        };
        __proto.heapify = function () {
            return this.heapFunction.heapify(this.nodes, this.cmp);
        };
        __proto.updateItem = function (x) {
            return this.heapFunction.updateItem(this.nodes, x, this.cmp);
        };
        __proto.clear = function () {
            return this.nodes = [];
        };
        __proto.empty = function () {
            return this.nodes.length === 0;
        };
        __proto.size = function () {
            return this.nodes.length;
        };
        __proto.clone = function () {
            var heap = new Heap();
            heap.nodes = this.nodes.slice(0);
            return heap;
        };
        __proto.toArray = function () {
            return this.nodes.slice(0);
        };
        return Heap;
    })();
    var HeapFunction = (function () {
        function HeapFunction() {
            this.defaultCmp = function (x, y) {
                if (x < y) {
                    return -1;
                }
                if (x > y) {
                    return 1;
                }
                return 0;
            };
        }
        __class(HeapFunction, 'PathFinding.libs.HeapFunction');
        var __proto = HeapFunction.prototype;
        __proto.insort = function (a, x, lo, hi, cmp) {
            var mid = NaN;
            if (lo == null) {
                lo = 0;
            }
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            if (lo < 0) {
                throw new Error('lo must be non-negative');
            }
            if (hi == null) {
                hi = a.length;
            }
            while (lo < hi) {
                mid = Math.floor((lo + hi) / 2);
                if (cmp(x, a[mid]) < 0) {
                    hi = mid;
                }
                else {
                    lo = mid + 1;
                }
            }
            return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
        };
        __proto.heappush = function (array, item, cmp) {
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            array.push(item);
            return this._siftdown(array, 0, array.length - 1, cmp);
        };
        __proto.heappop = function (array, cmp) {
            var lastelt, returnitem;
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            lastelt = array.pop();
            if (array.length) {
                returnitem = array[0];
                array[0] = lastelt;
                this._siftup(array, 0, cmp);
            }
            else {
                returnitem = lastelt;
            }
            return returnitem;
        };
        __proto.heapreplace = function (array, item, cmp) {
            var returnitem;
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            returnitem = array[0];
            array[0] = item;
            this._siftup(array, 0, cmp);
            return returnitem;
        };
        __proto.heappushpop = function (array, item, cmp) {
            var _ref;
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            if (array.length && cmp(array[0], item) < 0) {
                _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
                this._siftup(array, 0, cmp);
            }
            return item;
        };
        __proto.heapify = function (array, cmp) {
            var i = 0, _i = 0, _j = 0, _len = 0, _ref, _ref1, _results, _results1;
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            _ref1 = (function () {
                _results1 = [];
                for (_j = 0, _ref = Math.floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--) {
                    _results1.push(_j);
                }
                return _results1;
            }).apply(this).reverse();
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                i = _ref1[_i];
                _results.push(this._siftup(array, i, cmp));
            }
            return _results;
        };
        __proto.updateItem = function (array, item, cmp) {
            var pos = 0;
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            pos = array.indexOf(item);
            if (pos === -1) {
                return null;
            }
            this._siftdown(array, 0, pos, cmp);
            return this._siftup(array, pos, cmp);
        };
        __proto.nlargest = function (array, n, cmp) {
            var elem, result, _i = 0, _len = 0, _ref;
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            result = array.slice(0, n);
            if (!result.length) {
                return result;
            }
            this.heapify(result, cmp);
            _ref = array.slice(n);
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                elem = _ref[_i];
                this.heappushpop(result, elem, cmp);
            }
            return result.sort(cmp).reverse();
        };
        __proto.nsmallest = function (array, n, cmp) {
            var elem, i, los, result, _i = 0, _j = 0, _len, _ref, _ref1, _results;
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            if (n * 10 <= array.length) {
                result = array.slice(0, n).sort(cmp);
                if (!result.length) {
                    return result;
                }
                los = result[result.length - 1];
                _ref = array.slice(n);
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    elem = _ref[_i];
                    if (cmp(elem, los) < 0) {
                        this.insort(result, elem, 0, null, cmp);
                        result.pop();
                        los = result[result.length - 1];
                    }
                }
                return result;
            }
            this.heapify(array, cmp);
            _results = [];
            for (i = _j = 0, _ref1 = Math.min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
                _results.push(this.heappop(array, cmp));
            }
            return _results;
        };
        __proto._siftdown = function (array, startpos, pos, cmp) {
            var newitem, parent, parentpos = 0;
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            newitem = array[pos];
            while (pos > startpos) {
                parentpos = (pos - 1) >> 1;
                parent = array[parentpos];
                if (cmp(newitem, parent) < 0) {
                    array[pos] = parent;
                    pos = parentpos;
                    continue;
                }
                break;
            }
            return array[pos] = newitem;
        };
        __proto._siftup = function (array, pos, cmp) {
            var childpos = 0, endpos = 0, newitem, rightpos = 0, startpos = 0;
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            endpos = array.length;
            startpos = pos;
            newitem = array[pos];
            childpos = 2 * pos + 1;
            while (childpos < endpos) {
                rightpos = childpos + 1;
                if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
                    childpos = rightpos;
                }
                array[pos] = array[childpos];
                pos = childpos;
                childpos = 2 * pos + 1;
            }
            array[pos] = newitem;
            return this._siftdown(array, startpos, pos, cmp);
        };
        return HeapFunction;
    })();
    var BestFirstFinder = (function (_super) {
        function BestFirstFinder(opt) {
            BestFirstFinder.__super.call(this, opt);
            var orig = this.heuristic;
            this.heuristic = function (dx, dy) {
                return orig(dx, dy) * 1000000;
            };
        }
        __class(BestFirstFinder, 'PathFinding.finders.BestFirstFinder', _super);
        return BestFirstFinder;
    })(AStarFinder);
    var BiBestFirstFinder = (function (_super) {
        function BiBestFirstFinder(opt) {
            BiBestFirstFinder.__super.call(this, opt);
            var orig = this.heuristic;
            this.heuristic = function (dx, dy) {
                return orig(dx, dy) * 1000000;
            };
        }
        __class(BiBestFirstFinder, 'PathFinding.finders.BiBestFirstFinder', _super);
        return BiBestFirstFinder;
    })(BiAStarFinder);
    var BiDijkstraFinder = (function (_super) {
        function BiDijkstraFinder(opt) {
            BiDijkstraFinder.__super.call(this, opt);
            this.heuristic = function (dx, dy) {
                return 0;
            };
        }
        __class(BiDijkstraFinder, 'PathFinding.finders.BiDijkstraFinder', _super);
        return BiDijkstraFinder;
    })(BiAStarFinder);
    var DijkstraFinder = (function (_super) {
        function DijkstraFinder(opt) {
            DijkstraFinder.__super.call(this, opt);
            this.heuristic = function (dx, dy) {
                return 0;
            };
        }
        __class(DijkstraFinder, 'PathFinding.finders.DijkstraFinder', _super);
        return DijkstraFinder;
    })(AStarFinder);
    var JPFAlwaysMoveDiagonally = (function (_super) {
        function JPFAlwaysMoveDiagonally(opt) {
            JPFAlwaysMoveDiagonally.__super.call(this, opt);
        }
        __class(JPFAlwaysMoveDiagonally, 'PathFinding.finders.JPFAlwaysMoveDiagonally', _super);
        var __proto = JPFAlwaysMoveDiagonally.prototype;
        __proto._jump = function (x, y, px, py) {
            var grid = this.grid, dx = x - px, dy = y - py;
            if (!grid.isWalkableAt(x, y)) {
                return null;
            }
            if (this.trackJumpRecursion == true) {
                grid.getNodeAt(x, y).tested = true;
            }
            if (grid.getNodeAt(x, y) == this.endNode) {
                return [x, y];
            }
            if (dx !== 0 && dy !== 0) {
                if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) || (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
                    return [x, y];
                }
                if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
                    return [x, y];
                }
            }
            else {
                if (dx !== 0) {
                    if ((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) || (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {
                        return [x, y];
                    }
                }
                else {
                    if ((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) || (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {
                        return [x, y];
                    }
                }
            }
            return this._jump(x + dx, y + dy, x, y);
        };
        __proto._findNeighbors = function (node) {
            var parent = node.parent, x = node.x, y = node.y, grid = this.grid, px = 0, py = 0, nx = 0, ny = 0, dx = 0, dy = 0, neighbors = [], neighborNodes, neighborNode, i = 0, l = 0;
            if (parent) {
                px = parent.x;
                py = parent.y;
                dx = (x - px) / Math.max(Math.abs(x - px), 1);
                dy = (y - py) / Math.max(Math.abs(y - py), 1);
                if (dx !== 0 && dy !== 0) {
                    if (grid.isWalkableAt(x, y + dy)) {
                        neighbors.push([x, y + dy]);
                    }
                    if (grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y]);
                    }
                    if (grid.isWalkableAt(x + dx, y + dy)) {
                        neighbors.push([x + dx, y + dy]);
                    }
                    if (!grid.isWalkableAt(x - dx, y)) {
                        neighbors.push([x - dx, y + dy]);
                    }
                    if (!grid.isWalkableAt(x, y - dy)) {
                        neighbors.push([x + dx, y - dy]);
                    }
                }
                else {
                    if (dx === 0) {
                        if (grid.isWalkableAt(x, y + dy)) {
                            neighbors.push([x, y + dy]);
                        }
                        if (!grid.isWalkableAt(x + 1, y)) {
                            neighbors.push([x + 1, y + dy]);
                        }
                        if (!grid.isWalkableAt(x - 1, y)) {
                            neighbors.push([x - 1, y + dy]);
                        }
                    }
                    else {
                        if (grid.isWalkableAt(x + dx, y)) {
                            neighbors.push([x + dx, y]);
                        }
                        if (!grid.isWalkableAt(x, y + 1)) {
                            neighbors.push([x + dx, y + 1]);
                        }
                        if (!grid.isWalkableAt(x, y - 1)) {
                            neighbors.push([x + dx, y - 1]);
                        }
                    }
                }
            }
            else {
                neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);
                for (i = 0, l = neighborNodes.length; i < l; ++i) {
                    neighborNode = neighborNodes[i];
                    neighbors.push([neighborNode.x, neighborNode.y]);
                }
            }
            return neighbors;
        };
        return JPFAlwaysMoveDiagonally;
    })(JumpPointFinderBase);
    var JPFMoveDiagonallyIfAtMostOneObstacle = (function (_super) {
        function JPFMoveDiagonallyIfAtMostOneObstacle(opt) {
            JPFMoveDiagonallyIfAtMostOneObstacle.__super.call(this, opt);
        }
        __class(JPFMoveDiagonallyIfAtMostOneObstacle, 'PathFinding.finders.JPFMoveDiagonallyIfAtMostOneObstacle', _super);
        var __proto = JPFMoveDiagonallyIfAtMostOneObstacle.prototype;
        __proto._jump = function (x, y, px, py) {
            var grid = this.grid, dx = x - px, dy = y - py;
            if (!grid.isWalkableAt(x, y)) {
                return null;
            }
            if (this.trackJumpRecursion === true) {
                grid.getNodeAt(x, y).tested = true;
            }
            if (grid.getNodeAt(x, y) == this.endNode) {
                return [x, y];
            }
            if (dx !== 0 && dy !== 0) {
                if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) || (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
                    return [x, y];
                }
                if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
                    return [x, y];
                }
            }
            else {
                if (dx !== 0) {
                    if ((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) || (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {
                        return [x, y];
                    }
                }
                else {
                    if ((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) || (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {
                        return [x, y];
                    }
                }
            }
            if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {
                return this._jump(x + dx, y + dy, x, y);
            }
            else {
                return null;
            }
        };
        __proto._findNeighbors = function (node) {
            var parent = node.parent, x = node.x, y = node.y, grid = this.grid, px = 0, py = 0, nx = 0, ny = 0, dx = 0, dy = 0, neighbors = [], neighborNodes, neighborNode, i = 0, l = 0;
            if (parent) {
                px = parent.x;
                py = parent.y;
                dx = (x - px) / Math.max(Math.abs(x - px), 1);
                dy = (y - py) / Math.max(Math.abs(y - py), 1);
                if (dx !== 0 && dy !== 0) {
                    if (grid.isWalkableAt(x, y + dy)) {
                        neighbors.push([x, y + dy]);
                    }
                    if (grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y]);
                    }
                    if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y + dy]);
                    }
                    if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {
                        neighbors.push([x - dx, y + dy]);
                    }
                    if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y - dy]);
                    }
                }
                else {
                    if (dx === 0) {
                        if (grid.isWalkableAt(x, y + dy)) {
                            neighbors.push([x, y + dy]);
                            if (!grid.isWalkableAt(x + 1, y)) {
                                neighbors.push([x + 1, y + dy]);
                            }
                            if (!grid.isWalkableAt(x - 1, y)) {
                                neighbors.push([x - 1, y + dy]);
                            }
                        }
                    }
                    else {
                        if (grid.isWalkableAt(x + dx, y)) {
                            neighbors.push([x + dx, y]);
                            if (!grid.isWalkableAt(x, y + 1)) {
                                neighbors.push([x + dx, y + 1]);
                            }
                            if (!grid.isWalkableAt(x, y - 1)) {
                                neighbors.push([x + dx, y - 1]);
                            }
                        }
                    }
                }
            }
            else {
                neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);
                for (i = 0, l = neighborNodes.length; i < l; ++i) {
                    neighborNode = neighborNodes[i];
                    neighbors.push([neighborNode.x, neighborNode.y]);
                }
            }
            return neighbors;
        };
        return JPFMoveDiagonallyIfAtMostOneObstacle;
    })(JumpPointFinderBase);
    var JPFMoveDiagonallyIfNoObstacles = (function (_super) {
        function JPFMoveDiagonallyIfNoObstacles(opt) {
            JPFMoveDiagonallyIfNoObstacles.__super.call(this, opt);
        }
        __class(JPFMoveDiagonallyIfNoObstacles, 'PathFinding.finders.JPFMoveDiagonallyIfNoObstacles', _super);
        var __proto = JPFMoveDiagonallyIfNoObstacles.prototype;
        __proto._jump = function (x, y, px, py) {
            var grid = this.grid, dx = x - px, dy = y - py;
            if (!grid.isWalkableAt(x, y)) {
                return null;
            }
            if (this.trackJumpRecursion === true) {
                grid.getNodeAt(x, y).tested = true;
            }
            if (grid.getNodeAt(x, y) === this.endNode) {
                return [x, y];
            }
            if (dx !== 0 && dy !== 0) {
                if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
                    return [x, y];
                }
            }
            else {
                if (dx !== 0) {
                    if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) || (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {
                        return [x, y];
                    }
                }
                else if (dy !== 0) {
                    if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) || (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {
                        return [x, y];
                    }
                }
            }
            if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {
                return this._jump(x + dx, y + dy, x, y);
            }
            else {
                return null;
            }
        };
        __proto._findNeighbors = function (node) {
            var parent = node.parent, x = node.x, y = node.y, grid = this.grid, px = 0, py = 0, nx = 0, ny = 0, dx = 0, dy = 0, neighbors = [], neighborNodes, neighborNode, i = 0, l = 0;
            if (parent) {
                px = parent.x;
                py = parent.y;
                dx = (x - px) / Math.max(Math.abs(x - px), 1);
                dy = (y - py) / Math.max(Math.abs(y - py), 1);
                if (dx !== 0 && dy !== 0) {
                    if (grid.isWalkableAt(x, y + dy)) {
                        neighbors.push([x, y + dy]);
                    }
                    if (grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y]);
                    }
                    if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y + dy]);
                    }
                }
                else {
                    var isNextWalkable = false;
                    if (dx !== 0) {
                        isNextWalkable = grid.isWalkableAt(x + dx, y);
                        var isTopWalkable = grid.isWalkableAt(x, y + 1);
                        var isBottomWalkable = grid.isWalkableAt(x, y - 1);
                        if (isNextWalkable) {
                            neighbors.push([x + dx, y]);
                            if (isTopWalkable) {
                                neighbors.push([x + dx, y + 1]);
                            }
                            if (isBottomWalkable) {
                                neighbors.push([x + dx, y - 1]);
                            }
                        }
                        if (isTopWalkable) {
                            neighbors.push([x, y + 1]);
                        }
                        if (isBottomWalkable) {
                            neighbors.push([x, y - 1]);
                        }
                    }
                    else if (dy !== 0) {
                        isNextWalkable = grid.isWalkableAt(x, y + dy);
                        var isRightWalkable = grid.isWalkableAt(x + 1, y);
                        var isLeftWalkable = grid.isWalkableAt(x - 1, y);
                        if (isNextWalkable) {
                            neighbors.push([x, y + dy]);
                            if (isRightWalkable) {
                                neighbors.push([x + 1, y + dy]);
                            }
                            if (isLeftWalkable) {
                                neighbors.push([x - 1, y + dy]);
                            }
                        }
                        if (isRightWalkable) {
                            neighbors.push([x + 1, y]);
                        }
                        if (isLeftWalkable) {
                            neighbors.push([x - 1, y]);
                        }
                    }
                }
            }
            else {
                neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);
                for (i = 0, l = neighborNodes.length; i < l; ++i) {
                    neighborNode = neighborNodes[i];
                    neighbors.push([neighborNode.x, neighborNode.y]);
                }
            }
            return neighbors;
        };
        return JPFMoveDiagonallyIfNoObstacles;
    })(JumpPointFinderBase);
    var JPFNeverMoveDiagonally = (function (_super) {
        function JPFNeverMoveDiagonally(opt) {
            JPFNeverMoveDiagonally.__super.call(this, opt);
        }
        __class(JPFNeverMoveDiagonally, 'PathFinding.finders.JPFNeverMoveDiagonally', _super);
        var __proto = JPFNeverMoveDiagonally.prototype;
        __proto._jump = function (x, y, px, py) {
            var grid = this.grid, dx = x - px, dy = y - py;
            if (!grid.isWalkableAt(x, y)) {
                return null;
            }
            if (this.trackJumpRecursion === true) {
                grid.getNodeAt(x, y).tested = true;
            }
            if (grid.getNodeAt(x, y) == this.endNode) {
                return [x, y];
            }
            if (dx !== 0) {
                if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) || (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {
                    return [x, y];
                }
            }
            else if (dy !== 0) {
                if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) || (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {
                    return [x, y];
                }
                if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {
                    return [x, y];
                }
            }
            else {
                throw new Error("Only horizontal and vertical movements are allowed");
            }
            return this._jump(x + dx, y + dy, x, y);
        };
        __proto._findNeighbors = function (node) {
            var parent = node.parent, x = node.x, y = node.y, grid = this.grid, px = 0, py = 0, nx = 0, ny = 0, dx = 0, dy = 0, neighbors = [], neighborNodes, neighborNode, i = 0, l = 0;
            if (parent) {
                px = parent.x;
                py = parent.y;
                dx = (x - px) / Math.max(Math.abs(x - px), 1);
                dy = (y - py) / Math.max(Math.abs(y - py), 1);
                if (dx !== 0) {
                    if (grid.isWalkableAt(x, y - 1)) {
                        neighbors.push([x, y - 1]);
                    }
                    if (grid.isWalkableAt(x, y + 1)) {
                        neighbors.push([x, y + 1]);
                    }
                    if (grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y]);
                    }
                }
                else if (dy !== 0) {
                    if (grid.isWalkableAt(x - 1, y)) {
                        neighbors.push([x - 1, y]);
                    }
                    if (grid.isWalkableAt(x + 1, y)) {
                        neighbors.push([x + 1, y]);
                    }
                    if (grid.isWalkableAt(x, y + dy)) {
                        neighbors.push([x, y + dy]);
                    }
                }
            }
            else {
                neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);
                for (i = 0, l = neighborNodes.length; i < l; ++i) {
                    neighborNode = neighborNodes[i];
                    neighbors.push([neighborNode.x, neighborNode.y]);
                }
            }
            return neighbors;
        };
        return JPFNeverMoveDiagonally;
    })(JumpPointFinderBase);
})(window, document, Laya);
if (typeof define === 'function' && define.amd) {
    define('laya.core', ['require', "exports"], function (require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
            var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    var Bezier = laya.maths.Bezier, Browser = laya.utils.Browser, Byte = laya.utils.Byte, Event = laya.events.Event;
    var EventDispatcher = laya.events.EventDispatcher, Graphics = laya.display.Graphics, HTMLCanvas = laya.resource.HTMLCanvas;
    var Handler = laya.utils.Handler, Loader = laya.net.Loader, MathUtil = laya.maths.MathUtil, Matrix = laya.maths.Matrix;
    var Node = laya.display.Node, Point = laya.maths.Point, Rectangle = laya.maths.Rectangle, Render = laya.renders.Render;
    var RenderContext = laya.renders.RenderContext, Resource = laya.resource.Resource, RunDriver = laya.utils.RunDriver;
    var Sprite = laya.display.Sprite, Stat = laya.utils.Stat, Texture = laya.resource.Texture, URL = laya.net.URL, Utils = laya.utils.Utils;
    var AnimationContent = (function () {
        function AnimationContent() {
            this.nodes = null;
            this.name = null;
            this.playTime = NaN;
            this.bone3DMap = null;
            this.totalKeyframeDatasLength = 0;
        }
        __class(AnimationContent, 'laya.ani.AnimationContent');
        return AnimationContent;
    })();
    var AnimationNodeContent = (function () {
        function AnimationNodeContent() {
            this.name = null;
            this.parentIndex = 0;
            this.parent = null;
            this.keyframeWidth = 0;
            this.lerpType = 0;
            this.interpolationMethod = null;
            this.childs = null;
            this.keyFrame = null;
            this.playTime = NaN;
            this.extenData = null;
            this.dataOffset = 0;
        }
        __class(AnimationNodeContent, 'laya.ani.AnimationNodeContent');
        return AnimationNodeContent;
    })();
    var AnimationParser01 = (function () {
        function AnimationParser01() { }
        __class(AnimationParser01, 'laya.ani.AnimationParser01');
        AnimationParser01.parse = function (templet, reader) {
            var data = reader.__getBuffer();
            var i = 0, j = 0, k = 0, n = 0, l = 0, m = 0, o = 0;
            var aniClassName = reader.readUTFString();
            templet._aniClassName = aniClassName;
            var strList = reader.readUTFString().split("\n");
            var aniCount = reader.getUint8();
            var publicDataPos = reader.getUint32();
            var publicExtDataPos = reader.getUint32();
            var publicData;
            if (publicDataPos > 0)
                publicData = data.slice(publicDataPos, publicExtDataPos);
            var publicRead = new Byte(publicData);
            if (publicExtDataPos > 0)
                templet._publicExtData = data.slice(publicExtDataPos, data.byteLength);
            templet._useParent = !!reader.getUint8();
            templet._anis.length = aniCount;
            for (i = 0; i < aniCount; i++) {
                var ani = templet._anis[i] = new AnimationContent();
                { }
                ;
                ani.nodes = new Array;
                var name = ani.name = strList[reader.getUint16()];
                templet._aniMap[name] = i;
                ani.bone3DMap = {};
                ani.playTime = reader.getFloat32();
                var boneCount = ani.nodes.length = reader.getUint8();
                ani.totalKeyframeDatasLength = 0;
                for (j = 0; j < boneCount; j++) {
                    var node = ani.nodes[j] = new AnimationNodeContent();
                    { }
                    ;
                    node.childs = [];
                    var nameIndex = reader.getInt16();
                    if (nameIndex >= 0) {
                        node.name = strList[nameIndex];
                        ani.bone3DMap[node.name] = j;
                    }
                    node.keyFrame = new Array;
                    node.parentIndex = reader.getInt16();
                    node.parentIndex == -1 ? node.parent = null : node.parent = ani.nodes[node.parentIndex];
                    node.lerpType = reader.getUint8();
                    var keyframeParamsOffset = reader.getUint32();
                    publicRead.pos = keyframeParamsOffset;
                    var keyframeDataCount = node.keyframeWidth = publicRead.getUint16();
                    ani.totalKeyframeDatasLength += keyframeDataCount;
                    if (node.lerpType === 0 || node.lerpType === 1) {
                        node.interpolationMethod = [];
                        node.interpolationMethod.length = keyframeDataCount;
                        for (k = 0; k < keyframeDataCount; k++)
                            node.interpolationMethod[k] = AnimationTemplet.interpolation[publicRead.getUint8()];
                    }
                    if (node.parent != null)
                        node.parent.childs.push(node);
                    var privateDataLen = reader.getUint16();
                    if (privateDataLen > 0) {
                        node.extenData = data.slice(reader.pos, reader.pos + privateDataLen);
                        reader.pos += privateDataLen;
                    }
                    ;
                    var keyframeCount = reader.getUint16();
                    node.keyFrame.length = keyframeCount;
                    var startTime = 0;
                    var keyFrame;
                    for (k = 0, n = keyframeCount; k < n; k++) {
                        keyFrame = node.keyFrame[k] = new KeyFramesContent();
                        { }
                        ;
                        keyFrame.duration = reader.getFloat32();
                        keyFrame.startTime = startTime;
                        if (node.lerpType === 2) {
                            keyFrame.interpolationData = [];
                            var interDataLength = reader.getUint8();
                            var lerpType = 0;
                            lerpType = reader.getFloat32();
                            switch (lerpType) {
                                case 254:
                                    keyFrame.interpolationData.length = keyframeDataCount;
                                    for (o = 0; o < keyframeDataCount; o++)
                                        keyFrame.interpolationData[o] = 0;
                                    break;
                                case 255:
                                    keyFrame.interpolationData.length = keyframeDataCount;
                                    for (o = 0; o < keyframeDataCount; o++)
                                        keyFrame.interpolationData[o] = 5;
                                    break;
                                default:
                                    keyFrame.interpolationData.push(lerpType);
                                    for (m = 1; m < interDataLength; m++) {
                                        keyFrame.interpolationData.push(reader.getFloat32());
                                    }
                            }
                        }
                        keyFrame.data = new Float32Array(keyframeDataCount);
                        for (l = 0; l < keyframeDataCount; l++) {
                            keyFrame.data[l] = reader.getFloat32();
                            if (keyFrame.data[l] > -0.00000001 && keyFrame.data[l] < 0.00000001)
                                keyFrame.data[l] = 0;
                        }
                        startTime += keyFrame.duration;
                    }
                    keyFrame.startTime = ani.playTime;
                    node.playTime = ani.playTime;
                    templet._calculateKeyFrame(node, keyframeCount, keyframeDataCount);
                }
            }
        };
        return AnimationParser01;
    })();
    var AnimationParser02 = (function () {
        function AnimationParser02() { }
        __class(AnimationParser02, 'laya.ani.AnimationParser02');
        AnimationParser02.READ_DATA = function () {
            AnimationParser02._DATA.offset = AnimationParser02._reader.getUint32();
            AnimationParser02._DATA.size = AnimationParser02._reader.getUint32();
        };
        AnimationParser02.READ_BLOCK = function () {
            var count = AnimationParser02._BLOCK.count = AnimationParser02._reader.getUint16();
            var blockStarts = AnimationParser02._BLOCK.blockStarts = [];
            var blockLengths = AnimationParser02._BLOCK.blockLengths = [];
            for (var i = 0; i < count; i++) {
                blockStarts.push(AnimationParser02._reader.getUint32());
                blockLengths.push(AnimationParser02._reader.getUint32());
            }
        };
        AnimationParser02.READ_STRINGS = function () {
            var offset = AnimationParser02._reader.getUint32();
            var count = AnimationParser02._reader.getUint16();
            var prePos = AnimationParser02._reader.pos;
            AnimationParser02._reader.pos = offset + AnimationParser02._DATA.offset;
            for (var i = 0; i < count; i++)
                AnimationParser02._strings[i] = AnimationParser02._reader.readUTFString();
            AnimationParser02._reader.pos = prePos;
        };
        AnimationParser02.parse = function (templet, reader) {
            AnimationParser02._templet = templet;
            AnimationParser02._reader = reader;
            var arrayBuffer = reader.__getBuffer();
            AnimationParser02.READ_DATA();
            AnimationParser02.READ_BLOCK();
            AnimationParser02.READ_STRINGS();
            for (var i = 0, n = AnimationParser02._BLOCK.count; i < n; i++) {
                var index = reader.getUint16();
                var blockName = AnimationParser02._strings[index];
                var fn = AnimationParser02["READ_" + blockName];
                if (fn == null)
                    throw new Error("model file err,no this function:" + index + " " + blockName);
                else
                    fn.call();
            }
        };
        AnimationParser02.READ_ANIMATIONS = function () {
            var reader = AnimationParser02._reader;
            var arrayBuffer = reader.__getBuffer();
            var i = 0, j = 0, k = 0, n = 0, l = 0;
            var keyframeWidth = reader.getUint16();
            var interpolationMethod = [];
            interpolationMethod.length = keyframeWidth;
            for (i = 0; i < keyframeWidth; i++)
                interpolationMethod[i] = AnimationTemplet.interpolation[reader.getByte()];
            var aniCount = reader.getUint8();
            AnimationParser02._templet._anis.length = aniCount;
            for (i = 0; i < aniCount; i++) {
                var ani = AnimationParser02._templet._anis[i] =
                    {};
                ani.nodes = new Array;
                var aniName = ani.name = AnimationParser02._strings[reader.getUint16()];
                AnimationParser02._templet._aniMap[aniName] = i;
                ani.bone3DMap = {};
                ani.playTime = reader.getFloat32();
                var boneCount = ani.nodes.length = reader.getInt16();
                ani.totalKeyframeDatasLength = 0;
                for (j = 0; j < boneCount; j++) {
                    var node = ani.nodes[j] =
                        {};
                    node.keyframeWidth = keyframeWidth;
                    node.childs = [];
                    var nameIndex = reader.getUint16();
                    if (nameIndex >= 0) {
                        node.name = AnimationParser02._strings[nameIndex];
                        ani.bone3DMap[node.name] = j;
                    }
                    node.keyFrame = new Array;
                    node.parentIndex = reader.getInt16();
                    node.parentIndex == -1 ? node.parent = null : node.parent = ani.nodes[node.parentIndex];
                    ani.totalKeyframeDatasLength += keyframeWidth;
                    node.interpolationMethod = interpolationMethod;
                    if (node.parent != null)
                        node.parent.childs.push(node);
                    var keyframeCount = reader.getUint16();
                    node.keyFrame.length = keyframeCount;
                    var keyFrame = null, lastKeyFrame = null;
                    for (k = 0, n = keyframeCount; k < n; k++) {
                        keyFrame = node.keyFrame[k] =
                            {};
                        keyFrame.startTime = reader.getFloat32();
                        (lastKeyFrame) && (lastKeyFrame.duration = keyFrame.startTime - lastKeyFrame.startTime);
                        var offset = AnimationParser02._DATA.offset;
                        var keyframeDataOffset = reader.getUint32();
                        var keyframeDataLength = keyframeWidth * 4;
                        var keyframeArrayBuffer = arrayBuffer.slice(offset + keyframeDataOffset, offset + keyframeDataOffset + keyframeDataLength);
                        keyFrame.data = new Float32Array(keyframeArrayBuffer);
                        lastKeyFrame = keyFrame;
                    }
                    keyFrame.duration = 0;
                    node.playTime = ani.playTime;
                    AnimationParser02._templet._calculateKeyFrame(node, keyframeCount, keyframeWidth);
                }
            }
        };
        AnimationParser02._templet = null;
        AnimationParser02._reader = null;
        AnimationParser02._strings = [];
        __static(AnimationParser02, ['_BLOCK', function () { return this._BLOCK = { count: 0 }; }, '_DATA', function () { return this._DATA = { offset: 0, size: 0 }; }
        ]);
        return AnimationParser02;
    })();
    var AnimationState = (function () {
        function AnimationState() { }
        __class(AnimationState, 'laya.ani.AnimationState');
        AnimationState.stopped = 0;
        AnimationState.paused = 1;
        AnimationState.playing = 2;
        return AnimationState;
    })();
    var Bone = (function () {
        function Bone() {
            this.name = null;
            this.root = null;
            this.parentBone = null;
            this.length = 10;
            this.transform = null;
            this.inheritScale = true;
            this.inheritRotation = true;
            this.rotation = NaN;
            this.resultRotation = NaN;
            this.d = -1;
            this._tempMatrix = null;
            this._sprite = null;
            this.resultTransform = new Transform();
            this.resultMatrix = new Matrix();
            this._children = [];
        }
        __class(Bone, 'laya.ani.bone.Bone');
        var __proto = Bone.prototype;
        __proto.setTempMatrix = function (matrix) {
            this._tempMatrix = matrix;
            var i = 0, n = 0;
            var tBone;
            for (i = 0, n = this._children.length; i < n; i++) {
                tBone = this._children[i];
                tBone.setTempMatrix(this._tempMatrix);
            }
        };
        __proto.update = function (pMatrix) {
            this.rotation = this.transform.skX;
            var tResultMatrix;
            if (pMatrix) {
                tResultMatrix = this.resultTransform.getMatrix();
                Matrix.mul(tResultMatrix, pMatrix, this.resultMatrix);
                this.resultRotation = this.rotation;
            }
            else {
                this.resultRotation = this.rotation + this.parentBone.resultRotation;
                if (this.parentBone) {
                    if (this.inheritRotation && this.inheritScale) {
                        tResultMatrix = this.resultTransform.getMatrix();
                        Matrix.mul(tResultMatrix, this.parentBone.resultMatrix, this.resultMatrix);
                    }
                    else {
                        var temp = 0;
                        var parent = this.parentBone;
                        var tAngle = NaN;
                        var cos = NaN;
                        var sin = NaN;
                        var tParentMatrix = this.parentBone.resultMatrix;
                        tResultMatrix = this.resultTransform.getMatrix();
                        var worldX = tParentMatrix.a * tResultMatrix.tx + tParentMatrix.c * tResultMatrix.ty + tParentMatrix.tx;
                        var worldY = tParentMatrix.b * tResultMatrix.tx + tParentMatrix.d * tResultMatrix.ty + tParentMatrix.ty;
                        var tTestMatrix = new Matrix();
                        if (this.inheritRotation) {
                            tAngle = Math.atan2(parent.resultMatrix.b, parent.resultMatrix.a);
                            cos = Math.cos(tAngle), sin = Math.sin(tAngle);
                            tTestMatrix.setTo(cos, sin, -sin, cos, 0, 0);
                            Matrix.mul(this._tempMatrix, tTestMatrix, Matrix.TEMP);
                            Matrix.TEMP.copyTo(tTestMatrix);
                            tResultMatrix = this.resultTransform.getMatrix();
                            Matrix.mul(tResultMatrix, tTestMatrix, this.resultMatrix);
                            if (this.resultTransform.scX * this.resultTransform.scY < 0) {
                                this.resultMatrix.rotate(Math.PI * 0.5);
                            }
                            this.resultMatrix.tx = worldX;
                            this.resultMatrix.ty = worldY;
                        }
                        else if (this.inheritScale) {
                            tResultMatrix = this.resultTransform.getMatrix();
                            Matrix.TEMP.identity();
                            Matrix.TEMP.d = this.d;
                            Matrix.mul(tResultMatrix, Matrix.TEMP, this.resultMatrix);
                            this.resultMatrix.tx = worldX;
                            this.resultMatrix.ty = worldY;
                        }
                        else {
                            tResultMatrix = this.resultTransform.getMatrix();
                            Matrix.TEMP.identity();
                            Matrix.TEMP.d = this.d;
                            Matrix.mul(tResultMatrix, Matrix.TEMP, this.resultMatrix);
                            this.resultMatrix.tx = worldX;
                            this.resultMatrix.ty = worldY;
                        }
                    }
                }
                else {
                    tResultMatrix = this.resultTransform.getMatrix();
                    tResultMatrix.copyTo(this.resultMatrix);
                }
            }
            ;
            var i = 0, n = 0;
            var tBone;
            for (i = 0, n = this._children.length; i < n; i++) {
                tBone = this._children[i];
                tBone.update();
            }
        };
        __proto.updateChild = function () {
            var i = 0, n = 0;
            var tBone;
            for (i = 0, n = this._children.length; i < n; i++) {
                tBone = this._children[i];
                tBone.update();
            }
        };
        __proto.setRotation = function (rd) {
            if (this._sprite) {
                this._sprite.rotation = rd * 180 / Math.PI;
            }
        };
        __proto.updateDraw = function (x, y) {
            if (!Bone.ShowBones || Bone.ShowBones[this.name]) {
                if (this._sprite) {
                    this._sprite.x = x + this.resultMatrix.tx;
                    this._sprite.y = y + this.resultMatrix.ty;
                }
                else {
                    this._sprite = new Sprite();
                    this._sprite.graphics.drawCircle(0, 0, 5, "#ff0000");
                    this._sprite.graphics.drawLine(0, 0, this.length, 0, "#00ff00");
                    this._sprite.graphics.fillText(this.name, 0, 0, "20px Arial", "#00ff00", "center");
                    Laya.stage.addChild(this._sprite);
                    this._sprite.x = x + this.resultMatrix.tx;
                    this._sprite.y = y + this.resultMatrix.ty;
                }
            }
            ;
            var i = 0, n = 0;
            var tBone;
            for (i = 0, n = this._children.length; i < n; i++) {
                tBone = this._children[i];
                tBone.updateDraw(x, y);
            }
        };
        __proto.addChild = function (bone) {
            this._children.push(bone);
            bone.parentBone = this;
        };
        __proto.findBone = function (boneName) {
            if (this.name == boneName) {
                return this;
            }
            else {
                var i = 0, n = 0;
                var tBone;
                var tResult;
                for (i = 0, n = this._children.length; i < n; i++) {
                    tBone = this._children[i];
                    tResult = tBone.findBone(boneName);
                    if (tResult) {
                        return tResult;
                    }
                }
            }
            return null;
        };
        __proto.localToWorld = function (local) {
            var localX = local[0];
            var localY = local[1];
            local[0] = localX * this.resultMatrix.a + localY * this.resultMatrix.c + this.resultMatrix.tx;
            local[1] = localX * this.resultMatrix.b + localY * this.resultMatrix.d + this.resultMatrix.ty;
        };
        Bone.ShowBones = {};
        return Bone;
    })();
    var BoneSlot = (function () {
        function BoneSlot() {
            this.name = null;
            this.parent = null;
            this.attachmentName = null;
            this.srcDisplayIndex = -1;
            this.type = "src";
            this.templet = null;
            this.currSlotData = null;
            this.currTexture = null;
            this.currDisplayData = null;
            this.displayIndex = -1;
            this._diyTexture = null;
            this._parentMatrix = null;
            this._resultMatrix = null;
            this._replaceDic = {};
            this._curDiyUV = null;
            this._curDiyVS = null;
            this._skinSprite = null;
            this.deformData = null;
            this._mVerticleArr = null;
        }
        __class(BoneSlot, 'laya.ani.bone.BoneSlot');
        var __proto = BoneSlot.prototype;
        __proto.showSlotData = function (slotData, freshIndex) {
            (freshIndex === void 0) && (freshIndex = true);
            this.currSlotData = slotData;
            if (freshIndex)
                this.displayIndex = this.srcDisplayIndex;
            this.currDisplayData = null;
            this.currTexture = null;
        };
        __proto.showDisplayByName = function (name) {
            if (this.currSlotData) {
                this.showDisplayByIndex(this.currSlotData.getDisplayByName(name));
            }
        };
        __proto.replaceDisplayByName = function (tarName, newName) {
            if (!this.currSlotData)
                return;
            var preIndex = 0;
            preIndex = this.currSlotData.getDisplayByName(tarName);
            var newIndex = 0;
            newIndex = this.currSlotData.getDisplayByName(newName);
            this.replaceDisplayByIndex(preIndex, newIndex);
        };
        __proto.replaceDisplayByIndex = function (tarIndex, newIndex) {
            if (!this.currSlotData)
                return;
            this._replaceDic[tarIndex] = newIndex;
            if (this.displayIndex == tarIndex) {
                this.showDisplayByIndex(tarIndex);
            }
        };
        __proto.showDisplayByIndex = function (index) {
            if (this._replaceDic[index] != null)
                index = this._replaceDic[index];
            if (this.currSlotData && index > -1 && index < this.currSlotData.displayArr.length) {
                this.displayIndex = index;
                this.currDisplayData = this.currSlotData.displayArr[index];
                if (this.currDisplayData) {
                    var tName = this.currDisplayData.name;
                    this.currTexture = this.templet.getTexture(tName);
                    if (this.currTexture && !Render.isConchApp && this.currDisplayData.type == 0 && this.currDisplayData.uvs) {
                        this.currTexture = this.currDisplayData.createTexture(this.currTexture);
                    }
                }
            }
            else {
                this.displayIndex = -1;
                this.currDisplayData = null;
                this.currTexture = null;
            }
        };
        __proto.replaceSkin = function (_texture) {
            this._diyTexture = _texture;
            if (this._curDiyUV)
                this._curDiyUV.length = 0;
            if (this.currDisplayData && this._diyTexture == this.currDisplayData.texture) {
                this._diyTexture = null;
            }
        };
        __proto.setParentMatrix = function (parentMatrix) {
            this._parentMatrix = parentMatrix;
        };
        __proto.draw = function (graphics, boneMatrixArray, noUseSave, alpha) {
            (noUseSave === void 0) && (noUseSave = false);
            (alpha === void 0) && (alpha = 1);
            if ((this._diyTexture == null && this.currTexture == null) || this.currDisplayData == null) {
                if (!(this.currDisplayData && this.currDisplayData.type == 3)) {
                    return;
                }
            }
            ;
            var tTexture = this.currTexture;
            if (this._diyTexture)
                tTexture = this._diyTexture;
            var tSkinSprite;
            switch (this.currDisplayData.type) {
                case 0:
                    if (graphics) {
                        var tCurrentMatrix = this.getDisplayMatrix();
                        if (this._parentMatrix) {
                            var tRotateKey = false;
                            if (tCurrentMatrix) {
                                Matrix.mul(tCurrentMatrix, this._parentMatrix, Matrix.TEMP);
                                var tResultMatrix;
                                if (noUseSave) {
                                    if (this._resultMatrix == null)
                                        this._resultMatrix = new Matrix();
                                    tResultMatrix = this._resultMatrix;
                                }
                                else {
                                    tResultMatrix = new Matrix();
                                }
                                if ((!Render.isWebGL && this.currDisplayData.uvs) || (Render.isWebGL && this._diyTexture && this.currDisplayData.uvs)) {
                                    var tTestMatrix = BoneSlot._tempMatrix;
                                    tTestMatrix.identity();
                                    if (this.currDisplayData.uvs[1] > this.currDisplayData.uvs[5]) {
                                        tTestMatrix.d = -1;
                                    }
                                    if (this.currDisplayData.uvs[0] > this.currDisplayData.uvs[4]
                                        && this.currDisplayData.uvs[1] > this.currDisplayData.uvs[5]) {
                                        tRotateKey = true;
                                        tTestMatrix.rotate(-Math.PI / 2);
                                    }
                                    Matrix.mul(tTestMatrix, Matrix.TEMP, tResultMatrix);
                                }
                                else {
                                    Matrix.TEMP.copyTo(tResultMatrix);
                                }
                                if (tRotateKey) {
                                    graphics.drawTexture(tTexture, -this.currDisplayData.height / 2, -this.currDisplayData.width / 2, this.currDisplayData.height, this.currDisplayData.width, tResultMatrix);
                                }
                                else {
                                    graphics.drawTexture(tTexture, -this.currDisplayData.width / 2, -this.currDisplayData.height / 2, this.currDisplayData.width, this.currDisplayData.height, tResultMatrix);
                                }
                            }
                        }
                    }
                    break;
                case 1:
                    if (noUseSave) {
                        if (this._skinSprite == null) {
                            this._skinSprite = BoneSlot.createSkinMesh();
                        }
                        tSkinSprite = this._skinSprite;
                    }
                    else {
                        tSkinSprite = BoneSlot.createSkinMesh();
                    }
                    if (tSkinSprite == null) {
                        return;
                    }
                    ;
                    var tIBArray;
                    var tRed = 1;
                    var tGreed = 1;
                    var tBlue = 1;
                    var tAlpha = 1;
                    if (this.currDisplayData.bones == null) {
                        var tVertices = this.currDisplayData.weights;
                        if (this.deformData) {
                            tVertices = this.deformData;
                        }
                        ;
                        var tUVs;
                        if (this._diyTexture) {
                            if (!this._curDiyUV) {
                                this._curDiyUV = [];
                            }
                            if (this._curDiyUV.length == 0) {
                                this._curDiyUV = UVTools.getRelativeUV(this.currTexture.uv, this.currDisplayData.uvs, this._curDiyUV);
                                this._curDiyUV = UVTools.getAbsoluteUV(this._diyTexture.uv, this._curDiyUV, this._curDiyUV);
                            }
                            tUVs = this._curDiyUV;
                        }
                        else {
                            tUVs = this.currDisplayData.uvs;
                        }
                        this._mVerticleArr = tVertices;
                        var tTriangleNum = this.currDisplayData.triangles.length / 3;
                        tIBArray = this.currDisplayData.triangles;
                        tSkinSprite.init2(tTexture, null, tIBArray, this._mVerticleArr, tUVs);
                        var tCurrentMatrix2 = this.getDisplayMatrix();
                        if (this._parentMatrix) {
                            if (tCurrentMatrix2) {
                                Matrix.mul(tCurrentMatrix2, this._parentMatrix, Matrix.TEMP);
                                var tResultMatrix2;
                                if (noUseSave) {
                                    if (this._resultMatrix == null)
                                        this._resultMatrix = new Matrix();
                                    tResultMatrix2 = this._resultMatrix;
                                }
                                else {
                                    tResultMatrix2 = new Matrix();
                                }
                                Matrix.TEMP.copyTo(tResultMatrix2);
                                tSkinSprite.transform = tResultMatrix2;
                            }
                        }
                    }
                    else {
                        this.skinMesh(boneMatrixArray, tSkinSprite, alpha);
                    }
                    graphics.drawSkin(tSkinSprite);
                    break;
                case 2:
                    if (noUseSave) {
                        if (this._skinSprite == null) {
                            this._skinSprite = BoneSlot.createSkinMesh();
                        }
                        tSkinSprite = this._skinSprite;
                    }
                    else {
                        tSkinSprite = BoneSlot.createSkinMesh();
                    }
                    if (tSkinSprite == null) {
                        return;
                    }
                    this.skinMesh(boneMatrixArray, tSkinSprite, alpha);
                    graphics.drawSkin(tSkinSprite);
                    break;
                case 3:
                    break;
            }
        };
        __proto.skinMesh = function (boneMatrixArray, skinSprite, alpha) {
            var tTexture = this.currTexture;
            var tBones = this.currDisplayData.bones;
            var tUvs;
            if (this._diyTexture) {
                tTexture = this._diyTexture;
                if (!this._curDiyUV) {
                    this._curDiyUV = [];
                }
                if (this._curDiyUV.length == 0) {
                    this._curDiyUV = UVTools.getRelativeUV(this.currTexture.uv, this.currDisplayData.uvs, this._curDiyUV);
                    this._curDiyUV = UVTools.getAbsoluteUV(this._diyTexture.uv, this._curDiyUV, this._curDiyUV);
                }
                tUvs = this._curDiyUV;
            }
            else {
                tUvs = this.currDisplayData.uvs;
            }
            ;
            var tWeights = this.currDisplayData.weights;
            var tTriangles = this.currDisplayData.triangles;
            var tIBArray;
            var tRx = 0;
            var tRy = 0;
            var nn = 0;
            var tMatrix;
            var tX = NaN;
            var tY = NaN;
            var tB = 0;
            var tWeight = 0;
            var tVertices = [];
            var i = 0, j = 0, n = 0;
            var tRed = 1;
            var tGreed = 1;
            var tBlue = 1;
            var tAlpha = alpha;
            if (this.deformData && this.deformData.length > 0) {
                var f = 0;
                for (i = 0, n = tBones.length; i < n;) {
                    nn = tBones[i++] + i;
                    tRx = 0, tRy = 0;
                    for (; i < nn; i++) {
                        tMatrix = boneMatrixArray[tBones[i]];
                        tX = tWeights[tB] + this.deformData[f++];
                        tY = tWeights[tB + 1] + this.deformData[f++];
                        tWeight = tWeights[tB + 2];
                        tRx += (tX * tMatrix.a + tY * tMatrix.c + tMatrix.tx) * tWeight;
                        tRy += (tX * tMatrix.b + tY * tMatrix.d + tMatrix.ty) * tWeight;
                        tB += 3;
                    }
                    tVertices.push(tRx, tRy);
                }
            }
            else {
                for (i = 0, n = tBones.length; i < n;) {
                    nn = tBones[i++] + i;
                    tRx = 0, tRy = 0;
                    for (; i < nn; i++) {
                        tMatrix = boneMatrixArray[tBones[i]];
                        tX = tWeights[tB];
                        tY = tWeights[tB + 1];
                        tWeight = tWeights[tB + 2];
                        tRx += (tX * tMatrix.a + tY * tMatrix.c + tMatrix.tx) * tWeight;
                        tRy += (tX * tMatrix.b + tY * tMatrix.d + tMatrix.ty) * tWeight;
                        tB += 3;
                    }
                    tVertices.push(tRx, tRy);
                }
            }
            this._mVerticleArr = tVertices;
            tIBArray = tTriangles;
            skinSprite.init2(tTexture, null, tIBArray, this._mVerticleArr, tUvs);
        };
        __proto.drawBonePoint = function (graphics) {
            if (graphics && this._parentMatrix) {
                graphics.drawCircle(this._parentMatrix.tx, this._parentMatrix.ty, 5, "#ff0000");
            }
        };
        __proto.getDisplayMatrix = function () {
            if (this.currDisplayData) {
                return this.currDisplayData.transform.getMatrix();
            }
            return null;
        };
        __proto.getMatrix = function () {
            return this._resultMatrix;
        };
        __proto.copy = function () {
            var tBoneSlot = new BoneSlot();
            tBoneSlot.type = "copy";
            tBoneSlot.name = this.name;
            tBoneSlot.attachmentName = this.attachmentName;
            tBoneSlot.srcDisplayIndex = this.srcDisplayIndex;
            tBoneSlot.parent = this.parent;
            tBoneSlot.displayIndex = this.displayIndex;
            tBoneSlot.templet = this.templet;
            tBoneSlot.currSlotData = this.currSlotData;
            tBoneSlot.currTexture = this.currTexture;
            tBoneSlot.currDisplayData = this.currDisplayData;
            return tBoneSlot;
        };
        BoneSlot.createSkinMesh = function () {
            if (Render.isWebGL || Render.isConchApp) {
                return RunDriver.skinAniSprite();
            }
            else {
                if (!Render.isWebGL) {
                    if (Skeleton.useSimpleMeshInCanvas) {
                        return new SimpleSkinMeshCanvas();
                    }
                    else {
                        return new SkinMeshCanvas();
                    }
                }
            }
            return null;
        };
        __static(BoneSlot, ['_tempMatrix', function () { return this._tempMatrix = new Matrix(); }
        ]);
        return BoneSlot;
    })();
    var CanvasMeshRender = (function () {
        function CanvasMeshRender() {
            this.mesh = null;
            this.transform = null;
            this.context = null;
            this.mode = 0;
        }
        __class(CanvasMeshRender, 'laya.ani.bone.canvasmesh.CanvasMeshRender');
        var __proto = CanvasMeshRender.prototype;
        __proto.renderToContext = function (context) {
            this.context = context.ctx || context;
            if (this.mesh) {
                if (this.mode == 0) {
                    this._renderWithIndexes(this.mesh);
                }
                else {
                    this._renderNoIndexes(this.mesh);
                }
            }
        };
        __proto._renderNoIndexes = function (mesh) {
            var i = 0, len = mesh.vertices.length / 2;
            var index = 0;
            for (i = 0; i < len - 2; i++) {
                index = i * 2;
                this._renderDrawTriangle(mesh, index, (index + 2), (index + 4));
            }
        };
        __proto._renderWithIndexes = function (mesh) {
            var indexes = mesh.indexes;
            var i = 0, len = indexes.length;
            for (i = 0; i < len; i += 3) {
                var index0 = indexes[i] * 2;
                var index1 = indexes[i + 1] * 2;
                var index2 = indexes[i + 2] * 2;
                this._renderDrawTriangle(mesh, index0, index1, index2);
            }
        };
        __proto._renderDrawTriangle = function (mesh, index0, index1, index2) {
            var context = this.context;
            var uvs = mesh.uvs;
            var vertices = mesh.vertices;
            var texture = mesh.texture;
            var source = texture.bitmap;
            var textureSource = source.source;
            var textureWidth = texture.width;
            var textureHeight = texture.height;
            var sourceWidth = source.width;
            var sourceHeight = source.height;
            var u0 = NaN;
            var u1 = NaN;
            var u2 = NaN;
            var v0 = NaN;
            var v1 = NaN;
            var v2 = NaN;
            if (mesh.useUvTransform) {
                var ut = mesh.uvTransform;
                u0 = ((uvs[index0] * ut.a) + (uvs[index0 + 1] * ut.c) + ut.tx) * sourceWidth;
                u1 = ((uvs[index1] * ut.a) + (uvs[index1 + 1] * ut.c) + ut.tx) * sourceWidth;
                u2 = ((uvs[index2] * ut.a) + (uvs[index2 + 1] * ut.c) + ut.tx) * sourceWidth;
                v0 = ((uvs[index0] * ut.b) + (uvs[index0 + 1] * ut.d) + ut.ty) * sourceHeight;
                v1 = ((uvs[index1] * ut.b) + (uvs[index1 + 1] * ut.d) + ut.ty) * sourceHeight;
                v2 = ((uvs[index2] * ut.b) + (uvs[index2 + 1] * ut.d) + ut.ty) * sourceHeight;
            }
            else {
                u0 = uvs[index0] * sourceWidth;
                u1 = uvs[index1] * sourceWidth;
                u2 = uvs[index2] * sourceWidth;
                v0 = uvs[index0 + 1] * sourceHeight;
                v1 = uvs[index1 + 1] * sourceHeight;
                v2 = uvs[index2 + 1] * sourceHeight;
            }
            ;
            var x0 = vertices[index0];
            var x1 = vertices[index1];
            var x2 = vertices[index2];
            var y0 = vertices[index0 + 1];
            var y1 = vertices[index1 + 1];
            var y2 = vertices[index2 + 1];
            if (mesh.canvasPadding > 0) {
                var paddingX = mesh.canvasPadding;
                var paddingY = mesh.canvasPadding;
                var centerX = (x0 + x1 + x2) / 3;
                var centerY = (y0 + y1 + y2) / 3;
                var normX = x0 - centerX;
                var normY = y0 - centerY;
                var dist = Math.sqrt((normX * normX) + (normY * normY));
                x0 = centerX + ((normX / dist) * (dist + paddingX));
                y0 = centerY + ((normY / dist) * (dist + paddingY));
                normX = x1 - centerX;
                normY = y1 - centerY;
                dist = Math.sqrt((normX * normX) + (normY * normY));
                x1 = centerX + ((normX / dist) * (dist + paddingX));
                y1 = centerY + ((normY / dist) * (dist + paddingY));
                normX = x2 - centerX;
                normY = y2 - centerY;
                dist = Math.sqrt((normX * normX) + (normY * normY));
                x2 = centerX + ((normX / dist) * (dist + paddingX));
                y2 = centerY + ((normY / dist) * (dist + paddingY));
            }
            context.save();
            if (this.transform) {
                var mt = this.transform;
                context.transform(mt.a, mt.b, mt.c, mt.d, mt.tx, mt.ty);
            }
            context.beginPath();
            context.moveTo(x0, y0);
            context.lineTo(x1, y1);
            context.lineTo(x2, y2);
            context.closePath();
            context.clip();
            var delta = (u0 * v1) + (v0 * u2) + (u1 * v2) - (v1 * u2) - (v0 * u1) - (u0 * v2);
            var dDelta = 1 / delta;
            var deltaA = (x0 * v1) + (v0 * x2) + (x1 * v2) - (v1 * x2) - (v0 * x1) - (x0 * v2);
            var deltaB = (u0 * x1) + (x0 * u2) + (u1 * x2) - (x1 * u2) - (x0 * u1) - (u0 * x2);
            var deltaC = (u0 * v1 * x2) + (v0 * x1 * u2) + (x0 * u1 * v2) - (x0 * v1 * u2) - (v0 * u1 * x2) - (u0 * x1 * v2);
            var deltaD = (y0 * v1) + (v0 * y2) + (y1 * v2) - (v1 * y2) - (v0 * y1) - (y0 * v2);
            var deltaE = (u0 * y1) + (y0 * u2) + (u1 * y2) - (y1 * u2) - (y0 * u1) - (u0 * y2);
            var deltaF = (u0 * v1 * y2) + (v0 * y1 * u2) + (y0 * u1 * v2) - (y0 * v1 * u2) - (v0 * u1 * y2) - (u0 * y1 * v2);
            context.transform(deltaA * dDelta, deltaD * dDelta, deltaB * dDelta, deltaE * dDelta, deltaC * dDelta, deltaF * dDelta);
            context.drawImage(textureSource, texture.uv[0] * sourceWidth, texture.uv[1] * sourceHeight, textureWidth, textureHeight, texture.uv[0] * sourceWidth, texture.uv[1] * sourceHeight, textureWidth, textureHeight);
            context.restore();
        };
        return CanvasMeshRender;
    })();
    var MeshData = (function () {
        function MeshData() {
            this.texture = null;
            this.uvs = [0, 0, 1, 0, 1, 1, 0, 1];
            this.vertices = [0, 0, 100, 0, 100, 100, 0, 100];
            this.indexes = [0, 1, 3, 3, 1, 2];
            this.uvTransform = null;
            this.useUvTransform = false;
            this.canvasPadding = 1;
        }
        __class(MeshData, 'laya.ani.bone.canvasmesh.MeshData');
        var __proto = MeshData.prototype;
        __proto.getBounds = function () {
            return Rectangle._getWrapRec(this.vertices);
        };
        return MeshData;
    })();
    var DeformAniData = (function () {
        function DeformAniData() {
            this.skinName = null;
            this.deformSlotDataList = [];
        }
        __class(DeformAniData, 'laya.ani.bone.DeformAniData');
        return DeformAniData;
    })();
    var DeformSlotData = (function () {
        function DeformSlotData() {
            this.deformSlotDisplayList = [];
        }
        __class(DeformSlotData, 'laya.ani.bone.DeformSlotData');
        return DeformSlotData;
    })();
    var DeformSlotDisplayData = (function () {
        function DeformSlotDisplayData() {
            this.boneSlot = null;
            this.slotIndex = -1;
            this.attachment = null;
            this.deformData = null;
            this.frameIndex = 0;
            this.timeList = [];
            this.vectices = [];
            this.tweenKeyList = [];
        }
        __class(DeformSlotDisplayData, 'laya.ani.bone.DeformSlotDisplayData');
        var __proto = DeformSlotDisplayData.prototype;
        __proto.binarySearch1 = function (values, target) {
            var low = 0;
            var high = values.length - 2;
            if (high == 0)
                return 1;
            var current = high >>> 1;
            while (true) {
                if (values[Math.floor(current + 1)] <= target)
                    low = current + 1;
                else
                    high = current;
                if (low == high)
                    return low + 1;
                current = (low + high) >>> 1;
            }
            return 0;
        };
        __proto.apply = function (time, boneSlot, alpha) {
            (alpha === void 0) && (alpha = 1);
            time += 0.05;
            if (this.timeList.length <= 0) {
                return;
            }
            ;
            var i = 0;
            var n = 0;
            var tTime = this.timeList[0];
            if (time < tTime) {
                return;
            }
            ;
            var tVertexCount = this.vectices[0].length;
            var tVertices = [];
            var tFrameIndex = this.binarySearch1(this.timeList, time);
            this.frameIndex = tFrameIndex;
            if (time >= this.timeList[this.timeList.length - 1]) {
                var lastVertices = this.vectices[this.vectices.length - 1];
                if (alpha < 1) {
                    for (i = 0; i < tVertexCount; i++) {
                        tVertices[i] += (lastVertices[i] - tVertices[i]) * alpha;
                    }
                }
                else {
                    for (i = 0; i < tVertexCount; i++) {
                        tVertices[i] = lastVertices[i];
                    }
                }
                this.deformData = tVertices;
                return;
            }
            ;
            var tTweenKey = this.tweenKeyList[this.frameIndex];
            var tPrevVertices = this.vectices[this.frameIndex - 1];
            var tNextVertices = this.vectices[this.frameIndex];
            var tPreFrameTime = this.timeList[this.frameIndex - 1];
            var tFrameTime = this.timeList[this.frameIndex];
            if (this.tweenKeyList[tFrameIndex - 1]) {
                alpha = (time - tPreFrameTime) / (tFrameTime - tPreFrameTime);
            }
            else {
                alpha = 0;
            }
            ;
            var tPrev = NaN;
            for (i = 0; i < tVertexCount; i++) {
                tPrev = tPrevVertices[i];
                tVertices[i] = tPrev + (tNextVertices[i] - tPrev) * alpha;
            }
            this.deformData = tVertices;
        };
        return DeformSlotDisplayData;
    })();
    var DrawOrderData = (function () {
        function DrawOrderData() {
            this.time = NaN;
            this.drawOrder = [];
        }
        __class(DrawOrderData, 'laya.ani.bone.DrawOrderData');
        return DrawOrderData;
    })();
    var EventData = (function () {
        function EventData() {
            this.name = null;
            this.intValue = 0;
            this.floatValue = NaN;
            this.stringValue = null;
            this.time = NaN;
        }
        __class(EventData, 'laya.ani.bone.EventData');
        return EventData;
    })();
    var IkConstraint = (function () {
        function IkConstraint(data, bones) {
            this._targetBone = null;
            this._bones = null;
            this._data = null;
            this.name = null;
            this.mix = NaN;
            this.bendDirection = NaN;
            this.isSpine = true;
            this._sp = null;
            this.isDebug = false;
            this._data = data;
            this._targetBone = bones[data.targetBoneIndex];
            this.isSpine = data.isSpine;
            if (this._bones == null)
                this._bones = [];
            this._bones.length = 0;
            for (var i = 0, n = data.boneIndexs.length; i < n; i++) {
                this._bones.push(bones[data.boneIndexs[i]]);
            }
            this.name = data.name;
            this.mix = data.mix;
            this.bendDirection = data.bendDirection;
        }
        __class(IkConstraint, 'laya.ani.bone.IkConstraint');
        var __proto = IkConstraint.prototype;
        __proto.apply = function () {
            switch (this._bones.length) {
                case 1:
                    this._applyIk1(this._bones[0], this._targetBone.resultMatrix.tx, this._targetBone.resultMatrix.ty, this.mix);
                    break;
                case 2:
                    if (this.isSpine) {
                        this._applyIk2(this._bones[0], this._bones[1], this._targetBone.resultMatrix.tx, this._targetBone.resultMatrix.ty, this.bendDirection, this.mix);
                    }
                    else {
                        this._applyIk3(this._bones[0], this._bones[1], this._targetBone.resultMatrix.tx, this._targetBone.resultMatrix.ty, this.bendDirection, this.mix);
                    }
                    break;
            }
        };
        __proto._applyIk1 = function (bone, targetX, targetY, alpha) {
            var pp = bone.parentBone;
            var id = 1 / (pp.resultMatrix.a * pp.resultMatrix.d - pp.resultMatrix.b * pp.resultMatrix.c);
            var x = targetX - pp.resultMatrix.tx;
            var y = targetY - pp.resultMatrix.ty;
            var tx = (x * pp.resultMatrix.d - y * pp.resultMatrix.c) * id - bone.transform.x;
            var ty = (y * pp.resultMatrix.a - x * pp.resultMatrix.b) * id - bone.transform.y;
            var rotationIK = Math.atan2(ty, tx) * IkConstraint.radDeg - 0 - bone.transform.skX;
            if (bone.transform.scX < 0)
                rotationIK += 180;
            if (rotationIK > 180)
                rotationIK -= 360;
            else if (rotationIK < -180)
                rotationIK += 360;
            bone.transform.skX = bone.transform.skY = bone.transform.skX + rotationIK * alpha;
            bone.update();
        };
        __proto.updatePos = function (x, y) {
            if (this._sp) {
                this._sp.pos(x, y);
            }
        };
        __proto._applyIk2 = function (parent, child, targetX, targetY, bendDir, alpha) {
            if (alpha == 0) {
                return;
            }
            ;
            var px = parent.resultTransform.x, py = parent.resultTransform.y;
            var psx = parent.transform.scX, psy = parent.transform.scY;
            var csx = child.transform.scX;
            var os1 = 0, os2 = 0, s2 = 0;
            if (psx < 0) {
                psx = -psx;
                os1 = 180;
                s2 = -1;
            }
            else {
                os1 = 0;
                s2 = 1;
            }
            if (psy < 0) {
                psy = -psy;
                s2 = -s2;
            }
            if (csx < 0) {
                csx = -csx;
                os2 = 180;
            }
            else {
                os2 = 0;
            }
            ;
            var cx = child.resultTransform.x, cy = NaN, cwx = NaN, cwy = NaN;
            var a = parent.resultMatrix.a, b = parent.resultMatrix.c;
            var c = parent.resultMatrix.b, d = parent.resultMatrix.d;
            var u = Math.abs(psx - psy) <= 0.0001;
            if (!u) {
                cy = 0;
                cwx = a * cx + parent.resultMatrix.tx;
                cwy = c * cx + parent.resultMatrix.ty;
            }
            else {
                cy = child.resultTransform.y;
                cwx = a * cx + b * cy + parent.resultMatrix.tx;
                cwy = c * cx + d * cy + parent.resultMatrix.ty;
            }
            if (this.isDebug) {
                if (!this._sp) {
                    this._sp = new Sprite();
                    Laya.stage.addChild(this._sp);
                }
                this._sp.graphics.clear();
                this._sp.graphics.drawCircle(targetX, targetY, 15, "#ffff00");
                this._sp.graphics.drawCircle(cwx, cwy, 15, "#ff00ff");
            }
            parent.setRotation(Math.atan2(cwy - parent.resultMatrix.ty, cwx - parent.resultMatrix.tx));
            var pp = parent.parentBone;
            a = pp.resultMatrix.a;
            b = pp.resultMatrix.c;
            c = pp.resultMatrix.b;
            d = pp.resultMatrix.d;
            var id = 1 / (a * d - b * c);
            var x = targetX - pp.resultMatrix.tx, y = targetY - pp.resultMatrix.ty;
            var tx = (x * d - y * b) * id - px;
            var ty = (y * a - x * c) * id - py;
            x = cwx - pp.resultMatrix.tx;
            y = cwy - pp.resultMatrix.ty;
            var dx = (x * d - y * b) * id - px;
            var dy = (y * a - x * c) * id - py;
            var l1 = Math.sqrt(dx * dx + dy * dy);
            var l2 = child.length * csx;
            var a1 = NaN, a2 = NaN;
            if (u) {
                l2 *= psx;
                var cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);
                if (cos < -1)
                    cos = -1;
                else if (cos > 1)
                    cos = 1;
                a2 = Math.acos(cos) * bendDir;
                a = l1 + l2 * cos;
                b = l2 * Math.sin(a2);
                a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
            }
            else {
                a = psx * l2;
                b = psy * l2;
                var aa = a * a, bb = b * b, dd = tx * tx + ty * ty, ta = Math.atan2(ty, tx);
                c = bb * l1 * l1 + aa * dd - aa * bb;
                var c1 = -2 * bb * l1, c2 = bb - aa;
                d = c1 * c1 - 4 * c2 * c;
                if (d > 0) {
                    var q = Math.sqrt(d);
                    if (c1 < 0)
                        q = -q;
                    q = -(c1 + q) / 2;
                    var r0 = q / c2, r1 = c / q;
                    var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
                    if (r * r <= dd) {
                        y = Math.sqrt(dd - r * r) * bendDir;
                        a1 = ta - Math.atan2(y, r);
                        a2 = Math.atan2(y / psy, (r - l1) / psx);
                    }
                }
                ;
                var minAngle = 0, minDist = Number.MAX_VALUE, minX = 0, minY = 0;
                var maxAngle = 0, maxDist = 0, maxX = 0, maxY = 0;
                x = l1 + a;
                d = x * x;
                if (d > maxDist) {
                    maxAngle = 0;
                    maxDist = d;
                    maxX = x;
                }
                x = l1 - a;
                d = x * x;
                if (d < minDist) {
                    minAngle = Math.PI;
                    minDist = d;
                    minX = x;
                }
                ;
                var angle = Math.acos(-a * l1 / (aa - bb));
                x = a * Math.cos(angle) + l1;
                y = b * Math.sin(angle);
                d = x * x + y * y;
                if (d < minDist) {
                    minAngle = angle;
                    minDist = d;
                    minX = x;
                    minY = y;
                }
                if (d > maxDist) {
                    maxAngle = angle;
                    maxDist = d;
                    maxX = x;
                    maxY = y;
                }
                if (dd <= (minDist + maxDist) / 2) {
                    a1 = ta - Math.atan2(minY * bendDir, minX);
                    a2 = minAngle * bendDir;
                }
                else {
                    a1 = ta - Math.atan2(maxY * bendDir, maxX);
                    a2 = maxAngle * bendDir;
                }
            }
            ;
            var os = Math.atan2(cy, cx) * s2;
            var rotation = parent.resultTransform.skX;
            a1 = (a1 - os) * IkConstraint.radDeg + os1 - rotation;
            if (a1 > 180)
                a1 -= 360;
            else if (a1 < -180)
                a1 += 360;
            parent.resultTransform.x = px;
            parent.resultTransform.y = py;
            parent.resultTransform.skX = parent.resultTransform.skY = rotation + a1 * alpha;
            rotation = child.resultTransform.skX;
            rotation = rotation % 360;
            a2 = ((a2 + os) * IkConstraint.radDeg - 0) * s2 + os2 - rotation;
            if (a2 > 180)
                a2 -= 360;
            else if (a2 < -180)
                a2 += 360;
            child.resultTransform.x = cx;
            child.resultTransform.y = cy;
            child.resultTransform.skX = child.resultTransform.skY = child.resultTransform.skY + a2 * alpha;
            parent.update();
        };
        __proto._applyIk3 = function (parent, child, targetX, targetY, bendDir, alpha) {
            if (alpha == 0) {
                return;
            }
            ;
            var cwx = NaN, cwy = NaN;
            var x = child.resultMatrix.a * child.length;
            var y = child.resultMatrix.b * child.length;
            var lLL = x * x + y * y;
            var lL = Math.sqrt(lLL);
            var parentX = parent.resultMatrix.tx;
            var parentY = parent.resultMatrix.ty;
            var childX = child.resultMatrix.tx;
            var childY = child.resultMatrix.ty;
            var dX = childX - parentX;
            var dY = childY - parentY;
            var lPP = dX * dX + dY * dY;
            var lP = Math.sqrt(lPP);
            dX = targetX - parent.resultMatrix.tx;
            dY = targetY - parent.resultMatrix.ty;
            var lTT = dX * dX + dY * dY;
            var lT = Math.sqrt(lTT);
            var ikRadianA = 0;
            if (lL + lP <= lT || lT + lL <= lP || lT + lP <= lL) {
                var rate = NaN;
                if (lL + lP <= lT) {
                    rate = 1;
                }
                else {
                    rate = -1;
                }
                childX = parentX + rate * (targetX - parentX) * lP / lT;
                childY = parentY + rate * (targetY - parentY) * lP / lT;
            }
            else {
                var h = (lPP - lLL + lTT) / (2 * lTT);
                var r = Math.sqrt(lPP - h * h * lTT) / lT;
                var hX = parentX + (dX * h);
                var hY = parentY + (dY * h);
                var rX = -dY * r;
                var rY = dX * r;
                if (bendDir > 0) {
                    childX = hX - rX;
                    childY = hY - rY;
                }
                else {
                    childX = hX + rX;
                    childY = hY + rY;
                }
            }
            cwx = childX;
            cwy = childY;
            if (this.isDebug) {
                if (!this._sp) {
                    this._sp = new Sprite();
                    Laya.stage.addChild(this._sp);
                }
                this._sp.graphics.clear();
                this._sp.graphics.drawCircle(parentX, parentY, 15, "#ff00ff");
                this._sp.graphics.drawCircle(targetX, targetY, 15, "#ffff00");
                this._sp.graphics.drawCircle(cwx, cwy, 15, "#ff00ff");
            }
            ;
            var pRotation = NaN;
            pRotation = Math.atan2(cwy - parent.resultMatrix.ty, cwx - parent.resultMatrix.tx);
            parent.setRotation(pRotation);
            var pTarMatrix;
            pTarMatrix = IkConstraint._tempMatrix;
            pTarMatrix.identity();
            pTarMatrix.rotate(pRotation);
            pTarMatrix.scale(parent.resultMatrix.getScaleX(), parent.resultMatrix.getScaleY());
            pTarMatrix.translate(parent.resultMatrix.tx, parent.resultMatrix.ty);
            pTarMatrix.copyTo(parent.resultMatrix);
            parent.updateChild();
            var childRotation = NaN;
            childRotation = Math.atan2(targetY - cwy, targetX - cwx);
            child.setRotation(childRotation);
            var childTarMatrix;
            childTarMatrix = IkConstraint._tempMatrix;
            childTarMatrix.identity();
            childTarMatrix.rotate(childRotation);
            childTarMatrix.scale(child.resultMatrix.getScaleX(), child.resultMatrix.getScaleY());
            childTarMatrix.translate(cwx, cwy);
            pTarMatrix.copyTo(child.resultMatrix);
            child.updateChild();
        };
        __static(IkConstraint, ['radDeg', function () { return this.radDeg = 180 / Math.PI; }, 'degRad', function () { return this.degRad = Math.PI / 180; }, '_tempMatrix', function () { return this._tempMatrix = new Matrix(); }
        ]);
        return IkConstraint;
    })();
    var IkConstraintData = (function () {
        function IkConstraintData() {
            this.name = null;
            this.targetBoneName = null;
            this.bendDirection = 1;
            this.mix = 1;
            this.isSpine = true;
            this.targetBoneIndex = -1;
            this.boneNames = [];
            this.boneIndexs = [];
        }
        __class(IkConstraintData, 'laya.ani.bone.IkConstraintData');
        return IkConstraintData;
    })();
    var MeshTools = (function () {
        function MeshTools() { }
        __class(MeshTools, 'laya.ani.bone.MeshTools');
        MeshTools.findEdge = function (verticles, offI, min) {
            (offI === void 0) && (offI = 0);
            (min === void 0) && (min = true);
            var i = 0, len = 0;
            var tIndex = 0;
            len = verticles.length;
            tIndex = -1;
            for (i = 0; i < len; i += 2) {
                if (tIndex < 0 || (min == (verticles[tIndex + offI] < verticles[i + offI]))) {
                    tIndex = i;
                }
            }
            return tIndex;
        };
        MeshTools.findBestTriangle = function (verticles) {
            var topI = 0;
            topI = MeshTools.findEdge(verticles, 1, true);
            var bottomI = 0;
            bottomI = MeshTools.findEdge(verticles, 1, false);
            var leftI = 0;
            leftI = MeshTools.findEdge(verticles, 0, true);
            var rightI = 0;
            rightI = MeshTools.findEdge(verticles, 0, false);
            var rst;
            rst = MeshTools._bestTriangle;
            rst.length = 0;
            rst.push(leftI, rightI);
            if (rst.indexOf(topI) < 0)
                rst.push(topI);
            if (rst.indexOf(bottomI) < 0)
                rst.push(bottomI);
            return rst;
        };
        MeshTools.solveMesh = function (mesh, rst) {
            rst = rst || [];
            rst.length = 0;
            var mUv;
            mUv = mesh.uvs;
            var mVer;
            mVer = mesh.vertices;
            var uvAbs;
            var indexs;
            indexs = MeshTools.findBestTriangle(mUv);
            var index0 = 0;
            var index1 = 0;
            var index2 = 0;
            index0 = indexs[0];
            index1 = indexs[1];
            index2 = indexs[2];
            MeshTools._absArr.length = 0;
            uvAbs = MeshTools.solvePoints(mesh.texture.uv, mUv[index0], mUv[index0 + 1], mUv[index1] - mUv[index0], mUv[index1 + 1] - mUv[index0 + 1], mUv[index2] - mUv[index0], mUv[index2 + 1] - mUv[index0 + 1], MeshTools._absArr);
            var newVerticles;
            newVerticles = MeshTools.transPoints(uvAbs, mVer[index0], mVer[index0 + 1], mVer[index1] - mVer[index0], mVer[index1 + 1] - mVer[index0 + 1], mVer[index2] - mVer[index0], mVer[index2 + 1] - mVer[index0 + 1], rst);
            return newVerticles;
        };
        MeshTools.solvePoints = function (pointList, oX, oY, v1x, v1y, v2x, v2y, rst) {
            rst = rst || [];
            var i = 0, len = 0;
            len = pointList.length;
            var tRst;
            for (i = 0; i < len; i += 2) {
                tRst = MeshTools.solve2(pointList[i], pointList[i + 1], oX, oY, v1x, v1y, v2x, v2y);
                rst.push(tRst[0], tRst[1]);
            }
            return rst;
        };
        MeshTools.transPoints = function (abs, oX, oY, v1x, v1y, v2x, v2y, rst) {
            rst = rst || [];
            var i = 0, len = 0;
            len = abs.length;
            var tRst;
            for (i = 0; i < len; i += 2) {
                tRst = MeshTools.transPoint(abs[i], abs[i + 1], oX, oY, v1x, v1y, v2x, v2y, rst);
            }
            return rst;
        };
        MeshTools.transPoint = function (a, b, oX, oY, v1x, v1y, v2x, v2y, rst) {
            rst = rst || [];
            var nX = NaN;
            var nY = NaN;
            nX = oX + v1x * a + v2x * b;
            nY = oY + v1y * a + v2y * b;
            rst.push(nX, nY);
            return rst;
        };
        MeshTools.solve2 = function (rx, ry, oX, oY, v1x, v1y, v2x, v2y, rv, rst) {
            (rv === void 0) && (rv = false);
            rst = rst || [];
            var a = NaN, b = NaN;
            if (v1x == 0) {
                return MeshTools.solve2(rx, ry, oX, oY, v2x, v2y, v1x, v1y, true, rst);
            }
            ;
            var dX = NaN;
            var dY = NaN;
            dX = rx - oX;
            dY = ry - oY;
            b = (dY - dX * v1y / v1x) / (v2y - v2x * v1y / v1x);
            a = (dX - b * v2x) / v1x;
            if (rv) {
                rst.push(b, a);
            }
            else {
                rst.push(a, b);
            }
            return rst;
        };
        MeshTools.solve = function (pointC, point0, v1, v2) {
            return MeshTools.solve2(pointC.x, pointC.y, point0.x, point0.y, v1.x, v1.y, v2.x, v2.y);
        };
        MeshTools._bestTriangle = [];
        MeshTools._absArr = [];
        return MeshTools;
    })();
    var PathConstraint = (function () {
        function PathConstraint(data, bones) {
            this.target = null;
            this.data = null;
            this.bones = null;
            this.position = NaN;
            this.spacing = NaN;
            this.rotateMix = NaN;
            this.translateMix = NaN;
            this._debugKey = false;
            this._spaces = null;
            this._segments = [];
            this._curves = [];
            this.data = data;
            this.position = data.position;
            this.spacing = data.spacing;
            this.rotateMix = data.rotateMix;
            this.translateMix = data.translateMix;
            this.bones = [];
            var tBoneIds = this.data.bones;
            for (var i = 0, n = tBoneIds.length; i < n; i++) {
                this.bones.push(bones[tBoneIds[i]]);
            }
        }
        __class(PathConstraint, 'laya.ani.bone.PathConstraint');
        var __proto = PathConstraint.prototype;
        __proto.apply = function (boneList, graphics) {
            if (!this.target)
                return;
            var tTranslateMix = this.translateMix;
            var tRotateMix = this.translateMix;
            var tTranslate = tTranslateMix > 0;
            var tRotate = tRotateMix > 0;
            var tSpacingMode = this.data.spacingMode;
            var tLengthSpacing = tSpacingMode == "length";
            var tRotateMode = this.data.rotateMode;
            var tTangents = tRotateMode == "tangent";
            var tScale = tRotateMode == "chainScale";
            var lengths = [];
            var boneCount = this.bones.length;
            var spacesCount = tTangents ? boneCount : boneCount + 1;
            var spaces = [];
            this._spaces = spaces;
            spaces[0] = this.position;
            var spacing = this.spacing;
            if (tScale || tLengthSpacing) {
                for (var i = 0, n = spacesCount - 1; i < n;) {
                    var bone = this.bones[i];
                    var length = bone.length;
                    var x = length * bone.resultMatrix.a;
                    var y = length * bone.resultMatrix.b;
                    length = Math.sqrt(x * x + y * y);
                    if (tScale)
                        lengths[i] = length;
                    spaces[++i] = tLengthSpacing ? Math.max(0, length + spacing) : spacing;
                }
            }
            else {
                for (i = 1; i < spacesCount; i++) {
                    spaces[i] = spacing;
                }
            }
            ;
            var positions = this.computeWorldPositions(this.target, boneList, graphics, spacesCount, tTangents, this.data.positionMode == "percent", tSpacingMode == "percent");
            if (this._debugKey) {
                for (i = 0; i < positions.length; i++) {
                    graphics.drawCircle(positions[i++], positions[i++], 5, "#00ff00");
                }
                ;
                var tLinePos = [];
                for (i = 0; i < positions.length; i++) {
                    tLinePos.push(positions[i++], positions[i++]);
                }
                graphics.drawLines(0, 0, tLinePos, "#ff0000");
            }
            ;
            var skeletonX = NaN;
            var skeletonY = NaN;
            var boneX = positions[0];
            var boneY = positions[1];
            var offsetRotation = this.data.offsetRotation;
            var tip = tRotateMode == "chain" && offsetRotation == 0;
            var p = NaN;
            for (i = 0, p = 3; i < boneCount; i++, p += 3) {
                bone = this.bones[i];
                bone.resultMatrix.tx += (boneX - bone.resultMatrix.tx) * tTranslateMix;
                bone.resultMatrix.ty += (boneY - bone.resultMatrix.ty) * tTranslateMix;
                x = positions[p];
                y = positions[p + 1];
                var dx = x - boneX, dy = y - boneY;
                if (tScale) {
                    length = lengths[i];
                    if (length != 0) {
                        var s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * tRotateMix + 1;
                        bone.resultMatrix.a *= s;
                        bone.resultMatrix.c *= s;
                    }
                }
                boneX = x;
                boneY = y;
                if (tRotate) {
                    var a = bone.resultMatrix.a;
                    var b = bone.resultMatrix.c;
                    var c = bone.resultMatrix.b;
                    var d = bone.resultMatrix.d;
                    var r = NaN;
                    var cos = NaN;
                    var sin = NaN;
                    if (tTangents) {
                        r = positions[p - 1];
                    }
                    else if (spaces[i + 1] == 0) {
                        r = positions[p + 2];
                    }
                    else {
                        r = Math.atan2(dy, dx);
                    }
                    r -= Math.atan2(c, a) - offsetRotation / 180 * Math.PI;
                    if (tip) {
                        cos = Math.cos(r);
                        sin = Math.sin(r);
                        length = bone.length;
                        boneX += (length * (cos * a - sin * c) - dx) * tRotateMix;
                        boneY += (length * (sin * a + cos * c) - dy) * tRotateMix;
                    }
                    if (r > Math.PI) {
                        r -= (Math.PI * 2);
                    }
                    else if (r < -Math.PI) {
                        r += (Math.PI * 2);
                    }
                    r *= tRotateMix;
                    cos = Math.cos(r);
                    sin = Math.sin(r);
                    bone.resultMatrix.a = cos * a - sin * c;
                    bone.resultMatrix.c = cos * b - sin * d;
                    bone.resultMatrix.b = sin * a + cos * c;
                    bone.resultMatrix.d = sin * b + cos * d;
                }
            }
        };
        __proto.computeWorldVertices2 = function (boneSlot, boneList, start, count, worldVertices, offset) {
            var tBones = boneSlot.currDisplayData.bones;
            var tWeights = boneSlot.currDisplayData.weights;
            var tTriangles = boneSlot.currDisplayData.triangles;
            var tMatrix;
            var i = 0;
            var v = 0;
            var skip = 0;
            var n = 0;
            var w = 0;
            var b = 0;
            var wx = 0;
            var wy = 0;
            var vx = 0;
            var vy = 0;
            var bone;
            var len = 0;
            if (tBones == null) {
                if (!tTriangles)
                    tTriangles = tWeights;
                if (boneSlot.deformData)
                    tTriangles = boneSlot.deformData;
                var parentName;
                parentName = boneSlot.parent;
                if (boneList) {
                    len = boneList.length;
                    for (i = 0; i < len; i++) {
                        if (boneList[i].name == parentName) {
                            bone = boneList[i];
                            break;
                        }
                    }
                }
                ;
                var tBoneMt;
                if (bone) {
                    tBoneMt = bone.resultMatrix;
                }
                if (!tBoneMt)
                    tBoneMt = PathConstraint._tempMt;
                var x = tBoneMt.tx;
                var y = tBoneMt.ty;
                var a = tBoneMt.a, bb = tBoneMt.b, c = tBoneMt.c, d = tBoneMt.d;
                if (bone)
                    d *= bone.d;
                for (v = start, w = offset; w < count; v += 2, w += 2) {
                    vx = tTriangles[v], vy = tTriangles[v + 1];
                    worldVertices[w] = vx * a + vy * bb + x;
                    worldVertices[w + 1] = -(vx * c + vy * d + y);
                }
                return;
            }
            for (i = 0; i < start; i += 2) {
                n = tBones[v];
                v += n + 1;
                skip += n;
            }
            ;
            var skeletonBones = boneList;
            for (w = offset, b = skip * 3; w < count; w += 2) {
                wx = 0, wy = 0;
                n = tBones[v++];
                n += v;
                for (; v < n; v++, b += 3) {
                    tMatrix = skeletonBones[tBones[v]].resultMatrix;
                    vx = tWeights[b];
                    vy = tWeights[b + 1];
                    var weight = tWeights[b + 2];
                    wx += (vx * tMatrix.a + vy * tMatrix.c + tMatrix.tx) * weight;
                    wy += (vx * tMatrix.b + vy * tMatrix.d + tMatrix.ty) * weight;
                }
                worldVertices[w] = wx;
                worldVertices[w + 1] = wy;
            }
        };
        __proto.computeWorldPositions = function (boneSlot, boneList, graphics, spacesCount, tangents, percentPosition, percentSpacing) {
            var tBones = boneSlot.currDisplayData.bones;
            var tWeights = boneSlot.currDisplayData.weights;
            var tTriangles = boneSlot.currDisplayData.triangles;
            var tRx = 0;
            var tRy = 0;
            var nn = 0;
            var tMatrix;
            var tX = NaN;
            var tY = NaN;
            var tB = 0;
            var tWeight = 0;
            var tVertices = [];
            var i = 0, j = 0, n = 0;
            var verticesLength = boneSlot.currDisplayData.verLen;
            var target = boneSlot;
            var position = this.position;
            var spaces = this._spaces;
            var world = [];
            var out = [];
            var closed = false;
            var curveCount = verticesLength / 6;
            var prevCurve = -1;
            var pathLength = NaN;
            var o = 0, curve = 0;
            var p = NaN;
            var space = NaN;
            var prev = NaN;
            var length = NaN;
            if (!true) {
                var lengths = boneSlot.currDisplayData.lengths;
                curveCount -= closed ? 1 : 2;
                pathLength = lengths[curveCount];
                if (percentPosition)
                    position *= pathLength;
                if (percentSpacing) {
                    for (i = 0; i < spacesCount; i++)
                        spaces[i] *= pathLength;
                }
                world.length = 8;
                for (i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
                    space = spaces[i];
                    position += space;
                    p = position;
                    if (closed) {
                        p %= pathLength;
                        if (p < 0)
                            p += pathLength;
                        curve = 0;
                    }
                    else if (p < 0) {
                        if (prevCurve != PathConstraint.BEFORE) {
                            prevCurve = PathConstraint.BEFORE;
                            this.computeWorldVertices2(target, boneList, 2, 4, world, 0);
                        }
                        this.addBeforePosition(p, world, 0, out, o);
                        continue;
                    }
                    else if (p > pathLength) {
                        if (prevCurve != PathConstraint.AFTER) {
                            prevCurve = PathConstraint.AFTER;
                            this.computeWorldVertices2(target, boneList, verticesLength - 6, 4, world, 0);
                        }
                        this.addAfterPosition(p - pathLength, world, 0, out, o);
                        continue;
                    }
                    for (;; curve++) {
                        length = lengths[curve];
                        if (p > length)
                            continue;
                        if (curve == 0)
                            p /= length;
                        else {
                            prev = lengths[curve - 1];
                            p = (p - prev) / (length - prev);
                        }
                        break;
                    }
                    if (curve != prevCurve) {
                        prevCurve = curve;
                        if (closed && curve == curveCount) {
                            this.computeWorldVertices2(target, boneList, verticesLength - 4, 4, world, 0);
                            this.computeWorldVertices2(target, boneList, 0, 4, world, 4);
                        }
                        else
                            this.computeWorldVertices2(target, boneList, curve * 6 + 2, 8, world, 0);
                    }
                    this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));
                }
                return out;
            }
            if (closed) {
                verticesLength += 2;
                world[verticesLength - 2] = world[0];
                world[verticesLength - 1] = world[1];
            }
            else {
                curveCount--;
                verticesLength -= 4;
                this.computeWorldVertices2(boneSlot, boneList, 2, verticesLength, tVertices, 0);
                if (this._debugKey) {
                    for (i = 0; i < tVertices.length;) {
                        graphics.drawCircle(tVertices[i++], tVertices[i++], 10, "#ff0000");
                    }
                }
                world = tVertices;
            }
            this._curves.length = curveCount;
            var curves = this._curves;
            pathLength = 0;
            var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;
            var tmpx = NaN, tmpy = NaN, dddfx = NaN, dddfy = NaN, ddfx = NaN, ddfy = NaN, dfx = NaN, dfy = NaN;
            var w = 0;
            for (i = 0, w = 2; i < curveCount; i++, w += 6) {
                cx1 = world[w];
                cy1 = world[w + 1];
                cx2 = world[w + 2];
                cy2 = world[w + 3];
                x2 = world[w + 4];
                y2 = world[w + 5];
                tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
                tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
                ddfx = tmpx * 2 + dddfx;
                ddfy = tmpy * 2 + dddfy;
                dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
                dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                dfx += ddfx;
                dfy += ddfy;
                ddfx += dddfx;
                ddfy += dddfy;
                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                dfx += ddfx;
                dfy += ddfy;
                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                dfx += ddfx + dddfx;
                dfy += ddfy + dddfy;
                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                curves[i] = pathLength;
                x1 = x2;
                y1 = y2;
            }
            if (percentPosition)
                position *= pathLength;
            if (percentSpacing) {
                for (i = 0; i < spacesCount; i++)
                    spaces[i] *= pathLength;
            }
            ;
            var segments = this._segments;
            var curveLength = 0;
            var segment = 0;
            for (i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
                space = spaces[i];
                position += space;
                p = position;
                if (closed) {
                    p %= pathLength;
                    if (p < 0)
                        p += pathLength;
                    curve = 0;
                }
                else if (p < 0) {
                    this.addBeforePosition(p, world, 0, out, o);
                    continue;
                }
                else if (p > pathLength) {
                    this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
                    continue;
                }
                for (;; curve++) {
                    length = curves[curve];
                    if (p > length)
                        continue;
                    if (curve == 0)
                        p /= length;
                    else {
                        prev = curves[curve - 1];
                        p = (p - prev) / (length - prev);
                    }
                    break;
                }
                if (curve != prevCurve) {
                    prevCurve = curve;
                    var ii = curve * 6;
                    x1 = world[ii];
                    y1 = world[ii + 1];
                    cx1 = world[ii + 2];
                    cy1 = world[ii + 3];
                    cx2 = world[ii + 4];
                    cy2 = world[ii + 5];
                    x2 = world[ii + 6];
                    y2 = world[ii + 7];
                    tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
                    tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
                    dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;
                    dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;
                    ddfx = tmpx * 2 + dddfx;
                    ddfy = tmpy * 2 + dddfy;
                    dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
                    dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
                    curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
                    segments[0] = curveLength;
                    for (ii = 1; ii < 8; ii++) {
                        dfx += ddfx;
                        dfy += ddfy;
                        ddfx += dddfx;
                        ddfy += dddfy;
                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                        segments[ii] = curveLength;
                    }
                    dfx += ddfx;
                    dfy += ddfy;
                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    segments[8] = curveLength;
                    dfx += ddfx + dddfx;
                    dfy += ddfy + dddfy;
                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    segments[9] = curveLength;
                    segment = 0;
                }
                p *= curveLength;
                for (;; segment++) {
                    length = segments[segment];
                    if (p > length)
                        continue;
                    if (segment == 0)
                        p /= length;
                    else {
                        prev = segments[segment - 1];
                        p = segment + (p - prev) / (length - prev);
                    }
                    break;
                }
                this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));
            }
            return out;
        };
        __proto.addBeforePosition = function (p, temp, i, out, o) {
            var x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);
            out[o] = x1 + p * Math.cos(r);
            out[o + 1] = y1 + p * Math.sin(r);
            out[o + 2] = r;
        };
        __proto.addAfterPosition = function (p, temp, i, out, o) {
            var x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);
            out[o] = x1 + p * Math.cos(r);
            out[o + 1] = y1 + p * Math.sin(r);
            out[o + 2] = r;
        };
        __proto.addCurvePosition = function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
            if (p == 0)
                p = 0.0001;
            var tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;
            var ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;
            var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
            out[o] = x;
            out[o + 1] = y;
            if (tangents) {
                out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
            }
            else {
                out[o + 2] = 0;
            }
        };
        PathConstraint.NONE = -1;
        PathConstraint.BEFORE = -2;
        PathConstraint.AFTER = -3;
        __static(PathConstraint, ['_tempMt', function () { return this._tempMt = new Matrix(); }
        ]);
        return PathConstraint;
    })();
    var PathConstraintData = (function () {
        function PathConstraintData() {
            this.name = null;
            this.target = null;
            this.positionMode = null;
            this.spacingMode = null;
            this.rotateMode = null;
            this.offsetRotation = NaN;
            this.position = NaN;
            this.spacing = NaN;
            this.rotateMix = NaN;
            this.translateMix = NaN;
            this.bones = [];
        }
        __class(PathConstraintData, 'laya.ani.bone.PathConstraintData');
        return PathConstraintData;
    })();
    var SkinData = (function () {
        function SkinData() {
            this.name = null;
            this.slotArr = [];
        }
        __class(SkinData, 'laya.ani.bone.SkinData');
        return SkinData;
    })();
    var SkinSlotDisplayData = (function () {
        function SkinSlotDisplayData() {
            this.name = null;
            this.attachmentName = null;
            this.type = 0;
            this.transform = null;
            this.width = NaN;
            this.height = NaN;
            this.texture = null;
            this.bones = null;
            this.uvs = null;
            this.weights = null;
            this.triangles = null;
            this.vertices = null;
            this.lengths = null;
            this.verLen = 0;
        }
        __class(SkinSlotDisplayData, 'laya.ani.bone.SkinSlotDisplayData');
        var __proto = SkinSlotDisplayData.prototype;
        __proto.createTexture = function (currTexture) {
            if (this.texture)
                return this.texture;
            this.texture = new Texture(currTexture.bitmap, this.uvs);
            if (this.uvs[0] > this.uvs[4]
                && this.uvs[1] > this.uvs[5]) {
                this.texture.width = currTexture.height;
                this.texture.height = currTexture.width;
                this.texture.offsetX = -currTexture.offsetX;
                this.texture.offsetY = -currTexture.offsetY;
                this.texture.sourceWidth = currTexture.sourceHeight;
                this.texture.sourceHeight = currTexture.sourceWidth;
            }
            else {
                this.texture.width = currTexture.width;
                this.texture.height = currTexture.height;
                this.texture.offsetX = -currTexture.offsetX;
                this.texture.offsetY = -currTexture.offsetY;
                this.texture.sourceWidth = currTexture.sourceWidth;
                this.texture.sourceHeight = currTexture.sourceHeight;
            }
            if (!Render.isWebGL) {
                if (this.uvs[1] > this.uvs[5]) {
                    this.texture.offsetY = this.texture.sourceHeight - this.texture.height - this.texture.offsetY;
                }
            }
            return this.texture;
        };
        __proto.destory = function () {
            if (this.texture)
                this.texture.destroy();
        };
        return SkinSlotDisplayData;
    })();
    var SlotData = (function () {
        function SlotData() {
            this.name = null;
            this.displayArr = [];
        }
        __class(SlotData, 'laya.ani.bone.SlotData');
        var __proto = SlotData.prototype;
        __proto.getDisplayByName = function (name) {
            var tDisplay;
            for (var i = 0, n = this.displayArr.length; i < n; i++) {
                tDisplay = this.displayArr[i];
                if (tDisplay.attachmentName == name) {
                    return i;
                }
            }
            return -1;
        };
        return SlotData;
    })();
    var TfConstraint = (function () {
        function TfConstraint(data, bones) {
            this._data = null;
            this._bones = null;
            this.target = null;
            this.rotateMix = NaN;
            this.translateMix = NaN;
            this.scaleMix = NaN;
            this.shearMix = NaN;
            this._temp = __newvec(2, 0);
            this._data = data;
            if (this._bones == null) {
                this._bones = [];
            }
            this.target = bones[data.targetIndex];
            var j = 0, n = 0;
            for (j = 0, n = data.boneIndexs.length; j < n; j++) {
                this._bones.push(bones[data.boneIndexs[j]]);
            }
            this.rotateMix = data.rotateMix;
            this.translateMix = data.translateMix;
            this.scaleMix = data.scaleMix;
            this.shearMix = data.shearMix;
        }
        __class(TfConstraint, 'laya.ani.bone.TfConstraint');
        var __proto = TfConstraint.prototype;
        __proto.apply = function () {
            var tTfBone;
            var ta = this.target.resultMatrix.a, tb = this.target.resultMatrix.b, tc = this.target.resultMatrix.c, td = this.target.resultMatrix.d;
            for (var j = 0, n = this._bones.length; j < n; j++) {
                tTfBone = this._bones[j];
                if (this.rotateMix > 0) {
                    var a = tTfBone.resultMatrix.a, b = tTfBone.resultMatrix.b, c = tTfBone.resultMatrix.c, d = tTfBone.resultMatrix.d;
                    var r = Math.atan2(tc, ta) - Math.atan2(c, a) + this._data.offsetRotation * Math.PI / 180;
                    if (r > Math.PI)
                        r -= Math.PI * 2;
                    else if (r < -Math.PI)
                        r += Math.PI * 2;
                    r *= this.rotateMix;
                    var cos = Math.cos(r), sin = Math.sin(r);
                    tTfBone.resultMatrix.a = cos * a - sin * c;
                    tTfBone.resultMatrix.b = cos * b - sin * d;
                    tTfBone.resultMatrix.c = sin * a + cos * c;
                    tTfBone.resultMatrix.d = sin * b + cos * d;
                }
                if (this.translateMix) {
                    this._temp[0] = this._data.offsetX;
                    this._temp[1] = this._data.offsetY;
                    this.target.localToWorld(this._temp);
                    tTfBone.resultMatrix.tx += (this._temp[0] - tTfBone.resultMatrix.tx) * this.translateMix;
                    tTfBone.resultMatrix.ty += (this._temp[1] - tTfBone.resultMatrix.ty) * this.translateMix;
                    tTfBone.updateChild();
                }
                if (this.scaleMix > 0) {
                    var bs = Math.sqrt(tTfBone.resultMatrix.a * tTfBone.resultMatrix.a + tTfBone.resultMatrix.c * tTfBone.resultMatrix.c);
                    var ts = Math.sqrt(ta * ta + tc * tc);
                    var s = bs > 0.00001 ? (bs + (ts - bs + this._data.offsetScaleX) * this.scaleMix) / bs : 0;
                    tTfBone.resultMatrix.a *= s;
                    tTfBone.resultMatrix.c *= s;
                    bs = Math.sqrt(tTfBone.resultMatrix.b * tTfBone.resultMatrix.b + tTfBone.resultMatrix.d * tTfBone.resultMatrix.d);
                    ts = Math.sqrt(tb * tb + td * td);
                    s = bs > 0.00001 ? (bs + (ts - bs + this._data.offsetScaleY) * this.scaleMix) / bs : 0;
                    tTfBone.resultMatrix.b *= s;
                    tTfBone.resultMatrix.d *= s;
                }
                if (this.shearMix > 0) {
                    b = tTfBone.resultMatrix.b, d = tTfBone.resultMatrix.d;
                    var by = Math.atan2(d, b);
                    r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(tTfBone.resultMatrix.c, tTfBone.resultMatrix.a));
                    if (r > Math.PI)
                        r -= Math.PI * 2;
                    else if (r < -Math.PI)
                        r += Math.PI * 2;
                    r = by + (r + this._data.offsetShearY * Math.PI / 180) * this.shearMix;
                    s = Math.sqrt(b * b + d * d);
                    tTfBone.resultMatrix.b = Math.cos(r) * s;
                    tTfBone.resultMatrix.d = Math.sin(r) * s;
                }
            }
        };
        return TfConstraint;
    })();
    var TfConstraintData = (function () {
        function TfConstraintData() {
            this.name = null;
            this.targetIndex = 0;
            this.rotateMix = NaN;
            this.translateMix = NaN;
            this.scaleMix = NaN;
            this.shearMix = NaN;
            this.offsetRotation = NaN;
            this.offsetX = NaN;
            this.offsetY = NaN;
            this.offsetScaleX = NaN;
            this.offsetScaleY = NaN;
            this.offsetShearY = NaN;
            this.boneIndexs = [];
        }
        __class(TfConstraintData, 'laya.ani.bone.TfConstraintData');
        return TfConstraintData;
    })();
    var Transform = (function () {
        function Transform() {
            this.skX = 0;
            this.skY = 0;
            this.scX = 1;
            this.scY = 1;
            this.x = 0;
            this.y = 0;
            this.skewX = 0;
            this.skewY = 0;
            this.mMatrix = null;
        }
        __class(Transform, 'laya.ani.bone.Transform');
        var __proto = Transform.prototype;
        __proto.initData = function (data) {
            if (data.x != undefined) {
                this.x = data.x;
            }
            if (data.y != undefined) {
                this.y = data.y;
            }
            if (data.skX != undefined) {
                this.skX = data.skX;
            }
            if (data.skY != undefined) {
                this.skY = data.skY;
            }
            if (data.scX != undefined) {
                this.scX = data.scX;
            }
            if (data.scY != undefined) {
                this.scY = data.scY;
            }
        };
        __proto.getMatrix = function () {
            var tMatrix;
            if (this.mMatrix) {
                tMatrix = this.mMatrix;
            }
            else {
                tMatrix = this.mMatrix = new Matrix();
            }
            tMatrix.identity();
            tMatrix.scale(this.scX, this.scY);
            if (this.skewX || this.skewY) {
                this.skew(tMatrix, this.skewX * Math.PI / 180, this.skewY * Math.PI / 180);
            }
            tMatrix.rotate(this.skX * Math.PI / 180);
            tMatrix.translate(this.x, this.y);
            return tMatrix;
        };
        __proto.skew = function (m, x, y) {
            var sinX = Math.sin(y);
            var cosX = Math.cos(y);
            var sinY = Math.sin(x);
            var cosY = Math.cos(x);
            m.setTo(m.a * cosY - m.b * sinX, m.a * sinY + m.b * cosX, m.c * cosY - m.d * sinX, m.c * sinY + m.d * cosX, m.tx * cosY - m.ty * sinX, m.tx * sinY + m.ty * cosX);
            return m;
        };
        return Transform;
    })();
    var UVTools = (function () {
        function UVTools() { }
        __class(UVTools, 'laya.ani.bone.UVTools');
        UVTools.getRelativeUV = function (bigUV, smallUV, rst) {
            var startX = bigUV[0];
            var width = bigUV[2] - bigUV[0];
            var startY = bigUV[1];
            var height = bigUV[5] - bigUV[1];
            if (!rst)
                rst = [];
            rst.length = smallUV.length;
            var i = 0, len = 0;
            len = rst.length;
            var dWidth = 1 / width;
            var dHeight = 1 / height;
            for (i = 0; i < len; i += 2) {
                rst[i] = (smallUV[i] - startX) * dWidth;
                rst[i + 1] = (smallUV[i + 1] - startY) * dHeight;
            }
            return rst;
        };
        UVTools.getAbsoluteUV = function (bigUV, smallUV, rst) {
            if (bigUV[0] == 0 && bigUV[1] == 0 && bigUV[4] == 1 && bigUV[5] == 1) {
                if (rst) {
                    Utils.copyArray(rst, smallUV);
                    return rst;
                }
                else {
                    return smallUV;
                }
            }
            ;
            var startX = bigUV[0];
            var width = bigUV[2] - bigUV[0];
            var startY = bigUV[1];
            var height = bigUV[5] - bigUV[1];
            if (!rst)
                rst = [];
            rst.length = smallUV.length;
            var i = 0, len = 0;
            len = rst.length;
            for (i = 0; i < len; i += 2) {
                rst[i] = smallUV[i] * width + startX;
                rst[i + 1] = smallUV[i + 1] * height + startY;
            }
            return rst;
        };
        return UVTools;
    })();
    var KeyFramesContent = (function () {
        function KeyFramesContent() {
            this.startTime = NaN;
            this.duration = NaN;
            this.interpolationData = null;
            this.data = null;
            this.nextData = null;
        }
        __class(KeyFramesContent, 'laya.ani.KeyFramesContent');
        return KeyFramesContent;
    })();
    var BezierLerp = (function () {
        function BezierLerp() { }
        __class(BezierLerp, 'laya.ani.math.BezierLerp');
        BezierLerp.getBezierRate = function (t, px0, py0, px1, py1) {
            var key = BezierLerp._getBezierParamKey(px0, py0, px1, py1);
            var vKey = key * 100 + t;
            if (BezierLerp._bezierResultCache[vKey])
                return BezierLerp._bezierResultCache[vKey];
            var points = BezierLerp._getBezierPoints(px0, py0, px1, py1, key);
            var i = 0, len = 0;
            len = points.length;
            for (i = 0; i < len; i += 2) {
                if (t <= points[i]) {
                    BezierLerp._bezierResultCache[vKey] = points[i + 1];
                    return points[i + 1];
                }
            }
            BezierLerp._bezierResultCache[vKey] = 1;
            return 1;
        };
        BezierLerp._getBezierParamKey = function (px0, py0, px1, py1) {
            return (((px0 * 100 + py0) * 100 + px1) * 100 + py1) * 100;
        };
        BezierLerp._getBezierPoints = function (px0, py0, px1, py1, key) {
            if (BezierLerp._bezierPointsCache[key])
                return BezierLerp._bezierPointsCache[key];
            var controlPoints;
            controlPoints = [0, 0, px0, py0, px1, py1, 1, 1];
            var bz;
            bz = new Bezier();
            var points;
            points = bz.getBezierPoints(controlPoints, 100, 3);
            BezierLerp._bezierPointsCache[key] = points;
            return points;
        };
        BezierLerp._bezierResultCache = {};
        BezierLerp._bezierPointsCache = {};
        return BezierLerp;
    })();
    var AnimationPlayer = (function (_super) {
        function AnimationPlayer() {
            this._destroyed = false;
            this._templet = null;
            this._currentTime = NaN;
            this._currentFrameTime = NaN;
            this._playStart = NaN;
            this._playEnd = NaN;
            this._playDuration = NaN;
            this._overallDuration = NaN;
            this._stopWhenCircleFinish = false;
            this._elapsedPlaybackTime = NaN;
            this._startUpdateLoopCount = NaN;
            this._currentAnimationClipIndex = 0;
            this._currentKeyframeIndex = 0;
            this._paused = false;
            this._cacheFrameRate = 0;
            this._cacheFrameRateInterval = NaN;
            this._cachePlayRate = NaN;
            this._fullFrames = null;
            this.isCache = true;
            this.playbackRate = 1.0;
            this.returnToZeroStopped = false;
            AnimationPlayer.__super.call(this);
            this._destroyed = false;
            this._currentAnimationClipIndex = -1;
            this._currentKeyframeIndex = -1;
            this._currentTime = 0.0;
            this._overallDuration = Number.MAX_VALUE;
            this._stopWhenCircleFinish = false;
            this._elapsedPlaybackTime = 0;
            this._startUpdateLoopCount = -1;
            this._cachePlayRate = 1.0;
            this.cacheFrameRate = 60;
            this.returnToZeroStopped = false;
        }
        __class(AnimationPlayer, 'laya.ani.AnimationPlayer', _super);
        var __proto = AnimationPlayer.prototype;
        Laya.imps(__proto, { "laya.resource.IDestroy": true });
        __proto._onTempletLoadedComputeFullKeyframeIndices = function (cachePlayRate, cacheFrameRate, templet) {
            if (this._templet === templet && this._cachePlayRate === cachePlayRate && this._cacheFrameRate === cacheFrameRate)
                this._computeFullKeyframeIndices();
        };
        __proto._computeFullKeyframeIndices = function () {
            var anifullFrames = this._fullFrames = [];
            var templet = this._templet;
            var cacheFrameInterval = this._cacheFrameRateInterval * this._cachePlayRate;
            for (var i = 0, iNum = templet.getAnimationCount(); i < iNum; i++) {
                var aniFullFrame = [];
                for (var j = 0, jNum = templet.getAnimation(i).nodes.length; j < jNum; j++) {
                    var node = templet.getAnimation(i).nodes[j];
                    var frameCount = Math.floor(node.playTime / cacheFrameInterval + 0.01);
                    var nodeFullFrames = new Uint16Array(frameCount + 1);
                    var lastFrameIndex = -1;
                    for (var n = 0, nNum = node.keyFrame.length; n < nNum; n++) {
                        var keyFrame = node.keyFrame[n];
                        var tm = keyFrame.startTime;
                        var endTm = tm + keyFrame.duration + cacheFrameInterval;
                        do {
                            var frameIndex = Math.floor(tm / cacheFrameInterval + 0.5);
                            for (var k = lastFrameIndex + 1; k < frameIndex; k++)
                                nodeFullFrames[k] = n;
                            lastFrameIndex = frameIndex;
                            nodeFullFrames[frameIndex] = n;
                            tm += cacheFrameInterval;
                        } while (tm <= endTm);
                    }
                    aniFullFrame.push(nodeFullFrames);
                }
                anifullFrames.push(aniFullFrame);
            }
        };
        __proto._onAnimationTempletLoaded = function () {
            (this.destroyed) || (this._calculatePlayDuration());
        };
        __proto._calculatePlayDuration = function () {
            if (this.state !== 0) {
                var oriDuration = this._templet.getAniDuration(this._currentAnimationClipIndex);
                (this._playEnd === 0) && (this._playEnd = oriDuration);
                if (this._playEnd > oriDuration)
                    this._playEnd = oriDuration;
                this._playDuration = this._playEnd - this._playStart;
            }
        };
        __proto._setPlayParams = function (time, cacheFrameInterval) {
            this._currentTime = time;
            this._currentKeyframeIndex = Math.max(Math.floor((this.currentPlayTime) / cacheFrameInterval + 0.01), 0);
            this._currentFrameTime = this._currentKeyframeIndex * cacheFrameInterval;
        };
        __proto._setPlayParamsWhenStop = function (currentAniClipPlayDuration, cacheFrameInterval) {
            this._currentTime = currentAniClipPlayDuration;
            this._currentKeyframeIndex = Math.max(Math.floor(currentAniClipPlayDuration / cacheFrameInterval + 0.01), 0);
            this._currentFrameTime = this._currentKeyframeIndex * cacheFrameInterval;
            this._currentAnimationClipIndex = -1;
        };
        __proto._update = function (elapsedTime) {
            if (this._currentAnimationClipIndex === -1 || this._paused || !this._templet || !this._templet.loaded)
                return;
            var cacheFrameInterval = this._cacheFrameRateInterval * this._cachePlayRate;
            var time = 0;
            (this._startUpdateLoopCount !== Stat.loopCount) && (time = elapsedTime * this.playbackRate, this._elapsedPlaybackTime += time);
            var currentAniClipPlayDuration = this.playDuration;
            if ((this._overallDuration !== 0 && this._elapsedPlaybackTime >= this._overallDuration) || (this._overallDuration === 0 && this._elapsedPlaybackTime >= currentAniClipPlayDuration)) {
                this._setPlayParamsWhenStop(currentAniClipPlayDuration, cacheFrameInterval);
                this.event("stopped");
                return;
            }
            time += this._currentTime;
            if (currentAniClipPlayDuration > 0) {
                if (time >= currentAniClipPlayDuration) {
                    do {
                        time -= currentAniClipPlayDuration;
                        if (this._stopWhenCircleFinish) {
                            this._setPlayParamsWhenStop(currentAniClipPlayDuration, cacheFrameInterval);
                            this._stopWhenCircleFinish = false;
                            this.event("stopped");
                            return;
                        }
                        if (time < currentAniClipPlayDuration) {
                            this._setPlayParams(time, cacheFrameInterval);
                            this.event("complete");
                        }
                    } while (time >= currentAniClipPlayDuration);
                }
                else {
                    this._setPlayParams(time, cacheFrameInterval);
                }
            }
            else {
                if (this._stopWhenCircleFinish) {
                    this._setPlayParamsWhenStop(currentAniClipPlayDuration, cacheFrameInterval);
                    this._stopWhenCircleFinish = false;
                    this.event("stopped");
                    return;
                }
                this._currentTime = this._currentFrameTime = this._currentKeyframeIndex = 0;
                this.event("complete");
            }
        };
        __proto._destroy = function () {
            this.offAll();
            this._templet = null;
            this._fullFrames = null;
            this._destroyed = true;
        };
        __proto.play = function (index, playbackRate, overallDuration, playStart, playEnd) {
            (index === void 0) && (index = 0);
            (playbackRate === void 0) && (playbackRate = 1.0);
            (overallDuration === void 0) && (overallDuration = 2147483647);
            (playStart === void 0) && (playStart = 0);
            (playEnd === void 0) && (playEnd = 0);
            if (!this._templet)
                throw new Error("AnimationPlayer:templet must not be null,maybe you need to set url.");
            if (overallDuration < 0 || playStart < 0 || playEnd < 0)
                throw new Error("AnimationPlayer:overallDuration,playStart and playEnd must large than zero.");
            if ((playEnd !== 0) && (playStart > playEnd))
                throw new Error("AnimationPlayer:start must less than end.");
            this._currentTime = 0;
            this._currentFrameTime = 0;
            this._elapsedPlaybackTime = 0;
            this.playbackRate = playbackRate;
            this._overallDuration = overallDuration;
            this._playStart = playStart;
            this._playEnd = playEnd;
            this._paused = false;
            this._currentAnimationClipIndex = index;
            this._currentKeyframeIndex = 0;
            this._startUpdateLoopCount = Stat.loopCount;
            this.event("played");
            if (this._templet.loaded)
                this._calculatePlayDuration();
            else
                this._templet.once("loaded", this, this._onAnimationTempletLoaded);
            this._update(0);
        };
        __proto.playByFrame = function (index, playbackRate, overallDuration, playStartFrame, playEndFrame, fpsIn3DBuilder) {
            (index === void 0) && (index = 0);
            (playbackRate === void 0) && (playbackRate = 1.0);
            (overallDuration === void 0) && (overallDuration = 2147483647);
            (playStartFrame === void 0) && (playStartFrame = 0);
            (playEndFrame === void 0) && (playEndFrame = 0);
            (fpsIn3DBuilder === void 0) && (fpsIn3DBuilder = 30);
            var interval = 1000.0 / fpsIn3DBuilder;
            this.play(index, playbackRate, overallDuration, playStartFrame * interval, playEndFrame * interval);
        };
        __proto.stop = function (immediate) {
            (immediate === void 0) && (immediate = true);
            if (immediate) {
                this._currentTime = this._currentFrameTime = this._currentKeyframeIndex = 0;
                this._currentAnimationClipIndex = -1;
                this.event("stopped");
            }
            else {
                this._stopWhenCircleFinish = true;
            }
        };
        __getset(0, __proto, 'playEnd', function () {
            return this._playEnd;
        });
        __getset(0, __proto, 'templet', function () {
            return this._templet;
        }, function (value) {
            if (!this.state === 0)
                this.stop(true);
            if (this._templet !== value) {
                this._templet = value;
                if (value.loaded)
                    this._computeFullKeyframeIndices();
                else
                    value.once("loaded", this, this._onTempletLoadedComputeFullKeyframeIndices, [this._cachePlayRate, this._cacheFrameRate]);
            }
        });
        __getset(0, __proto, 'playStart', function () {
            return this._playStart;
        });
        __getset(0, __proto, 'playDuration', function () {
            return this._playDuration;
        });
        __getset(0, __proto, 'state', function () {
            if (this._currentAnimationClipIndex === -1)
                return 0;
            if (this._paused)
                return 1;
            return 2;
        });
        __getset(0, __proto, 'currentKeyframeIndex', function () {
            return this._currentKeyframeIndex;
        });
        __getset(0, __proto, 'overallDuration', function () {
            return this._overallDuration;
        });
        __getset(0, __proto, 'currentFrameTime', function () {
            return this._currentFrameTime;
        });
        __getset(0, __proto, 'currentAnimationClipIndex', function () {
            return this._currentAnimationClipIndex;
        });
        __getset(0, __proto, 'currentPlayTime', function () {
            return this._currentTime + this._playStart;
        });
        __getset(0, __proto, 'cachePlayRate', function () {
            return this._cachePlayRate;
        }, function (value) {
            if (this._cachePlayRate !== value) {
                this._cachePlayRate = value;
                if (this._templet)
                    if (this._templet.loaded)
                        this._computeFullKeyframeIndices();
                    else
                        this._templet.once("loaded", this, this._onTempletLoadedComputeFullKeyframeIndices, [value, this._cacheFrameRate]);
            }
        });
        __getset(0, __proto, 'cacheFrameRate', function () {
            return this._cacheFrameRate;
        }, function (value) {
            if (this._cacheFrameRate !== value) {
                this._cacheFrameRate = value;
                this._cacheFrameRateInterval = 1000.0 / this._cacheFrameRate;
                if (this._templet)
                    if (this._templet.loaded)
                        this._computeFullKeyframeIndices();
                    else
                        this._templet.once("loaded", this, this._onTempletLoadedComputeFullKeyframeIndices, [this._cachePlayRate, value]);
            }
        });
        __getset(0, __proto, 'currentTime', null, function (value) {
            if (this._currentAnimationClipIndex === -1 || !this._templet || !this._templet.loaded)
                return;
            if (value < this._playStart || value > this._playEnd)
                throw new Error("AnimationPlayer:value must large than playStartTime,small than playEndTime.");
            this._startUpdateLoopCount = Stat.loopCount;
            var cacheFrameInterval = this._cacheFrameRateInterval * this._cachePlayRate;
            this._currentTime = value;
            this._currentKeyframeIndex = Math.max(Math.floor(this.currentPlayTime / cacheFrameInterval), 0);
            this._currentFrameTime = this._currentKeyframeIndex * cacheFrameInterval;
        });
        __getset(0, __proto, 'paused', function () {
            return this._paused;
        }, function (value) {
            this._paused = value;
            value && this.event("paused");
        });
        __getset(0, __proto, 'cacheFrameRateInterval', function () {
            return this._cacheFrameRateInterval;
        });
        __getset(0, __proto, 'destroyed', function () {
            return this._destroyed;
        });
        __getset(0, __proto, 'disposed', function () {
            return this._destroyed;
        });
        return AnimationPlayer;
    })(EventDispatcher);
    var GraphicsAni = (function (_super) {
        function GraphicsAni() {
            GraphicsAni.__super.call(this);
            if (Render.isConchNode) {
                this["drawSkin"] = function (skin) {
                    skin.transform || (skin.transform = Matrix.EMPTY);
                    this.setSkinMesh && this.setSkinMesh(skin._ps, skin.mVBData, skin.mEleNum, 0, skin.mTexture, skin.transform);
                };
            }
        }
        __class(GraphicsAni, 'laya.ani.GraphicsAni', _super);
        var __proto = GraphicsAni.prototype;
        __proto.drawSkin = function (skin) {
            var arr = [skin];
            this._saveToCmd(Render._context._drawSkin, arr);
        };
        return GraphicsAni;
    })(Graphics);
    var SkinMeshCanvas = (function (_super) {
        function SkinMeshCanvas() {
            SkinMeshCanvas.__super.call(this);
            this.mesh = new MeshData();
        }
        __class(SkinMeshCanvas, 'laya.ani.bone.canvasmesh.SkinMeshCanvas', _super);
        var __proto = SkinMeshCanvas.prototype;
        __proto.init2 = function (texture, vs, ps, verticles, uvs) {
            if (this.transform) {
                this.transform = null;
            }
            ;
            var _ps;
            if (ps) {
                _ps = ps;
            }
            else {
                _ps = [];
                _ps.push(0, 1, 3, 3, 1, 2);
            }
            this.mesh.texture = texture;
            this.mesh.indexes = _ps;
            this.mesh.vertices = verticles;
            this.mesh.uvs = uvs;
        };
        __proto.render = function (context, x, y) {
            if (!this.mesh.texture)
                return;
            if (!this.transform) {
                this.transform = SkinMeshCanvas._tempMatrix;
                this.transform.identity();
                this.transform.translate(x, y);
                this.renderToContext(context);
                this.transform.translate(-x, -y);
                this.transform = null;
            }
            else {
                this.transform.translate(x, y);
                this.renderToContext(context);
                this.transform.translate(-x, -y);
            }
        };
        __static(SkinMeshCanvas, ['_tempMatrix', function () { return this._tempMatrix = new Matrix(); }
        ]);
        return SkinMeshCanvas;
    })(CanvasMeshRender);
    var AnimationTemplet = (function (_super) {
        function AnimationTemplet() {
            this._aniMap = {};
            this.unfixedLastAniIndex = -1;
            AnimationTemplet.__super.call(this);
            this._anis = new Array;
        }
        __class(AnimationTemplet, 'laya.ani.AnimationTemplet', _super);
        var __proto = AnimationTemplet.prototype;
        __proto.parse = function (data) {
            var reader = new Byte(data);
            this._aniVersion = reader.readUTFString();
            AnimationParser01.parse(this, reader);
        };
        __proto._calculateKeyFrame = function (node, keyframeCount, keyframeDataCount) {
            var keyFrames = node.keyFrame;
            keyFrames[keyframeCount] = keyFrames[0];
            for (var i = 0; i < keyframeCount; i++) {
                var keyFrame = keyFrames[i];
                keyFrame.nextData = (keyFrame.duration === 0) ? keyFrame.data : keyFrames[i + 1].data;
            }
            keyFrames.length--;
        };
        __proto.onAsynLoaded = function (url, data, params) {
            var reader = new Byte(data);
            this._aniVersion = reader.readUTFString();
            switch (this._aniVersion) {
                case "LAYAANIMATION:02":
                    AnimationParser02.parse(this, reader);
                    break;
                default:
                    AnimationParser01.parse(this, reader);
            }
            this._endLoaded();
        };
        __proto.disposeResource = function () {
            this._aniVersion = null;
            this._anis = null;
            this._aniMap = null;
            this._publicExtData = null;
            this.unfixedCurrentFrameIndexes = null;
            this.unfixedCurrentTimes = null;
            this.unfixedKeyframes = null;
            this._aniClassName = null;
            this._animationDatasCache = null;
        };
        __proto.getAnimationCount = function () {
            return this._anis.length;
        };
        __proto.getAnimation = function (aniIndex) {
            return this._anis[aniIndex];
        };
        __proto.getAniDuration = function (aniIndex) {
            return this._anis[aniIndex].playTime;
        };
        __proto.getNodes = function (aniIndex) {
            return this._anis[aniIndex].nodes;
        };
        __proto.getNodeIndexWithName = function (aniIndex, name) {
            return this._anis[aniIndex].bone3DMap[name];
        };
        __proto.getNodeCount = function (aniIndex) {
            return this._anis[aniIndex].nodes.length;
        };
        __proto.getTotalkeyframesLength = function (aniIndex) {
            return this._anis[aniIndex].totalKeyframeDatasLength;
        };
        __proto.getPublicExtData = function () {
            return this._publicExtData;
        };
        __proto.getAnimationDataWithCache = function (key, cacheDatas, aniIndex, frameIndex) {
            var aniDatas = cacheDatas[aniIndex];
            if (!aniDatas) {
                return null;
            }
            else {
                var keyDatas = aniDatas[key];
                if (!keyDatas)
                    return null;
                else {
                    return keyDatas[frameIndex];
                }
            }
        };
        __proto.setAnimationDataWithCache = function (key, cacheDatas, aniIndex, frameIndex, data) {
            var aniDatas = (cacheDatas[aniIndex]) || (cacheDatas[aniIndex] = {});
            var aniDatasCache = (aniDatas[key]) || (aniDatas[key] = []);
            aniDatasCache[frameIndex] = data;
        };
        __proto.getOriginalData = function (aniIndex, originalData, nodesFrameIndices, frameIndex, playCurTime) {
            var oneAni = this._anis[aniIndex];
            var nodes = oneAni.nodes;
            var j = 0;
            for (var i = 0, n = nodes.length, outOfs = 0; i < n; i++) {
                var node = nodes[i];
                var key;
                key = node.keyFrame[nodesFrameIndices[i][frameIndex]];
                node.dataOffset = outOfs;
                var dt = playCurTime - key.startTime;
                var lerpType = node.lerpType;
                if (lerpType) {
                    switch (lerpType) {
                        case 0:
                        case 1:
                            for (j = 0; j < node.keyframeWidth;)
                                j += node.interpolationMethod[j](node, j, originalData, outOfs + j, key.data, dt, null, key.duration, key.nextData);
                            break;
                        case 2:
                            ;
                            var interpolationData = key.interpolationData;
                            var interDataLen = interpolationData.length;
                            var dataIndex = 0;
                            for (j = 0; j < interDataLen;) {
                                var type = interpolationData[j];
                                switch (type) {
                                    case 6:
                                        j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, null, key.duration, key.nextData, interpolationData, j + 1);
                                        break;
                                    case 7:
                                        j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, null, key.duration, key.nextData, interpolationData, j + 1);
                                        break;
                                    default:
                                        j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, null, key.duration, key.nextData);
                                }
                                dataIndex++;
                            }
                            break;
                    }
                }
                else {
                    for (j = 0; j < node.keyframeWidth;)
                        j += node.interpolationMethod[j](node, j, originalData, outOfs + j, key.data, dt, null, key.duration, key.nextData);
                }
                outOfs += node.keyframeWidth;
            }
        };
        __proto.getNodesCurrentFrameIndex = function (aniIndex, playCurTime) {
            var ani = this._anis[aniIndex];
            var nodes = ani.nodes;
            if (aniIndex !== this.unfixedLastAniIndex) {
                this.unfixedCurrentFrameIndexes = new Uint32Array(nodes.length);
                this.unfixedCurrentTimes = new Float32Array(nodes.length);
                this.unfixedLastAniIndex = aniIndex;
            }
            for (var i = 0, n = nodes.length, outOfs = 0; i < n; i++) {
                var node = nodes[i];
                if (playCurTime < this.unfixedCurrentTimes[i])
                    this.unfixedCurrentFrameIndexes[i] = 0;
                this.unfixedCurrentTimes[i] = playCurTime;
                while ((this.unfixedCurrentFrameIndexes[i] < node.keyFrame.length)) {
                    if (node.keyFrame[this.unfixedCurrentFrameIndexes[i]].startTime > this.unfixedCurrentTimes[i])
                        break;
                    this.unfixedCurrentFrameIndexes[i]++;
                }
                this.unfixedCurrentFrameIndexes[i]--;
            }
            return this.unfixedCurrentFrameIndexes;
        };
        __proto.getOriginalDataUnfixedRate = function (aniIndex, originalData, playCurTime) {
            var oneAni = this._anis[aniIndex];
            var nodes = oneAni.nodes;
            if (aniIndex !== this.unfixedLastAniIndex) {
                this.unfixedCurrentFrameIndexes = new Uint32Array(nodes.length);
                this.unfixedCurrentTimes = new Float32Array(nodes.length);
                this.unfixedKeyframes = __newvec(nodes.length);
                this.unfixedLastAniIndex = aniIndex;
            }
            ;
            var j = 0;
            for (var i = 0, n = nodes.length, outOfs = 0; i < n; i++) {
                var node = nodes[i];
                if (playCurTime < this.unfixedCurrentTimes[i])
                    this.unfixedCurrentFrameIndexes[i] = 0;
                this.unfixedCurrentTimes[i] = playCurTime;
                while (this.unfixedCurrentFrameIndexes[i] < node.keyFrame.length) {
                    if (node.keyFrame[this.unfixedCurrentFrameIndexes[i]].startTime > this.unfixedCurrentTimes[i])
                        break;
                    this.unfixedKeyframes[i] = node.keyFrame[this.unfixedCurrentFrameIndexes[i]];
                    this.unfixedCurrentFrameIndexes[i]++;
                }
                ;
                var key = this.unfixedKeyframes[i];
                node.dataOffset = outOfs;
                var dt = playCurTime - key.startTime;
                var lerpType = node.lerpType;
                if (lerpType) {
                    switch (node.lerpType) {
                        case 0:
                        case 1:
                            for (j = 0; j < node.keyframeWidth;)
                                j += node.interpolationMethod[j](node, j, originalData, outOfs + j, key.data, dt, null, key.duration, key.nextData);
                            break;
                        case 2:
                            ;
                            var interpolationData = key.interpolationData;
                            var interDataLen = interpolationData.length;
                            var dataIndex = 0;
                            for (j = 0; j < interDataLen;) {
                                var type = interpolationData[j];
                                switch (type) {
                                    case 6:
                                        j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, null, key.duration, key.nextData, interpolationData, j + 1);
                                        break;
                                    case 7:
                                        j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, null, key.duration, key.nextData, interpolationData, j + 1);
                                        break;
                                    default:
                                        j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, null, key.duration, key.nextData);
                                }
                                dataIndex++;
                            }
                            break;
                    }
                }
                else {
                    for (j = 0; j < node.keyframeWidth;)
                        j += node.interpolationMethod[j](node, j, originalData, outOfs + j, key.data, dt, null, key.duration, key.nextData);
                }
                outOfs += node.keyframeWidth;
            }
        };
        AnimationTemplet._LinearInterpolation_0 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData) {
            var amount = duration === 0 ? 0 : dt / duration;
            out[outOfs] = (1.0 - amount) * data[index] + amount * nextData[index];
            return 1;
        };
        AnimationTemplet._QuaternionInterpolation_1 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData) {
            var amount = duration === 0 ? 0 : dt / duration;
            MathUtil.slerpQuaternionArray(data, index, nextData, index, amount, out, outOfs);
            return 4;
        };
        AnimationTemplet._AngleInterpolation_2 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData) {
            return 0;
        };
        AnimationTemplet._RadiansInterpolation_3 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData) {
            return 0;
        };
        AnimationTemplet._Matrix4x4Interpolation_4 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData) {
            for (var i = 0; i < 16; i++, index++)
                out[outOfs + i] = data[index] + dt * dData[index];
            return 16;
        };
        AnimationTemplet._NoInterpolation_5 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData) {
            out[outOfs] = data[index];
            return 1;
        };
        AnimationTemplet._BezierInterpolation_6 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData, offset) {
            (offset === void 0) && (offset = 0);
            out[outOfs] = data[index] + (nextData[index] - data[index]) * BezierLerp.getBezierRate(dt / duration, interData[offset], interData[offset + 1], interData[offset + 2], interData[offset + 3]);
            return 5;
        };
        AnimationTemplet._BezierInterpolation_7 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData, offset) {
            (offset === void 0) && (offset = 0);
            out[outOfs] = interData[offset + 4] + interData[offset + 5] * BezierLerp.getBezierRate((dt * 0.001 + interData[offset + 6]) / interData[offset + 7], interData[offset], interData[offset + 1], interData[offset + 2], interData[offset + 3]);
            return 9;
        };
        AnimationTemplet.load = function (url) {
            return Laya.loader.create(url, null, null, AnimationTemplet);
        };
        AnimationTemplet.interpolation = [AnimationTemplet._LinearInterpolation_0, AnimationTemplet._QuaternionInterpolation_1, AnimationTemplet._AngleInterpolation_2, AnimationTemplet._RadiansInterpolation_3, AnimationTemplet._Matrix4x4Interpolation_4, AnimationTemplet._NoInterpolation_5, AnimationTemplet._BezierInterpolation_6, AnimationTemplet._BezierInterpolation_7];
        return AnimationTemplet;
    })(Resource);
    var CacheAbleSkinMesh = (function (_super) {
        function CacheAbleSkinMesh() {
            this.isCached = false;
            this.canvas = null;
            this.tex = null;
            this.rec = null;
            CacheAbleSkinMesh.__super.call(this);
        }
        __class(CacheAbleSkinMesh, 'laya.ani.bone.canvasmesh.CacheAbleSkinMesh', _super);
        var __proto = CacheAbleSkinMesh.prototype;
        __proto.getCanvasPic = function () {
            var canvas = new HTMLCanvas("2D");
            var ctx = canvas.getContext('2d');
            this.rec = this.mesh.getBounds();
            canvas.size(this.rec.width, this.rec.height);
            var preTransform;
            preTransform = this.transform;
            this.transform = CacheAbleSkinMesh.tempMt;
            this.transform.identity();
            this.transform.translate(-this.rec.x, -this.rec.y);
            this.renderToContext(ctx);
            this.transform.translate(+this.rec.x, +this.rec.y);
            this.transform = preTransform;
            return new Texture(canvas);
        };
        __proto.render = function (context, x, y) {
            if (!this.mesh.texture)
                return;
            if (!this.isCached) {
                this.isCached = true;
                this.tex = this.getCanvasPic();
            }
            if (!this.transform) {
                this.transform = SkinMeshCanvas._tempMatrix;
                this.transform.identity();
                this.transform.translate(x, y);
                this._renderTextureToContext(context);
                this.transform.translate(-x, -y);
                this.transform = null;
            }
            else {
                this.transform.translate(x, y);
                this._renderTextureToContext(context);
                this.transform.translate(-x, -y);
            }
        };
        __proto._renderTextureToContext = function (context) {
            this.context = context.ctx || context;
            context.save();
            var texture;
            texture = this.tex;
            if (this.transform) {
                var mt = this.transform;
                context.transform(mt.a, mt.b, mt.c, mt.d, mt.tx, mt.ty);
            }
            this.rec = this.mesh.getBounds();
            context.translate(this.rec.x, this.rec.y);
            context.drawTexture(texture, 0, 0, texture.width, texture.height, 0, 0);
            context.restore();
        };
        __static(CacheAbleSkinMesh, ['tempMt', function () { return this.tempMt = new Matrix(); }
        ]);
        return CacheAbleSkinMesh;
    })(SkinMeshCanvas);
    var SimpleSkinMeshCanvas = (function (_super) {
        function SimpleSkinMeshCanvas() {
            this.cacheOK = false;
            this.cacheCmdOK = false;
            this.transformCmds = [];
            this.drawCmds = [];
            SimpleSkinMeshCanvas.__super.call(this);
            this.tempMesh = new MeshData();
        }
        __class(SimpleSkinMeshCanvas, 'laya.ani.bone.canvasmesh.SimpleSkinMeshCanvas', _super);
        var __proto = SimpleSkinMeshCanvas.prototype;
        __proto.init2 = function (texture, vs, ps, verticles, uvs) {
            _super.prototype.init2.call(this, texture, vs, ps, verticles, uvs);
            this.cacheOK = false;
            this.cacheCmdOK = false;
            this.transformCmds.length = 6;
            this.drawCmds.length = 9;
        };
        __proto.renderToContext = function (context) {
            this.context = context.ctx || context;
            if (this.mesh) {
                if (this.mesh.uvs.length <= 8) {
                    if (this.mode == 0) {
                        this._renderWithIndexes(this.mesh);
                    }
                    else {
                        this._renderNoIndexes(this.mesh);
                    }
                    return;
                }
                if (!this.cacheOK) {
                    this.tempMesh.texture = this.mesh.texture;
                    this.tempMesh.uvs = this.mesh.texture.uv;
                    this.tempMesh.vertices = MeshTools.solveMesh(this.mesh, this.tempMesh.vertices);
                    this.cacheOK = true;
                }
                if (this.mode == 0) {
                    this._renderWithIndexes(this.tempMesh);
                }
                else {
                    this._renderNoIndexes(this.tempMesh);
                }
            }
        };
        __proto._renderWithIndexes = function (mesh) {
            if (this.cacheCmdOK) {
                this.renderByCache(mesh);
                return;
            }
            ;
            var indexes = mesh.indexes;
            var i = 0, len = indexes.length;
            if (len > 1)
                len = 1;
            for (i = 0; i < len; i += 3) {
                var index0 = indexes[i] * 2;
                var index1 = indexes[i + 1] * 2;
                var index2 = indexes[i + 2] * 2;
                this._renderDrawTriangle(mesh, index0, index1, index2);
            }
            this.cacheCmdOK = true;
        };
        __proto._renderDrawTriangle = function (mesh, index0, index1, index2) {
            var context = this.context;
            var uvs = mesh.uvs;
            var vertices = mesh.vertices;
            var texture = mesh.texture;
            var source = texture.bitmap;
            var textureSource = source.source;
            var textureWidth = texture.width;
            var textureHeight = texture.height;
            var sourceWidth = source.width;
            var sourceHeight = source.height;
            var u0 = NaN;
            var u1 = NaN;
            var u2 = NaN;
            var v0 = NaN;
            var v1 = NaN;
            var v2 = NaN;
            if (mesh.useUvTransform) {
                var ut = mesh.uvTransform;
                u0 = ((uvs[index0] * ut.a) + (uvs[index0 + 1] * ut.c) + ut.tx) * sourceWidth;
                u1 = ((uvs[index1] * ut.a) + (uvs[index1 + 1] * ut.c) + ut.tx) * sourceWidth;
                u2 = ((uvs[index2] * ut.a) + (uvs[index2 + 1] * ut.c) + ut.tx) * sourceWidth;
                v0 = ((uvs[index0] * ut.b) + (uvs[index0 + 1] * ut.d) + ut.ty) * sourceHeight;
                v1 = ((uvs[index1] * ut.b) + (uvs[index1 + 1] * ut.d) + ut.ty) * sourceHeight;
                v2 = ((uvs[index2] * ut.b) + (uvs[index2 + 1] * ut.d) + ut.ty) * sourceHeight;
            }
            else {
                u0 = uvs[index0] * sourceWidth;
                u1 = uvs[index1] * sourceWidth;
                u2 = uvs[index2] * sourceWidth;
                v0 = uvs[index0 + 1] * sourceHeight;
                v1 = uvs[index1 + 1] * sourceHeight;
                v2 = uvs[index2 + 1] * sourceHeight;
            }
            ;
            var x0 = vertices[index0];
            var x1 = vertices[index1];
            var x2 = vertices[index2];
            var y0 = vertices[index0 + 1];
            var y1 = vertices[index1 + 1];
            var y2 = vertices[index2 + 1];
            var delta = (u0 * v1) + (v0 * u2) + (u1 * v2) - (v1 * u2) - (v0 * u1) - (u0 * v2);
            var dDelta = 1 / delta;
            var deltaA = (x0 * v1) + (v0 * x2) + (x1 * v2) - (v1 * x2) - (v0 * x1) - (x0 * v2);
            var deltaB = (u0 * x1) + (x0 * u2) + (u1 * x2) - (x1 * u2) - (x0 * u1) - (u0 * x2);
            var deltaC = (u0 * v1 * x2) + (v0 * x1 * u2) + (x0 * u1 * v2) - (x0 * v1 * u2) - (v0 * u1 * x2) - (u0 * x1 * v2);
            var deltaD = (y0 * v1) + (v0 * y2) + (y1 * v2) - (v1 * y2) - (v0 * y1) - (y0 * v2);
            var deltaE = (u0 * y1) + (y0 * u2) + (u1 * y2) - (y1 * u2) - (y0 * u1) - (u0 * y2);
            var deltaF = (u0 * v1 * y2) + (v0 * y1 * u2) + (y0 * u1 * v2) - (y0 * v1 * u2) - (v0 * u1 * y2) - (u0 * y1 * v2);
            this.transformCmds[0] = deltaA * dDelta;
            this.transformCmds[1] = deltaD * dDelta;
            this.transformCmds[2] = deltaB * dDelta;
            this.transformCmds[3] = deltaE * dDelta;
            this.transformCmds[4] = deltaC * dDelta;
            this.transformCmds[5] = deltaF * dDelta;
            this.drawCmds[0] = textureSource;
            this.drawCmds[1] = texture.uv[0] * sourceWidth;
            this.drawCmds[2] = texture.uv[1] * sourceHeight;
            this.drawCmds[3] = textureWidth;
            this.drawCmds[4] = textureHeight;
            this.drawCmds[5] = texture.uv[0] * sourceWidth;
            this.drawCmds[6] = texture.uv[1] * sourceHeight;
            this.drawCmds[7] = textureWidth;
            this.drawCmds[8] = textureHeight;
            context.save();
            if (this.transform) {
                var mt = this.transform;
                context.transform(mt.a, mt.b, mt.c, mt.d, mt.tx, mt.ty);
            }
            context.transform.apply(context, this.transformCmds);
            context.drawImage.apply(context, this.drawCmds);
            context.restore();
        };
        __proto.renderByCache = function (mesh) {
            var context = this.context;
            context.save();
            if (this.transform) {
                var mt = this.transform;
                context.transform(mt.a, mt.b, mt.c, mt.d, mt.tx, mt.ty);
            }
            context.transform.apply(context, this.transformCmds);
            context.drawImage.apply(context, this.drawCmds);
            context.restore();
        };
        return SimpleSkinMeshCanvas;
    })(SkinMeshCanvas);
    var Skeleton = (function (_super) {
        function Skeleton(templet, aniMode) {
            this._templet = null;
            this._player = null;
            this._curOriginalData = null;
            this._boneMatrixArray = [];
            this._lastTime = 0;
            this._currAniName = null;
            this._currAniIndex = -1;
            this._pause = true;
            this._aniClipIndex = -1;
            this._clipIndex = -1;
            this._skinIndex = 0;
            this._skinName = "default";
            this._aniMode = 0;
            this._graphicsCache = null;
            this._boneSlotDic = null;
            this._bindBoneBoneSlotDic = null;
            this._boneSlotArray = null;
            this._index = -1;
            this._total = -1;
            this._indexControl = false;
            this._aniPath = null;
            this._texturePath = null;
            this._complete = null;
            this._loadAniMode = 0;
            this._yReverseMatrix = null;
            this._ikArr = null;
            this._tfArr = null;
            this._pathDic = null;
            this._rootBone = null;
            this._boneList = null;
            this._aniSectionDic = null;
            this._eventIndex = 0;
            this._drawOrderIndex = 0;
            this._drawOrder = null;
            this._lastAniClipIndex = -1;
            this._lastUpdateAniClipIndex = -1;
            Skeleton.__super.call(this);
            (aniMode === void 0) && (aniMode = 0);
            if (templet)
                this.init(templet, aniMode);
        }
        __class(Skeleton, 'laya.ani.bone.Skeleton', _super);
        var __proto = Skeleton.prototype;
        __proto.init = function (templet, aniMode) {
            (aniMode === void 0) && (aniMode = 0);
            var i = 0, n = 0;
            if (aniMode == 1) {
                this._graphicsCache = [];
                for (i = 0, n = templet.getAnimationCount(); i < n; i++) {
                    this._graphicsCache.push([]);
                }
            }
            this._yReverseMatrix = templet.yReverseMatrix;
            this._aniMode = aniMode;
            this._templet = templet;
            this._player = new AnimationPlayer();
            this._player.cacheFrameRate = templet.rate;
            this._player.templet = templet;
            this._player.play();
            this._parseSrcBoneMatrix();
            this._boneList = templet.mBoneArr;
            this._rootBone = templet.mRootBone;
            this._aniSectionDic = templet.aniSectionDic;
            if (templet.ikArr.length > 0) {
                this._ikArr = [];
                for (i = 0, n = templet.ikArr.length; i < n; i++) {
                    this._ikArr.push(new IkConstraint(templet.ikArr[i], this._boneList));
                }
            }
            if (templet.pathArr.length > 0) {
                var tPathData;
                var tPathConstraint;
                if (this._pathDic == null)
                    this._pathDic = {};
                var tBoneSlot;
                for (i = 0, n = templet.pathArr.length; i < n; i++) {
                    tPathData = templet.pathArr[i];
                    tPathConstraint = new PathConstraint(tPathData, this._boneList);
                    tBoneSlot = this._boneSlotDic[tPathData.name];
                    if (tBoneSlot) {
                        tPathConstraint = new PathConstraint(tPathData, this._boneList);
                        tPathConstraint.target = tBoneSlot;
                    }
                    this._pathDic[tPathData.name] = tPathConstraint;
                }
            }
            if (templet.tfArr.length > 0) {
                this._tfArr = [];
                for (i = 0, n = templet.tfArr.length; i < n; i++) {
                    this._tfArr.push(new TfConstraint(templet.tfArr[i], this._boneList));
                }
            }
            if (templet.skinDataArray.length > 0) {
                var tSkinData = this._templet.skinDataArray[this._skinIndex];
                this._skinName = tSkinData.name;
            }
            this._player.on("played", this, this._onPlay);
            this._player.on("stopped", this, this._onStop);
            this._player.on("paused", this, this._onPause);
        };
        __proto.load = function (path, complete, aniMode) {
            (aniMode === void 0) && (aniMode = 0);
            this._aniPath = path;
            this._complete = complete;
            this._loadAniMode = aniMode;
            Laya.loader.load([{ url: path, type: "arraybuffer" }], Handler.create(this, this._onLoaded));
        };
        __proto._onLoaded = function () {
            var arraybuffer = Loader.getRes(this._aniPath);
            if (arraybuffer == null)
                return;
            if (Templet.TEMPLET_DICTIONARY == null) {
                Templet.TEMPLET_DICTIONARY = {};
            }
            ;
            var tFactory;
            tFactory = Templet.TEMPLET_DICTIONARY[this._aniPath];
            if (tFactory) {
                if (tFactory.isParseFail) {
                    this._parseFail();
                }
                else {
                    if (tFactory.isParserComplete) {
                        this._parseComplete();
                    }
                    else {
                        tFactory.on("complete", this, this._parseComplete);
                        tFactory.on("error", this, this._parseFail);
                    }
                }
            }
            else {
                tFactory = new Templet();
                tFactory._setUrl(this._aniPath);
                Templet.TEMPLET_DICTIONARY[this._aniPath] = tFactory;
                tFactory.on("complete", this, this._parseComplete);
                tFactory.on("error", this, this._parseFail);
                tFactory.isParserComplete = false;
                tFactory.parseData(null, arraybuffer);
            }
        };
        __proto._parseComplete = function () {
            var tTemple = Templet.TEMPLET_DICTIONARY[this._aniPath];
            if (tTemple) {
                this.init(tTemple, this._loadAniMode);
                this.play(0, true);
            }
            this._complete && this._complete.runWith(this);
        };
        __proto._parseFail = function () {
            console_log("[Error]:" + this._aniPath + "解析失败");
        };
        __proto._onPlay = function () {
            this.event("played");
        };
        __proto._onStop = function () {
            var tEventData;
            var tEventAniArr = this._templet.eventAniArr;
            var tEventArr = tEventAniArr[this._aniClipIndex];
            if (tEventArr && this._eventIndex < tEventArr.length) {
                for (; this._eventIndex < tEventArr.length; this._eventIndex++) {
                    tEventData = tEventArr[this._eventIndex];
                    if (tEventData.time >= this._player.playStart && tEventData.time <= this._player.playEnd) {
                        this.event("label", tEventData);
                    }
                }
            }
            this._eventIndex = 0;
            this._drawOrder = null;
            this.event("stopped");
        };
        __proto._onPause = function () {
            this.event("paused");
        };
        __proto._parseSrcBoneMatrix = function () {
            var i = 0, n = 0;
            n = this._templet.srcBoneMatrixArr.length;
            for (i = 0; i < n; i++) {
                this._boneMatrixArray.push(new Matrix());
            }
            if (this._aniMode == 0) {
                this._boneSlotDic = this._templet.boneSlotDic;
                this._bindBoneBoneSlotDic = this._templet.bindBoneBoneSlotDic;
                this._boneSlotArray = this._templet.boneSlotArray;
            }
            else {
                if (this._boneSlotDic == null)
                    this._boneSlotDic = {};
                if (this._bindBoneBoneSlotDic == null)
                    this._bindBoneBoneSlotDic = {};
                if (this._boneSlotArray == null)
                    this._boneSlotArray = [];
                var tArr = this._templet.boneSlotArray;
                var tBS;
                var tBSArr;
                for (i = 0, n = tArr.length; i < n; i++) {
                    tBS = tArr[i];
                    tBSArr = this._bindBoneBoneSlotDic[tBS.parent];
                    if (tBSArr == null) {
                        this._bindBoneBoneSlotDic[tBS.parent] = tBSArr = [];
                    }
                    this._boneSlotDic[tBS.name] = tBS = tBS.copy();
                    tBSArr.push(tBS);
                    this._boneSlotArray.push(tBS);
                }
            }
        };
        __proto._emitMissedEvents = function (startTime, endTime, startIndex) {
            (startIndex === void 0) && (startIndex = 0);
            var tEventAniArr = this._templet.eventAniArr;
            var tEventArr = tEventAniArr[this._player.currentAnimationClipIndex];
            if (tEventArr) {
                var i = 0, len = 0;
                var tEventData;
                len = tEventArr.length;
                for (i = startIndex; i < len; i++) {
                    tEventData = tEventArr[i];
                    if (tEventData.time >= this._player.playStart && tEventData.time <= this._player.playEnd) {
                        this.event("label", tEventData);
                    }
                }
            }
        };
        __proto._update = function (autoKey) {
            (autoKey === void 0) && (autoKey = true);
            if (this._pause)
                return;
            if (autoKey && this._indexControl) {
                return;
            }
            ;
            var tCurrTime = this.timer.currTimer;
            var preIndex = this._player.currentKeyframeIndex;
            var dTime = tCurrTime - this._lastTime;
            if (autoKey) {
                this._player._update(dTime);
            }
            else {
                preIndex = -1;
            }
            this._lastTime = tCurrTime;
            if (!this._player)
                return;
            this._index = this._clipIndex = this._player.currentKeyframeIndex;
            if (this._index < 0)
                return;
            if (dTime > 0 && this._clipIndex == preIndex && this._lastUpdateAniClipIndex == this._aniClipIndex) {
                return;
            }
            this._lastUpdateAniClipIndex = this._aniClipIndex;
            if (preIndex > this._clipIndex && this._eventIndex != 0) {
                this._emitMissedEvents(this._player.playStart, this._player.playEnd, this._eventIndex);
                this._eventIndex = 0;
            }
            ;
            var tEventData;
            var tEventAniArr = this._templet.eventAniArr;
            var tEventArr = tEventAniArr[this._aniClipIndex];
            if (tEventArr && this._eventIndex < tEventArr.length) {
                tEventData = tEventArr[this._eventIndex];
                if (tEventData.time >= this._player.playStart && tEventData.time <= this._player.playEnd) {
                    if (this._player.currentPlayTime >= tEventData.time) {
                        this.event("label", tEventData);
                        this._eventIndex++;
                    }
                }
                else {
                    this._eventIndex++;
                }
            }
            ;
            var tGraphics;
            if (this._aniMode == 0) {
                tGraphics = this._templet.getGrahicsDataWithCache(this._aniClipIndex, this._clipIndex);
                if (tGraphics) {
                    if (this.graphics != tGraphics) {
                        this.graphics = tGraphics;
                    }
                    return;
                }
                else {
                    var i = 0, minIndex = 0;
                    minIndex = this._clipIndex;
                    while ((!this._templet.getGrahicsDataWithCache(this._aniClipIndex, minIndex - 1)) && (minIndex > 0)) {
                        minIndex--;
                    }
                    if (minIndex < this._clipIndex) {
                        for (i = minIndex; i < this._clipIndex; i++) {
                            this._createGraphics(i);
                        }
                    }
                }
            }
            else if (this._aniMode == 1) {
                tGraphics = this._getGrahicsDataWithCache(this._aniClipIndex, this._clipIndex);
                if (tGraphics) {
                    if (this.graphics != tGraphics) {
                        this.graphics = tGraphics;
                    }
                    return;
                }
                else {
                    minIndex = this._clipIndex;
                    while ((!this._getGrahicsDataWithCache(this._aniClipIndex, minIndex - 1)) && (minIndex > 0)) {
                        minIndex--;
                    }
                    if (minIndex < this._clipIndex) {
                        for (i = minIndex; i < this._clipIndex; i++) {
                            this._createGraphics(i);
                        }
                    }
                }
            }
            this._createGraphics();
        };
        __proto._createGraphics = function (_clipIndex) {
            (_clipIndex === void 0) && (_clipIndex = -1);
            if (_clipIndex == -1)
                _clipIndex = this._clipIndex;
            var curTime = _clipIndex * this._player.cacheFrameRateInterval;
            var tDrawOrderData;
            var tDrawOrderAniArr = this._templet.drawOrderAniArr;
            var tDrawOrderArr = tDrawOrderAniArr[this._aniClipIndex];
            if (tDrawOrderArr && tDrawOrderArr.length > 0) {
                this._drawOrderIndex = 0;
                tDrawOrderData = tDrawOrderArr[this._drawOrderIndex];
                while (curTime >= tDrawOrderData.time) {
                    this._drawOrder = tDrawOrderData.drawOrder;
                    this._drawOrderIndex++;
                    if (this._drawOrderIndex >= tDrawOrderArr.length) {
                        break;
                    }
                    tDrawOrderData = tDrawOrderArr[this._drawOrderIndex];
                }
            }
            ;
            var tGraphics;
            if (this._aniMode == 0 || this._aniMode == 1) {
                this.graphics = new GraphicsAni();
            }
            else {
                if ((this.graphics instanceof laya.ani.GraphicsAni)) {
                    this.graphics.clear();
                }
                else {
                    this.graphics = new GraphicsAni();
                }
            }
            tGraphics = this.graphics;
            var bones = this._templet.getNodes(this._aniClipIndex);
            this._templet.getOriginalData(this._aniClipIndex, this._curOriginalData, this._player._fullFrames[this._aniClipIndex], _clipIndex, curTime);
            var tSectionArr = this._aniSectionDic[this._aniClipIndex];
            var tParentMatrix;
            var tStartIndex = 0;
            var i = 0, j = 0, k = 0, n = 0;
            var tDBBoneSlot;
            var tDBBoneSlotArr;
            var tParentTransform;
            var tSrcBone;
            var boneCount = this._templet.srcBoneMatrixArr.length;
            for (i = 0, n = tSectionArr[0]; i < boneCount; i++) {
                tSrcBone = this._boneList[i];
                tParentTransform = this._templet.srcBoneMatrixArr[i];
                tSrcBone.resultTransform.scX = tParentTransform.scX * this._curOriginalData[tStartIndex++];
                tSrcBone.resultTransform.skX = tParentTransform.skX + this._curOriginalData[tStartIndex++];
                tSrcBone.resultTransform.skY = tParentTransform.skY + this._curOriginalData[tStartIndex++];
                tSrcBone.resultTransform.scY = tParentTransform.scY * this._curOriginalData[tStartIndex++];
                tSrcBone.resultTransform.x = tParentTransform.x + this._curOriginalData[tStartIndex++];
                tSrcBone.resultTransform.y = tParentTransform.y + this._curOriginalData[tStartIndex++];
                if (this._templet.tMatrixDataLen === 8) {
                    tSrcBone.resultTransform.skewX = tParentTransform.skewX + this._curOriginalData[tStartIndex++];
                    tSrcBone.resultTransform.skewY = tParentTransform.skewY + this._curOriginalData[tStartIndex++];
                }
            }
            ;
            var tSlotDic = {};
            var tSlotAlphaDic = {};
            var tBoneData;
            for (n += tSectionArr[1]; i < n; i++) {
                tBoneData = bones[i];
                tSlotDic[tBoneData.name] = this._curOriginalData[tStartIndex++];
                tSlotAlphaDic[tBoneData.name] = this._curOriginalData[tStartIndex++];
                this._curOriginalData[tStartIndex++];
                this._curOriginalData[tStartIndex++];
                this._curOriginalData[tStartIndex++];
                this._curOriginalData[tStartIndex++];
            }
            ;
            var tBendDirectionDic = {};
            var tMixDic = {};
            for (n += tSectionArr[2]; i < n; i++) {
                tBoneData = bones[i];
                tBendDirectionDic[tBoneData.name] = this._curOriginalData[tStartIndex++];
                tMixDic[tBoneData.name] = this._curOriginalData[tStartIndex++];
                this._curOriginalData[tStartIndex++];
                this._curOriginalData[tStartIndex++];
                this._curOriginalData[tStartIndex++];
                this._curOriginalData[tStartIndex++];
            }
            if (this._pathDic) {
                var tPathConstraint;
                for (n += tSectionArr[3]; i < n; i++) {
                    tBoneData = bones[i];
                    tPathConstraint = this._pathDic[tBoneData.name];
                    if (tPathConstraint) {
                        var tByte = new Byte(tBoneData.extenData);
                        switch (tByte.getByte()) {
                            case 1:
                                tPathConstraint.position = this._curOriginalData[tStartIndex++];
                                break;
                            case 2:
                                tPathConstraint.spacing = this._curOriginalData[tStartIndex++];
                                break;
                            case 3:
                                tPathConstraint.rotateMix = this._curOriginalData[tStartIndex++];
                                tPathConstraint.translateMix = this._curOriginalData[tStartIndex++];
                                break;
                        }
                    }
                }
            }
            if (this._yReverseMatrix) {
                this._rootBone.update(this._yReverseMatrix);
            }
            else {
                this._rootBone.update(Matrix.TEMP.identity());
            }
            if (this._ikArr) {
                var tIkConstraint;
                for (i = 0, n = this._ikArr.length; i < n; i++) {
                    tIkConstraint = this._ikArr[i];
                    if (tBendDirectionDic.hasOwnProperty(tIkConstraint.name)) {
                        tIkConstraint.bendDirection = tBendDirectionDic[tIkConstraint.name];
                    }
                    if (tMixDic.hasOwnProperty(tIkConstraint.name)) {
                        tIkConstraint.mix = tMixDic[tIkConstraint.name];
                    }
                    tIkConstraint.apply();
                }
            }
            if (this._pathDic) {
                for (var tPathStr in this._pathDic) {
                    tPathConstraint = this._pathDic[tPathStr];
                    tPathConstraint.apply(this._boneList, tGraphics);
                }
            }
            if (this._tfArr) {
                var tTfConstraint;
                for (i = 0, k = this._tfArr.length; i < k; i++) {
                    tTfConstraint = this._tfArr[i];
                    tTfConstraint.apply();
                }
            }
            for (i = 0, k = this._boneList.length; i < k; i++) {
                tSrcBone = this._boneList[i];
                tDBBoneSlotArr = this._bindBoneBoneSlotDic[tSrcBone.name];
                tSrcBone.resultMatrix.copyTo(this._boneMatrixArray[i]);
                if (tDBBoneSlotArr) {
                    for (j = 0, n = tDBBoneSlotArr.length; j < n; j++) {
                        tDBBoneSlot = tDBBoneSlotArr[j];
                        if (tDBBoneSlot) {
                            tDBBoneSlot.setParentMatrix(tSrcBone.resultMatrix);
                        }
                    }
                }
            }
            ;
            var tDeformDic = {};
            var tDeformAniArr = this._templet.deformAniArr;
            var tDeformAniData;
            var tDeformSlotData;
            var tDeformSlotDisplayData;
            if (tDeformAniArr && tDeformAniArr.length > 0) {
                if (this._lastAniClipIndex != this._aniClipIndex) {
                    this._lastAniClipIndex = this._aniClipIndex;
                    for (i = 0, n = this._boneSlotArray.length; i < n; i++) {
                        tDBBoneSlot = this._boneSlotArray[i];
                        tDBBoneSlot.deformData = null;
                    }
                }
                ;
                var tSkinDeformAni = tDeformAniArr[this._aniClipIndex];
                tDeformAniData = (tSkinDeformAni["default"]);
                this._setDeform(tDeformAniData, tDeformDic, this._boneSlotArray, curTime);
                var tSkin;
                for (tSkin in tSkinDeformAni) {
                    if (tSkin != "default" && tSkin != this._skinName) {
                        tDeformAniData = tSkinDeformAni[tSkin];
                        this._setDeform(tDeformAniData, tDeformDic, this._boneSlotArray, curTime);
                    }
                }
                tDeformAniData = (tSkinDeformAni[this._skinName]);
                this._setDeform(tDeformAniData, tDeformDic, this._boneSlotArray, curTime);
            }
            ;
            var tSlotData2;
            var tSlotData3;
            var tObject;
            if (this._drawOrder) {
                for (i = 0, n = this._drawOrder.length; i < n; i++) {
                    tDBBoneSlot = this._boneSlotArray[this._drawOrder[i]];
                    tSlotData2 = tSlotDic[tDBBoneSlot.name];
                    tSlotData3 = tSlotAlphaDic[tDBBoneSlot.name];
                    if (!isNaN(tSlotData3)) {
                        tGraphics.save();
                        tGraphics.alpha(tSlotData3);
                    }
                    if (!isNaN(tSlotData2) && tSlotData2 != -2) {
                        if (this._templet.attachmentNames) {
                            tDBBoneSlot.showDisplayByName(this._templet.attachmentNames[tSlotData2]);
                        }
                        else {
                            tDBBoneSlot.showDisplayByIndex(tSlotData2);
                        }
                    }
                    if (tDeformDic[this._drawOrder[i]]) {
                        tObject = tDeformDic[this._drawOrder[i]];
                        if (tDBBoneSlot.currDisplayData && tObject[tDBBoneSlot.currDisplayData.attachmentName]) {
                            tDBBoneSlot.deformData = tObject[tDBBoneSlot.currDisplayData.attachmentName];
                        }
                        else {
                            tDBBoneSlot.deformData = null;
                        }
                    }
                    else {
                        tDBBoneSlot.deformData = null;
                    }
                    if (!isNaN(tSlotData3)) {
                        tDBBoneSlot.draw(tGraphics, this._boneMatrixArray, this._aniMode == 2, tSlotData3);
                    }
                    else {
                        tDBBoneSlot.draw(tGraphics, this._boneMatrixArray, this._aniMode == 2);
                    }
                    if (!isNaN(tSlotData3)) {
                        tGraphics.restore();
                    }
                }
            }
            else {
                for (i = 0, n = this._boneSlotArray.length; i < n; i++) {
                    tDBBoneSlot = this._boneSlotArray[i];
                    tSlotData2 = tSlotDic[tDBBoneSlot.name];
                    tSlotData3 = tSlotAlphaDic[tDBBoneSlot.name];
                    if (!isNaN(tSlotData3)) {
                        tGraphics.save();
                        tGraphics.alpha(tSlotData3);
                    }
                    if (!isNaN(tSlotData2) && tSlotData2 != -2) {
                        if (this._templet.attachmentNames) {
                            tDBBoneSlot.showDisplayByName(this._templet.attachmentNames[tSlotData2]);
                        }
                        else {
                            tDBBoneSlot.showDisplayByIndex(tSlotData2);
                        }
                    }
                    if (tDeformDic[i]) {
                        tObject = tDeformDic[i];
                        if (tDBBoneSlot.currDisplayData && tObject[tDBBoneSlot.currDisplayData.attachmentName]) {
                            tDBBoneSlot.deformData = tObject[tDBBoneSlot.currDisplayData.attachmentName];
                        }
                        else {
                            tDBBoneSlot.deformData = null;
                        }
                    }
                    else {
                        tDBBoneSlot.deformData = null;
                    }
                    if (!isNaN(tSlotData3)) {
                        tDBBoneSlot.draw(tGraphics, this._boneMatrixArray, this._aniMode == 2, tSlotData3);
                    }
                    else {
                        tDBBoneSlot.draw(tGraphics, this._boneMatrixArray, this._aniMode == 2);
                    }
                    if (!isNaN(tSlotData3)) {
                        tGraphics.restore();
                    }
                }
            }
            if (this._aniMode == 0) {
                this._templet.setGrahicsDataWithCache(this._aniClipIndex, _clipIndex, tGraphics);
            }
            else if (this._aniMode == 1) {
                this._setGrahicsDataWithCache(this._aniClipIndex, _clipIndex, tGraphics);
            }
        };
        __proto._setDeform = function (tDeformAniData, tDeformDic, _boneSlotArray, curTime) {
            if (!tDeformAniData)
                return;
            var tDeformSlotData;
            var tDeformSlotDisplayData;
            var tDBBoneSlot;
            var i = 0, n = 0, j = 0;
            if (tDeformAniData) {
                for (i = 0, n = tDeformAniData.deformSlotDataList.length; i < n; i++) {
                    tDeformSlotData = tDeformAniData.deformSlotDataList[i];
                    for (j = 0; j < tDeformSlotData.deformSlotDisplayList.length; j++) {
                        tDeformSlotDisplayData = tDeformSlotData.deformSlotDisplayList[j];
                        tDBBoneSlot = _boneSlotArray[tDeformSlotDisplayData.slotIndex];
                        tDeformSlotDisplayData.apply(curTime, tDBBoneSlot);
                        if (!tDeformDic[tDeformSlotDisplayData.slotIndex]) {
                            tDeformDic[tDeformSlotDisplayData.slotIndex] = {};
                        }
                        tDeformDic[tDeformSlotDisplayData.slotIndex][tDeformSlotDisplayData.attachment] = tDeformSlotDisplayData.deformData;
                    }
                }
            }
        };
        __proto.getAnimNum = function () {
            return this._templet.getAnimationCount();
        };
        __proto.getAniNameByIndex = function (index) {
            return this._templet.getAniNameByIndex(index);
        };
        __proto.getSlotByName = function (name) {
            return this._boneSlotDic[name];
        };
        __proto.showSkinByName = function (name, freshSlotIndex) {
            (freshSlotIndex === void 0) && (freshSlotIndex = true);
            this.showSkinByIndex(this._templet.getSkinIndexByName(name), freshSlotIndex);
        };
        __proto.showSkinByIndex = function (skinIndex, freshSlotIndex) {
            (freshSlotIndex === void 0) && (freshSlotIndex = true);
            for (var i = 0; i < this._boneSlotArray.length; i++) {
                (this._boneSlotArray[i]).showSlotData(null, freshSlotIndex);
            }
            if (this._templet.showSkinByIndex(this._boneSlotDic, skinIndex, freshSlotIndex)) {
                var tSkinData = this._templet.skinDataArray[skinIndex];
                this._skinIndex = skinIndex;
                this._skinName = tSkinData.name;
            }
            this._clearCache();
        };
        __proto.showSlotSkinByIndex = function (slotName, index) {
            if (this._aniMode == 0)
                return;
            var tBoneSlot = this.getSlotByName(slotName);
            if (tBoneSlot) {
                tBoneSlot.showDisplayByIndex(index);
            }
            this._clearCache();
        };
        __proto.showSlotSkinByName = function (slotName, name) {
            if (this._aniMode == 0)
                return;
            var tBoneSlot = this.getSlotByName(slotName);
            if (tBoneSlot) {
                tBoneSlot.showDisplayByName(name);
            }
            this._clearCache();
        };
        __proto.replaceSlotSkinName = function (slotName, oldName, newName) {
            if (this._aniMode == 0)
                return;
            var tBoneSlot = this.getSlotByName(slotName);
            if (tBoneSlot) {
                tBoneSlot.replaceDisplayByName(oldName, newName);
            }
            this._clearCache();
        };
        __proto.replaceSlotSkinByIndex = function (slotName, oldIndex, newIndex) {
            if (this._aniMode == 0)
                return;
            var tBoneSlot = this.getSlotByName(slotName);
            if (tBoneSlot) {
                tBoneSlot.replaceDisplayByIndex(oldIndex, newIndex);
            }
            this._clearCache();
        };
        __proto.setSlotSkin = function (slotName, texture) {
            if (this._aniMode == 0)
                return;
            var tBoneSlot = this.getSlotByName(slotName);
            if (tBoneSlot) {
                tBoneSlot.replaceSkin(texture);
            }
            this._clearCache();
        };
        __proto._clearCache = function () {
            if (this._aniMode == 1) {
                for (var i = 0, n = this._graphicsCache.length; i < n; i++) {
                    this._graphicsCache[i].length = 0;
                }
            }
        };
        __proto.play = function (nameOrIndex, loop, force, start, end, freshSkin) {
            (force === void 0) && (force = true);
            (start === void 0) && (start = 0);
            (end === void 0) && (end = 0);
            (freshSkin === void 0) && (freshSkin = true);
            this._indexControl = false;
            var index = -1;
            var duration = NaN;
            if (loop) {
                duration = 2147483647;
            }
            else {
                duration = 0;
            }
            if ((typeof nameOrIndex == 'string')) {
                for (var i = 0, n = this._templet.getAnimationCount(); i < n; i++) {
                    var animation = this._templet.getAnimation(i);
                    if (animation && nameOrIndex == animation.name) {
                        index = i;
                        break;
                    }
                }
            }
            else {
                index = nameOrIndex;
            }
            if (index > -1 && index < this.getAnimNum()) {
                this._aniClipIndex = index;
                if (force || this._pause || this._currAniIndex != index) {
                    this._currAniIndex = index;
                    this._curOriginalData = new Float32Array(this._templet.getTotalkeyframesLength(index));
                    this._drawOrder = null;
                    this._eventIndex = 0;
                    this._player.play(index, this._player.playbackRate, duration, start, end);
                    if (freshSkin)
                        this._templet.showSkinByIndex(this._boneSlotDic, this._skinIndex);
                    if (this._pause) {
                        this._pause = false;
                        this._lastTime = Browser.now();
                        this.timer.frameLoop(1, this, this._update, null, true);
                    }
                    this._update();
                }
            }
        };
        __proto.stop = function () {
            if (!this._pause) {
                this._pause = true;
                if (this._player) {
                    this._player.stop(true);
                }
                this.timer.clear(this, this._update);
            }
        };
        __proto.playbackRate = function (value) {
            if (this._player) {
                this._player.playbackRate = value;
            }
        };
        __proto.paused = function () {
            if (!this._pause) {
                this._pause = true;
                if (this._player) {
                    this._player.paused = true;
                }
                this.timer.clear(this, this._update);
            }
        };
        __proto.resume = function () {
            this._indexControl = false;
            if (this._pause) {
                this._pause = false;
                if (this._player) {
                    this._player.paused = false;
                }
                this._lastTime = Browser.now();
                this.timer.frameLoop(1, this, this._update, null, true);
            }
        };
        __proto._getGrahicsDataWithCache = function (aniIndex, frameIndex) {
            return this._graphicsCache[aniIndex][frameIndex];
        };
        __proto._setGrahicsDataWithCache = function (aniIndex, frameIndex, graphics) {
            this._graphicsCache[aniIndex][frameIndex] = graphics;
        };
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._templet = null;
            if (this._player)
                this._player.offAll();
            this._player = null;
            this._curOriginalData = null;
            this._boneMatrixArray.length = 0;
            this._lastTime = 0;
            this.timer.clear(this, this._update);
        };
        __getset(0, __proto, 'url', function () {
            return this._aniPath;
        }, function (path) {
            this.load(path);
        });
        __getset(0, __proto, 'index', function () {
            return this._index;
        }, function (value) {
            if (this.player) {
                this._index = value;
                this._player.currentTime = this._index * 1000 / this._player.cacheFrameRate;
                this._indexControl = true;
                this._update(false);
            }
        });
        __getset(0, __proto, 'total', function () {
            if (this._templet && this._player) {
                this._total = Math.floor(this._templet.getAniDuration(this._player.currentAnimationClipIndex) / 1000 * this._player.cacheFrameRate);
            }
            else {
                this._total = -1;
            }
            return this._total;
        });
        __getset(0, __proto, 'templet', function () {
            return this._templet;
        });
        __getset(0, __proto, 'player', function () {
            return this._player;
        });
        Skeleton.useSimpleMeshInCanvas = false;
        return Skeleton;
    })(Sprite);
    var MovieClip = (function (_super) {
        function MovieClip(parentMovieClip) {
            this._start = 0;
            this._Pos = 0;
            this._data = null;
            this._curIndex = 0;
            this._preIndex = 0;
            this._playIndex = 0;
            this._playing = false;
            this._ended = true;
            this._count = 0;
            this._ids = null;
            this._loadedImage = {};
            this._idOfSprite = null;
            this._parentMovieClip = null;
            this._movieClipList = null;
            this._labels = null;
            this.basePath = null;
            this._atlasPath = null;
            this._url = null;
            this._isRoot = false;
            this._completeHandler = null;
            this._endFrame = -1;
            this.interval = 30;
            this.loop = false;
            MovieClip.__super.call(this);
            this._ids = {};
            this._idOfSprite = [];
            this._reset();
            this._playing = false;
            this._parentMovieClip = parentMovieClip;
            if (!parentMovieClip) {
                this._movieClipList = [this];
                this._isRoot = true;
                this._setUpNoticeType(0x1);
            }
            else {
                this._isRoot = false;
                this._movieClipList = parentMovieClip._movieClipList;
                this._movieClipList.push(this);
            }
        }
        __class(MovieClip, 'laya.ani.swf.MovieClip', _super);
        var __proto = MovieClip.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            this._clear();
            _super.prototype.destroy.call(this, destroyChild);
        };
        __proto._setDisplay = function (value) {
            _super.prototype._setDisplay.call(this, value);
            if (this._isRoot) {
                this._$3__onDisplay(value);
            }
        };
        __proto._$3__onDisplay = function (value) {
            if (value)
                this.timer.loop(this.interval, this, this.updates, null, true);
            else
                this.timer.clear(this, this.updates);
        };
        __proto.updates = function () {
            if (this._parentMovieClip)
                return;
            var i = 0, len = 0;
            len = this._movieClipList.length;
            for (i = 0; i < len; i++) {
                this._movieClipList[i] && this._movieClipList[i]._update();
            }
        };
        __proto.addLabel = function (label, index) {
            if (!this._labels)
                this._labels = {};
            this._labels[index] = label;
        };
        __proto.removeLabel = function (label) {
            if (!label)
                this._labels = null;
            else if (!this._labels) {
                for (var name in this._labels) {
                    if (this._labels[name] === label) {
                        delete this._labels[name];
                        break;
                    }
                }
            }
        };
        __proto._update = function () {
            if (!this._data)
                return;
            if (!this._playing)
                return;
            this._playIndex++;
            if (this._playIndex >= this._count) {
                if (!this.loop) {
                    this._playIndex--;
                    this.stop();
                    return;
                }
                this._playIndex = 0;
            }
            this._parse(this._playIndex);
            if (this._labels && this._labels[this._playIndex])
                this.event("label", this._labels[this._playIndex]);
            if (this._endFrame != -1 && this._endFrame == this._playIndex) {
                this._endFrame = -1;
                if (this._completeHandler != null) {
                    var handler = this._completeHandler;
                    this._completeHandler = null;
                    handler.run();
                }
                this.stop();
            }
        };
        __proto.stop = function () {
            this._playing = false;
        };
        __proto.gotoAndStop = function (index) {
            this.index = index;
            this.stop();
        };
        __proto._clear = function () {
            this.stop();
            this._idOfSprite.length = 0;
            if (!this._parentMovieClip) {
                this.timer.clear(this, this.updates);
                var i = 0, len = 0;
                len = this._movieClipList.length;
                for (i = 0; i < len; i++) {
                    if (this._movieClipList[i] != this)
                        this._movieClipList[i]._clear();
                }
                this._movieClipList.length = 0;
            }
            if (this._atlasPath) {
                Loader.clearRes(this._atlasPath);
            }
            ;
            var key;
            for (key in this._loadedImage) {
                if (this._loadedImage[key]) {
                    Loader.clearRes(key);
                    this._loadedImage[key] = false;
                }
            }
            this.removeChildren();
            this.graphics = null;
            this._parentMovieClip = null;
        };
        __proto.play = function (index, loop) {
            (index === void 0) && (index = 0);
            (loop === void 0) && (loop = true);
            this.loop = loop;
            this._playing = true;
            if (this._data)
                this._displayFrame(index);
        };
        __proto._displayFrame = function (frameIndex) {
            (frameIndex === void 0) && (frameIndex = -1);
            if (frameIndex != -1) {
                if (this._curIndex > frameIndex)
                    this._reset();
                this._parse(frameIndex);
            }
        };
        __proto._reset = function (rm) {
            (rm === void 0) && (rm = true);
            if (rm && this._curIndex != 1)
                this.removeChildren();
            this._preIndex = this._curIndex = -1;
            this._Pos = this._start;
        };
        __proto._parse = function (frameIndex) {
            var curChild = this;
            var mc, sp, key = 0, type = 0, tPos = 0, ttype = 0, ifAdd = false;
            var _idOfSprite = this._idOfSprite, _data = this._data, eStr;
            if (this._ended)
                this._reset();
            _data.pos = this._Pos;
            this._ended = false;
            this._playIndex = frameIndex;
            if (this._curIndex > frameIndex && frameIndex < this._preIndex) {
                this._reset(true);
                _data.pos = this._Pos;
            }
            while ((this._curIndex <= frameIndex) && (!this._ended)) {
                type = _data.getUint16();
                switch (type) {
                    case 12:
                        key = _data.getUint16();
                        tPos = this._ids[_data.getUint16()];
                        this._Pos = _data.pos;
                        _data.pos = tPos;
                        if ((ttype = _data.getUint8()) == 0) {
                            var pid = _data.getUint16();
                            sp = _idOfSprite[key];
                            if (!sp) {
                                sp = _idOfSprite[key] = new Sprite();
                                var spp = new Sprite();
                                spp.loadImage(this.basePath + pid + ".png");
                                this._loadedImage[this.basePath + pid + ".png"] = true;
                                sp.addChild(spp);
                                spp.size(_data.getFloat32(), _data.getFloat32());
                                var mat = _data._getMatrix();
                                spp.transform = mat;
                            }
                            sp.alpha = 1;
                        }
                        else if (ttype == 1) {
                            mc = _idOfSprite[key];
                            if (!mc) {
                                _idOfSprite[key] = mc = new MovieClip(this);
                                mc.interval = this.interval;
                                mc._ids = this._ids;
                                mc.basePath = this.basePath;
                                mc._setData(_data, tPos);
                                mc._initState();
                                mc.play(0);
                            }
                            mc.alpha = 1;
                        }
                        _data.pos = this._Pos;
                        break;
                    case 3:
                        ;
                        var node = _idOfSprite[_data.getUint16()];
                        if (node) {
                            this.addChild(node);
                            node.zOrder = _data.getUint16();
                            ifAdd = true;
                        }
                        break;
                    case 4:
                        node = _idOfSprite[_data.getUint16()];
                        node && node.removeSelf();
                        break;
                    case 5:
                        _idOfSprite[_data.getUint16()][MovieClip._ValueList[_data.getUint16()]] = (_data.getFloat32());
                        break;
                    case 6:
                        _idOfSprite[_data.getUint16()].visible = (_data.getUint8() > 0);
                        break;
                    case 7:
                        sp = _idOfSprite[_data.getUint16()];
                        var mt = sp.transform || Matrix.create();
                        mt.setTo(_data.getFloat32(), _data.getFloat32(), _data.getFloat32(), _data.getFloat32(), _data.getFloat32(), _data.getFloat32());
                        sp.transform = mt;
                        break;
                    case 8:
                        _idOfSprite[_data.getUint16()].setPos(_data.getFloat32(), _data.getFloat32());
                        break;
                    case 9:
                        _idOfSprite[_data.getUint16()].setSize(_data.getFloat32(), _data.getFloat32());
                        break;
                    case 10:
                        _idOfSprite[_data.getUint16()].alpha = _data.getFloat32();
                        break;
                    case 11:
                        _idOfSprite[_data.getUint16()].setScale(_data.getFloat32(), _data.getFloat32());
                        break;
                    case 98:
                        eStr = _data.getString();
                        this.event(eStr);
                        if (eStr == "stop")
                            this.stop();
                        break;
                    case 99:
                        this._curIndex = _data.getUint16();
                        ifAdd && this.updateZOrder();
                        break;
                    case 100:
                        this._count = this._curIndex + 1;
                        this._ended = true;
                        if (this._playing) {
                            this.event("enterframe");
                            this.event("end");
                            this.event("complete");
                        }
                        this._reset(false);
                        break;
                }
            }
            if (this._playing && !this._ended)
                this.event("enterframe");
            this._Pos = _data.pos;
        };
        __proto._setData = function (data, start) {
            this._data = data;
            this._start = start + 3;
        };
        __proto.load = function (url, atlas, atlasPath) {
            (atlas === void 0) && (atlas = false);
            this._url = url = URL.formatURL(url);
            if (atlas)
                this._atlasPath = atlasPath ? atlasPath : url.split(".swf")[0] + ".json";
            this.stop();
            this._clear();
            this._movieClipList = [this];
            var urls;
            urls = [{ url: url, type: "arraybuffer" }];
            if (this._atlasPath) {
                urls.push({ url: this._atlasPath, type: "atlas" });
            }
            Laya.loader.load(urls, Handler.create(this, this._onLoaded));
        };
        __proto._onLoaded = function () {
            var data;
            data = Loader.getRes(this._url);
            if (!data) {
                this.event("error", "file not find");
                return;
            }
            this.basePath = this._atlasPath ? Loader.getAtlas(this._atlasPath).dir : this._url.split(".swf")[0] + "/image/";
            this._initData(data);
        };
        __proto._initState = function () {
            this._reset();
            this._ended = false;
            var preState = this._playing;
            this._playing = false;
            this._curIndex = 0;
            while (!this._ended)
                this._parse(++this._curIndex);
            this._playing = preState;
        };
        __proto._initData = function (data) {
            this._data = new Byte(data);
            var i = 0, len = this._data.getUint16();
            for (i = 0; i < len; i++)
                this._ids[this._data.getInt16()] = this._data.getInt32();
            this.interval = 1000 / this._data.getUint16();
            this._setData(this._data, this._ids[32767]);
            this._initState();
            this.play(0);
            this.event("loaded");
            if (!this._parentMovieClip)
                this.timer.loop(this.interval, this, this.updates, null, true);
        };
        __proto.playTo = function (start, end, complete) {
            this._completeHandler = complete;
            this._endFrame = end;
            this.play(start, false);
        };
        __getset(0, __proto, 'index', function () {
            return this._playIndex;
        }, function (value) {
            this._playIndex = value;
            if (this._data)
                this._displayFrame(this._playIndex);
            if (this._labels && this._labels[value])
                this.event("label", this._labels[value]);
        });
        __getset(0, __proto, 'count', function () {
            return this._count;
        });
        __getset(0, __proto, 'playing', function () {
            return this._playing;
        });
        __getset(0, __proto, 'url', null, function (path) {
            this.load(path);
        });
        MovieClip._ValueList = ["x", "y", "width", "height", "scaleX", "scaleY", "rotation", "alpha"];
        return MovieClip;
    })(Sprite);
    var Templet = (function (_super) {
        function Templet() {
            this._mainTexture = null;
            this._textureJson = null;
            this._graphicsCache = [];
            this.srcBoneMatrixArr = [];
            this.ikArr = [];
            this.tfArr = [];
            this.pathArr = [];
            this.boneSlotDic = {};
            this.bindBoneBoneSlotDic = {};
            this.boneSlotArray = [];
            this.skinDataArray = [];
            this.skinDic = {};
            this.subTextureDic = {};
            this.isParseFail = false;
            this.yReverseMatrix = null;
            this.drawOrderAniArr = [];
            this.eventAniArr = [];
            this.attachmentNames = null;
            this.deformAniArr = [];
            this._isDestroyed = false;
            this._rate = 30;
            this.isParserComplete = false;
            this.aniSectionDic = {};
            this._skBufferUrl = null;
            this._textureDic = {};
            this._loadList = null;
            this._path = null;
            this.tMatrixDataLen = 0;
            this.mRootBone = null;
            Templet.__super.call(this);
            this.skinSlotDisplayDataArr = [];
            this.mBoneArr = [];
        }
        __class(Templet, 'laya.ani.bone.Templet', _super);
        var __proto = Templet.prototype;
        __proto.loadAni = function (url) {
            this._skBufferUrl = url;
            Laya.loader.load(url, Handler.create(this, this.onComplete), null, "arraybuffer");
        };
        __proto.onComplete = function (content) {
            if (this._isDestroyed) {
                this.destroy();
                return;
            }
            ;
            var tSkBuffer = Loader.getRes(this._skBufferUrl);
            if (!tSkBuffer) {
                this.event("error", "load failed:" + this._skBufferUrl);
                return;
            }
            this._path = this._skBufferUrl.slice(0, this._skBufferUrl.lastIndexOf("/")) + "/";
            this.parseData(null, tSkBuffer);
        };
        __proto.parseData = function (texture, skeletonData, playbackRate) {
            (playbackRate === void 0) && (playbackRate = 30);
            if (!this._path && this.url)
                this._path = this.url.slice(0, this.url.lastIndexOf("/")) + "/";
            this._mainTexture = texture;
            if (this._mainTexture) {
                if (Render.isWebGL && texture.bitmap) {
                    texture.bitmap.enableMerageInAtlas = false;
                }
            }
            this._rate = playbackRate;
            this.parse(skeletonData);
        };
        __proto.buildArmature = function (aniMode) {
            (aniMode === void 0) && (aniMode = 0);
            return new Skeleton(this, aniMode);
        };
        __proto.parse = function (data) {
            _super.prototype.parse.call(this, data);
            this._endLoaded();
            if (this._aniVersion != Templet.LAYA_ANIMATION_VISION) {
                console_log("[Error] 版本不一致，请使用IDE版本配套的重新导出" + this._aniVersion + "->" + Templet.LAYA_ANIMATION_VISION);
                this._loaded = false;
            }
            if (this.loaded) {
                if (this._mainTexture) {
                    this._parsePublicExtData();
                }
                else {
                    this._parseTexturePath();
                }
            }
            else {
                this.event("error", this);
                this.isParseFail = true;
            }
        };
        __proto._parseTexturePath = function () {
            if (this._isDestroyed) {
                this.destroy();
                return;
            }
            ;
            var i = 0;
            this._loadList = [];
            var tByte = new Byte(this.getPublicExtData());
            var tX = 0, tY = 0, tWidth = 0, tHeight = 0;
            var tFrameX = 0, tFrameY = 0, tFrameWidth = 0, tFrameHeight = 0;
            var tTempleData = 0;
            var tTextureLen = tByte.getInt32();
            var tTextureName = tByte.readUTFString();
            var tTextureNameArr = tTextureName.split("\n");
            var tTexture;
            var tSrcTexturePath;
            for (i = 0; i < tTextureLen; i++) {
                tSrcTexturePath = this._path + tTextureNameArr[i * 2];
                tTextureName = tTextureNameArr[i * 2 + 1];
                tX = tByte.getFloat32();
                tY = tByte.getFloat32();
                tWidth = tByte.getFloat32();
                tHeight = tByte.getFloat32();
                tTempleData = tByte.getFloat32();
                tFrameX = isNaN(tTempleData) ? 0 : tTempleData;
                tTempleData = tByte.getFloat32();
                tFrameY = isNaN(tTempleData) ? 0 : tTempleData;
                tTempleData = tByte.getFloat32();
                tFrameWidth = isNaN(tTempleData) ? tWidth : tTempleData;
                tTempleData = tByte.getFloat32();
                tFrameHeight = isNaN(tTempleData) ? tHeight : tTempleData;
                if (this._loadList.indexOf(tSrcTexturePath) == -1) {
                    this._loadList.push(tSrcTexturePath);
                }
            }
            Laya.loader.load(this._loadList, Handler.create(this, this._textureComplete));
        };
        __proto._textureComplete = function () {
            var tTexture;
            var tTextureName;
            for (var i = 0, n = this._loadList.length; i < n; i++) {
                tTextureName = this._loadList[i];
                tTexture = this._textureDic[tTextureName] = Loader.getRes(tTextureName);
                if (Render.isWebGL && tTexture && tTexture.bitmap) {
                    tTexture.bitmap.enableMerageInAtlas = false;
                }
            }
            this._parsePublicExtData();
        };
        __proto._parsePublicExtData = function () {
            var i = 0, j = 0, k = 0, l = 0, n = 0;
            for (i = 0, n = this.getAnimationCount(); i < n; i++) {
                this._graphicsCache.push([]);
            }
            ;
            var isSpine = false;
            isSpine = this._aniClassName != "Dragon";
            var tByte = new Byte(this.getPublicExtData());
            var tX = 0, tY = 0, tWidth = 0, tHeight = 0;
            var tFrameX = 0, tFrameY = 0, tFrameWidth = 0, tFrameHeight = 0;
            var tTempleData = 0;
            var tTextureLen = tByte.getInt32();
            var tTextureName = tByte.readUTFString();
            var tTextureNameArr = tTextureName.split("\n");
            var tTexture;
            var tSrcTexturePath;
            for (i = 0; i < tTextureLen; i++) {
                tTexture = this._mainTexture;
                tSrcTexturePath = this._path + tTextureNameArr[i * 2];
                tTextureName = tTextureNameArr[i * 2 + 1];
                if (this._mainTexture == null) {
                    tTexture = this._textureDic[tSrcTexturePath];
                }
                if (!tTexture) {
                    this.event("error", this);
                    this.isParseFail = true;
                    return;
                }
                tX = tByte.getFloat32();
                tY = tByte.getFloat32();
                tWidth = tByte.getFloat32();
                tHeight = tByte.getFloat32();
                tTempleData = tByte.getFloat32();
                tFrameX = isNaN(tTempleData) ? 0 : tTempleData;
                tTempleData = tByte.getFloat32();
                tFrameY = isNaN(tTempleData) ? 0 : tTempleData;
                tTempleData = tByte.getFloat32();
                tFrameWidth = isNaN(tTempleData) ? tWidth : tTempleData;
                tTempleData = tByte.getFloat32();
                tFrameHeight = isNaN(tTempleData) ? tHeight : tTempleData;
                this.subTextureDic[tTextureName] = Texture.create(tTexture, tX, tY, tWidth, tHeight, -tFrameX, -tFrameY, tFrameWidth, tFrameHeight);
            }
            this._mainTexture = tTexture;
            var tAniCount = tByte.getUint16();
            var tSectionArr;
            for (i = 0; i < tAniCount; i++) {
                tSectionArr = [];
                tSectionArr.push(tByte.getUint16());
                tSectionArr.push(tByte.getUint16());
                tSectionArr.push(tByte.getUint16());
                tSectionArr.push(tByte.getUint16());
                this.aniSectionDic[i] = tSectionArr;
            }
            ;
            var tBone;
            var tParentBone;
            var tName;
            var tParentName;
            var tBoneLen = tByte.getInt16();
            var tBoneDic = {};
            var tRootBone;
            for (i = 0; i < tBoneLen; i++) {
                tBone = new Bone();
                if (i == 0) {
                    tRootBone = tBone;
                }
                else {
                    tBone.root = tRootBone;
                }
                tBone.d = isSpine ? -1 : 1;
                tName = tByte.readUTFString();
                tParentName = tByte.readUTFString();
                tBone.length = tByte.getFloat32();
                if (tByte.getByte() == 1) {
                    tBone.inheritRotation = false;
                }
                if (tByte.getByte() == 1) {
                    tBone.inheritScale = false;
                }
                tBone.name = tName;
                if (tParentName) {
                    tParentBone = tBoneDic[tParentName];
                    if (tParentBone) {
                        tParentBone.addChild(tBone);
                    }
                    else {
                        this.mRootBone = tBone;
                    }
                }
                tBoneDic[tName] = tBone;
                this.mBoneArr.push(tBone);
            }
            this.tMatrixDataLen = tByte.getUint16();
            var tLen = tByte.getUint16();
            var parentIndex = 0;
            var boneLength = Math.floor(tLen / this.tMatrixDataLen);
            var tResultTransform;
            var tMatrixArray = this.srcBoneMatrixArr;
            for (i = 0; i < boneLength; i++) {
                tResultTransform = new Transform();
                tResultTransform.scX = tByte.getFloat32();
                tResultTransform.skX = tByte.getFloat32();
                tResultTransform.skY = tByte.getFloat32();
                tResultTransform.scY = tByte.getFloat32();
                tResultTransform.x = tByte.getFloat32();
                tResultTransform.y = tByte.getFloat32();
                if (this.tMatrixDataLen === 8) {
                    tResultTransform.skewX = tByte.getFloat32();
                    tResultTransform.skewY = tByte.getFloat32();
                }
                tMatrixArray.push(tResultTransform);
                tBone = this.mBoneArr[i];
                tBone.transform = tResultTransform;
            }
            ;
            var tIkConstraintData;
            var tIkLen = tByte.getUint16();
            var tIkBoneLen = 0;
            for (i = 0; i < tIkLen; i++) {
                tIkConstraintData = new IkConstraintData();
                tIkBoneLen = tByte.getUint16();
                for (j = 0; j < tIkBoneLen; j++) {
                    tIkConstraintData.boneNames.push(tByte.readUTFString());
                    tIkConstraintData.boneIndexs.push(tByte.getInt16());
                }
                tIkConstraintData.name = tByte.readUTFString();
                tIkConstraintData.targetBoneName = tByte.readUTFString();
                tIkConstraintData.targetBoneIndex = tByte.getInt16();
                tIkConstraintData.bendDirection = tByte.getFloat32();
                tIkConstraintData.mix = tByte.getFloat32();
                tIkConstraintData.isSpine = isSpine;
                this.ikArr.push(tIkConstraintData);
            }
            ;
            var tTfConstraintData;
            var tTfLen = tByte.getUint16();
            var tTfBoneLen = 0;
            for (i = 0; i < tTfLen; i++) {
                tTfConstraintData = new TfConstraintData();
                tTfBoneLen = tByte.getUint16();
                for (j = 0; j < tTfBoneLen; j++) {
                    tTfConstraintData.boneIndexs.push(tByte.getInt16());
                }
                tTfConstraintData.name = tByte.getUTFString();
                tTfConstraintData.targetIndex = tByte.getInt16();
                tTfConstraintData.rotateMix = tByte.getFloat32();
                tTfConstraintData.translateMix = tByte.getFloat32();
                tTfConstraintData.scaleMix = tByte.getFloat32();
                tTfConstraintData.shearMix = tByte.getFloat32();
                tTfConstraintData.offsetRotation = tByte.getFloat32();
                tTfConstraintData.offsetX = tByte.getFloat32();
                tTfConstraintData.offsetY = tByte.getFloat32();
                tTfConstraintData.offsetScaleX = tByte.getFloat32();
                tTfConstraintData.offsetScaleY = tByte.getFloat32();
                tTfConstraintData.offsetShearY = tByte.getFloat32();
                this.tfArr.push(tTfConstraintData);
            }
            ;
            var tPathConstraintData;
            var tPathLen = tByte.getUint16();
            var tPathBoneLen = 0;
            for (i = 0; i < tPathLen; i++) {
                tPathConstraintData = new PathConstraintData();
                tPathConstraintData.name = tByte.readUTFString();
                tPathBoneLen = tByte.getUint16();
                for (j = 0; j < tPathBoneLen; j++) {
                    tPathConstraintData.bones.push(tByte.getInt16());
                }
                tPathConstraintData.target = tByte.readUTFString();
                tPathConstraintData.positionMode = tByte.readUTFString();
                tPathConstraintData.spacingMode = tByte.readUTFString();
                tPathConstraintData.rotateMode = tByte.readUTFString();
                tPathConstraintData.offsetRotation = tByte.getFloat32();
                tPathConstraintData.position = tByte.getFloat32();
                tPathConstraintData.spacing = tByte.getFloat32();
                tPathConstraintData.rotateMix = tByte.getFloat32();
                tPathConstraintData.translateMix = tByte.getFloat32();
                this.pathArr.push(tPathConstraintData);
            }
            ;
            var tDeformSlotLen = 0;
            var tDeformSlotDisplayLen = 0;
            var tDSlotIndex = 0;
            var tDAttachment;
            var tDeformTimeLen = 0;
            var tDTime = NaN;
            var tDeformVecticesLen = 0;
            var tDeformAniData;
            var tDeformSlotData;
            var tDeformSlotDisplayData;
            var tDeformVectices;
            var tDeformAniLen = tByte.getInt16();
            for (i = 0; i < tDeformAniLen; i++) {
                var tDeformSkinLen = tByte.getUint8();
                var tSkinDic = {};
                this.deformAniArr.push(tSkinDic);
                for (var f = 0; f < tDeformSkinLen; f++) {
                    tDeformAniData = new DeformAniData();
                    tDeformAniData.skinName = tByte.getUTFString();
                    tSkinDic[tDeformAniData.skinName] = tDeformAniData;
                    tDeformSlotLen = tByte.getInt16();
                    for (j = 0; j < tDeformSlotLen; j++) {
                        tDeformSlotData = new DeformSlotData();
                        tDeformAniData.deformSlotDataList.push(tDeformSlotData);
                        tDeformSlotDisplayLen = tByte.getInt16();
                        for (k = 0; k < tDeformSlotDisplayLen; k++) {
                            tDeformSlotDisplayData = new DeformSlotDisplayData();
                            tDeformSlotData.deformSlotDisplayList.push(tDeformSlotDisplayData);
                            tDeformSlotDisplayData.slotIndex = tDSlotIndex = tByte.getInt16();
                            tDeformSlotDisplayData.attachment = tDAttachment = tByte.getUTFString();
                            tDeformTimeLen = tByte.getInt16();
                            for (l = 0; l < tDeformTimeLen; l++) {
                                if (tByte.getByte() == 1) {
                                    tDeformSlotDisplayData.tweenKeyList.push(true);
                                }
                                else {
                                    tDeformSlotDisplayData.tweenKeyList.push(false);
                                }
                                tDTime = tByte.getFloat32();
                                tDeformSlotDisplayData.timeList.push(tDTime);
                                tDeformVectices = [];
                                tDeformSlotDisplayData.vectices.push(tDeformVectices);
                                tDeformVecticesLen = tByte.getInt16();
                                for (n = 0; n < tDeformVecticesLen; n++) {
                                    tDeformVectices.push(tByte.getFloat32());
                                }
                            }
                        }
                    }
                }
            }
            ;
            var tDrawOrderArr;
            var tDrawOrderAniLen = tByte.getInt16();
            var tDrawOrderLen = 0;
            var tDrawOrderData;
            var tDoLen = 0;
            for (i = 0; i < tDrawOrderAniLen; i++) {
                tDrawOrderLen = tByte.getInt16();
                tDrawOrderArr = [];
                for (j = 0; j < tDrawOrderLen; j++) {
                    tDrawOrderData = new DrawOrderData();
                    tDrawOrderData.time = tByte.getFloat32();
                    tDoLen = tByte.getInt16();
                    for (k = 0; k < tDoLen; k++) {
                        tDrawOrderData.drawOrder.push(tByte.getInt16());
                    }
                    tDrawOrderArr.push(tDrawOrderData);
                }
                this.drawOrderAniArr.push(tDrawOrderArr);
            }
            ;
            var tEventArr;
            var tEventAniLen = tByte.getInt16();
            var tEventLen = 0;
            var tEventData;
            for (i = 0; i < tEventAniLen; i++) {
                tEventLen = tByte.getInt16();
                tEventArr = [];
                for (j = 0; j < tEventLen; j++) {
                    tEventData = new EventData();
                    tEventData.name = tByte.getUTFString();
                    tEventData.intValue = tByte.getInt32();
                    tEventData.floatValue = tByte.getFloat32();
                    tEventData.stringValue = tByte.getUTFString();
                    tEventData.time = tByte.getFloat32();
                    tEventArr.push(tEventData);
                }
                this.eventAniArr.push(tEventArr);
            }
            ;
            var tAttachmentLen = tByte.getInt16();
            if (tAttachmentLen > 0) {
                this.attachmentNames = [];
                for (i = 0; i < tAttachmentLen; i++) {
                    this.attachmentNames.push(tByte.getUTFString());
                }
            }
            ;
            var tBoneSlotLen = tByte.getInt16();
            var tDBBoneSlot;
            var tDBBoneSlotArr;
            for (i = 0; i < tBoneSlotLen; i++) {
                tDBBoneSlot = new BoneSlot();
                tDBBoneSlot.name = tByte.readUTFString();
                tDBBoneSlot.parent = tByte.readUTFString();
                tDBBoneSlot.attachmentName = tByte.readUTFString();
                tDBBoneSlot.srcDisplayIndex = tDBBoneSlot.displayIndex = tByte.getInt16();
                tDBBoneSlot.templet = this;
                this.boneSlotDic[tDBBoneSlot.name] = tDBBoneSlot;
                tDBBoneSlotArr = this.bindBoneBoneSlotDic[tDBBoneSlot.parent];
                if (tDBBoneSlotArr == null) {
                    this.bindBoneBoneSlotDic[tDBBoneSlot.parent] = tDBBoneSlotArr = [];
                }
                tDBBoneSlotArr.push(tDBBoneSlot);
                this.boneSlotArray.push(tDBBoneSlot);
            }
            ;
            var tNameString = tByte.readUTFString();
            var tNameArray = tNameString.split("\n");
            var tNameStartIndex = 0;
            var tSkinDataLen = tByte.getUint8();
            var tSkinData, tSlotData, tDisplayData;
            var tSlotDataLen = 0, tDisplayDataLen = 0;
            var tUvLen = 0, tWeightLen = 0, tTriangleLen = 0, tVerticeLen = 0, tLengthLen = 0;
            for (i = 0; i < tSkinDataLen; i++) {
                tSkinData = new SkinData();
                tSkinData.name = tNameArray[tNameStartIndex++];
                tSlotDataLen = tByte.getUint8();
                for (j = 0; j < tSlotDataLen; j++) {
                    tSlotData = new SlotData();
                    tSlotData.name = tNameArray[tNameStartIndex++];
                    tDBBoneSlot = this.boneSlotDic[tSlotData.name];
                    tDisplayDataLen = tByte.getUint8();
                    for (k = 0; k < tDisplayDataLen; k++) {
                        tDisplayData = new SkinSlotDisplayData();
                        this.skinSlotDisplayDataArr.push(tDisplayData);
                        tDisplayData.name = tNameArray[tNameStartIndex++];
                        tDisplayData.attachmentName = tNameArray[tNameStartIndex++];
                        tDisplayData.transform = new Transform();
                        tDisplayData.transform.scX = tByte.getFloat32();
                        tDisplayData.transform.skX = tByte.getFloat32();
                        tDisplayData.transform.skY = tByte.getFloat32();
                        tDisplayData.transform.scY = tByte.getFloat32();
                        tDisplayData.transform.x = tByte.getFloat32();
                        tDisplayData.transform.y = tByte.getFloat32();
                        tSlotData.displayArr.push(tDisplayData);
                        tDisplayData.width = tByte.getFloat32();
                        tDisplayData.height = tByte.getFloat32();
                        tDisplayData.type = tByte.getUint8();
                        tDisplayData.verLen = tByte.getUint16();
                        tBoneLen = tByte.getUint16();
                        if (tBoneLen > 0) {
                            tDisplayData.bones = [];
                            for (l = 0; l < tBoneLen; l++) {
                                var tBoneId = tByte.getUint16();
                                tDisplayData.bones.push(tBoneId);
                            }
                        }
                        tUvLen = tByte.getUint16();
                        if (tUvLen > 0) {
                            tDisplayData.uvs = [];
                            for (l = 0; l < tUvLen; l++) {
                                tDisplayData.uvs.push(tByte.getFloat32());
                            }
                        }
                        tWeightLen = tByte.getUint16();
                        if (tWeightLen > 0) {
                            tDisplayData.weights = [];
                            for (l = 0; l < tWeightLen; l++) {
                                tDisplayData.weights.push(tByte.getFloat32());
                            }
                        }
                        tTriangleLen = tByte.getUint16();
                        if (tTriangleLen > 0) {
                            tDisplayData.triangles = [];
                            for (l = 0; l < tTriangleLen; l++) {
                                tDisplayData.triangles.push(tByte.getUint16());
                            }
                        }
                        tVerticeLen = tByte.getUint16();
                        if (tVerticeLen > 0) {
                            tDisplayData.vertices = [];
                            for (l = 0; l < tVerticeLen; l++) {
                                tDisplayData.vertices.push(tByte.getFloat32());
                            }
                        }
                        tLengthLen = tByte.getUint16();
                        if (tLengthLen > 0) {
                            tDisplayData.lengths = [];
                            for (l = 0; l < tLengthLen; l++) {
                                tDisplayData.lengths.push(tByte.getFloat32());
                            }
                        }
                    }
                    tSkinData.slotArr.push(tSlotData);
                }
                this.skinDic[tSkinData.name] = tSkinData;
                this.skinDataArray.push(tSkinData);
            }
            ;
            var tReverse = tByte.getUint8();
            if (tReverse == 1) {
                this.yReverseMatrix = new Matrix(1, 0, 0, -1, 0, 0);
                if (tRootBone) {
                    tRootBone.setTempMatrix(this.yReverseMatrix);
                }
            }
            else {
                if (tRootBone) {
                    tRootBone.setTempMatrix(new Matrix());
                }
            }
            this.showSkinByIndex(this.boneSlotDic, 0);
            this.isParserComplete = true;
            this.event("complete", this);
        };
        __proto.getTexture = function (name) {
            var tTexture = this.subTextureDic[name];
            if (tTexture == null) {
                return this._mainTexture;
            }
            return tTexture;
        };
        __proto.showSkinByIndex = function (boneSlotDic, skinIndex, freshDisplayIndex) {
            (freshDisplayIndex === void 0) && (freshDisplayIndex = true);
            if (skinIndex < 0 && skinIndex >= this.skinDataArray.length)
                return false;
            var i = 0, n = 0;
            var tBoneSlot;
            var tSlotData;
            var tSkinData = this.skinDataArray[skinIndex];
            if (tSkinData) {
                for (i = 0, n = tSkinData.slotArr.length; i < n; i++) {
                    tSlotData = tSkinData.slotArr[i];
                    if (tSlotData) {
                        tBoneSlot = boneSlotDic[tSlotData.name];
                        if (tBoneSlot) {
                            tBoneSlot.showSlotData(tSlotData, freshDisplayIndex);
                            if (freshDisplayIndex && tBoneSlot.attachmentName != "undefined" && tBoneSlot.attachmentName != "null") {
                                tBoneSlot.showDisplayByName(tBoneSlot.attachmentName);
                            }
                            else {
                                tBoneSlot.showDisplayByIndex(tBoneSlot.displayIndex);
                            }
                        }
                    }
                }
                return true;
            }
            return false;
        };
        __proto.getSkinIndexByName = function (skinName) {
            var tSkinData;
            for (var i = 0, n = this.skinDataArray.length; i < n; i++) {
                tSkinData = this.skinDataArray[i];
                if (tSkinData.name == skinName) {
                    return i;
                }
            }
            return -1;
        };
        __proto.getGrahicsDataWithCache = function (aniIndex, frameIndex) {
            return this._graphicsCache[aniIndex][frameIndex];
        };
        __proto.setGrahicsDataWithCache = function (aniIndex, frameIndex, graphics) {
            this._graphicsCache[aniIndex][frameIndex] = graphics;
        };
        __proto.destroy = function () {
            this._isDestroyed = true;
            var tTexture;
            for (var $each_tTexture in this.subTextureDic) {
                tTexture = this.subTextureDic[$each_tTexture];
                if (tTexture)
                    tTexture.destroy();
            }
            var $each_tTexture;
            for ($each_tTexture in this._textureDic) {
                tTexture = this._textureDic[$each_tTexture];
                if (tTexture)
                    tTexture.destroy();
            }
            ;
            var tSkinSlotDisplayData;
            for (var i = 0, n = this.skinSlotDisplayDataArr.length; i < n; i++) {
                tSkinSlotDisplayData = this.skinSlotDisplayDataArr[i];
                tSkinSlotDisplayData.destory();
            }
            this.skinSlotDisplayDataArr.length = 0;
            if (this.url) {
                delete Templet.TEMPLET_DICTIONARY[this.url];
            }
            laya.resource.Resource.prototype.destroy.call(this);
        };
        __proto.getAniNameByIndex = function (index) {
            var tAni = this.getAnimation(index);
            if (tAni)
                return tAni.name;
            return null;
        };
        __getset(0, __proto, 'rate', function () {
            return this._rate;
        }, function (v) {
            this._rate = v;
        });
        Templet.LAYA_ANIMATION_VISION = "LAYAANIMATION:1.6.0";
        Templet.TEMPLET_DICTIONARY = null;
        return Templet;
    })(AnimationTemplet);
})(window, document, Laya);
if (typeof define === 'function' && define.amd) {
    define('laya.core', ['require', "exports"], function (require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
            var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    var Browser = laya.utils.Browser, HTMLCanvas = laya.resource.HTMLCanvas, Handler = laya.utils.Handler, Loader = laya.net.Loader;
    var Point = laya.maths.Point, Rectangle = laya.maths.Rectangle, Render = laya.renders.Render, RenderContext = laya.renders.RenderContext;
    var Sprite = laya.display.Sprite, Texture = laya.resource.Texture;
    var TiledMap = (function () {
        var GRect, TileMapAniData, TileSet;
        function TiledMap() {
            this._jsonData = null;
            this._tileTexSetArr = [];
            this._texArray = [];
            this._x = 0;
            this._y = 0;
            this._width = 0;
            this._height = 0;
            this._mapW = 0;
            this._mapH = 0;
            this._mapTileW = 0;
            this._mapTileH = 0;
            this._mapSprite = null;
            this._layerArray = [];
            this._renderLayerArray = [];
            this._gridArray = [];
            this._showGridKey = false;
            this._totalGridNum = 0;
            this._gridW = 0;
            this._gridH = 0;
            this._gridWidth = 450;
            this._gridHeight = 450;
            this._jsonLoader = null;
            this._loader = null;
            this._tileSetArray = [];
            this._currTileSet = null;
            this._completeHandler = null;
            this._index = 0;
            this._animationDic = {};
            this._properties = null;
            this._tileProperties = {};
            this._tileProperties2 = {};
            this._orientation = "orthogonal";
            this._renderOrder = "right-down";
            this._colorArray = ["FF", "00", "33", "66"];
            this._scale = 1;
            this._pivotScaleX = 0.5;
            this._pivotScaleY = 0.5;
            this._centerX = 0;
            this._centerY = 0;
            this._viewPortX = 0;
            this._viewPortY = 0;
            this._viewPortWidth = 0;
            this._viewPortHeight = 0;
            this._enableLinear = true;
            this._resPath = null;
            this._pathArray = null;
            this._limitRange = false;
            this._fastDirty = true;
            this.autoCache = true;
            this.autoCacheType = "normal";
            this.enableMergeLayer = false;
            this.removeCoveredTile = false;
            this.showGridTextureCount = false;
            this.antiCrack = true;
            this.cacheAllAfterInit = false;
            this._texutreStartDic = {};
            this._rect = new Rectangle();
            this._paddingRect = new Rectangle();
            this._mapRect = new GRect();
            this._mapLogicRect = new GRect();
            this._mapLastRect = new GRect();
            this._mapSprite = new Sprite();
        }
        __class(TiledMap, 'laya.map.TiledMap');
        var __proto = TiledMap.prototype;
        __proto.createMap = function (mapName, viewRect, completeHandler, viewRectPadding, gridSize, enableLinear, limitRange) {
            (enableLinear === void 0) && (enableLinear = true);
            (limitRange === void 0) && (limitRange = false);
            this._enableLinear = enableLinear;
            this._limitRange = limitRange;
            this._rect.x = viewRect.x;
            this._rect.y = viewRect.y;
            this._rect.width = viewRect.width;
            this._rect.height = viewRect.height;
            this._viewPortWidth = viewRect.width / this._scale;
            this._viewPortHeight = viewRect.height / this._scale;
            this._completeHandler = completeHandler;
            if (viewRectPadding) {
                this._paddingRect.copyFrom(viewRectPadding);
            }
            else {
                this._paddingRect.setTo(0, 0, 0, 0);
            }
            if (gridSize) {
                this._gridWidth = gridSize.x;
                this._gridHeight = gridSize.y;
            }
            ;
            var tIndex = mapName.lastIndexOf("/");
            if (tIndex > -1) {
                this._resPath = mapName.substr(0, tIndex);
                this._pathArray = this._resPath.split("/");
            }
            else {
                this._resPath = "";
                this._pathArray = [];
            }
            this._jsonLoader = new Loader();
            this._jsonLoader.once("complete", this, this.onJsonComplete);
            this._jsonLoader.load(mapName, "json", false);
        };
        __proto.onJsonComplete = function (e) {
            var tJsonData = this._jsonData = e;
            this._properties = tJsonData.properties;
            this._orientation = tJsonData.orientation;
            this._renderOrder = tJsonData.renderorder;
            this._mapW = tJsonData.width;
            this._mapH = tJsonData.height;
            this._mapTileW = tJsonData.tilewidth;
            this._mapTileH = tJsonData.tileheight;
            this._width = this._mapTileW * this._mapW;
            this._height = this._mapTileH * this._mapH;
            if (this._orientation == "staggered") {
                this._height = (0.5 + this._mapH * 0.5) * this._mapTileH;
            }
            this._mapLastRect.top = this._mapLastRect.bottom = this._mapLastRect.left = this._mapLastRect.right = -1;
            var tArray = tJsonData.tilesets;
            var tileset;
            var tTileSet;
            var i = 0;
            for (i = 0; i < tArray.length; i++) {
                tileset = tArray[i];
                tTileSet = new TileSet();
                tTileSet.init(tileset);
                if (tTileSet.properties && tTileSet.properties.ignore)
                    continue;
                this._tileProperties[i] = tTileSet.tileproperties;
                this.addTileProperties(tTileSet.tileproperties);
                this._tileSetArray.push(tTileSet);
                var tTiles = tileset.tiles;
                if (tTiles) {
                    for (var p in tTiles) {
                        var tAnimation = tTiles[p].animation;
                        if (tAnimation) {
                            var tAniData = new TileMapAniData();
                            this._animationDic[p] = tAniData;
                            tAniData.image = tileset.image;
                            for (var j = 0; j < tAnimation.length; j++) {
                                var tAnimationItem = tAnimation[j];
                                tAniData.mAniIdArray.push(tAnimationItem.tileid);
                                tAniData.mDurationTimeArray.push(tAnimationItem.duration);
                            }
                        }
                    }
                }
            }
            this._tileTexSetArr.push(null);
            if (this._tileSetArray.length > 0) {
                tTileSet = this._currTileSet = this._tileSetArray.shift();
                this._loader = new Loader();
                this._loader.once("complete", this, this.onTextureComplete);
                var tPath = this.mergePath(this._resPath, tTileSet.image);
                this._loader.load(tPath, "image", false);
            }
        };
        __proto.mergePath = function (resPath, relativePath) {
            var tResultPath = "";
            var tImageArray = relativePath.split("/");
            var tParentPathNum = 0;
            var i = 0;
            for (i = tImageArray.length - 1; i >= 0; i--) {
                if (tImageArray[i] == "..") {
                    tParentPathNum++;
                }
            }
            if (tParentPathNum == 0) {
                if (this._pathArray.length > 0) {
                    tResultPath = resPath + "/" + relativePath;
                }
                else {
                    tResultPath = relativePath;
                }
                return tResultPath;
            }
            ;
            var tSrcNum = this._pathArray.length - tParentPathNum;
            if (tSrcNum < 0) {
                console_log("[error]path does not exist", this._pathArray, tImageArray, resPath, relativePath);
            }
            for (i = 0; i < tSrcNum; i++) {
                if (i == 0) {
                    tResultPath += this._pathArray[i];
                }
                else {
                    tResultPath = tResultPath + "/" + this._pathArray[i];
                }
            }
            for (i = tParentPathNum; i < tImageArray.length; i++) {
                tResultPath = tResultPath + "/" + tImageArray[i];
            }
            return tResultPath;
        };
        __proto.onTextureComplete = function (e) {
            var json = this._jsonData;
            var tTexture = e;
            if (Render.isWebGL && (!this._enableLinear)) {
                tTexture.bitmap.minFifter = 0x2600;
                tTexture.bitmap.magFifter = 0x2600;
                tTexture.bitmap.enableMerageInAtlas = false;
            }
            this._texArray.push(tTexture);
            var tSubTexture = null;
            var tTileSet = this._currTileSet;
            var tTileTextureW = tTileSet.tilewidth;
            var tTileTextureH = tTileSet.tileheight;
            var tImageWidth = tTileSet.imagewidth;
            var tImageHeight = tTileSet.imageheight;
            var tFirstgid = tTileSet.firstgid;
            var tTileWNum = Math.floor((tImageWidth - tTileSet.margin - tTileTextureW) / (tTileTextureW + tTileSet.spacing)) + 1;
            var tTileHNum = Math.floor((tImageHeight - tTileSet.margin - tTileTextureH) / (tTileTextureH + tTileSet.spacing)) + 1;
            var tTileTexSet = null;
            this._texutreStartDic[tTileSet.image] = this._tileTexSetArr.length;
            for (var i = 0; i < tTileHNum; i++) {
                for (var j = 0; j < tTileWNum; j++) {
                    tTileTexSet = new TileTexSet();
                    tTileTexSet.offX = tTileSet.titleoffsetX;
                    tTileTexSet.offY = tTileSet.titleoffsetY - (tTileTextureH - this._mapTileH);
                    tTileTexSet.texture = Texture.createFromTexture(tTexture, tTileSet.margin + (tTileTextureW + tTileSet.spacing) * j, tTileSet.margin + (tTileTextureH + tTileSet.spacing) * i, tTileTextureW, tTileTextureH);
                    if (this.antiCrack)
                        this.adptTexture(tTileTexSet.texture);
                    this._tileTexSetArr.push(tTileTexSet);
                    tTileTexSet.gid = this._tileTexSetArr.length;
                }
            }
            if (this._tileSetArray.length > 0) {
                tTileSet = this._currTileSet = this._tileSetArray.shift();
                this._loader.once("complete", this, this.onTextureComplete);
                var tPath = this.mergePath(this._resPath, tTileSet.image);
                this._loader.load(tPath, "image", false);
            }
            else {
                this._currTileSet = null;
                this.initMap();
            }
        };
        __proto.adptTexture = function (tex) {
            if (!tex)
                return;
            var pX = tex.uv[0];
            var pX1 = tex.uv[2];
            var pY = tex.uv[1];
            var pY1 = tex.uv[7];
            var dW = 1 / tex.bitmap.width;
            var dH = 1 / tex.bitmap.height;
            tex.uv[0] = tex.uv[6] = pX + dW;
            tex.uv[2] = tex.uv[4] = pX1 - dW;
            tex.uv[1] = tex.uv[3] = pY + dH;
            tex.uv[5] = tex.uv[7] = pY1 - dH;
        };
        __proto.initMap = function () {
            var i = 0, n = 0;
            for (var p in this._animationDic) {
                var tAniData = this._animationDic[p];
                var gStart = 0;
                gStart = this._texutreStartDic[tAniData.image];
                var tTileTexSet = this.getTexture(parseInt(p) + gStart);
                if (tAniData.mAniIdArray.length > 0) {
                    tTileTexSet.textureArray = [];
                    tTileTexSet.durationTimeArray = tAniData.mDurationTimeArray;
                    tTileTexSet.isAnimation = true;
                    tTileTexSet.animationTotalTime = 0;
                    for (i = 0, n = tTileTexSet.durationTimeArray.length; i < n; i++) {
                        tTileTexSet.animationTotalTime += tTileTexSet.durationTimeArray[i];
                    }
                    for (i = 0, n = tAniData.mAniIdArray.length; i < n; i++) {
                        var tTexture = this.getTexture(tAniData.mAniIdArray[i] + gStart);
                        tTileTexSet.textureArray.push(tTexture);
                    }
                }
            }
            this._gridWidth = Math.floor(this._gridWidth / this._mapTileW) * this._mapTileW;
            this._gridHeight = Math.floor(this._gridHeight / this._mapTileH) * this._mapTileH;
            if (this._gridWidth < this._mapTileW) {
                this._gridWidth = this._mapTileW;
            }
            if (this._gridHeight < this._mapTileH) {
                this._gridHeight = this._mapTileH;
            }
            this._gridW = Math.ceil(this._width / this._gridWidth);
            this._gridH = Math.ceil(this._height / this._gridHeight);
            this._totalGridNum = this._gridW * this._gridH;
            for (i = 0; i < this._gridH; i++) {
                var tGridArray = [];
                this._gridArray.push(tGridArray);
                for (var j = 0; j < this._gridW; j++) {
                    tGridArray.push(null);
                }
            }
            ;
            var tLayerArray = this._jsonData.layers;
            var isFirst = true;
            var tTarLayerID = 1;
            var tLayerTarLayerName;
            var preLayerTarName;
            var preLayer;
            for (var tLayerLoop = 0; tLayerLoop < tLayerArray.length; tLayerLoop++) {
                var tLayerData = tLayerArray[tLayerLoop];
                if (tLayerData.visible == true) {
                    var tMapLayer = new MapLayer();
                    tMapLayer.init(tLayerData, this);
                    if (!this.enableMergeLayer) {
                        this._mapSprite.addChild(tMapLayer);
                        this._renderLayerArray.push(tMapLayer);
                    }
                    else {
                        tLayerTarLayerName = tMapLayer.getLayerProperties("layer");
                        isFirst = isFirst || (!preLayer) || (tLayerTarLayerName != preLayerTarName);
                        if (isFirst) {
                            isFirst = false;
                            tMapLayer.tarLayer = tMapLayer;
                            preLayer = tMapLayer;
                            this._mapSprite.addChild(tMapLayer);
                            this._renderLayerArray.push(tMapLayer);
                        }
                        else {
                            tMapLayer.tarLayer = preLayer;
                        }
                        preLayerTarName = tLayerTarLayerName;
                    }
                    this._layerArray.push(tMapLayer);
                }
            }
            if (this.removeCoveredTile) {
                this.adptTiledMapData();
            }
            if (this.cacheAllAfterInit) {
                this.cacheAllGrid();
            }
            this.moveViewPort(this._rect.x, this._rect.y);
            Laya.stage.addChild(this.mapSprite());
            if (this._completeHandler != null) {
                this._completeHandler.run();
            }
        };
        __proto.addTileProperties = function (tileDataDic) {
            var key;
            for (key in tileDataDic) {
                this._tileProperties2[key] = tileDataDic[key];
            }
        };
        __proto.getTileUserData = function (id, sign, defaultV) {
            if (!this._tileProperties2 || !this._tileProperties2[id] || !(sign in this._tileProperties2[id]))
                return defaultV;
            return this._tileProperties2[id][sign];
        };
        __proto.adptTiledMapData = function () {
            var i = 0, len = 0;
            len = this._layerArray.length;
            var tLayer;
            var noNeeds = {};
            var tDatas;
            for (i = len - 1; i >= 0; i--) {
                tLayer = this._layerArray[i];
                tDatas = tLayer._mapData;
                if (!tDatas)
                    continue;
                this.removeCoverd(tDatas, noNeeds);
                this.collectCovers(tDatas, noNeeds, i);
            }
        };
        __proto.removeCoverd = function (datas, noNeeds) {
            var i = 0, len = 0;
            len = datas.length;
            for (i = 0; i < len; i++) {
                if (noNeeds[i]) {
                    datas[i] = 0;
                }
            }
        };
        __proto.collectCovers = function (datas, noNeeds, layer) {
            var i = 0, len = 0;
            len = datas.length;
            var tTileData = 0;
            var isCover = 0;
            for (i = 0; i < len; i++) {
                tTileData = datas[i];
                if (tTileData > 0) {
                    isCover = this.getTileUserData(tTileData - 1, "type", 0);
                    if (isCover > 0) {
                        noNeeds[i] = tTileData;
                    }
                }
            }
        };
        __proto.getTexture = function (index) {
            if (index < this._tileTexSetArr.length) {
                return this._tileTexSetArr[index];
            }
            return null;
        };
        __proto.getMapProperties = function (name) {
            if (this._properties) {
                return this._properties[name];
            }
            return null;
        };
        __proto.getTileProperties = function (index, id, name) {
            if (this._tileProperties[index] && this._tileProperties[index][id]) {
                return this._tileProperties[index][id][name];
            }
            return null;
        };
        __proto.getSprite = function (index, width, height) {
            if (0 < this._tileTexSetArr.length) {
                var tGridSprite = new GridSprite();
                tGridSprite.initData(this, true);
                tGridSprite.size(width, height);
                var tTileTexSet = this._tileTexSetArr[index];
                if (tTileTexSet != null && tTileTexSet.texture != null) {
                    if (tTileTexSet.isAnimation) {
                        var tAnimationSprite = new TileAniSprite();
                        this._index++;
                        tAnimationSprite.setTileTextureSet(this._index.toString(), tTileTexSet);
                        tGridSprite.addAniSprite(tAnimationSprite);
                        tGridSprite.addChild(tAnimationSprite);
                    }
                    else {
                        tGridSprite.graphics.drawTexture(tTileTexSet.texture, 0, 0, width, height);
                    }
                    tGridSprite.drawImageNum++;
                }
                return tGridSprite;
            }
            return null;
        };
        __proto.setViewPortPivotByScale = function (scaleX, scaleY) {
            this._pivotScaleX = scaleX;
            this._pivotScaleY = scaleY;
            this._fastDirty = true;
        };
        __proto.moveViewPort = function (moveX, moveY) {
            this._x = -moveX;
            this._y = -moveY;
            if (this._fastDirty) {
                this._rect.x = moveX;
                this._rect.y = moveY;
                this.updateViewPort();
            }
            else {
                var dx = NaN, dy = NaN;
                dx = moveX - this._rect.x;
                dy = moveY - this._rect.y;
                this._rect.x = moveX;
                this._rect.y = moveY;
                this.updateViewPortFast(dx, dy);
            }
        };
        __proto.changeViewPort = function (moveX, moveY, width, height) {
            if (moveX == this._rect.x && moveY == this._rect.y && width == this._rect.width && height == this._rect.height)
                return;
            if (width == this._rect.width && height == this._rect.height) {
                this.moveViewPort(moveX, moveY);
                return;
            }
            this._fastDirty = true;
            this._x = -moveX;
            this._y = -moveY;
            this._rect.x = moveX;
            this._rect.y = moveY;
            this._rect.width = width;
            this._rect.height = height;
            this._viewPortWidth = width / this._scale;
            this._viewPortHeight = height / this._scale;
            this.updateViewPort();
        };
        __proto.changeViewPortBySize = function (width, height, rect) {
            if (rect == null) {
                rect = new Rectangle();
            }
            this._centerX = this._rect.x + this._rect.width * this._pivotScaleX;
            this._centerY = this._rect.y + this._rect.height * this._pivotScaleY;
            rect.x = this._centerX - width * this._pivotScaleX;
            rect.y = this._centerY - height * this._pivotScaleY;
            rect.width = width;
            rect.height = height;
            this.changeViewPort(rect.x, rect.y, rect.width, rect.height);
            return rect;
        };
        __proto.updateViewPortFast = function (dx, dy) {
            this._centerX += dx;
            this._centerY += dy;
            this._viewPortX += dx;
            this._viewPortY += dy;
            var posChanged = false;
            var dyG = dy / this._gridHeight;
            var dxG = dx / this._gridWidth;
            this._mapLogicRect.top += dyG;
            this._mapLogicRect.bottom += dyG;
            this._mapLogicRect.left += dxG;
            this._mapLogicRect.right += dxG;
            this._mapRect.top = 0 | this._mapLogicRect.top;
            this._mapRect.bottom = 0 | this._mapLogicRect.bottom;
            this._mapRect.left = 0 | this._mapLogicRect.left;
            this._mapRect.right = 0 | this._mapLogicRect.right;
            if (this._mapRect.top != this._mapLastRect.top || this._mapRect.bottom != this._mapLastRect.bottom || this._mapRect.left != this._mapLastRect.left || this._mapRect.right != this._mapLastRect.right) {
                this.clipViewPort();
                this._mapLastRect.top = this._mapRect.top;
                this._mapLastRect.bottom = this._mapRect.bottom;
                this._mapLastRect.left = this._mapRect.left;
                this._mapLastRect.right = this._mapRect.right;
                posChanged = true;
            }
            ;
            posChanged = posChanged || (dx != 0 || dy != 0);
            if (!posChanged)
                return;
            this.updateMapLayersPos();
        };
        __proto.updateMapLayersPos = function () {
            var tMapLayer;
            var len = this._renderLayerArray.length;
            for (var i = 0; i < len; i++) {
                tMapLayer = this._renderLayerArray[i];
                if (tMapLayer._gridSpriteArray.length > 0) {
                    tMapLayer.updateAloneObject();
                    tMapLayer.pos(-this._viewPortX, -this._viewPortY);
                }
            }
        };
        __proto.updateViewPort = function () {
            this._fastDirty = false;
            var dw = this._rect.width * this._pivotScaleX;
            var dh = this._rect.height * this._pivotScaleY;
            this._centerX = this._rect.x + dw;
            this._centerY = this._rect.y + dh;
            var posChanged = false;
            var preValue = this._viewPortX;
            this._viewPortX = this._centerX - dw / this._scale;
            if (preValue != this._viewPortX) {
                posChanged = true;
            }
            else {
                preValue = this._viewPortY;
            }
            this._viewPortY = this._centerY - dh / this._scale;
            if (!posChanged && preValue != this._viewPortY) {
                posChanged = true;
            }
            if (this._limitRange) {
                var tRight = this._viewPortX + this._viewPortWidth;
                if (tRight > this._width) {
                    this._viewPortX = this._width - this._viewPortWidth;
                }
                ;
                var tBottom = this._viewPortY + this._viewPortHeight;
                if (tBottom > this._height) {
                    this._viewPortY = this._height - this._viewPortHeight;
                }
                if (this._viewPortX < 0) {
                    this._viewPortX = 0;
                }
                if (this._viewPortY < 0) {
                    this._viewPortY = 0;
                }
            }
            ;
            var tPaddingRect = this._paddingRect;
            this._mapLogicRect.top = (this._viewPortY - tPaddingRect.y) / this._gridHeight;
            this._mapLogicRect.bottom = (this._viewPortY + this._viewPortHeight + tPaddingRect.height + tPaddingRect.y) / this._gridHeight;
            this._mapLogicRect.left = (this._viewPortX - tPaddingRect.x) / this._gridWidth;
            this._mapLogicRect.right = (this._viewPortX + this._viewPortWidth + tPaddingRect.width + tPaddingRect.x) / this._gridWidth;
            this._mapRect.top = 0 | this._mapLogicRect.top;
            this._mapRect.bottom = 0 | this._mapLogicRect.bottom;
            this._mapRect.left = 0 | this._mapLogicRect.left;
            this._mapRect.right = 0 | this._mapLogicRect.right;
            if (this._mapRect.top != this._mapLastRect.top || this._mapRect.bottom != this._mapLastRect.bottom || this._mapRect.left != this._mapLastRect.left || this._mapRect.right != this._mapLastRect.right) {
                this.clipViewPort();
                this._mapLastRect.top = this._mapRect.top;
                this._mapLastRect.bottom = this._mapRect.bottom;
                this._mapLastRect.left = this._mapRect.left;
                this._mapLastRect.right = this._mapRect.right;
                posChanged = true;
            }
            if (!posChanged)
                return;
            this.updateMapLayersPos();
        };
        __proto.clipViewPort = function () {
            var tSpriteNum = 0;
            var tSprite;
            var tIndex = 0;
            var tSub = 0;
            var tAdd = 0;
            var i = 0, j = 0;
            if (this._mapRect.left > this._mapLastRect.left) {
                tSub = this._mapRect.left - this._mapLastRect.left;
                if (tSub > 0) {
                    for (j = this._mapLastRect.left; j < this._mapLastRect.left + tSub; j++) {
                        for (i = this._mapLastRect.top; i <= this._mapLastRect.bottom; i++) {
                            this.hideGrid(j, i);
                        }
                    }
                }
            }
            else {
                tAdd = Math.min(this._mapLastRect.left, this._mapRect.right + 1) - this._mapRect.left;
                if (tAdd > 0) {
                    for (j = this._mapRect.left; j < this._mapRect.left + tAdd; j++) {
                        for (i = this._mapRect.top; i <= this._mapRect.bottom; i++) {
                            this.showGrid(j, i);
                        }
                    }
                }
            }
            if (this._mapRect.right > this._mapLastRect.right) {
                tAdd = this._mapRect.right - this._mapLastRect.right;
                if (tAdd > 0) {
                    for (j = Math.max(this._mapLastRect.right + 1, this._mapRect.left); j <= this._mapLastRect.right + tAdd; j++) {
                        for (i = this._mapRect.top; i <= this._mapRect.bottom; i++) {
                            this.showGrid(j, i);
                        }
                    }
                }
            }
            else {
                tSub = this._mapLastRect.right - this._mapRect.right;
                if (tSub > 0) {
                    for (j = this._mapRect.right + 1; j <= this._mapRect.right + tSub; j++) {
                        for (i = this._mapLastRect.top; i <= this._mapLastRect.bottom; i++) {
                            this.hideGrid(j, i);
                        }
                    }
                }
            }
            if (this._mapRect.top > this._mapLastRect.top) {
                tSub = this._mapRect.top - this._mapLastRect.top;
                if (tSub > 0) {
                    for (i = this._mapLastRect.top; i < this._mapLastRect.top + tSub; i++) {
                        for (j = this._mapLastRect.left; j <= this._mapLastRect.right; j++) {
                            this.hideGrid(j, i);
                        }
                    }
                }
            }
            else {
                tAdd = Math.min(this._mapLastRect.top, this._mapRect.bottom + 1) - this._mapRect.top;
                if (tAdd > 0) {
                    for (i = this._mapRect.top; i < this._mapRect.top + tAdd; i++) {
                        for (j = this._mapRect.left; j <= this._mapRect.right; j++) {
                            this.showGrid(j, i);
                        }
                    }
                }
            }
            if (this._mapRect.bottom > this._mapLastRect.bottom) {
                tAdd = this._mapRect.bottom - this._mapLastRect.bottom;
                if (tAdd > 0) {
                    for (i = Math.max(this._mapLastRect.bottom + 1, this._mapRect.top); i <= this._mapLastRect.bottom + tAdd; i++) {
                        for (j = this._mapRect.left; j <= this._mapRect.right; j++) {
                            this.showGrid(j, i);
                        }
                    }
                }
            }
            else {
                tSub = this._mapLastRect.bottom - this._mapRect.bottom;
                if (tSub > 0) {
                    for (i = this._mapRect.bottom + 1; i <= this._mapRect.bottom + tSub; i++) {
                        for (j = this._mapLastRect.left; j <= this._mapLastRect.right; j++) {
                            this.hideGrid(j, i);
                        }
                    }
                }
            }
        };
        __proto.showGrid = function (gridX, gridY) {
            if (gridX < 0 || gridX >= this._gridW || gridY < 0 || gridY >= this._gridH) {
                return;
            }
            ;
            var i = 0, j = 0;
            var tGridSprite;
            var tTempArray = this._gridArray[gridY][gridX];
            if (tTempArray == null) {
                tTempArray = this.getGridArray(gridX, gridY);
            }
            else {
                for (i = 0; i < tTempArray.length && i < this._layerArray.length; i++) {
                    var tLayerSprite = this._layerArray[i];
                    if (tLayerSprite && tTempArray[i]) {
                        tGridSprite = tTempArray[i];
                        if (tGridSprite.visible == false && tGridSprite.drawImageNum > 0) {
                            tGridSprite.show();
                        }
                    }
                }
            }
        };
        __proto.cacheAllGrid = function () {
            var i = 0, j = 0;
            var tempArr;
            for (i = 0; i < this._gridW; i++) {
                for (j = 0; j < this._gridH; j++) {
                    tempArr = this.getGridArray(i, j);
                    this.cacheGridsArray(tempArr);
                }
            }
        };
        __proto.cacheGridsArray = function (arr) {
            var canvas;
            if (!TiledMap._tempContext) {
                TiledMap._tempContext = new RenderContext(1, 1, HTMLCanvas.create("AUTO"));
            }
            canvas = TiledMap._tempContext.canvas;
            canvas.context.asBitmap = false;
            var i = 0, len = 0;
            len = arr.length;
            var tGrid;
            for (i = 0; i < len; i++) {
                tGrid = arr[i];
                canvas.clear();
                canvas.size(1, 1);
                tGrid.render(TiledMap._tempContext, 0, 0);
                tGrid.hide();
            }
            canvas.clear();
            canvas.size(1, 1);
        };
        __proto.getGridArray = function (gridX, gridY) {
            var i = 0, j = 0;
            var tGridSprite;
            var tTempArray = this._gridArray[gridY][gridX];
            if (tTempArray == null) {
                tTempArray = this._gridArray[gridY][gridX] = [];
                var tLeft = 0;
                var tRight = 0;
                var tTop = 0;
                var tBottom = 0;
                var tGridWidth = this._gridWidth;
                var tGridHeight = this._gridHeight;
                switch (this.orientation) {
                    case "isometric":
                        tLeft = Math.floor(gridX * tGridWidth);
                        tRight = Math.floor(gridX * tGridWidth + tGridWidth);
                        tTop = Math.floor(gridY * tGridHeight);
                        tBottom = Math.floor(gridY * tGridHeight + tGridHeight);
                        var tLeft1 = 0, tRight1 = 0, tTop1 = 0, tBottom1 = 0;
                        break;
                    case "staggered":
                        tLeft = Math.floor(gridX * tGridWidth / this._mapTileW);
                        tRight = Math.floor((gridX * tGridWidth + tGridWidth) / this._mapTileW);
                        tTop = Math.floor(gridY * tGridHeight / (this._mapTileH / 2));
                        tBottom = Math.floor((gridY * tGridHeight + tGridHeight) / (this._mapTileH / 2));
                        break;
                    case "orthogonal":
                        tLeft = Math.floor(gridX * tGridWidth / this._mapTileW);
                        tRight = Math.floor((gridX * tGridWidth + tGridWidth) / this._mapTileW);
                        tTop = Math.floor(gridY * tGridHeight / this._mapTileH);
                        tBottom = Math.floor((gridY * tGridHeight + tGridHeight) / this._mapTileH);
                        break;
                    case "hexagonal":
                        ;
                        var tHeight = this._mapTileH * 2 / 3;
                        tLeft = Math.floor(gridX * tGridWidth / this._mapTileW);
                        tRight = Math.ceil((gridX * tGridWidth + tGridWidth) / this._mapTileW);
                        tTop = Math.floor(gridY * tGridHeight / tHeight);
                        tBottom = Math.ceil((gridY * tGridHeight + tGridHeight) / tHeight);
                        break;
                }
                ;
                var tLayer = null;
                var tTGridSprite;
                var tDrawMapLayer;
                for (var z = 0; z < this._layerArray.length; z++) {
                    tLayer = this._layerArray[z];
                    if (this.enableMergeLayer) {
                        if (tLayer.tarLayer != tDrawMapLayer) {
                            tTGridSprite = null;
                            tDrawMapLayer = tLayer.tarLayer;
                        }
                        if (!tTGridSprite) {
                            tTGridSprite = tDrawMapLayer.getDrawSprite(gridX, gridY);
                            tTempArray.push(tTGridSprite);
                        }
                        tGridSprite = tTGridSprite;
                    }
                    else {
                        tGridSprite = tLayer.getDrawSprite(gridX, gridY);
                        tTempArray.push(tGridSprite);
                    }
                    ;
                    var tColorStr;
                    if (this._showGridKey) {
                        tColorStr = "#";
                        tColorStr += this._colorArray[Math.floor(Math.random() * this._colorArray.length)];
                        tColorStr += this._colorArray[Math.floor(Math.random() * this._colorArray.length)];
                        tColorStr += this._colorArray[Math.floor(Math.random() * this._colorArray.length)];
                    }
                    switch (this.orientation) {
                        case "isometric":
                            ;
                            var tHalfTileHeight = this.tileHeight / 2;
                            var tHalfTileWidth = this.tileWidth / 2;
                            var tHalfMapWidth = this._width / 2;
                            tTop1 = Math.floor(tTop / tHalfTileHeight);
                            tBottom1 = Math.floor(tBottom / tHalfTileHeight);
                            tLeft1 = this._mapW + Math.floor((tLeft - tHalfMapWidth) / tHalfTileWidth);
                            tRight1 = this._mapW + Math.floor((tRight - tHalfMapWidth) / tHalfTileWidth);
                            var tMapW = this._mapW * 2;
                            var tMapH = this._mapH * 2;
                            if (tTop1 < 0) {
                                tTop1 = 0;
                            }
                            if (tTop1 >= tMapH) {
                                tTop1 = tMapH - 1;
                            }
                            if (tBottom1 < 0) {
                                tBottom = 0;
                            }
                            if (tBottom1 >= tMapH) {
                                tBottom1 = tMapH - 1;
                            }
                            tGridSprite.zOrder = this._totalGridNum * z + gridY * this._gridW + gridX;
                            for (i = tTop1; i < tBottom1; i++) {
                                for (j = 0; j <= i; j++) {
                                    var tIndexX = i - j;
                                    var tIndexY = j;
                                    var tIndexValue = (tIndexX - tIndexY) + this._mapW;
                                    if (tIndexValue > tLeft1 && tIndexValue <= tRight1) {
                                        if (tLayer.drawTileTexture(tGridSprite, tIndexX, tIndexY)) {
                                            tGridSprite.drawImageNum++;
                                        }
                                    }
                                }
                            }
                            break;
                        case "staggered":
                            tGridSprite.zOrder = z * this._totalGridNum + gridY * this._gridW + gridX;
                            for (i = tTop; i < tBottom; i++) {
                                for (j = tLeft; j < tRight; j++) {
                                    if (tLayer.drawTileTexture(tGridSprite, j, i)) {
                                        tGridSprite.drawImageNum++;
                                    }
                                }
                            }
                            break;
                        case "orthogonal":
                        case "hexagonal":
                            switch (this._renderOrder) {
                                case "right-down":
                                    tGridSprite.zOrder = z * this._totalGridNum + gridY * this._gridW + gridX;
                                    for (i = tTop; i < tBottom; i++) {
                                        for (j = tLeft; j < tRight; j++) {
                                            if (tLayer.drawTileTexture(tGridSprite, j, i)) {
                                                tGridSprite.drawImageNum++;
                                            }
                                        }
                                    }
                                    break;
                                case "right-up":
                                    tGridSprite.zOrder = z * this._totalGridNum + (this._gridH - 1 - gridY) * this._gridW + gridX;
                                    for (i = tBottom - 1; i >= tTop; i--) {
                                        for (j = tLeft; j < tRight; j++) {
                                            if (tLayer.drawTileTexture(tGridSprite, j, i)) {
                                                tGridSprite.drawImageNum++;
                                            }
                                        }
                                    }
                                    break;
                                case "left-down":
                                    tGridSprite.zOrder = z * this._totalGridNum + gridY * this._gridW + (this._gridW - 1 - gridX);
                                    for (i = tTop; i < tBottom; i++) {
                                        for (j = tRight - 1; j >= tLeft; j--) {
                                            if (tLayer.drawTileTexture(tGridSprite, j, i)) {
                                                tGridSprite.drawImageNum++;
                                            }
                                        }
                                    }
                                    break;
                                case "left-up":
                                    tGridSprite.zOrder = z * this._totalGridNum + (this._gridH - 1 - gridY) * this._gridW + (this._gridW - 1 - gridX);
                                    for (i = tBottom - 1; i >= tTop; i--) {
                                        for (j = tRight - 1; j >= tLeft; j--) {
                                            if (tLayer.drawTileTexture(tGridSprite, j, i)) {
                                                tGridSprite.drawImageNum++;
                                            }
                                        }
                                    }
                                    break;
                            }
                            break;
                    }
                    if (!tGridSprite.isHaveAnimation) {
                        tGridSprite.autoSize = true;
                        if (this.autoCache)
                            tGridSprite.cacheAs = this.autoCacheType;
                        tGridSprite.autoSize = false;
                    }
                    if (!this.enableMergeLayer) {
                        if (tGridSprite.drawImageNum > 0) {
                            tLayer.addChild(tGridSprite);
                            tGridSprite.visible = false;
                            tGridSprite.show();
                        }
                        if (this._showGridKey) {
                            tGridSprite.graphics.drawRect(0, 0, tGridWidth, tGridHeight, null, tColorStr);
                        }
                    }
                    else {
                        if (tTGridSprite && tTGridSprite.drawImageNum > 0 && tDrawMapLayer) {
                            tDrawMapLayer.addChild(tTGridSprite);
                            tTGridSprite.visible = false;
                            tTGridSprite.show();
                        }
                    }
                }
                if (this.enableMergeLayer && this.showGridTextureCount) {
                    if (tTGridSprite) {
                        tTGridSprite.graphics.fillText(tTGridSprite.drawImageNum + "", 20, 20, null, "#ff0000", "left");
                    }
                }
            }
            return tTempArray;
        };
        __proto.hideGrid = function (gridX, gridY) {
            if (gridX < 0 || gridX >= this._gridW || gridY < 0 || gridY >= this._gridH) {
                return;
            }
            ;
            var tTempArray = this._gridArray[gridY][gridX];
            if (tTempArray) {
                var tGridSprite;
                for (var i = 0; i < tTempArray.length; i++) {
                    tGridSprite = tTempArray[i];
                    if (tGridSprite.drawImageNum > 0) {
                        if (tGridSprite != null) {
                            tGridSprite.hide();
                        }
                    }
                }
            }
        };
        __proto.getLayerObject = function (layerName, objectName) {
            var tLayer = null;
            for (var i = 0; i < this._layerArray.length; i++) {
                tLayer = this._layerArray[i];
                if (tLayer.layerName == layerName) {
                    break;
                }
            }
            if (tLayer) {
                return tLayer.getObjectByName(objectName);
            }
            return null;
        };
        __proto.destroy = function () {
            this._orientation = "orthogonal";
            this._jsonData = null;
            var i = 0;
            var j = 0;
            var z = 0;
            this._gridArray = [];
            var tTileTexSet;
            for (i = 0; i < this._tileTexSetArr.length; i++) {
                tTileTexSet = this._tileTexSetArr[i];
                if (tTileTexSet) {
                    tTileTexSet.clearAll();
                }
            }
            this._tileTexSetArr = [];
            var tTexture;
            for (i = 0; i < this._texArray.length; i++) {
                tTexture = this._texArray[i];
                tTexture.destroy();
            }
            this._texArray = [];
            this._width = 0;
            this._height = 0;
            this._mapW = 0;
            this._mapH = 0;
            this._mapTileW = 0;
            this._mapTileH = 0;
            this._rect.setTo(0, 0, 0, 0);
            var tLayer;
            for (i = 0; i < this._layerArray.length; i++) {
                tLayer = this._layerArray[i];
                tLayer.clearAll();
            }
            this._layerArray = [];
            this._renderLayerArray = [];
            if (this._mapSprite) {
                this._mapSprite.destroy();
                this._mapSprite = null;
            }
            this._jsonLoader = null;
            this._loader = null;
            var tDic = this._animationDic;
            for (var p in tDic) {
                delete tDic[p];
            }
            this._properties = null;
            tDic = this._tileProperties;
            for (p in tDic) {
                delete tDic[p];
            }
            this._currTileSet = null;
            this._completeHandler = null;
            this._mapRect.clearAll();
            this._mapLastRect.clearAll();
            this._tileSetArray = [];
            this._gridWidth = 450;
            this._gridHeight = 450;
            this._gridW = 0;
            this._gridH = 0;
            this._x = 0;
            this._y = 0;
            this._index = 0;
            this._enableLinear = true;
            this._resPath = null;
            this._pathArray = null;
        };
        __proto.mapSprite = function () {
            return this._mapSprite;
        };
        __proto.getLayerByName = function (layerName) {
            var tMapLayer;
            for (var i = 0; i < this._layerArray.length; i++) {
                tMapLayer = this._layerArray[i];
                if (layerName == tMapLayer.layerName) {
                    return tMapLayer;
                }
            }
            return null;
        };
        __proto.getLayerByIndex = function (index) {
            if (index < this._layerArray.length) {
                return this._layerArray[index];
            }
            return null;
        };
        __getset(0, __proto, 'orientation', function () {
            return this._orientation;
        });
        __getset(0, __proto, 'viewPortX', function () {
            return -this._viewPortX;
        });
        __getset(0, __proto, 'scale', function () {
            return this._scale;
        }, function (scale) {
            if (scale <= 0)
                return;
            this._scale = scale;
            this._viewPortWidth = this._rect.width / scale;
            this._viewPortHeight = this._rect.height / scale;
            this._mapSprite.scale(this._scale, this._scale);
            this.updateViewPort();
        });
        __getset(0, __proto, 'tileWidth', function () {
            return this._mapTileW;
        });
        __getset(0, __proto, 'viewPortY', function () {
            return -this._viewPortY;
        });
        __getset(0, __proto, 'tileHeight', function () {
            return this._mapTileH;
        });
        __getset(0, __proto, 'width', function () {
            return this._width;
        });
        __getset(0, __proto, 'numRowsTile', function () {
            return this._mapH;
        });
        __getset(0, __proto, 'numColumnsTile', function () {
            return this._mapW;
        });
        __getset(0, __proto, 'height', function () {
            return this._height;
        });
        __getset(0, __proto, 'viewPortWidth', function () {
            return this._viewPortWidth;
        });
        __getset(0, __proto, 'viewPortHeight', function () {
            return this._viewPortHeight;
        });
        __getset(0, __proto, 'x', function () {
            return this._x;
        });
        __getset(0, __proto, 'y', function () {
            return this._y;
        });
        __getset(0, __proto, 'gridWidth', function () {
            return this._gridWidth;
        });
        __getset(0, __proto, 'gridHeight', function () {
            return this._gridHeight;
        });
        __getset(0, __proto, 'numColumnsGrid', function () {
            return this._gridW;
        });
        __getset(0, __proto, 'numRowsGrid', function () {
            return this._gridH;
        });
        __getset(0, __proto, 'renderOrder', function () {
            return this._renderOrder;
        });
        TiledMap.ORIENTATION_ORTHOGONAL = "orthogonal";
        TiledMap.ORIENTATION_ISOMETRIC = "isometric";
        TiledMap.ORIENTATION_STAGGERED = "staggered";
        TiledMap.ORIENTATION_HEXAGONAL = "hexagonal";
        TiledMap.RENDERORDER_RIGHTDOWN = "right-down";
        TiledMap.RENDERORDER_RIGHTUP = "right-up";
        TiledMap.RENDERORDER_LEFTDOWN = "left-down";
        TiledMap.RENDERORDER_LEFTUP = "left-up";
        TiledMap._tempContext = null;
        TiledMap.__init$ = function () {
            GRect = (function () {
                function GRect() {
                    this.left = 0;
                    this.top = 0;
                    this.right = 0;
                    this.bottom = 0;
                }
                __class(GRect, '');
                var __proto = GRect.prototype;
                __proto.clearAll = function () {
                    this.left = this.top = this.right = this.bottom = 0;
                };
                return GRect;
            })();
            TileMapAniData = (function () {
                function TileMapAniData() {
                    this.mAniIdArray = [];
                    this.mDurationTimeArray = [];
                    this.mTileTexSetArr = [];
                    this.image = null;
                }
                __class(TileMapAniData, '');
                return TileMapAniData;
            })();
            TileSet = (function () {
                function TileSet() {
                    this.firstgid = 0;
                    this.image = "";
                    this.imageheight = 0;
                    this.imagewidth = 0;
                    this.margin = 0;
                    this.name = 0;
                    this.properties = null;
                    this.spacing = 0;
                    this.tileheight = 0;
                    this.tilewidth = 0;
                    this.titleoffsetX = 0;
                    this.titleoffsetY = 0;
                    this.tileproperties = null;
                }
                __class(TileSet, '');
                var __proto = TileSet.prototype;
                __proto.init = function (data) {
                    this.firstgid = data.firstgid;
                    this.image = data.image;
                    this.imageheight = data.imageheight;
                    this.imagewidth = data.imagewidth;
                    this.margin = data.margin;
                    this.name = data.name;
                    this.properties = data.properties;
                    this.spacing = data.spacing;
                    this.tileheight = data.tileheight;
                    this.tilewidth = data.tilewidth;
                    this.tileproperties = data.tileproperties;
                    var tTileoffset = data.tileoffset;
                    if (tTileoffset) {
                        this.titleoffsetX = tTileoffset.x;
                        this.titleoffsetY = tTileoffset.y;
                    }
                };
                return TileSet;
            })();
        };
        return TiledMap;
    })();
    var TileTexSet = (function () {
        function TileTexSet() {
            this.gid = -1;
            this.texture = null;
            this.offX = 0;
            this.offY = 0;
            this.textureArray = null;
            this.durationTimeArray = null;
            this.animationTotalTime = 0;
            this.isAnimation = false;
            this._spriteNum = 0;
            this._aniDic = null;
            this._frameIndex = 0;
            this._time = 0;
            this._interval = 0;
            this._preFrameTime = 0;
        }
        __class(TileTexSet, 'laya.map.TileTexSet');
        var __proto = TileTexSet.prototype;
        __proto.addAniSprite = function (aniName, sprite) {
            if (this.animationTotalTime == 0) {
                return;
            }
            if (this._aniDic == null) {
                this._aniDic = {};
            }
            if (this._spriteNum == 0) {
                Laya.timer.frameLoop(3, this, this.animate);
                this._preFrameTime = Browser.now();
                this._frameIndex = 0;
                this._time = 0;
                this._interval = 0;
            }
            this._spriteNum++;
            this._aniDic[aniName] = sprite;
            if (this.textureArray && this._frameIndex < this.textureArray.length) {
                var tTileTextureSet = this.textureArray[this._frameIndex];
                this.drawTexture(sprite, tTileTextureSet);
            }
        };
        __proto.animate = function () {
            if (this.textureArray && this.textureArray.length > 0 && this.durationTimeArray && this.durationTimeArray.length > 0) {
                var tNow = Browser.now();
                this._interval = tNow - this._preFrameTime;
                this._preFrameTime = tNow;
                if (this._interval > this.animationTotalTime) {
                    this._interval = this._interval % this.animationTotalTime;
                }
                this._time += this._interval;
                var tTime = this.durationTimeArray[this._frameIndex];
                while (this._time > tTime) {
                    this._time -= tTime;
                    this._frameIndex++;
                    if (this._frameIndex >= this.durationTimeArray.length || this._frameIndex >= this.textureArray.length) {
                        this._frameIndex = 0;
                    }
                    ;
                    var tTileTextureSet = this.textureArray[this._frameIndex];
                    var tSprite;
                    for (var p in this._aniDic) {
                        tSprite = this._aniDic[p];
                        this.drawTexture(tSprite, tTileTextureSet);
                    }
                    tTime = this.durationTimeArray[this._frameIndex];
                }
            }
        };
        __proto.drawTexture = function (sprite, tileTextSet) {
            sprite.graphics.clear();
            sprite.graphics.drawTexture(tileTextSet.texture, tileTextSet.offX, tileTextSet.offY);
        };
        __proto.removeAniSprite = function (_name) {
            if (this._aniDic && this._aniDic[_name]) {
                delete this._aniDic[_name];
                this._spriteNum--;
                if (this._spriteNum == 0) {
                    Laya.timer.clear(this, this.animate);
                }
            }
        };
        __proto.showDebugInfo = function () {
            var tInfo = null;
            if (this._spriteNum > 0) {
                tInfo = "TileTextureSet::gid:" + this.gid.toString() + " 动画数:" + this._spriteNum.toString();
            }
            return tInfo;
        };
        __proto.clearAll = function () {
            this.gid = -1;
            if (this.texture) {
                this.texture.destroy();
                this.texture = null;
            }
            this.offX = 0;
            this.offY = 0;
            this.textureArray = null;
            this.durationTimeArray = null;
            this.isAnimation = false;
            this._spriteNum = 0;
            this._aniDic = null;
            this._frameIndex = 0;
            this._preFrameTime = 0;
            this._time = 0;
            this._interval = 0;
        };
        return TileTexSet;
    })();
    var GridSprite = (function (_super) {
        function GridSprite() {
            this.relativeX = 0;
            this.relativeY = 0;
            this.isAloneObject = false;
            this.isHaveAnimation = false;
            this.aniSpriteArray = null;
            this.drawImageNum = 0;
            this._map = null;
            GridSprite.__super.call(this);
        }
        __class(GridSprite, 'laya.map.GridSprite', _super);
        var __proto = GridSprite.prototype;
        __proto.initData = function (map, objectKey) {
            (objectKey === void 0) && (objectKey = false);
            this._map = map;
            this.isAloneObject = objectKey;
        };
        __proto._setDisplay = function (value) {
            if (!value) {
                var cc = this._$P.cacheCanvas;
                if (cc && cc.ctx) {
                    cc.ctx.canvas.destroy();
                    cc.ctx = null;
                }
                ;
                var fc = this._$P._filterCache;
                if (fc) {
                    fc.destroy();
                    fc.recycle();
                    this._set$P('_filterCache', null);
                }
                this._$P._isHaveGlowFilter && this._set$P('_isHaveGlowFilter', false);
            }
            _super.prototype._setDisplay.call(this, value);
        };
        __proto.addAniSprite = function (sprite) {
            if (this.aniSpriteArray == null) {
                this.aniSpriteArray = [];
            }
            this.aniSpriteArray.push(sprite);
        };
        __proto.show = function () {
            if (!this.visible) {
                this.visible = true;
                if (!this.isAloneObject) {
                    var tParent;
                    tParent = this.parent;
                    if (tParent) {
                        tParent.showGridSprite(this);
                    }
                }
                if (!Render.isWebGL && this._map.autoCache) {
                    this.cacheAs = this._map.autoCacheType;
                }
                if (this.aniSpriteArray == null) {
                    return;
                }
                ;
                var tAniSprite;
                for (var i = 0; i < this.aniSpriteArray.length; i++) {
                    tAniSprite = this.aniSpriteArray[i];
                    tAniSprite.show();
                }
            }
        };
        __proto.hide = function () {
            if (this.visible) {
                this.visible = false;
                if (!this.isAloneObject) {
                    var tParent;
                    tParent = this.parent;
                    if (tParent) {
                        tParent.hideGridSprite(this);
                    }
                }
                if (!Render.isWebGL && this._map.autoCache) {
                    this.cacheAs = "none";
                }
                if (this.aniSpriteArray == null) {
                    return;
                }
                ;
                var tAniSprite;
                for (var i = 0; i < this.aniSpriteArray.length; i++) {
                    tAniSprite = this.aniSpriteArray[i];
                    tAniSprite.hide();
                }
            }
        };
        __proto.updatePos = function () {
            if (this.isAloneObject) {
                if (this._map) {
                    this.x = this.relativeX;
                    this.y = this.relativeY;
                }
                if (this.x < 0 || this.x > this._map.viewPortWidth || this.y < 0 || this.y > this._map.viewPortHeight) {
                    this.hide();
                }
                else {
                    this.show();
                }
            }
            else {
                if (this._map) {
                    this.x = this.relativeX;
                    this.y = this.relativeY;
                }
            }
        };
        __proto.clearAll = function () {
            if (this._map) {
                this._map = null;
            }
            this.visible = false;
            if (this.aniSpriteArray == null) {
                return;
            }
            ;
            var tAniSprite;
            for (var i = 0; i < this.aniSpriteArray.length; i++) {
                tAniSprite = this.aniSpriteArray[i];
                tAniSprite.clearAll();
            }
            this.destroy();
            this.relativeX = 0;
            this.relativeY = 0;
            this.isHaveAnimation = false;
            this.aniSpriteArray = null;
            this.drawImageNum = 0;
        };
        return GridSprite;
    })(Sprite);
    var MapLayer = (function (_super) {
        function MapLayer() {
            this._map = null;
            this._mapData = null;
            this._tileWidthHalf = 0;
            this._tileHeightHalf = 0;
            this._mapWidthHalf = 0;
            this._mapHeightHalf = 0;
            this._gridSpriteArray = [];
            this._objDic = null;
            this._dataDic = null;
            this._properties = null;
            this.tarLayer = null;
            this.layerName = null;
            this._showGridList = [];
            this._aloneObjs = [];
            MapLayer.__super.call(this);
            this._tempMapPos = new Point();
        }
        __class(MapLayer, 'laya.map.MapLayer', _super);
        var __proto = MapLayer.prototype;
        __proto.init = function (layerData, map) {
            this._map = map;
            this._mapData = layerData.data;
            var tHeight = layerData.height;
            var tWidth = layerData.width;
            var tTileW = map.tileWidth;
            var tTileH = map.tileHeight;
            this.layerName = layerData.name;
            this._properties = layerData.properties;
            this.alpha = layerData.opacity;
            this._tileWidthHalf = tTileW / 2;
            this._tileHeightHalf = tTileH / 2;
            this._mapWidthHalf = this._map.width / 2 - this._tileWidthHalf;
            this._mapHeightHalf = this._map.height / 2;
            switch (layerData.type) {
                case "tilelayer":
                    break;
                case "objectgroup":
                    ;
                    var tObjectGid = 0;
                    var tArray = layerData.objects;
                    if (tArray.length > 0) {
                        this._objDic = {};
                        this._dataDic = {};
                    }
                    ;
                    var tObjectData;
                    var tObjWidth = NaN;
                    var tObjHeight = NaN;
                    for (var i = 0; i < tArray.length; i++) {
                        tObjectData = tArray[i];
                        this._dataDic[tObjectData.name] = tObjectData;
                        if (tObjectData.visible == true) {
                            tObjWidth = tObjectData.width;
                            tObjHeight = tObjectData.height;
                            var tSprite = map.getSprite(tObjectData.gid, tObjWidth, tObjHeight);
                            if (tSprite != null) {
                                switch (this._map.orientation) {
                                    case "isometric":
                                        this.getScreenPositionByTilePos(tObjectData.x / tTileH, tObjectData.y / tTileH, Point.TEMP);
                                        tSprite.pivot(tObjWidth / 2, tObjHeight / 2);
                                        tSprite.rotation = tObjectData.rotation;
                                        tSprite.x = tSprite.relativeX = Point.TEMP.x + this._map.viewPortX;
                                        tSprite.y = tSprite.relativeY = Point.TEMP.y + this._map.viewPortY - tObjHeight / 2;
                                        break;
                                    case "staggered":
                                        tSprite.pivot(tObjWidth / 2, tObjHeight / 2);
                                        tSprite.rotation = tObjectData.rotation;
                                        tSprite.x = tSprite.relativeX = tObjectData.x + tObjWidth / 2;
                                        tSprite.y = tSprite.relativeY = tObjectData.y - tObjHeight / 2;
                                        break;
                                    case "orthogonal":
                                        tSprite.pivot(tObjWidth / 2, tObjHeight / 2);
                                        tSprite.rotation = tObjectData.rotation;
                                        tSprite.x = tSprite.relativeX = tObjectData.x + tObjWidth / 2;
                                        tSprite.y = tSprite.relativeY = tObjectData.y - tObjHeight / 2;
                                        break;
                                    case "hexagonal":
                                        tSprite.x = tSprite.relativeX = tObjectData.x;
                                        tSprite.y = tSprite.relativeY = tObjectData.y;
                                        break;
                                }
                                this.addChild(tSprite);
                                this._gridSpriteArray.push(tSprite);
                                if (tSprite.isAloneObject) {
                                    this._showGridList.push(tSprite);
                                    this._aloneObjs.push(tSprite);
                                }
                                this._objDic[tObjectData.name] = tSprite;
                            }
                        }
                    }
                    break;
            }
        };
        __proto.getObjectByName = function (objName) {
            if (this._objDic) {
                return this._objDic[objName];
            }
            return null;
        };
        __proto.getObjectDataByName = function (objName) {
            if (this._dataDic) {
                return this._dataDic[objName];
            }
            return null;
        };
        __proto.getLayerProperties = function (name) {
            if (this._properties) {
                return this._properties[name];
            }
            return null;
        };
        __proto.getTileData = function (tileX, tileY) {
            if (tileY >= 0 && tileY < this._map.numRowsTile && tileX >= 0 && tileX < this._map.numColumnsTile) {
                var tIndex = tileY * this._map.numColumnsTile + tileX;
                var tMapData = this._mapData;
                if (tMapData != null && tIndex < tMapData.length) {
                    return tMapData[tIndex];
                }
            }
            return 0;
        };
        __proto.getScreenPositionByTilePos = function (tileX, tileY, screenPos) {
            if (screenPos) {
                switch (this._map.orientation) {
                    case "isometric":
                        screenPos.x = this._map.width / 2 - (tileY - tileX) * this._tileWidthHalf;
                        screenPos.y = (tileY + tileX) * this._tileHeightHalf;
                        break;
                    case "staggered":
                        tileX = Math.floor(tileX);
                        tileY = Math.floor(tileY);
                        screenPos.x = tileX * this._map.tileWidth + (tileY & 1) * this._tileWidthHalf;
                        screenPos.y = tileY * this._tileHeightHalf;
                        break;
                    case "orthogonal":
                        screenPos.x = tileX * this._map.tileWidth;
                        screenPos.y = tileY * this._map.tileHeight;
                        break;
                    case "hexagonal":
                        tileX = Math.floor(tileX);
                        tileY = Math.floor(tileY);
                        var tTileHeight = this._map.tileHeight * 2 / 3;
                        screenPos.x = (tileX * this._map.tileWidth + tileY % 2 * this._tileWidthHalf) % this._map.gridWidth;
                        screenPos.y = (tileY * tTileHeight) % this._map.gridHeight;
                        break;
                }
                screenPos.x = (screenPos.x + this._map.viewPortX) * this._map.scale;
                screenPos.y = (screenPos.y + this._map.viewPortY) * this._map.scale;
            }
        };
        __proto.getTileDataByScreenPos = function (screenX, screenY) {
            var tData = 0;
            if (this.getTilePositionByScreenPos(screenX, screenY, this._tempMapPos)) {
                tData = this.getTileData(Math.floor(this._tempMapPos.x), Math.floor(this._tempMapPos.y));
            }
            return tData;
        };
        __proto.getTilePositionByScreenPos = function (screenX, screenY, result) {
            screenX = screenX / this._map.scale - this._map.viewPortX;
            screenY = screenY / this._map.scale - this._map.viewPortY;
            var tTileW = this._map.tileWidth;
            var tTileH = this._map.tileHeight;
            var tV = 0;
            var tU = 0;
            switch (this._map.orientation) {
                case "isometric":
                    ;
                    var tDirX = screenX - this._map.width / 2;
                    var tDirY = screenY;
                    tV = -(tDirX / tTileW - tDirY / tTileH);
                    tU = tDirX / tTileW + tDirY / tTileH;
                    if (result) {
                        result.x = tU;
                        result.y = tV;
                    }
                    return true;
                    break;
                case "staggered":
                    if (result) {
                        var cx = 0, cy = 0, rx = 0, ry = 0;
                        cx = Math.floor(screenX / tTileW) * tTileW + tTileW / 2;
                        cy = Math.floor(screenY / tTileH) * tTileH + tTileH / 2;
                        rx = (screenX - cx) * tTileH / 2;
                        ry = (screenY - cy) * tTileW / 2;
                        if (Math.abs(rx) + Math.abs(ry) <= tTileW * tTileH / 4) {
                            tU = Math.floor(screenX / tTileW);
                            tV = Math.floor(screenY / tTileH) * 2;
                        }
                        else {
                            screenX = screenX - tTileW / 2;
                            tU = Math.floor(screenX / tTileW) + 1;
                            screenY = screenY - tTileH / 2;
                            tV = Math.floor(screenY / tTileH) * 2 + 1;
                        }
                        result.x = tU - (tV & 1);
                        result.y = tV;
                    }
                    return true;
                    break;
                case "orthogonal":
                    tU = screenX / tTileW;
                    tV = screenY / tTileH;
                    if (result) {
                        result.x = tU;
                        result.y = tV;
                    }
                    return true;
                    break;
                case "hexagonal":
                    ;
                    var tTileHeight = tTileH * 2 / 3;
                    tV = screenY / tTileHeight;
                    tU = (screenX - tV % 2 * this._tileWidthHalf) / tTileW;
                    if (result) {
                        result.x = tU;
                        result.y = tV;
                    }
                    break;
            }
            return false;
        };
        __proto.getDrawSprite = function (gridX, gridY) {
            var tSprite = new GridSprite();
            tSprite.relativeX = gridX * this._map.gridWidth;
            tSprite.relativeY = gridY * this._map.gridHeight;
            tSprite.initData(this._map);
            tSprite.updatePos();
            this._gridSpriteArray.push(tSprite);
            return tSprite;
        };
        __proto.showGridSprite = function (gridSprite) {
            var gridList = this._showGridList;
            var i = 0, len = 0;
            len = gridList.length;
            var ok_i = -1;
            var tGridSprite;
            for (i = 0; i < len; i++) {
                tGridSprite = gridList[i];
                if (tGridSprite == gridSprite)
                    return;
                if (!tGridSprite.isAloneObject && !tGridSprite.visible) {
                    ok_i = i;
                }
            }
            if (ok_i >= 0) {
                gridList[ok_i] = gridSprite;
            }
            else {
                gridList.push(gridSprite);
            }
        };
        __proto.hideGridSprite = function (gridSprite) {
            gridSprite.visible = false;
        };
        __proto.updateGridPos = function () {
            var tSprite;
            var tList;
            tList = this._showGridList;
            var len = 0;
            len = tList.length;
            for (var i = 0; i < len; i++) {
                tSprite = tList[i];
                if ((tSprite._style.visible || tSprite.isAloneObject) && tSprite.drawImageNum > 0) {
                    tSprite.updatePos();
                }
            }
        };
        __proto.updateAloneObject = function () {
            var tSprite;
            var tList;
            tList = this._aloneObjs;
            var len = 0;
            len = tList.length;
            for (var i = 0; i < len; i++) {
                tSprite = tList[i];
                if (tSprite.drawImageNum > 0) {
                    tSprite.updatePos();
                }
            }
        };
        __proto.render = function (context, x, y) {
            var childs = this._childs;
            this._childs = this._showGridList;
            _super.prototype.render.call(this, context, x, y);
            this._childs = childs;
        };
        __proto.drawTileTexture = function (gridSprite, tileX, tileY) {
            if (tileY >= 0 && tileY < this._map.numRowsTile && tileX >= 0 && tileX < this._map.numColumnsTile) {
                var tIndex = tileY * this._map.numColumnsTile + tileX;
                var tMapData = this._mapData;
                if (tMapData != null && tIndex < tMapData.length) {
                    if (tMapData[tIndex] != 0) {
                        var tTileTexSet = this._map.getTexture(tMapData[tIndex]);
                        if (tTileTexSet) {
                            var tX = 0;
                            var tY = 0;
                            var tTexture = tTileTexSet.texture;
                            switch (this._map.orientation) {
                                case "staggered":
                                    tX = tileX * this._map.tileWidth % this._map.gridWidth + (tileY & 1) * this._tileWidthHalf;
                                    tY = tileY * this._tileHeightHalf % this._map.gridHeight;
                                    break;
                                case "orthogonal":
                                    tX = tileX * this._map.tileWidth % this._map.gridWidth;
                                    tY = tileY * this._map.tileHeight % this._map.gridHeight;
                                    break;
                                case "isometric":
                                    tX = (this._mapWidthHalf + (tileX - tileY) * this._tileWidthHalf) % this._map.gridWidth;
                                    tY = ((tileX + tileY) * this._tileHeightHalf) % this._map.gridHeight;
                                    break;
                                case "hexagonal":
                                    ;
                                    var tTileHeight = this._map.tileHeight * 2 / 3;
                                    tX = (tileX * this._map.tileWidth + tileY % 2 * this._tileWidthHalf) % this._map.gridWidth;
                                    tY = (tileY * tTileHeight) % this._map.gridHeight;
                                    break;
                            }
                            if (tTileTexSet.isAnimation) {
                                var tAnimationSprite = new TileAniSprite();
                                tAnimationSprite.x = tX;
                                tAnimationSprite.y = tY;
                                tAnimationSprite.setTileTextureSet(tIndex.toString(), tTileTexSet);
                                gridSprite.addAniSprite(tAnimationSprite);
                                gridSprite.addChild(tAnimationSprite);
                                gridSprite.isHaveAnimation = true;
                            }
                            else {
                                gridSprite.graphics.drawTexture(tTileTexSet.texture, tX + tTileTexSet.offX, tY + tTileTexSet.offY);
                            }
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        __proto.clearAll = function () {
            this._map = null;
            this._mapData = null;
            this._tileWidthHalf = 0;
            this._tileHeightHalf = 0;
            this._mapWidthHalf = 0;
            this._mapHeightHalf = 0;
            this.layerName = null;
            var i = 0;
            if (this._objDic) {
                for (var p in this._objDic) {
                    delete this._objDic[p];
                }
                this._objDic = null;
            }
            if (this._dataDic) {
                for (p in this._dataDic) {
                    delete this._dataDic[p];
                }
                this._dataDic = null;
            }
            ;
            var tGridSprite;
            for (i = 0; i < this._gridSpriteArray.length; i++) {
                tGridSprite = this._gridSpriteArray[i];
                tGridSprite.clearAll();
            }
            this._properties = null;
            this._tempMapPos = null;
            this.tarLayer = null;
        };
        return MapLayer;
    })(Sprite);
    var TileAniSprite = (function (_super) {
        function TileAniSprite() {
            this._tileTextureSet = null;
            this._aniName = null;
            TileAniSprite.__super.call(this);
        }
        __class(TileAniSprite, 'laya.map.TileAniSprite', _super);
        var __proto = TileAniSprite.prototype;
        __proto.setTileTextureSet = function (aniName, tileTextureSet) {
            this._aniName = aniName;
            this._tileTextureSet = tileTextureSet;
            tileTextureSet.addAniSprite(this._aniName, this);
        };
        __proto.show = function () {
            this._tileTextureSet.addAniSprite(this._aniName, this);
        };
        __proto.hide = function () {
            this._tileTextureSet.removeAniSprite(this._aniName);
        };
        __proto.clearAll = function () {
            this._tileTextureSet.removeAniSprite(this._aniName);
            this.destroy();
            this._tileTextureSet = null;
            this._aniName = null;
        };
        return TileAniSprite;
    })(Sprite);
    Laya.__init([TiledMap]);
})(window, document, Laya);
if (typeof define === 'function' && define.amd) {
    define('laya.core', ['require', "exports"], function (require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
            var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    var Bitmap = laya.resource.Bitmap, Browser = laya.utils.Browser, Event = laya.events.Event, EventDispatcher = laya.events.EventDispatcher;
    var Handler = laya.utils.Handler, Rectangle = laya.maths.Rectangle, Render = laya.renders.Render, Sprite = laya.display.Sprite;
    var Stage = laya.display.Stage, Texture = laya.resource.Texture, Utils = laya.utils.Utils, WebGL = laya.webgl.WebGL;
    var WebGLContext = laya.webgl.WebGLContext;
    var Geolocation = (function () {
        function Geolocation() { }
        __class(Geolocation, 'laya.device.geolocation.Geolocation');
        Geolocation.getCurrentPosition = function (onSuccess, onError) {
            Geolocation.navigator.geolocation.getCurrentPosition(function (pos) {
                Geolocation.position.setPosition(pos);
                onSuccess.runWith(Geolocation.position);
            }, function (error) {
                onError.runWith(error);
            }, {
                enableHighAccuracy: laya.device.geolocation.Geolocation.enableHighAccuracy,
                timeout: laya.device.geolocation.Geolocation.timeout,
                maximumAge: laya.device.geolocation.Geolocation.maximumAge
            });
        };
        Geolocation.watchPosition = function (onSuccess, onError) {
            return Geolocation.navigator.geolocation.watchPosition(function (pos) {
                Geolocation.position.setPosition(pos);
                onSuccess.runWith(Geolocation.position);
            }, function (error) {
                onError.runWith(error);
            }, {
                enableHighAccuracy: Geolocation.enableHighAccuracy,
                timeout: Geolocation.timeout,
                maximumAge: Geolocation.maximumAge
            });
        };
        Geolocation.clearWatch = function (id) {
            Geolocation.navigator.geolocation.clearWatch(id);
        };
        Geolocation.PERMISSION_DENIED = 1;
        Geolocation.POSITION_UNAVAILABLE = 2;
        Geolocation.TIMEOUT = 3;
        Geolocation.enableHighAccuracy = false;
        Geolocation.maximumAge = 0;
        __static(Geolocation, ['navigator', function () { return this.navigator = Browser.window.navigator; }, 'position', function () { return this.position = new GeolocationInfo(); }, 'supported', function () { return this.supported = !!Geolocation.navigator.geolocation; }, 'timeout', function () { return this.timeout = 1E10; }
        ]);
        return Geolocation;
    })();
    var GeolocationInfo = (function () {
        function GeolocationInfo() {
            this.pos = null;
            this.coords = null;
        }
        __class(GeolocationInfo, 'laya.device.geolocation.GeolocationInfo');
        var __proto = GeolocationInfo.prototype;
        __proto.setPosition = function (pos) {
            this.pos = pos;
            this.coords = pos.coords;
        };
        __getset(0, __proto, 'heading', function () {
            return this.coords.heading;
        });
        __getset(0, __proto, 'latitude', function () {
            return this.coords.latitude;
        });
        __getset(0, __proto, 'altitudeAccuracy', function () {
            return this.coords.altitudeAccuracy;
        });
        __getset(0, __proto, 'longitude', function () {
            return this.coords.longitude;
        });
        __getset(0, __proto, 'altitude', function () {
            return this.coords.altitude;
        });
        __getset(0, __proto, 'accuracy', function () {
            return this.coords.accuracy;
        });
        __getset(0, __proto, 'speed', function () {
            return this.coords.speed;
        });
        __getset(0, __proto, 'timestamp', function () {
            return this.pos.timestamp;
        });
        return GeolocationInfo;
    })();
    var Media = (function () {
        function Media() { }
        __class(Media, 'laya.device.media.Media');
        Media.supported = function () {
            return !!Browser.window.navigator.getUserMedia;
        };
        Media.getMedia = function (options, onSuccess, onError) {
            if (Browser.window.navigator.getUserMedia) {
                Browser.window.navigator.getUserMedia(options, function (stream) {
                    onSuccess.runWith(Browser.window.URL.createObjectURL(stream));
                }, function (err) {
                    onError.runWith(err);
                });
            }
        };
        Media.__init$ = function () {
            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
            ;
        };
        return Media;
    })();
    var AccelerationInfo = (function () {
        function AccelerationInfo() {
            this.x = NaN;
            this.y = NaN;
            this.z = NaN;
        }
        __class(AccelerationInfo, 'laya.device.motion.AccelerationInfo');
        return AccelerationInfo;
    })();
    var RotationInfo = (function () {
        function RotationInfo() {
            this.absolute = false;
            this.alpha = NaN;
            this.beta = NaN;
            this.gamma = NaN;
            this.compassAccuracy = NaN;
        }
        __class(RotationInfo, 'laya.device.motion.RotationInfo');
        return RotationInfo;
    })();
    var Accelerator = (function (_super) {
        function Accelerator(singleton) {
            Accelerator.__super.call(this);
            this.onDeviceOrientationChange = this.onDeviceOrientationChange.bind(this);
        }
        __class(Accelerator, 'laya.device.motion.Accelerator', _super);
        var __proto = Accelerator.prototype;
        __proto.on = function (type, caller, listener, args) {
            _super.prototype.on.call(this, type, caller, listener, args);
            Browser.window.addEventListener('devicemotion', this.onDeviceOrientationChange);
            return this;
        };
        __proto.off = function (type, caller, listener, onceOnly) {
            (onceOnly === void 0) && (onceOnly = false);
            if (!this.hasListener(type))
                Browser.window.removeEventListener('devicemotion', this.onDeviceOrientationChange);
            return _super.prototype.off.call(this, type, caller, listener, onceOnly);
        };
        __proto.onDeviceOrientationChange = function (e) {
            var interval = e.interval;
            Accelerator.acceleration.x = e.acceleration.x;
            Accelerator.acceleration.y = e.acceleration.y;
            Accelerator.acceleration.z = e.acceleration.z;
            Accelerator.accelerationIncludingGravity.x = e.accelerationIncludingGravity.x;
            Accelerator.accelerationIncludingGravity.y = e.accelerationIncludingGravity.y;
            Accelerator.accelerationIncludingGravity.z = e.accelerationIncludingGravity.z;
            Accelerator.rotationRate.alpha = e.rotationRate.gamma * -1;
            Accelerator.rotationRate.beta = e.rotationRate.alpha * -1;
            Accelerator.rotationRate.gamma = e.rotationRate.beta;
            if (Browser.onAndriod) {
                if (Accelerator.onChrome) {
                    Accelerator.rotationRate.alpha *= 180 / Math.PI;
                    Accelerator.rotationRate.beta *= 180 / Math.PI;
                    Accelerator.rotationRate.gamma *= 180 / Math.PI;
                }
                Accelerator.acceleration.x *= -1;
                Accelerator.accelerationIncludingGravity.x *= -1;
            }
            else if (Browser.onIOS) {
                Accelerator.acceleration.y *= -1;
                Accelerator.acceleration.z *= -1;
                Accelerator.accelerationIncludingGravity.y *= -1;
                Accelerator.accelerationIncludingGravity.z *= -1;
                interval *= 1000;
            }
            this.event("change", [Accelerator.acceleration, Accelerator.accelerationIncludingGravity, Accelerator.rotationRate, interval]);
        };
        __getset(1, Accelerator, 'instance', function () {
            Accelerator._instance = Accelerator._instance || new Accelerator(0);
            return Accelerator._instance;
        }, laya.events.EventDispatcher._$SET_instance);
        Accelerator.getTransformedAcceleration = function (acceleration) {
            Accelerator.transformedAcceleration = Accelerator.transformedAcceleration || new AccelerationInfo();
            Accelerator.transformedAcceleration.z = acceleration.z;
            if (Browser.window.orientation == 90) {
                Accelerator.transformedAcceleration.x = acceleration.y;
                Accelerator.transformedAcceleration.y = -acceleration.x;
            }
            else if (Browser.window.orientation == -90) {
                Accelerator.transformedAcceleration.x = -acceleration.y;
                Accelerator.transformedAcceleration.y = acceleration.x;
            }
            else if (!Browser.window.orientation) {
                Accelerator.transformedAcceleration.x = acceleration.x;
                Accelerator.transformedAcceleration.y = acceleration.y;
            }
            else if (Browser.window.orientation == 180) {
                Accelerator.transformedAcceleration.x = -acceleration.x;
                Accelerator.transformedAcceleration.y = -acceleration.y;
            }
            ;
            var tx = NaN;
            if (Laya.stage.canvasDegree == -90) {
                tx = Accelerator.transformedAcceleration.x;
                Accelerator.transformedAcceleration.x = -Accelerator.transformedAcceleration.y;
                Accelerator.transformedAcceleration.y = tx;
            }
            else if (Laya.stage.canvasDegree == 90) {
                tx = Accelerator.transformedAcceleration.x;
                Accelerator.transformedAcceleration.x = Accelerator.transformedAcceleration.y;
                Accelerator.transformedAcceleration.y = -tx;
            }
            return Accelerator.transformedAcceleration;
        };
        Accelerator._instance = null;
        Accelerator.transformedAcceleration = null;
        __static(Accelerator, ['acceleration', function () { return this.acceleration = new AccelerationInfo(); }, 'accelerationIncludingGravity', function () { return this.accelerationIncludingGravity = new AccelerationInfo(); }, 'rotationRate', function () { return this.rotationRate = new RotationInfo(); }, 'onChrome', function () { return this.onChrome = (Browser.userAgent.indexOf("Chrome") > -1); }
        ]);
        return Accelerator;
    })(EventDispatcher);
    var Gyroscope = (function (_super) {
        function Gyroscope(singleton) {
            Gyroscope.__super.call(this);
            this.onDeviceOrientationChange = this.onDeviceOrientationChange.bind(this);
        }
        __class(Gyroscope, 'laya.device.motion.Gyroscope', _super);
        var __proto = Gyroscope.prototype;
        __proto.on = function (type, caller, listener, args) {
            _super.prototype.on.call(this, type, caller, listener, args);
            Browser.window.addEventListener('deviceorientation', this.onDeviceOrientationChange);
            return this;
        };
        __proto.off = function (type, caller, listener, onceOnly) {
            (onceOnly === void 0) && (onceOnly = false);
            if (!this.hasListener(type))
                Browser.window.removeEventListener('deviceorientation', this.onDeviceOrientationChange);
            return _super.prototype.off.call(this, type, caller, listener, onceOnly);
        };
        __proto.onDeviceOrientationChange = function (e) {
            Gyroscope.info.alpha = e.alpha;
            Gyroscope.info.beta = e.beta;
            Gyroscope.info.gamma = e.gamma;
            if (e.webkitCompassHeading) {
                Gyroscope.info.alpha = e.webkitCompassHeading * -1;
                Gyroscope.info.compassAccuracy = e.webkitCompassAccuracy;
            }
            this.event("change", [e.absolute, Gyroscope.info]);
        };
        __getset(1, Gyroscope, 'instance', function () {
            Gyroscope._instance = Gyroscope._instance || new Gyroscope(0);
            return Gyroscope._instance;
        }, laya.events.EventDispatcher._$SET_instance);
        Gyroscope._instance = null;
        __static(Gyroscope, ['info', function () { return this.info = new RotationInfo(); }
        ]);
        return Gyroscope;
    })(EventDispatcher);
    var Shake = (function (_super) {
        function Shake() {
            this.throushold = 0;
            this.shakeInterval = 0;
            this.callback = null;
            this.lastX = NaN;
            this.lastY = NaN;
            this.lastZ = NaN;
            this.lastMillSecond = NaN;
            Shake.__super.call(this);
        }
        __class(Shake, 'laya.device.Shake', _super);
        var __proto = Shake.prototype;
        __proto.start = function (throushold, interval) {
            this.throushold = throushold;
            this.shakeInterval = interval;
            this.lastX = this.lastY = this.lastZ = NaN;
            Accelerator.instance.on("change", this, this.onShake);
        };
        __proto.stop = function () {
            Accelerator.instance.off("change", this, this.onShake);
        };
        __proto.onShake = function (acceleration, accelerationIncludingGravity, rotationRate, interval) {
            if (isNaN(this.lastX)) {
                this.lastX = accelerationIncludingGravity.x;
                this.lastY = accelerationIncludingGravity.y;
                this.lastZ = accelerationIncludingGravity.z;
                this.lastMillSecond = Browser.now();
                return;
            }
            ;
            var deltaX = Math.abs(this.lastX - accelerationIncludingGravity.x);
            var deltaY = Math.abs(this.lastY - accelerationIncludingGravity.y);
            var deltaZ = Math.abs(this.lastZ - accelerationIncludingGravity.z);
            if (this.isShaked(deltaX, deltaY, deltaZ)) {
                var deltaMillSecond = Browser.now() - this.lastMillSecond;
                if (deltaMillSecond > this.shakeInterval) {
                    this.event("change");
                    this.lastMillSecond = Browser.now();
                }
            }
            this.lastX = accelerationIncludingGravity.x;
            this.lastY = accelerationIncludingGravity.y;
            this.lastZ = accelerationIncludingGravity.z;
        };
        __proto.isShaked = function (deltaX, deltaY, deltaZ) {
            return (deltaX > this.throushold && deltaY > this.throushold) ||
                (deltaX > this.throushold && deltaZ > this.throushold) ||
                (deltaY > this.throushold && deltaZ > this.throushold);
        };
        __getset(1, Shake, 'instance', function () {
            Shake._instance = Shake._instance || new Shake();
            return Shake._instance;
        }, laya.events.EventDispatcher._$SET_instance);
        Shake._instance = null;
        return Shake;
    })(EventDispatcher);
    var Video = (function (_super) {
        function Video(width, height) {
            this.htmlVideo = null;
            this.videoElement = null;
            this.internalTexture = null;
            (width === void 0) && (width = 320);
            (height === void 0) && (height = 240);
            Video.__super.call(this);
            if (Render.isWebGL)
                this.htmlVideo = new WebGLVideo();
            else
                this.htmlVideo = new HtmlVideo();
            this.videoElement = this.htmlVideo.getVideo();
            this.videoElement.the3Target = this;
            this.internalTexture = new Texture(this.htmlVideo);
            this.videoElement.addEventListener("abort", Video.onAbort);
            this.videoElement.addEventListener("canplay", Video.onCanplay);
            this.videoElement.addEventListener("canplaythrough", Video.onCanplaythrough);
            this.videoElement.addEventListener("durationchange", Video.onDurationchange);
            this.videoElement.addEventListener("emptied", Video.onEmptied);
            this.videoElement.addEventListener("error", Video.onError);
            this.videoElement.addEventListener("loadeddata", Video.onLoadeddata);
            this.videoElement.addEventListener("loadedmetadata", Video.onLoadedmetadata);
            this.videoElement.addEventListener("loadstart", Video.onLoadstart);
            this.videoElement.addEventListener("pause", Video.onPause);
            this.videoElement.addEventListener("play", Video.onPlay);
            this.videoElement.addEventListener("playing", Video.onPlaying);
            this.videoElement.addEventListener("progress", Video.onProgress);
            this.videoElement.addEventListener("ratechange", Video.onRatechange);
            this.videoElement.addEventListener("seeked", Video.onSeeked);
            this.videoElement.addEventListener("seeking", Video.onSeeking);
            this.videoElement.addEventListener("stalled", Video.onStalled);
            this.videoElement.addEventListener("suspend", Video.onSuspend);
            this.videoElement.addEventListener("timeupdate", Video.onTimeupdate);
            this.videoElement.addEventListener("volumechange", Video.onVolumechange);
            this.videoElement.addEventListener("waiting", Video.onWaiting);
            this.videoElement.addEventListener("ended", this.onPlayComplete['bind'](this));
            this.size(width, height);
            if (Browser.onMobile) {
                this.onDocumentClick = this.onDocumentClick.bind(this);
                Browser.document.addEventListener("touchend", this.onDocumentClick);
            }
        }
        __class(Video, 'laya.device.media.Video', _super);
        var __proto = Video.prototype;
        __proto.onPlayComplete = function (e) {
            Laya.timer.clear(this, this.renderCanvas);
            this.event("ended");
        };
        __proto.load = function (url) {
            if (url.indexOf("blob:") == 0)
                this.videoElement.src = url;
            else
                this.htmlVideo.setSource(url, laya.device.media.Video.MP4);
        };
        __proto.play = function () {
            this.videoElement.play();
            Laya.timer.frameLoop(1, this, this.renderCanvas);
        };
        __proto.pause = function () {
            this.videoElement.pause();
            Laya.timer.clear(this, this.renderCanvas);
        };
        __proto.reload = function () {
            this.videoElement.load();
        };
        __proto.canPlayType = function (type) {
            var typeString;
            switch (type) {
                case laya.device.media.Video.MP4:
                    typeString = "video/mp4";
                    break;
                case laya.device.media.Video.OGG:
                    typeString = "video/ogg";
                    break;
                case laya.device.media.Video.WEBM:
                    typeString = "video/webm";
                    break;
            }
            return this.videoElement.canPlayType(typeString);
        };
        __proto.renderCanvas = function () {
            if (this.readyState === 0)
                return;
            if (Render.isWebGL)
                this.htmlVideo['updateTexture']();
            this.graphics.clear();
            this.graphics.drawTexture(this.internalTexture, 0, 0, this.width, this.height);
        };
        __proto.onDocumentClick = function () {
            this.videoElement.play();
            this.videoElement.pause();
            Browser.document.removeEventListener("touchend", this.onDocumentClick);
        };
        __proto.size = function (width, height) {
            _super.prototype.size.call(this, width, height);
            this.videoElement.width = width / Browser.pixelRatio;
            if (this.paused)
                this.renderCanvas();
            return this;
        };
        __proto.destroy = function (detroyChildren) {
            (detroyChildren === void 0) && (detroyChildren = true);
            _super.prototype.destroy.call(this, detroyChildren);
            this.videoElement.removeEventListener("abort", Video.onAbort);
            this.videoElement.removeEventListener("canplay", Video.onCanplay);
            this.videoElement.removeEventListener("canplaythrough", Video.onCanplaythrough);
            this.videoElement.removeEventListener("durationchange", Video.onDurationchange);
            this.videoElement.removeEventListener("emptied", Video.onEmptied);
            this.videoElement.removeEventListener("error", Video.onError);
            this.videoElement.removeEventListener("loadeddata", Video.onLoadeddata);
            this.videoElement.removeEventListener("loadedmetadata", Video.onLoadedmetadata);
            this.videoElement.removeEventListener("loadstart", Video.onLoadstart);
            this.videoElement.removeEventListener("pause", Video.onPause);
            this.videoElement.removeEventListener("play", Video.onPlay);
            this.videoElement.removeEventListener("playing", Video.onPlaying);
            this.videoElement.removeEventListener("progress", Video.onProgress);
            this.videoElement.removeEventListener("ratechange", Video.onRatechange);
            this.videoElement.removeEventListener("seeked", Video.onSeeked);
            this.videoElement.removeEventListener("seeking", Video.onSeeking);
            this.videoElement.removeEventListener("stalled", Video.onStalled);
            this.videoElement.removeEventListener("suspend", Video.onSuspend);
            this.videoElement.removeEventListener("timeupdate", Video.onTimeupdate);
            this.videoElement.removeEventListener("volumechange", Video.onVolumechange);
            this.videoElement.removeEventListener("waiting", Video.onWaiting);
            this.videoElement.removeEventListener("ended", this.onPlayComplete);
            this.pause();
            this.videoElement = null;
        };
        __proto.syncVideoPosition = function () {
            var stage = Laya.stage;
            var rec;
            rec = Utils.getGlobalPosAndScale(this);
            var a = stage._canvasTransform.a, d = stage._canvasTransform.d;
            var x = rec.x * stage.clientScaleX * a + stage.offset.x;
            var y = rec.y * stage.clientScaleY * d + stage.offset.y;
            this.videoElement.style.left = x + 'px';
            ;
            this.videoElement.style.top = y + 'px';
            this.videoElement.width = this.width / Browser.pixelRatio;
            this.videoElement.height = this.height / Browser.pixelRatio;
        };
        __getset(0, __proto, 'buffered', function () {
            return this.videoElement.buffered;
        });
        __getset(0, __proto, 'videoWidth', function () {
            return this.videoElement.videoWidth;
        });
        __getset(0, __proto, 'currentSrc', function () {
            return this.videoElement.currentSrc;
        });
        __getset(0, __proto, 'currentTime', function () {
            return this.videoElement.currentTime;
        }, function (value) {
            this.videoElement.currentTime = value;
            this.renderCanvas();
        });
        __getset(0, __proto, 'ended', function () {
            return this.videoElement.ended;
        });
        __getset(0, __proto, 'volume', function () {
            return this.videoElement.volume;
        }, function (value) {
            this.videoElement.volume = value;
        });
        __getset(0, __proto, 'videoHeight', function () {
            return this.videoElement.videoHeight;
        });
        __getset(0, __proto, 'readyState', function () {
            return this.videoElement.readyState;
        });
        __getset(0, __proto, 'duration', function () {
            return this.videoElement.duration;
        });
        __getset(0, __proto, 'error', function () {
            return this.videoElement.error;
        });
        __getset(0, __proto, 'loop', function () {
            return this.videoElement.loop;
        }, function (value) {
            this.videoElement.loop = value;
        });
        __getset(0, __proto, 'playbackRate', function () {
            return this.videoElement.playbackRate;
        }, function (value) {
            this.videoElement.playbackRate = value;
        });
        __getset(0, __proto, 'muted', function () {
            return this.videoElement.muted;
        }, function (value) {
            this.videoElement.muted = value;
        });
        __getset(0, __proto, 'paused', function () {
            return this.videoElement.paused;
        });
        __getset(0, __proto, 'preload', function () {
            return this.videoElement.preload;
        }, function (value) {
            this.videoElement.preload = value;
        });
        __getset(0, __proto, 'seekable', function () {
            return this.videoElement.seekable;
        });
        __getset(0, __proto, 'seeking', function () {
            return this.videoElement.seeking;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(Sprite, this, 'height', value);
            if (this.paused)
                this.renderCanvas();
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            this.videoElement.width = this.width / Browser.pixelRatio;
            Laya.superSet(Sprite, this, 'width', value);
            if (this.paused)
                this.renderCanvas();
        });
        Video.onAbort = function (e) { e.target.the3Target.event("abort"); };
        Video.onCanplay = function (e) { e.target.the3Target.event("canplay"); };
        Video.onCanplaythrough = function (e) { e.target.the3Target.event("canplaythrough"); };
        Video.onDurationchange = function (e) { e.target.the3Target.event("durationchange"); };
        Video.onEmptied = function (e) { e.target.the3Target.event("emptied"); };
        Video.onError = function (e) { e.target.the3Target.event("error"); };
        Video.onLoadeddata = function (e) { e.target.the3Target.event("loadeddata"); };
        Video.onLoadedmetadata = function (e) { e.target.the3Target.event("loadedmetadata"); };
        Video.onLoadstart = function (e) { e.target.the3Target.event("loadstart"); };
        Video.onPause = function (e) { e.target.the3Target.event("pause"); };
        Video.onPlay = function (e) { e.target.the3Target.event("play"); };
        Video.onPlaying = function (e) { e.target.the3Target.event("playing"); };
        Video.onProgress = function (e) { e.target.the3Target.event("progress"); };
        Video.onRatechange = function (e) { e.target.the3Target.event("ratechange"); };
        Video.onSeeked = function (e) { e.target.the3Target.event("seeked"); };
        Video.onSeeking = function (e) { e.target.the3Target.event("seeking"); };
        Video.onStalled = function (e) { e.target.the3Target.event("stalled"); };
        Video.onSuspend = function (e) { e.target.the3Target.event("suspend"); };
        Video.onTimeupdate = function (e) { e.target.the3Target.event("timeupdate"); };
        Video.onVolumechange = function (e) { e.target.the3Target.event("volumechange"); };
        Video.onWaiting = function (e) { e.target.the3Target.event("waiting"); };
        Video.MP4 = 1;
        Video.OGG = 2;
        Video.CAMERA = 4;
        Video.WEBM = 8;
        Video.SUPPORT_PROBABLY = "probably";
        Video.SUPPORT_MAYBY = "maybe";
        Video.SUPPORT_NO = "";
        return Video;
    })(Sprite);
    var HtmlVideo = (function (_super) {
        function HtmlVideo() {
            this.video = null;
            HtmlVideo.__super.call(this);
            this._w = 1;
            this._h = 1;
            this.createDomElement();
        }
        __class(HtmlVideo, 'laya.device.media.HtmlVideo', _super);
        var __proto = HtmlVideo.prototype;
        __proto.createDomElement = function () {
            var _$this = this;
            this._source = this.video = Browser.createElement("video");
            var style = this.video.style;
            style.position = 'absolute';
            style.top = '0px';
            style.left = '0px';
            this.video.addEventListener("loadedmetadata", (function () {
                this._w = _$this.video.videoWidth;
                this._h = _$this.video.videoHeight;
            })['bind'](this));
        };
        __proto.setSource = function (url, extension) {
            while (this.video.childElementCount)
                this.video.firstChild.remove();
            if (extension & Video.MP4)
                this.appendSource(url, "video/mp4");
            if (extension & Video.OGG)
                this.appendSource(url + ".ogg", "video/ogg");
        };
        __proto.appendSource = function (source, type) {
            var sourceElement = Browser.createElement("source");
            sourceElement.src = source;
            sourceElement.type = type;
            this.video.appendChild(sourceElement);
        };
        __proto.getVideo = function () {
            return this.video;
        };
        HtmlVideo.create = function () {
            return new HtmlVideo();
        };
        return HtmlVideo;
    })(Bitmap);
    var WebGLVideo = (function (_super) {
        function WebGLVideo() {
            this.gl = null;
            this.preTarget = null;
            this.preTexture = null;
            WebGLVideo.__super.call(this);
            if (Browser.onIPhone)
                return;
            this.gl = WebGL.mainContext;
            this._source = this.gl.createTexture();
            this.preTarget = WebGLContext.curBindTexTarget;
            this.preTexture = WebGLContext.curBindTexValue;
            WebGLContext.bindTexture(this.gl, 0x0DE1, this._source);
            this.gl.texParameteri(0x0DE1, 0x2802, 0x812F);
            this.gl.texParameteri(0x0DE1, 0x2803, 0x812F);
            this.gl.texParameteri(0x0DE1, 0x2800, 0x2601);
            this.gl.texParameteri(0x0DE1, 0x2801, 0x2601);
            (this.preTarget && this.preTexture) && (WebGLContext.bindTexture(this.gl, this.preTarget, this.preTexture));
        }
        __class(WebGLVideo, 'laya.device.media.WebGLVideo', _super);
        var __proto = WebGLVideo.prototype;
        __proto.updateTexture = function () {
            if (Browser.onIPhone)
                return;
            WebGLContext.bindTexture(this.gl, 0x0DE1, this._source);
            this.gl.texImage2D(0x0DE1, 0, 0x1907, 0x1907, 0x1401, this.video);
        };
        return WebGLVideo;
    })(HtmlVideo);
    Laya.__init([Media]);
})(window, document, Laya);
if (typeof define === 'function' && define.amd) {
    define('laya.core', ['require', "exports"], function (require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
            var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    var BlendMode = laya.webgl.canvas.BlendMode, Event = laya.events.Event, HTMLCanvas = laya.resource.HTMLCanvas;
    var Handler = laya.utils.Handler, IndexBuffer2D = laya.webgl.utils.IndexBuffer2D, Loader = laya.net.Loader, MathUtil = laya.maths.MathUtil;
    var Matrix = laya.maths.Matrix, Render = laya.renders.Render, RenderContext = laya.renders.RenderContext, RenderSprite = laya.renders.RenderSprite;
    var Shader = laya.webgl.shader.Shader, Sprite = laya.display.Sprite, Stat = laya.utils.Stat, Texture = laya.resource.Texture;
    var Utils = laya.utils.Utils, Value2D = laya.webgl.shader.d2.value.Value2D, VertexBuffer2D = laya.webgl.utils.VertexBuffer2D;
    var WebGL = laya.webgl.WebGL, WebGLContext = laya.webgl.WebGLContext;
    var EmitterBase = (function () {
        function EmitterBase() {
            this._frameTime = 0;
            this._emissionRate = 60;
            this._emissionTime = 0;
            this.minEmissionTime = 1 / 60;
            this._particleTemplate = null;
        }
        __class(EmitterBase, 'laya.particle.emitter.EmitterBase');
        var __proto = EmitterBase.prototype;
        __proto.start = function (duration) {
            (duration === void 0) && (duration = 2147483647);
            if (this._emissionRate != 0)
                this._emissionTime = duration;
        };
        __proto.stop = function () {
            this._emissionTime = 0;
        };
        __proto.clear = function () {
            this._emissionTime = 0;
        };
        __proto.emit = function () { };
        __proto.advanceTime = function (passedTime) {
            (passedTime === void 0) && (passedTime = 1);
            this._emissionTime -= passedTime;
            if (this._emissionTime < 0)
                return;
            this._frameTime += passedTime;
            if (this._frameTime < this.minEmissionTime)
                return;
            while (this._frameTime > this.minEmissionTime) {
                this._frameTime -= this.minEmissionTime;
                this.emit();
            }
        };
        __getset(0, __proto, 'particleTemplate', null, function (particleTemplate) {
            this._particleTemplate = particleTemplate;
        });
        __getset(0, __proto, 'emissionRate', function () {
            return this._emissionRate;
        }, function (_emissionRate) {
            if (_emissionRate <= 0)
                return;
            this._emissionRate = _emissionRate;
            (_emissionRate > 0) && (this.minEmissionTime = 1 / _emissionRate);
        });
        return EmitterBase;
    })();
    var ParticleData = (function () {
        function ParticleData() {
            this.position = null;
            this.velocity = null;
            this.startColor = null;
            this.endColor = null;
            this.sizeRotation = null;
            this.radius = null;
            this.radian = null;
            this.durationAddScale = NaN;
            this.time = NaN;
        }
        __class(ParticleData, 'laya.particle.ParticleData');
        ParticleData.Create = function (settings, position, velocity, time) {
            var particleData = new ParticleData();
            particleData.position = position;
            MathUtil.scaleVector3(velocity, settings.emitterVelocitySensitivity, ParticleData._tempVelocity);
            var horizontalVelocity = MathUtil.lerp(settings.minHorizontalVelocity, settings.maxHorizontalVelocity, Math.random());
            var horizontalAngle = Math.random() * Math.PI * 2;
            ParticleData._tempVelocity[0] += horizontalVelocity * Math.cos(horizontalAngle);
            ParticleData._tempVelocity[2] += horizontalVelocity * Math.sin(horizontalAngle);
            ParticleData._tempVelocity[1] += MathUtil.lerp(settings.minVerticalVelocity, settings.maxVerticalVelocity, Math.random());
            particleData.velocity = ParticleData._tempVelocity;
            particleData.startColor = ParticleData._tempStartColor;
            particleData.endColor = ParticleData._tempEndColor;
            var i = 0;
            if (settings.disableColor) {
                for (i = 0; i < 4; i++) {
                    particleData.startColor[i] = 1;
                    particleData.endColor[i] = 1;
                }
            }
            else {
                if (settings.colorComponentInter) {
                    for (i = 0; i < 4; i++) {
                        particleData.startColor[i] = MathUtil.lerp(settings.minStartColor[i], settings.maxStartColor[i], Math.random());
                        particleData.endColor[i] = MathUtil.lerp(settings.minEndColor[i], settings.maxEndColor[i], Math.random());
                    }
                }
                else {
                    MathUtil.lerpVector4(settings.minStartColor, settings.maxStartColor, Math.random(), particleData.startColor);
                    MathUtil.lerpVector4(settings.minEndColor, settings.maxEndColor, Math.random(), particleData.endColor);
                }
            }
            particleData.sizeRotation = ParticleData._tempSizeRotation;
            var sizeRandom = Math.random();
            particleData.sizeRotation[0] = MathUtil.lerp(settings.minStartSize, settings.maxStartSize, sizeRandom);
            particleData.sizeRotation[1] = MathUtil.lerp(settings.minEndSize, settings.maxEndSize, sizeRandom);
            particleData.sizeRotation[2] = MathUtil.lerp(settings.minRotateSpeed, settings.maxRotateSpeed, Math.random());
            particleData.radius = ParticleData._tempRadius;
            var radiusRandom = Math.random();
            particleData.radius[0] = MathUtil.lerp(settings.minStartRadius, settings.maxStartRadius, radiusRandom);
            particleData.radius[1] = MathUtil.lerp(settings.minEndRadius, settings.maxEndRadius, radiusRandom);
            particleData.radian = ParticleData._tempRadian;
            particleData.radian[0] = MathUtil.lerp(settings.minHorizontalStartRadian, settings.maxHorizontalStartRadian, Math.random());
            particleData.radian[1] = MathUtil.lerp(settings.minVerticalStartRadian, settings.maxVerticalStartRadian, Math.random());
            var useEndRadian = settings.useEndRadian;
            particleData.radian[2] = useEndRadian ? MathUtil.lerp(settings.minHorizontalEndRadian, settings.maxHorizontalEndRadian, Math.random()) : particleData.radian[0];
            particleData.radian[3] = useEndRadian ? MathUtil.lerp(settings.minVerticalEndRadian, settings.maxVerticalEndRadian, Math.random()) : particleData.radian[1];
            particleData.durationAddScale = settings.ageAddScale * Math.random();
            particleData.time = time;
            return particleData;
        };
        __static(ParticleData, ['_tempVelocity', function () { return this._tempVelocity = new Float32Array(3); }, '_tempStartColor', function () { return this._tempStartColor = new Float32Array(4); }, '_tempEndColor', function () { return this._tempEndColor = new Float32Array(4); }, '_tempSizeRotation', function () { return this._tempSizeRotation = new Float32Array(3); }, '_tempRadius', function () { return this._tempRadius = new Float32Array(2); }, '_tempRadian', function () { return this._tempRadian = new Float32Array(4); }
        ]);
        return ParticleData;
    })();
    var ParticleEmitter = (function () {
        function ParticleEmitter(templet, particlesPerSecond, initialPosition) {
            this._templet = null;
            this._timeBetweenParticles = NaN;
            this._previousPosition = null;
            this._timeLeftOver = 0;
            this._tempVelocity = new Float32Array([0, 0, 0]);
            this._tempPosition = new Float32Array([0, 0, 0]);
            this._templet = templet;
            this._timeBetweenParticles = 1.0 / particlesPerSecond;
            this._previousPosition = initialPosition;
        }
        __class(ParticleEmitter, 'laya.particle.ParticleEmitter');
        var __proto = ParticleEmitter.prototype;
        __proto.update = function (elapsedTime, newPosition) {
            elapsedTime = elapsedTime / 1000;
            if (elapsedTime > 0) {
                MathUtil.subtractVector3(newPosition, this._previousPosition, this._tempVelocity);
                MathUtil.scaleVector3(this._tempVelocity, 1 / elapsedTime, this._tempVelocity);
                var timeToSpend = this._timeLeftOver + elapsedTime;
                var currentTime = -this._timeLeftOver;
                while (timeToSpend > this._timeBetweenParticles) {
                    currentTime += this._timeBetweenParticles;
                    timeToSpend -= this._timeBetweenParticles;
                    MathUtil.lerpVector3(this._previousPosition, newPosition, currentTime / elapsedTime, this._tempPosition);
                    this._templet.addParticleArray(this._tempPosition, this._tempVelocity);
                }
                this._timeLeftOver = timeToSpend;
            }
            this._previousPosition[0] = newPosition[0];
            this._previousPosition[1] = newPosition[1];
            this._previousPosition[2] = newPosition[2];
        };
        return ParticleEmitter;
    })();
    var ParticleSetting = (function () {
        function ParticleSetting() {
            this.textureName = null;
            this.textureCount = 1;
            this.maxPartices = 100;
            this.duration = 1;
            this.ageAddScale = 0;
            this.emitterVelocitySensitivity = 1;
            this.minStartSize = 100;
            this.maxStartSize = 100;
            this.minEndSize = 100;
            this.maxEndSize = 100;
            this.minHorizontalVelocity = 0;
            this.maxHorizontalVelocity = 0;
            this.minVerticalVelocity = 0;
            this.maxVerticalVelocity = 0;
            this.endVelocity = 1;
            this.minRotateSpeed = 0;
            this.maxRotateSpeed = 0;
            this.minStartRadius = 0;
            this.maxStartRadius = 0;
            this.minEndRadius = 0;
            this.maxEndRadius = 0;
            this.minHorizontalStartRadian = 0;
            this.maxHorizontalStartRadian = 0;
            this.minVerticalStartRadian = 0;
            this.maxVerticalStartRadian = 0;
            this.useEndRadian = true;
            this.minHorizontalEndRadian = 0;
            this.maxHorizontalEndRadian = 0;
            this.minVerticalEndRadian = 0;
            this.maxVerticalEndRadian = 0;
            this.colorComponentInter = false;
            this.disableColor = false;
            this.blendState = 0;
            this.emitterType = "null";
            this.emissionRate = 0;
            this.sphereEmitterRadius = 1;
            this.sphereEmitterVelocity = 0;
            this.sphereEmitterVelocityAddVariance = 0;
            this.ringEmitterRadius = 30;
            this.ringEmitterVelocity = 0;
            this.ringEmitterVelocityAddVariance = 0;
            this.ringEmitterUp = 2;
            this.gravity = new Float32Array([0, 0, 0]);
            this.minStartColor = new Float32Array([1, 1, 1, 1]);
            this.maxStartColor = new Float32Array([1, 1, 1, 1]);
            this.minEndColor = new Float32Array([1, 1, 1, 1]);
            this.maxEndColor = new Float32Array([1, 1, 1, 1]);
            this.pointEmitterPosition = new Float32Array([0, 0, 0]);
            this.pointEmitterPositionVariance = new Float32Array([0, 0, 0]);
            this.pointEmitterVelocity = new Float32Array([0, 0, 0]);
            this.pointEmitterVelocityAddVariance = new Float32Array([0, 0, 0]);
            this.boxEmitterCenterPosition = new Float32Array([0, 0, 0]);
            this.boxEmitterSize = new Float32Array([0, 0, 0]);
            this.boxEmitterVelocity = new Float32Array([0, 0, 0]);
            this.boxEmitterVelocityAddVariance = new Float32Array([0, 0, 0]);
            this.sphereEmitterCenterPosition = new Float32Array([0, 0, 0]);
            this.ringEmitterCenterPosition = new Float32Array([0, 0, 0]);
            this.positionVariance = new Float32Array([0, 0, 0]);
        }
        __class(ParticleSetting, 'laya.particle.ParticleSetting');
        ParticleSetting.checkSetting = function (setting) {
            var key;
            for (key in ParticleSetting._defaultSetting) {
                if (!setting.hasOwnProperty(key)) {
                    setting[key] = ParticleSetting._defaultSetting[key];
                }
            }
        };
        __static(ParticleSetting, ['_defaultSetting', function () { return this._defaultSetting = new ParticleSetting(); }
        ]);
        return ParticleSetting;
    })();
    var ParticleTemplateBase = (function () {
        function ParticleTemplateBase() {
            this.settings = null;
            this.texture = null;
        }
        __class(ParticleTemplateBase, 'laya.particle.ParticleTemplateBase');
        var __proto = ParticleTemplateBase.prototype;
        __proto.addParticleArray = function (position, velocity) { };
        return ParticleTemplateBase;
    })();
    var CanvasShader = (function () {
        function CanvasShader() {
            this.u_Duration = NaN;
            this.u_EndVelocity = NaN;
            this.u_Gravity = null;
            this.a_Position = null;
            this.a_Velocity = null;
            this.a_StartColor = null;
            this.a_EndColor = null;
            this.a_SizeRotation = null;
            this.a_Radius = null;
            this.a_Radian = null;
            this.a_AgeAddScale = NaN;
            this.gl_Position = null;
            this.v_Color = null;
            this.oSize = NaN;
            this._color = new Float32Array(4);
            this._position = new Float32Array(3);
        }
        __class(CanvasShader, 'laya.particle.particleUtils.CanvasShader');
        var __proto = CanvasShader.prototype;
        __proto.getLen = function (position) {
            return Math.sqrt(position[0] * position[0] + position[1] * position[1] + position[2] * position[2]);
        };
        __proto.ComputeParticlePosition = function (position, velocity, age, normalizedAge) {
            this._position[0] = position[0];
            this._position[1] = position[1];
            this._position[2] = position[2];
            var startVelocity = this.getLen(velocity);
            var endVelocity = startVelocity * this.u_EndVelocity;
            var velocityIntegral = startVelocity * normalizedAge + (endVelocity - startVelocity) * normalizedAge * normalizedAge / 2.0;
            var lenVelocity = NaN;
            lenVelocity = this.getLen(velocity);
            var i = 0, len = 0;
            len = 3;
            for (i = 0; i < len; i++) {
                this._position[i] = this._position[i] + (velocity[i] / lenVelocity) * velocityIntegral * this.u_Duration;
                this._position[i] += this.u_Gravity[i] * age * normalizedAge;
            }
            ;
            var radius = MathUtil.lerp(this.a_Radius[0], this.a_Radius[1], normalizedAge);
            var radianHorizontal = MathUtil.lerp(this.a_Radian[0], this.a_Radian[2], normalizedAge);
            var radianVertical = MathUtil.lerp(this.a_Radian[1], this.a_Radian[3], normalizedAge);
            var r = Math.cos(radianVertical) * radius;
            this._position[1] += Math.sin(radianVertical) * radius;
            this._position[0] += Math.cos(radianHorizontal) * r;
            this._position[2] += Math.sin(radianHorizontal) * r;
            return new Float32Array([this._position[0], this._position[1], 0.0, 1.0]);
        };
        __proto.ComputeParticleSize = function (startSize, endSize, normalizedAge) {
            var size = MathUtil.lerp(startSize, endSize, normalizedAge);
            return size;
        };
        __proto.ComputeParticleRotation = function (rot, age) {
            return rot * age;
        };
        __proto.ComputeParticleColor = function (startColor, endColor, normalizedAge) {
            var rst = this._color;
            MathUtil.lerpVector4(startColor, endColor, normalizedAge, rst);
            rst[3] = rst[3] * normalizedAge * (1.0 - normalizedAge) * (1.0 - normalizedAge) * 6.7;
            return rst;
        };
        __proto.clamp = function (value, min, max) {
            if (value < min)
                return min;
            if (value > max)
                return max;
            return value;
        };
        __proto.getData = function (age) {
            age *= 1.0 + this.a_AgeAddScale;
            var normalizedAge = this.clamp(age / this.u_Duration, 0.0, 1.0);
            this.gl_Position = this.ComputeParticlePosition(this.a_Position, this.a_Velocity, age, normalizedAge);
            var pSize = this.ComputeParticleSize(this.a_SizeRotation[0], this.a_SizeRotation[1], normalizedAge);
            var rotation = this.ComputeParticleRotation(this.a_SizeRotation[2], age);
            this.v_Color = this.ComputeParticleColor(this.a_StartColor, this.a_EndColor, normalizedAge);
            var matric = new Matrix();
            var scale = NaN;
            scale = pSize / this.oSize * 2;
            matric.scale(scale, scale);
            matric.rotate(rotation);
            matric.setTranslate(this.gl_Position[0], -this.gl_Position[1]);
            var alpha = NaN;
            alpha = this.v_Color[3];
            return [this.v_Color, alpha, matric, this.v_Color[0] * alpha, this.v_Color[1] * alpha, this.v_Color[2] * alpha];
        };
        return CanvasShader;
    })();
    var CMDParticle = (function () {
        function CMDParticle() {
            this.maxIndex = 0;
            this.cmds = null;
            this.id = 0;
        }
        __class(CMDParticle, 'laya.particle.particleUtils.CMDParticle');
        var __proto = CMDParticle.prototype;
        __proto.setCmds = function (cmds) {
            this.cmds = cmds;
            this.maxIndex = cmds.length - 1;
        };
        return CMDParticle;
    })();
    var PicTool = (function () {
        function PicTool() { }
        __class(PicTool, 'laya.particle.particleUtils.PicTool');
        PicTool.getCanvasPic = function (img, color) {
            img = img.bitmap;
            var canvas = new HTMLCanvas("2D");
            var ctx = canvas.getContext('2d');
            canvas.size(img.width, img.height);
            var red = (color >> 16 & 0xFF);
            var green = (color >> 8 & 0xFF);
            var blue = (color & 0xFF);
            if (Render.isConchApp) {
                ctx.setFilter(red / 255, green / 255, blue / 255, 0);
            }
            ctx.drawImage(img.source, 0, 0);
            if (!Render.isConchApp) {
                var imgdata = ctx.getImageData(0, 0, canvas.width, canvas.height);
                var data = imgdata.data;
                for (var i = 0, n = data.length; i < n; i += 4) {
                    if (data[i + 3] == 0)
                        continue;
                    data[i] *= red / 255;
                    data[i + 1] *= green / 255;
                    data[i + 2] *= blue / 255;
                }
                ctx.putImageData(imgdata, 0, 0);
            }
            return canvas;
        };
        PicTool.getRGBPic = function (img) {
            var rst;
            rst = [new Texture(PicTool.getCanvasPic(img, 0xFF0000)), new Texture(PicTool.getCanvasPic(img, 0x00FF00)), new Texture(PicTool.getCanvasPic(img, 0x0000FF))];
            return rst;
        };
        return PicTool;
    })();
    var Emitter2D = (function (_super) {
        function Emitter2D(_template) {
            this.setting = null;
            this._posRange = null;
            this._canvasTemplate = null;
            this._emitFun = null;
            Emitter2D.__super.call(this);
            this.template = _template;
        }
        __class(Emitter2D, 'laya.particle.emitter.Emitter2D', _super);
        var __proto = Emitter2D.prototype;
        __proto.emit = function () {
            _super.prototype.emit.call(this);
            if (this._emitFun != null)
                this._emitFun();
        };
        __proto.getRandom = function (value) {
            return (Math.random() * 2 - 1) * value;
        };
        __proto.webGLEmit = function () {
            var pos = new Float32Array(3);
            pos[0] = this.getRandom(this._posRange[0]);
            pos[1] = this.getRandom(this._posRange[1]);
            pos[2] = this.getRandom(this._posRange[2]);
            var v = new Float32Array(3);
            v[0] = 0;
            v[1] = 0;
            v[2] = 0;
            this._particleTemplate.addParticleArray(pos, v);
        };
        __proto.canvasEmit = function () {
            var pos = new Float32Array(3);
            pos[0] = this.getRandom(this._posRange[0]);
            pos[1] = this.getRandom(this._posRange[1]);
            pos[2] = this.getRandom(this._posRange[2]);
            var v = new Float32Array(3);
            v[0] = 0;
            v[1] = 0;
            v[2] = 0;
            this._particleTemplate.addParticleArray(pos, v);
        };
        __getset(0, __proto, 'template', function () {
            return this._particleTemplate;
        }, function (template) {
            this._particleTemplate = template;
            if (!template) {
                this._emitFun = null;
                this.setting = null;
                this._posRange = null;
            }
            ;
            this.setting = template.settings;
            this._posRange = this.setting.positionVariance;
            if ((this._particleTemplate instanceof laya.particle.ParticleTemplate2D)) {
                this._emitFun = this.webGLEmit;
            }
            else if ((this._particleTemplate instanceof laya.particle.ParticleTemplateCanvas)) {
                this._canvasTemplate = template;
                this._emitFun = this.canvasEmit;
            }
        });
        return Emitter2D;
    })(EmitterBase);
    var ParticleTemplateWebGL = (function (_super) {
        function ParticleTemplateWebGL(parSetting) {
            this._vertices = null;
            this._vertexBuffer = null;
            this._indexBuffer = null;
            this._floatCountPerVertex = 29;
            this._firstActiveElement = 0;
            this._firstNewElement = 0;
            this._firstFreeElement = 0;
            this._firstRetiredElement = 0;
            this._currentTime = 0;
            this._drawCounter = 0;
            ParticleTemplateWebGL.__super.call(this);
            this.settings = parSetting;
        }
        __class(ParticleTemplateWebGL, 'laya.particle.ParticleTemplateWebGL', _super);
        var __proto = ParticleTemplateWebGL.prototype;
        __proto.initialize = function () {
            this._vertices = new Float32Array(this.settings.maxPartices * this._floatCountPerVertex * 4);
            var particleOffset = 0;
            for (var i = 0; i < this.settings.maxPartices; i++) {
                var random = Math.random();
                var cornerYSegement = this.settings.textureCount ? 1.0 / this.settings.textureCount : 1.0;
                var cornerY = NaN;
                for (cornerY = 0; cornerY < this.settings.textureCount; cornerY += cornerYSegement) {
                    if (random < cornerY + cornerYSegement)
                        break;
                }
                particleOffset = i * this._floatCountPerVertex * 4;
                this._vertices[particleOffset + this._floatCountPerVertex * 0 + 0] = -1;
                this._vertices[particleOffset + this._floatCountPerVertex * 0 + 1] = -1;
                this._vertices[particleOffset + this._floatCountPerVertex * 0 + 2] = 0;
                this._vertices[particleOffset + this._floatCountPerVertex * 0 + 3] = cornerY;
                this._vertices[particleOffset + this._floatCountPerVertex * 1 + 0] = 1;
                this._vertices[particleOffset + this._floatCountPerVertex * 1 + 1] = -1;
                this._vertices[particleOffset + this._floatCountPerVertex * 1 + 2] = 1;
                this._vertices[particleOffset + this._floatCountPerVertex * 1 + 3] = cornerY;
                this._vertices[particleOffset + this._floatCountPerVertex * 2 + 0] = 1;
                this._vertices[particleOffset + this._floatCountPerVertex * 2 + 1] = 1;
                this._vertices[particleOffset + this._floatCountPerVertex * 2 + 2] = 1;
                this._vertices[particleOffset + this._floatCountPerVertex * 2 + 3] = cornerY + cornerYSegement;
                this._vertices[particleOffset + this._floatCountPerVertex * 3 + 0] = -1;
                this._vertices[particleOffset + this._floatCountPerVertex * 3 + 1] = 1;
                this._vertices[particleOffset + this._floatCountPerVertex * 3 + 2] = 0;
                this._vertices[particleOffset + this._floatCountPerVertex * 3 + 3] = cornerY + cornerYSegement;
            }
        };
        __proto.loadContent = function () { };
        __proto.update = function (elapsedTime) {
            this._currentTime += elapsedTime / 1000;
            this.retireActiveParticles();
            this.freeRetiredParticles();
            if (this._firstActiveElement == this._firstFreeElement)
                this._currentTime = 0;
            if (this._firstRetiredElement == this._firstActiveElement)
                this._drawCounter = 0;
        };
        __proto.retireActiveParticles = function () {
            var epsilon = 0.0001;
            var particleDuration = this.settings.duration;
            while (this._firstActiveElement != this._firstNewElement) {
                var offset = this._firstActiveElement * this._floatCountPerVertex * 4;
                var index = offset + 28;
                var particleAge = this._currentTime - this._vertices[index];
                particleAge *= (1.0 + this._vertices[offset + 27]);
                if (particleAge + epsilon < particleDuration)
                    break;
                this._vertices[index] = this._drawCounter;
                this._firstActiveElement++;
                if (this._firstActiveElement >= this.settings.maxPartices)
                    this._firstActiveElement = 0;
            }
        };
        __proto.freeRetiredParticles = function () {
            while (this._firstRetiredElement != this._firstActiveElement) {
                var age = this._drawCounter - this._vertices[this._firstRetiredElement * this._floatCountPerVertex * 4 + 28];
                if (age < 3)
                    break;
                this._firstRetiredElement++;
                if (this._firstRetiredElement >= this.settings.maxPartices)
                    this._firstRetiredElement = 0;
            }
        };
        __proto.addNewParticlesToVertexBuffer = function () { };
        __proto.addParticleArray = function (position, velocity) {
            var nextFreeParticle = this._firstFreeElement + 1;
            if (nextFreeParticle >= this.settings.maxPartices)
                nextFreeParticle = 0;
            if (nextFreeParticle === this._firstRetiredElement)
                return;
            var particleData = ParticleData.Create(this.settings, position, velocity, this._currentTime);
            var startIndex = this._firstFreeElement * this._floatCountPerVertex * 4;
            for (var i = 0; i < 4; i++) {
                var j = 0, offset = 0;
                for (j = 0, offset = 4; j < 3; j++)
                    this._vertices[startIndex + i * this._floatCountPerVertex + offset + j] = particleData.position[j];
                for (j = 0, offset = 7; j < 3; j++)
                    this._vertices[startIndex + i * this._floatCountPerVertex + offset + j] = particleData.velocity[j];
                for (j = 0, offset = 10; j < 4; j++)
                    this._vertices[startIndex + i * this._floatCountPerVertex + offset + j] = particleData.startColor[j];
                for (j = 0, offset = 14; j < 4; j++)
                    this._vertices[startIndex + i * this._floatCountPerVertex + offset + j] = particleData.endColor[j];
                for (j = 0, offset = 18; j < 3; j++)
                    this._vertices[startIndex + i * this._floatCountPerVertex + offset + j] = particleData.sizeRotation[j];
                for (j = 0, offset = 21; j < 2; j++)
                    this._vertices[startIndex + i * this._floatCountPerVertex + offset + j] = particleData.radius[j];
                for (j = 0, offset = 23; j < 4; j++)
                    this._vertices[startIndex + i * this._floatCountPerVertex + offset + j] = particleData.radian[j];
                this._vertices[startIndex + i * this._floatCountPerVertex + 27] = particleData.durationAddScale;
                this._vertices[startIndex + i * this._floatCountPerVertex + 28] = particleData.time;
            }
            this._firstFreeElement = nextFreeParticle;
        };
        return ParticleTemplateWebGL;
    })(ParticleTemplateBase);
    var ParticleTemplateCanvas = (function (_super) {
        function ParticleTemplateCanvas(particleSetting) {
            this._ready = false;
            this.textureList = [];
            this.particleList = [];
            this.pX = 0;
            this.pY = 0;
            this.activeParticles = [];
            this.deadParticles = [];
            this.iList = [];
            this._maxNumParticles = 0;
            this.textureWidth = NaN;
            this.dTextureWidth = NaN;
            this.colorChange = true;
            this.step = 1 / 60;
            this.canvasShader = new CanvasShader();
            ParticleTemplateCanvas.__super.call(this);
            this.settings = particleSetting;
            this._maxNumParticles = particleSetting.maxPartices;
            this.texture = new Texture();
            this.texture.on("loaded", this, this._textureLoaded);
            this.texture.load(particleSetting.textureName);
        }
        __class(ParticleTemplateCanvas, 'laya.particle.ParticleTemplateCanvas', _super);
        var __proto = ParticleTemplateCanvas.prototype;
        __proto._textureLoaded = function (e) {
            this.setTexture(this.texture);
            this._ready = true;
        };
        __proto.clear = function (clearTexture) {
            (clearTexture === void 0) && (clearTexture = true);
            this.deadParticles.length = 0;
            this.activeParticles.length = 0;
            this.textureList.length = 0;
        };
        __proto.setTexture = function (texture) {
            this.texture = texture;
            this.textureWidth = texture.width;
            this.dTextureWidth = 1 / this.textureWidth;
            this.pX = -texture.width * 0.5;
            this.pY = -texture.height * 0.5;
            this.textureList = ParticleTemplateCanvas.changeTexture(texture, this.textureList);
            this.particleList.length = 0;
            this.deadParticles.length = 0;
            this.activeParticles.length = 0;
        };
        __proto._createAParticleData = function (position, velocity) {
            this.canvasShader.u_EndVelocity = this.settings.endVelocity;
            this.canvasShader.u_Gravity = this.settings.gravity;
            this.canvasShader.u_Duration = this.settings.duration;
            var particle;
            particle = ParticleData.Create(this.settings, position, velocity, 0);
            this.canvasShader.a_Position = particle.position;
            this.canvasShader.a_Velocity = particle.velocity;
            this.canvasShader.a_StartColor = particle.startColor;
            this.canvasShader.a_EndColor = particle.endColor;
            this.canvasShader.a_SizeRotation = particle.sizeRotation;
            this.canvasShader.a_Radius = particle.radius;
            this.canvasShader.a_Radian = particle.radian;
            this.canvasShader.a_AgeAddScale = particle.durationAddScale;
            this.canvasShader.oSize = this.textureWidth;
            var rst = new CMDParticle();
            var i = 0, len = this.settings.duration / (1 + particle.durationAddScale);
            var params = [];
            var mStep = NaN;
            for (i = 0; i < len; i += this.step) {
                params.push(this.canvasShader.getData(i));
            }
            rst.id = this.particleList.length;
            this.particleList.push(rst);
            rst.setCmds(params);
            return rst;
        };
        __proto.addParticleArray = function (position, velocity) {
            if (!this._ready)
                return;
            var tParticle;
            if (this.particleList.length < this._maxNumParticles) {
                tParticle = this._createAParticleData(position, velocity);
                this.iList[tParticle.id] = 0;
                this.activeParticles.push(tParticle);
            }
            else {
                if (this.deadParticles.length > 0) {
                    tParticle = this.deadParticles.pop();
                    this.iList[tParticle.id] = 0;
                    this.activeParticles.push(tParticle);
                }
            }
        };
        __proto.advanceTime = function (passedTime) {
            (passedTime === void 0) && (passedTime = 1);
            if (!this._ready)
                return;
            var particleList = this.activeParticles;
            var pool = this.deadParticles;
            var i = 0, len = particleList.length;
            var tcmd;
            var tI = 0;
            var iList = this.iList;
            for (i = len - 1; i > -1; i--) {
                tcmd = particleList[i];
                tI = iList[tcmd.id];
                if (tI >= tcmd.maxIndex) {
                    tI = 0;
                    particleList.splice(i, 1);
                    pool.push(tcmd);
                }
                else {
                    tI += 1;
                }
                iList[tcmd.id] = tI;
            }
        };
        __proto.render = function (context, x, y) {
            if (!this._ready)
                return;
            if (this.activeParticles.length < 1)
                return;
            if (this.textureList.length < 2)
                return;
            if (this.settings.disableColor) {
                this.noColorRender(context, x, y);
            }
            else {
                this.canvasRender(context, x, y);
            }
        };
        __proto.noColorRender = function (context, x, y) {
            var particleList = this.activeParticles;
            var i = 0, len = particleList.length;
            var tcmd;
            var tParam;
            var tAlpha = NaN;
            var px = this.pX, py = this.pY;
            var pw = -px * 2, ph = -py * 2;
            var tI = 0;
            var textureList = this.textureList;
            var iList = this.iList;
            var preAlpha = NaN;
            context.translate(x, y);
            preAlpha = context.ctx.globalAlpha;
            for (i = 0; i < len; i++) {
                tcmd = particleList[i];
                tI = iList[tcmd.id];
                tParam = tcmd.cmds[tI];
                if (!tParam)
                    continue;
                if ((tAlpha = tParam[1]) <= 0.01)
                    continue;
                context.setAlpha(preAlpha * tAlpha);
                context.drawTextureWithTransform(this.texture, px, py, pw, ph, tParam[2], 1);
            }
            context.setAlpha(preAlpha);
            context.translate(-x, -y);
        };
        __proto.canvasRender = function (context, x, y) {
            var particleList = this.activeParticles;
            var i = 0, len = particleList.length;
            var tcmd;
            var tParam;
            var tAlpha = NaN;
            var px = this.pX, py = this.pY;
            var pw = -px * 2, ph = -py * 2;
            var tI = 0;
            var textureList = this.textureList;
            var iList = this.iList;
            var preAlpha = NaN;
            var preB;
            context.translate(x, y);
            preAlpha = context.ctx.globalAlpha;
            preB = context.ctx.globalCompositeOperation;
            context.blendMode("lighter");
            for (i = 0; i < len; i++) {
                tcmd = particleList[i];
                tI = iList[tcmd.id];
                tParam = tcmd.cmds[tI];
                if (!tParam)
                    continue;
                if ((tAlpha = tParam[1]) <= 0.01)
                    continue;
                context.save();
                context.transformByMatrix(tParam[2]);
                if (tParam[3] > 0.01) {
                    context.setAlpha(preAlpha * tParam[3]);
                    context.drawTexture(textureList[0], px, py, pw, ph);
                }
                if (tParam[4] > 0.01) {
                    context.setAlpha(preAlpha * tParam[4]);
                    context.drawTexture(textureList[1], px, py, pw, ph);
                }
                if (tParam[5] > 0.01) {
                    context.setAlpha(preAlpha * tParam[5]);
                    context.drawTexture(textureList[2], px, py, pw, ph);
                }
                context.restore();
            }
            context.setAlpha(preAlpha);
            context.translate(-x, -y);
            context.blendMode(preB);
        };
        ParticleTemplateCanvas.changeTexture = function (texture, rst, settings) {
            if (!rst)
                rst = [];
            rst.length = 0;
            if (settings && settings.disableColor) {
                rst.push(texture, texture, texture);
            }
            else {
                Utils.copyArray(rst, PicTool.getRGBPic(texture));
            }
            return rst;
        };
        return ParticleTemplateCanvas;
    })(ParticleTemplateBase);
    var ParticleTemplate2D = (function (_super) {
        function ParticleTemplate2D(parSetting) {
            this._vertexBuffer2D = null;
            this._indexBuffer2D = null;
            this.x = 0;
            this.y = 0;
            this._blendFn = null;
            this._startTime = 0;
            this.sv = new ParticleShaderValue();
            ParticleTemplate2D.__super.call(this, parSetting);
            var _this = this;
            Laya.loader.load(this.settings.textureName, Handler.create(null, function (texture) {
                (texture.bitmap).enableMerageInAtlas = false;
                _this.texture = texture;
            }));
            this.sv.u_Duration = this.settings.duration;
            this.sv.u_Gravity = this.settings.gravity;
            this.sv.u_EndVelocity = this.settings.endVelocity;
            this._blendFn = BlendMode.fns[parSetting.blendState];
            this.initialize();
            this._vertexBuffer = this._vertexBuffer2D = VertexBuffer2D.create(-1, 0x88E8);
            this._indexBuffer = this._indexBuffer2D = IndexBuffer2D.create(0x88E4);
            this.loadContent();
        }
        __class(ParticleTemplate2D, 'laya.particle.ParticleTemplate2D', _super);
        var __proto = ParticleTemplate2D.prototype;
        Laya.imps(__proto, { "laya.webgl.submit.ISubmit": true });
        __proto.getRenderType = function () { return -111; };
        __proto.releaseRender = function () { };
        __proto.addParticleArray = function (position, velocity) {
            position[0] += this.x;
            position[1] += this.y;
            _super.prototype.addParticleArray.call(this, position, velocity);
        };
        __proto.loadContent = function () {
            var indexes = new Uint16Array(this.settings.maxPartices * 6);
            for (var i = 0; i < this.settings.maxPartices; i++) {
                indexes[i * 6 + 0] = (i * 4 + 0);
                indexes[i * 6 + 1] = (i * 4 + 1);
                indexes[i * 6 + 2] = (i * 4 + 2);
                indexes[i * 6 + 3] = (i * 4 + 0);
                indexes[i * 6 + 4] = (i * 4 + 2);
                indexes[i * 6 + 5] = (i * 4 + 3);
            }
            this._indexBuffer2D.clear();
            this._indexBuffer2D.append(indexes);
            this._indexBuffer2D.upload();
        };
        __proto.addNewParticlesToVertexBuffer = function () {
            this._vertexBuffer2D.clear();
            this._vertexBuffer2D.append(this._vertices);
            var start = 0;
            if (this._firstNewElement < this._firstFreeElement) {
                start = this._firstNewElement * 4 * this._floatCountPerVertex * 4;
                this._vertexBuffer2D.subUpload(start, start, start + (this._firstFreeElement - this._firstNewElement) * 4 * this._floatCountPerVertex * 4);
            }
            else {
                start = this._firstNewElement * 4 * this._floatCountPerVertex * 4;
                this._vertexBuffer2D.subUpload(start, start, start + (this.settings.maxPartices - this._firstNewElement) * 4 * this._floatCountPerVertex * 4);
                if (this._firstFreeElement > 0) {
                    this._vertexBuffer2D.setNeedUpload();
                    this._vertexBuffer2D.subUpload(0, 0, this._firstFreeElement * 4 * this._floatCountPerVertex * 4);
                }
            }
            this._firstNewElement = this._firstFreeElement;
        };
        __proto.renderSubmit = function () {
            if (this.texture && this.texture.loaded) {
                this.update(Laya.timer.delta);
                this.sv.u_CurrentTime = this._currentTime;
                if (this._firstNewElement != this._firstFreeElement) {
                    this.addNewParticlesToVertexBuffer();
                }
                this.blend();
                if (this._firstActiveElement != this._firstFreeElement) {
                    var gl = WebGL.mainContext;
                    this._vertexBuffer2D.bind(this._indexBuffer2D);
                    this.sv.u_texture = this.texture.source;
                    this.sv.upload();
                    if (this._firstActiveElement < this._firstFreeElement) {
                        WebGL.mainContext.drawElements(0x0004, (this._firstFreeElement - this._firstActiveElement) * 6, 0x1403, this._firstActiveElement * 6 * 2);
                    }
                    else {
                        WebGL.mainContext.drawElements(0x0004, (this.settings.maxPartices - this._firstActiveElement) * 6, 0x1403, this._firstActiveElement * 6 * 2);
                        if (this._firstFreeElement > 0)
                            WebGL.mainContext.drawElements(0x0004, this._firstFreeElement * 6, 0x1403, 0);
                    }
                    Stat.drawCall++;
                }
                this._drawCounter++;
            }
            return 1;
        };
        __proto.blend = function () {
            if (BlendMode.activeBlendFunction !== this._blendFn) {
                var gl = WebGL.mainContext;
                gl.enable(0x0BE2);
                this._blendFn(gl);
                BlendMode.activeBlendFunction = this._blendFn;
            }
        };
        __proto.dispose = function () {
            this._vertexBuffer2D.dispose();
            this._indexBuffer2D.dispose();
        };
        ParticleTemplate2D.activeBlendType = -1;
        return ParticleTemplate2D;
    })(ParticleTemplateWebGL);
    var ParticleShaderValue = (function (_super) {
        function ParticleShaderValue() {
            this.a_CornerTextureCoordinate = [4, 0x1406, false, 116, 0];
            this.a_Position = [3, 0x1406, false, 116, 16];
            this.a_Velocity = [3, 0x1406, false, 116, 28];
            this.a_StartColor = [4, 0x1406, false, 116, 40];
            this.a_EndColor = [4, 0x1406, false, 116, 56];
            this.a_SizeRotation = [3, 0x1406, false, 116, 72];
            this.a_Radius = [2, 0x1406, false, 116, 84];
            this.a_Radian = [4, 0x1406, false, 116, 92];
            this.a_AgeAddScale = [1, 0x1406, false, 116, 108];
            this.a_Time = [1, 0x1406, false, 116, 112];
            this.u_CurrentTime = NaN;
            this.u_Duration = NaN;
            this.u_Gravity = null;
            this.u_EndVelocity = NaN;
            this.u_texture = null;
            ParticleShaderValue.__super.call(this, 0, 0);
        }
        __class(ParticleShaderValue, 'laya.particle.shader.value.ParticleShaderValue', _super);
        var __proto = ParticleShaderValue.prototype;
        __proto.upload = function () {
            this.refresh();
            ParticleShaderValue.pShader.upload(this);
        };
        __static(ParticleShaderValue, ['pShader', function () { return this.pShader = new ParticleShader(); }
        ]);
        return ParticleShaderValue;
    })(Value2D);
    var Particle2D = (function (_super) {
        function Particle2D(setting) {
            this._matrix4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
            this._particleTemplate = null;
            this._canvasTemplate = null;
            this._emitter = null;
            this.autoPlay = true;
            Particle2D.__super.call(this);
            if (setting)
                this.setParticleSetting(setting);
        }
        __class(Particle2D, 'laya.particle.Particle2D', _super);
        var __proto = Particle2D.prototype;
        __proto.load = function (url) {
            Laya.loader.load(url, Handler.create(this, this.setParticleSetting), null, "json");
        };
        __proto.setParticleSetting = function (setting) {
            var _$this = this;
            if (!setting)
                return this.stop();
            ParticleSetting.checkSetting(setting);
            if (!window.ConchParticleTemplate2D || Render.isWebGL)
                this.customRenderEnable = true;
            if (Render.isWebGL) {
                this._particleTemplate = new ParticleTemplate2D(setting);
                this.graphics._saveToCmd(Render.context._drawParticle, [this._particleTemplate]);
            }
            else if (Render.isConchApp && window.ConchParticleTemplate2D) {
                this._particleTemplate = new ConchParticleTemplate2D();
                var _this = this;
                Laya.loader.load(setting.textureName, Handler.create(null, function (texture) {
                    _this._particleTemplate.texture = texture;
                    _this._particleTemplate.settings = setting;
                    if (Render.isConchNode) {
                        _this.graphics.drawParticle(_this._particleTemplate);
                    }
                    else {
                        _this.graphics._saveToCmd(Render.context._drawParticle, [_$this._particleTemplate]);
                    }
                }));
                this._emitter = { start: function () { } };
                this.play = this._particleTemplate.play.bind(this._particleTemplate);
                this.stop = this._particleTemplate.stop.bind(this._particleTemplate);
                if (this.autoPlay)
                    this.play();
                return;
            }
            else {
                this._particleTemplate = this._canvasTemplate = new ParticleTemplateCanvas(setting);
            }
            if (!this._emitter) {
                this._emitter = new Emitter2D(this._particleTemplate);
            }
            else {
                (this._emitter).template = this._particleTemplate;
            }
            if (this.autoPlay) {
                this.emitter.start();
                this.play();
            }
        };
        __proto.play = function () {
            this.timer.frameLoop(1, this, this._loop);
        };
        __proto.stop = function () {
            this.timer.clear(this, this._loop);
        };
        __proto._loop = function () {
            this.advanceTime(1 / 60);
        };
        __proto.advanceTime = function (passedTime) {
            (passedTime === void 0) && (passedTime = 1);
            if (this._canvasTemplate) {
                this._canvasTemplate.advanceTime(passedTime);
            }
            if (this._emitter) {
                this._emitter.advanceTime(passedTime);
            }
        };
        __proto.customRender = function (context, x, y) {
            if (Render.isWebGL) {
                this._matrix4[0] = context.ctx._curMat.a;
                this._matrix4[1] = context.ctx._curMat.b;
                this._matrix4[4] = context.ctx._curMat.c;
                this._matrix4[5] = context.ctx._curMat.d;
                this._matrix4[12] = context.ctx._curMat.tx;
                this._matrix4[13] = context.ctx._curMat.ty;
                var sv = (this._particleTemplate).sv;
                sv.u_xxxx = { 0: 0, 1: 0, 2: 0 };
                sv.u_mmat = this._matrix4;
            }
            if (this._canvasTemplate) {
                this._canvasTemplate.render(context, x, y);
            }
        };
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            if ((this._particleTemplate instanceof laya.particle.ParticleTemplate2D))
                (this._particleTemplate).dispose();
            _super.prototype.destroy.call(this, destroyChild);
        };
        __getset(0, __proto, 'url', null, function (url) {
            this.load(url);
        });
        __getset(0, __proto, 'emitter', function () {
            return this._emitter;
        });
        return Particle2D;
    })(Sprite);
    var ParticleShader = (function (_super) {
        function ParticleShader() {
            ParticleShader.__super.call(this, ParticleShader.vs, ParticleShader.ps, "ParticleShader");
        }
        __class(ParticleShader, 'laya.particle.shader.ParticleShader', _super);
        __static(ParticleShader, ['vs', function () { return this.vs = "attribute vec4 a_CornerTextureCoordinate;\nattribute vec3 a_Position;\nattribute vec3 a_Velocity;\nattribute vec4 a_StartColor;\nattribute vec4 a_EndColor;\nattribute vec3 a_SizeRotation;\nattribute vec2 a_Radius;\nattribute vec4 a_Radian;\nattribute float a_AgeAddScale;\nattribute float a_Time;\n\nvarying vec4 v_Color;\nvarying vec2 v_TextureCoordinate;\n\nuniform float u_CurrentTime;\nuniform float u_Duration;\nuniform float u_EndVelocity;\nuniform vec3 u_Gravity;\n\n#ifdef PARTICLE3D\n uniform mat4 u_WorldMat;\n uniform mat4 u_View;\n uniform mat4 u_Projection;\n uniform vec2 u_ViewportScale;\n#else\n uniform vec2 size;\n uniform mat4 mmat;\n uniform mat4 u_mmat;\n#endif\n\nvec4 ComputeParticlePosition(in vec3 position, in vec3 velocity,in float age,in float normalizedAge)\n{\n\n   float startVelocity = length(velocity);//起始标量速度\n   float endVelocity = startVelocity * u_EndVelocity;//结束标量速度\n\n   float velocityIntegral = startVelocity * normalizedAge +(endVelocity - startVelocity) * normalizedAge *normalizedAge/2.0;//计算当前速度的标量（单位空间），vt=v0*t+(1/2)*a*(t^2)\n   \n   vec3 addPosition = normalize(velocity) * velocityIntegral * u_Duration;//计算受自身速度影响的位置，转换标量到矢量    \n   addPosition += u_Gravity * age * normalizedAge;//计算受重力影响的位置\n   \n   float radius=mix(a_Radius.x, a_Radius.y, normalizedAge); //计算粒子受半径和角度影响（无需计算角度和半径时，可用宏定义优化屏蔽此计算）\n   float radianHorizontal =mix(a_Radian.x,a_Radian.z,normalizedAge);\n   float radianVertical =mix(a_Radian.y,a_Radian.w,normalizedAge);\n   \n   float r =cos(radianVertical)* radius;\n   addPosition.y += sin(radianVertical) * radius;\n	\n   addPosition.x += cos(radianHorizontal) *r;\n   addPosition.z += sin(radianHorizontal) *r;\n  \n   #ifdef PARTICLE3D\n   position+=addPosition;\n    return  u_Projection*u_View*u_WorldMat*(vec4(position, 1.0));\n   #else\n   addPosition.y=-addPosition.y;//2D粒子位置更新需要取负，2D粒子坐标系Y轴正向朝上\n   position+=addPosition;\n    return  vec4(position,1.0);\n   #endif\n}\n\nfloat ComputeParticleSize(in float startSize,in float endSize, in float normalizedAge)\n{    \n    float size = mix(startSize, endSize, normalizedAge);\n    \n	#ifdef PARTICLE3D\n    //Project the size into screen coordinates.\n     return size * u_Projection[1][1];\n	#else\n	 return size;\n	#endif\n}\n\nmat2 ComputeParticleRotation(in float rot,in float age)\n{    \n    float rotation =rot * age;\n    //计算2x2旋转矩阵.\n    float c = cos(rotation);\n    float s = sin(rotation);\n    return mat2(c, -s, s, c);\n}\n\nvec4 ComputeParticleColor(in vec4 startColor,in vec4 endColor,in float normalizedAge)\n{\n	vec4 color=mix(startColor,endColor,normalizedAge);\n    //硬编码设置，使粒子淡入很快，淡出很慢,6.7的缩放因子把置归一在0到1之间，可以谷歌x*(1-x)*(1-x)*6.7的制图表\n    color.a *= normalizedAge * (1.0-normalizedAge) * (1.0-normalizedAge) * 6.7;\n   \n    return color;\n}\n\nvoid main()\n{\n   float age = u_CurrentTime - a_Time;\n   age *= 1.0 + a_AgeAddScale;\n   float normalizedAge = clamp(age / u_Duration,0.0,1.0);\n   gl_Position = ComputeParticlePosition(a_Position, a_Velocity, age, normalizedAge);//计算粒子位置\n   float pSize = ComputeParticleSize(a_SizeRotation.x,a_SizeRotation.y, normalizedAge);\n   mat2 rotation = ComputeParticleRotation(a_SizeRotation.z, age);\n	\n   #ifdef PARTICLE3D\n	gl_Position.xy += (rotation*a_CornerTextureCoordinate.xy) * pSize * u_ViewportScale;\n   #else\n    mat4 mat=u_mmat*mmat;\n    gl_Position=vec4((mat*gl_Position).xy,0.0,1.0);\n	gl_Position.xy += (rotation*a_CornerTextureCoordinate.xy) * pSize*vec2(mat[0][0],mat[1][1]);\n    gl_Position=vec4((gl_Position.x/size.x-0.5)*2.0,(0.5-gl_Position.y/size.y)*2.0,0.0,1.0);\n   #endif\n   \n   v_Color = ComputeParticleColor(a_StartColor,a_EndColor, normalizedAge);\n   v_TextureCoordinate =a_CornerTextureCoordinate.zw;\n}\n\n"; }, 'ps', function () { return this.ps = "#ifdef FSHIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nvarying vec4 v_Color;\nvarying vec2 v_TextureCoordinate;\nuniform sampler2D u_texture;\n\nvoid main()\n{	\n	gl_FragColor=texture2D(u_texture,v_TextureCoordinate)*v_Color;\n	gl_FragColor.xyz *= v_Color.w;\n}"; }
        ]);
        return ParticleShader;
    })(Shader);
})(window, document, Laya);
if (typeof define === 'function' && define.amd) {
    define('laya.core', ['require', "exports"], function (require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
            var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}
//------------------------------------------------------------------------------------------------------
//  GameCreator 库
//------------------------------------------------------------------------------------------------------
/**
 * 该文件在运行时附加，IDE-Stand不附加
 * Created by 黑暗之神KDS on 2017/1/16.
 */
"use strict";
//------------------------------------------------------------------------------------------------------
// 插件用的继承关系（TS编译后的继承）
//------------------------------------------------------------------------------------------------------
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b)
        if (b.hasOwnProperty(p))
            d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
//------------------------------------------------------------------------------------------------------
// 初始化
//------------------------------------------------------------------------------------------------------
var os = {};
/**
 * 系统初始化
 * @param w 宽度
 * @param h 高度
 * @param isWebGL 是否使用WEBGL
 * @param is3D 是否启用3D模块
 */
os.init = function (w, h, isWebGL, is3D) {
    // 不输入或0的话表示全屏
    if (w == null || w == 0)
        w = window.innerWidth || document.body.clientWidth;
    if (h == null || h == 0)
        h = window.innerHeight || document.body.clientHeight;
    isWebGL = isWebGL == null ? true : isWebGL;
    is3D = is3D == null ? false : is3D;
    Browser.container = document.getElementById("layer1");
    if (is3D) {
        The33D.init(w, h, true);
    }
    else {
        isWebGL ? Laya.init(w, h, WebGL) : Laya.init(w, h);
    }
    window.stage = Laya.stage;
    window.loader = os.loader = Laya.loader;
    window.timer = Laya.timer;
    if (!isWebGL)
        Config.isAlpha = true;
    os.canvas = document.getElementById("gcCanvas");
    os.context = Laya.RunDriver.getWebGLContext(os.canvas);
    if (os.context)
        os.MAX_TEXTURE_SIZE = os.context.getParameter(os.context.MAX_TEXTURE_SIZE);
    // if (!is3D) {
    //     WorkerLoader.workerPath = "/kdsrpg/kdsrpg_core/libs/worker.js";
    //     WorkerLoader.enable = true;
    // }
    // alert(WorkerLoader)
    // 适配KS
    //for (var i in kdsrpg_staticVarInitFuncs) { kdsrpg_staticVarInitFuncs[i](); };
    //kdsrpg_staticVarInitFuncs = [];
};
// 音频默认关闭的
if (!!!window.navigator.userAgent.match(/\(i[^;]+;(U;)? CPU.+Mac OS X/)) {
    (function () {
        // window["mozAudioContext"] = top.window["mozAudioContext"];
        // window["AudioContext"] = top.window["AudioContext"];
        // window["webkitAudioContext"] = top.window["webkitAudioContext"];
        // window["_mozAudioContext"] = window["mozAudioContext"];
        // window["_AudioContext"] = window["AudioContext"];
        // window["_webkitAudioContext"] = window["webkitAudioContext"];
    })();
}
/**
 *
 * @returns Mac/Unix/Linux/Win2000/WinXP/Win2003/WinVista/Win7/Win10/Android/iPhone/other
 */
os.detectOS = function () {
    var sUserAgent = navigator.userAgent;
    if (sUserAgent.indexOf("Android") != -1)
        return "Android";
    if (sUserAgent.indexOf("iPhone") != -1)
        return "iPhone";
    var isWin = (navigator.platform == "Win32") || (navigator.platform == "Windows");
    var isMac = (navigator.platform == "Mac68K") || (navigator.platform == "MacPPC") || (navigator.platform == "Macintosh") || (navigator.platform == "MacIntel");
    if (isMac)
        return "Mac";
    var isUnix = (navigator.platform == "X11") && !isWin && !isMac;
    if (isUnix)
        return "Unix";
    var isLinux = (String(navigator.platform).indexOf("Linux") > -1);
    if (isLinux)
        return "Linux";
    if (isWin) {
        var isWin2K = sUserAgent.indexOf("Windows NT 5.0") > -1 || sUserAgent.indexOf("Windows 2000") > -1;
        if (isWin2K)
            return "Win2000";
        var isWinXP = sUserAgent.indexOf("Windows NT 5.1") > -1 || sUserAgent.indexOf("Windows XP") > -1;
        if (isWinXP)
            return "WinXP";
        var isWin2003 = sUserAgent.indexOf("Windows NT 5.2") > -1 || sUserAgent.indexOf("Windows 2003") > -1;
        if (isWin2003)
            return "Win2003";
        var isWinVista = sUserAgent.indexOf("Windows NT 6.0") > -1 || sUserAgent.indexOf("Windows Vista") > -1;
        if (isWinVista)
            return "WinVista";
        var isWin7 = sUserAgent.indexOf("Windows NT 6.1") > -1 || sUserAgent.indexOf("Windows 7") > -1;
        if (isWin7)
            return "Win7";
        var isWIn10 = sUserAgent.indexOf("Windows NT 10.0") > -1 || sUserAgent.indexOf("Windows 10") > -1;
        if (isWIn10)
            return "Win10";
    }
    return "other";
};
if ((gcTop == window && typeof gcTop.require != "undefined") || (window.location.href.indexOf("gcDebugPort=") != -1)) {
    os._gui = gcTop.require('nw.gui');
    os._win = os._gui.Window.get();
}
if (typeof gcTop.require != "undefined" && (window.location.href.indexOf("chrome") == 0 || window.location.href.indexOf("file") == 0)) {
    os.platform = 2;
}
else {
    if (window.location.href.indexOf("gamecreator.com.cn") != -1)
        os.platform = 0;
    else
        os.platform = 3;
}
Object.defineProperty(os, "fullscreen", { get: function () { if (!os._win)
        return null; return os._win.isFullscreen; }, set: function (v) { var win = os._win; if (!win)
        return; v ? win.enterFullscreen() : win.leaveFullscreen(); } });
osWinFuncs = ["resizeTo", "moveTo", "setResizable", "setAlwaysOnTop", "restore", "maximize", "minimize"];
for (var i in osWinFuncs) {
    var osWinFuncName = osWinFuncs[i];
    eval("os[\"" + osWinFuncName + "\"]=function(){if(!os._win)return;os._win[\"" + osWinFuncName + "\"].apply(os._win,arguments);};");
}
os.closeWindow = function () {
    if (window.location.href.indexOf("gcDebugPort=") != -1) {
        gcTop.close();
    }
    if (gcTop != window && typeof gcTop.require != "undefined" && typeof top_kdsrpg != "undefined") {
        gcParent.close();
    }
    else if (gcTop == window || (typeof process == "undefined" && typeof require == "undefined")) {
        window.close();
    }
};
os.inGC = function (independentWindow) {
    if (independentWindow == null)
        independentWindow = true;
    var inGC = (gcTop != window && typeof gcTop.require != "undefined" && typeof top_kdsrpg != "undefined");
    return inGC || (independentWindow && typeof Config != "undefined" && !Config.EDIT_MODE && window.location.href.indexOf("gcDebugPort=") != -1);
};
os.showFPS = function () {
    Stat.show();
};
os.hideFPS = function () {
    Stat.hide();
};
//------------------------------------------------------------------------------------------------------
// 鼠标样式设定
//------------------------------------------------------------------------------------------------------
os._recordCursor = "default";
os.setCursor = function (style) { if (document.body.style.cursor == style) {
    return;
} ; os._recordCursor = document.body.style.cursor; document.body.style.cursor = style; };
os.restoreCursor = function () { document.body.style.cursor = os._recordCursor; };
// enterframe 对同一个对象注册多次，在移除的时候会按照注册的顺序移除，同样要移除多次才能移除
window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
os._enterframeMap = new Map();
os._removeframeMap = new Map();
os.fps = 60; //帧率
os.add_ENTERFRAME = function (onHappen, thisPtr, args) {
    // 记录初始时间
    var then = Date.now();
    var _loop;
    window.requestAnimationFrame(_loop = function () {
        var now = Date.now();
        if (Math.round(now * os.fps * 0.001) > Math.round(then * os.fps * 0.001)) {
            var _removeArr = os._removeframeMap.get(onHappen);
            if (_removeArr) {
                var idx = _removeArr.indexOf(thisPtr);
                if (idx != -1) {
                    _removeArr.splice(idx, 1);
                    return;
                }
            }
            onHappen.apply(thisPtr, args);
            then = now;
        }
        window.requestAnimationFrame(_loop); // next frame 执行本函数
    });
    //ENTERFRAME侦听
    var enterArr = os._enterframeMap.get(onHappen);
    if (!enterArr) {
        enterArr = [];
        os._enterframeMap.set(onHappen, enterArr);
    }
    enterArr.push(thisPtr);
};
os.remove_ENTERFRAME = function (onHappen, thisPtr) {
    var enterArr = os._enterframeMap.get(onHappen);
    if (!enterArr)
        return;
    var idx = enterArr.indexOf(thisPtr);
    if (idx == -1)
        return;
    enterArr.splice(idx, 1);
    var removeArr = os._removeframeMap.get(onHappen);
    if (!removeArr) {
        removeArr = [];
        os._removeframeMap.set(onHappen, removeArr);
    }
    removeArr.push(thisPtr);
};
Object.defineProperty(os, 'defaultFamily', {
    get: function () {
        return Font.defaultFamily;
    },
    set: function (v) {
        Font.defaultFamily = v;
    }
});
//------------------------------------------------------------------------------------------------------
// top namespace
//------------------------------------------------------------------------------------------------------
for (var p in Laya) {
    if (typeof window[p] == "undefined") {
        var t_1 = Laya[p];
        if (p == "Buffer")
            continue;
        window[p] = t_1;
        if (t_1 && t_1.prototype && t_1.prototype.destroy != null && t_1.prototype.dispose == null)
            t_1.prototype.dispose = t_1.prototype.destroy;
    }
}
window.TextField = Laya.Text;
window.URLInfo = Laya.URL;
window.EngineConfig = Laya.Config;
window.EventObject = Laya.Event;
window.TreeNode = Laya.Node;
window.UIImage = Laya.Image;
window.LayaAnimation = Laya.Animation;
window.UIEventObject = Laya.UIEvent;
window.DevGeolocation = Laya.Geolocation;
window.DivElement = Laya.HTMLDivElement;
window.Keyboard = Laya.Keyboard;
//------------------------------------------------------------------------------------------------------
// class Extends
//------------------------------------------------------------------------------------------------------
// event extends
function eventExtends(evArr, clsObj) {
    if (clsObj == null)
        return;
    function toUpFuncName(funcName) {
        var regx = new RegExp("[A-Z]", "g");
        var m = funcName.match(regx);
        for (var i in m)
            funcName = funcName.replace(m[i], "_" + m[i]);
        return funcName.toUpperCase();
        ;
    }
    function evPush(extStr, evUpStr, evAPI, evType) {
        clsObj.prototype[extStr + evUpStr] = function (a, b, c) {
            this[evAPI](evType, b, a, c);
        };
    }
    function evHas(evType, evUpStr) {
        clsObj.prototype["has_" + evUpStr] = function () {
            return this.hasListener(evType);
        };
    }
    function evHappen(evType, evUpStr) {
        clsObj.prototype["happen_" + evUpStr] = function (data) {
            this.event(evType, data);
        };
    }
    for (var s in evArr) {
        var evType = evArr[s];
        var evUpStr = toUpFuncName(evType);
        evPush("add_", evUpStr, "on", evType);
        evPush("remove_", evUpStr, "off", evType);
        evPush("addOnce_", evUpStr, "once", evType);
        evHas(evType, evUpStr);
        evHappen(evType, evUpStr);
    }
    clsObj.prototype.removeAllListen = function () {
        this.offAll();
    };
}
var node_events = ["added", "display", "removed", "undisplay"];
eventExtends(node_events, TreeNode);
var sprite_events = ["click", "dragend", "dragmove", "dragstart", "mousedown", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "mousewheel", "doubleclick", "rightclick", "rightmousedown", "rightmouseup", "enterframe"];
eventExtends(sprite_events, Sprite);
var stage_events = ["blur", "focus", "focuschange", "fullscreenchange", "resize", "visibilitychange", "keydown", "keypress", "keyup"];
eventExtends(stage_events, Stage);
var httpRequest_event = ["complete", "error", "progress"];
eventExtends(httpRequest_event, HttpRequest);
var Socket_event = ["close", "error", "message", "open"];
eventExtends(Socket_event, Socket);
var Animation_event = ["complete", "label"];
eventExtends(Animation_event, Animation);
var FrameAnimation_event = ["complete"];
eventExtends(FrameAnimation_event, FrameAnimation);
// 由于the3Box的双击存在BUG，暂时还未修复，先使用这个拿去用下
Sprite.prototype.add_DOUBLECLICK = function (onHappen, thisPtr, args) {
    var clickTimes = 0;
    var lastMouseX = null, lastMouseY = null;
    this.__dbclickObj = null;
    var timeF = [];
    var _onClick = function (e) {
        var dPx = Browser.onMobile ? 100 : 5;
        if (lastMouseX != null && (Math.abs(e.stageX - lastMouseX) > dPx || Math.abs(e.stageY - lastMouseY) > dPx)) {
            clickTimes = 0;
            for (var i in timeF) {
                clearTimeout(timeF[i]);
            }
            timeF.length = 0;
        }
        lastMouseX = e.stageX;
        lastMouseY = e.stageY;
        clickTimes++;
        var f = setTimeout(function () {
            clickTimes--;
            timeF.shift();
        }, 250);
        timeF.push(f);
        if (clickTimes == 2) {
            clickTimes = 0;
            for (var i in timeF) {
                clearTimeout(timeF[i]);
            }
            timeF.length = 0;
            e.type = "doubleclick";
            var params = args ? args.concat(e) : [e];
            onHappen.apply(thisPtr, params);
        }
    };
    if (this.__doubleClickFuncs == null)
        this.__doubleClickFuncs = {};
    this.__doubleClickFuncs[onHappen] = _onClick;
    this.add_CLICK(_onClick);
};
Sprite.prototype.remove_DOUBLECLICK = function (onHappen, thisPtr) {
    if (this.__doubleClickFuncs) {
        var _onClick = this.__doubleClickFuncs[onHappen];
        if (!_onClick)
            return;
        delete this.__doubleClickFuncs[onHappen];
        this.remove_CLICK(_onClick);
    }
};
var oldSpriteOn = Sprite.prototype.on;
Sprite.prototype.on = function (type, caller, listener, args) {
    if (type == "doubleclick") {
        this.add_DOUBLECLICK(listener, caller, args);
        return;
    }
    return oldSpriteOn.apply(this, arguments);
};
var oldSpriteOff = Sprite.prototype.off;
Sprite.prototype.off = function (type, caller, listener, onceOnly) {
    if (type == "doubleclick") {
        this.remove_DOUBLECLICK(listener, caller);
        return;
    }
    return oldSpriteOff.apply(this, arguments);
};
var ___mouseEvent = [EventObject.RIGHT_MOUSE_DOWN, EventObject.RIGHT_MOUSE_UP, EventObject.RIGHT_CLICK,
    EventObject.MOUSE_WHEEL, EventObject.MOUSE_DOWN, EventObject.MOUSE_UP, EventObject.CLICK,
    EventObject.DOUBLE_CLICK, EventObject.ROLL_OVER, EventObject.ROLL_OUT, EventObject.MOUSE_OVER,
    EventObject.MOUSE_OUT, EventObject.MOUSE_MOVE];
var ___mouseEventStr = JSON.stringify(___mouseEvent);
getset(0, Sprite.prototype, 'hasMouseEvent', function () {
    for (var i in ___mouseEvent) {
        if (this.hasListener(___mouseEvent[i])) {
            return true;
        }
    }
    return false;
});
var component_events = ["resize"];
eventExtends(component_events, Component);
var label_events = ["change"];
eventExtends(label_events, Label);
var textInput_events = ["enter", "input", "blur", "focus"];
eventExtends(textInput_events, TextInput);
var UIGroup_events = ["change"];
eventExtends(UIGroup_events, UIGroup);
var clip_events = ["change", "loaded"];
var scroll_events = ["change", "end", "start"];
eventExtends(clip_events, Clip);
eventExtends(label_events, Button);
eventExtends(UIGroup_events, ComboBox);
eventExtends(scroll_events, ScrollBar);
eventExtends(UIGroup_events, List);
// 获取选中的列表以及设置为选中
getset(0, List.prototype, 'selectedItemList', function () {
    var arr = [];
    for (var i in this.array) {
        var item = this.array[i];
        if (item.selected)
            arr.push(item);
    }
    return arr;
}, function (arr) {
    for (var i in arr) {
        var item = arr[i];
        if (this.array.indexOf(item) != -1)
            item.selected = true;
    }
});
// 获取未选中的的列表以及设置为未选中
getset(0, List.prototype, 'unSelectedItemList', function () {
    var arr = [];
    for (var i in this.array) {
        var item = this.array[i];
        if (!item.selected)
            arr.push(item);
    }
    return arr;
}, function (arr) {
    for (var i in arr) {
        var item = arr[i];
        if (this.array.indexOf(item) != -1)
            item.selected = false;
    }
});
// Handler
Handler.prototype.delayRun = function (delay) {
    return setTimeout(function (handler) {
        handler.run();
    }, delay, this);
};
Handler.prototype.delayRunConver = function (delay) {
    if (this.delayRunSign) {
        clearTimeout(this.delayRunSign);
    }
    this.delayRunSign = this.delayRun(delay);
};
// utils Browser
getset(0, Browser, 'onMac', function () {
    return os.detectOS() == "Mac";
});
// Point
Point.interpolate = function (to, from, per) {
    var p = new Point();
    p.x = (to.x - from.x) * per + from.x;
    p.y = (to.y - from.y) * per + from.y;
    return p;
};
Point.distance = function (from, to) {
    return from.distance(to.x, to.y);
};
// 
Keyboard.keyNames = [];
for (var i in Keyboard) {
    var v = Keyboard[i];
    if (!isNaN(v)) {
        Keyboard.keyNames[v] = i;
    }
}
Keyboard.getKeyName = function (keyCode) {
    return Keyboard.keyNames[keyCode];
};
//------------------------------------------------------------------------------------------------------
// 追加的事件类型
//------------------------------------------------------------------------------------------------------
UIEventObject.DATA_CHANGE = "DATA_CHANGE";
var ListItemData = /** @class */ (function (_super) {
    __extends(ListItemData, _super);
    function ListItemData() {
        var _this = _super.call(this) || this;
        _this._selected = false;
        _this._group = null;
        _this._label = "";
        return _this;
    }
    Object.defineProperty(ListItemData.prototype, "selected", {
        get: function () { return this._selected; },
        set: function (v) {
            if (v != this._selected) {
                this._selected = v;
                this.happen_SELECTE_CHANGED();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ListItemData.prototype, "label", {
        get: function () { return this._label; },
        set: function (v) { this._label = v; },
        enumerable: false,
        configurable: true
    });
    ListItemData.prototype.add_SELECTE_CHANGED = function (onHappen, thisPtr, args) {
        if (args === void 0) { args = null; }
        this.on("SELECTE_CHANGED", thisPtr, onHappen, args);
    };
    ListItemData.prototype.remove_SELECTE_CHANGED = function (onHappen, thisPtr) {
        this.off("SELECTE_CHANGED", thisPtr, onHappen);
    };
    ListItemData.prototype.happen_SELECTE_CHANGED = function (data) {
        if (data === void 0) { data = null; }
        this.event("SELECTE_CHANGED", data);
    };
    ListItemData.prototype.has_SELECTE_CHANGED = function () {
        return this.hasListener("SELECTE_CHANGED");
    };
    return ListItemData;
}(EventDispatcher));
var TreeItemData = /** @class */ (function (_super) {
    __extends(TreeItemData, _super);
    function TreeItemData() {
        var _this = _super.call(this) || this;
        _this._visible = false;
        _this._isOpen = true;
        _this.isDirectory = false;
        _this._children = [];
        _this._parent = null;
        _this._visible = true;
        return _this;
    }
    Object.defineProperty(TreeItemData.prototype, "isOpen", {
        get: function () { return this._isOpen; },
        set: function (v) { this._isOpen = v; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TreeItemData.prototype, "visible", {
        get: function () { return this._visible; },
        set: function (v) { this._visible = v; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TreeItemData.prototype, "parent", {
        get: function () { return this._parent; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TreeItemData.prototype, "nodeParent", {
        get: function () { return this._parent; },
        enumerable: false,
        configurable: true
    });
    TreeItemData.prototype.addChild = function (item) { this._children.push(item); item._parent = this; };
    TreeItemData.prototype.addChildAt = function (item, index) { this._children.splice(index, 0, item); item._parent = this; };
    TreeItemData.prototype.removeChild = function (item) { this._children.splice(this._children.indexOf(item), 1); item._parent = null; };
    TreeItemData.prototype.removeChildAt = function (index) { var item = this._children.splice(index, 1)[0]; item._parent = null; };
    TreeItemData.prototype.removeAll = function () { for (var i in this._children) {
        this._children[i]._parent = null;
    } ; this._children.length = 0; };
    TreeItemData.prototype.getChildAt = function (index) { return this._children[index]; };
    TreeItemData.prototype.getChildIndex = function (item) { return this._children.indexOf(item); };
    TreeItemData.prototype.getChildByName = function (name) { for (var i in this._children) {
        if (this._children[i].label == name)
            return this._children[i];
    } ; return null; };
    Object.defineProperty(TreeItemData.prototype, "numChildren", {
        get: function () { return this._children.length; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TreeItemData.prototype, "children", {
        get: function () { return this._children; },
        enumerable: false,
        configurable: true
    });
    TreeItemData.prototype.isInherit = function (data) {
        var p = this.parent;
        while (p) {
            if (p == data)
                return true;
            p = p._parent;
        }
        return false;
    };
    TreeItemData.prototype.getList = function (arr) {
        arr.push(this);
        var len = this.numChildren;
        for (var i = 0; i < len; i++) {
            this.getChildAt(i).getList(arr);
        }
    };
    Object.defineProperty(TreeItemData.prototype, "root", {
        get: function () {
            var p = this;
            while (true) {
                if (p._parent) {
                    p = p._parent;
                }
                else {
                    break;
                }
            }
            return p;
        },
        enumerable: false,
        configurable: true
    });
    TreeItemData.removeExistChild = function (list) {
        for (var i = list.length - 1; i >= 0; i--) {
            for (var s in list) {
                if (list[i].isInherit(list[s])) {
                    list.splice(i, 1);
                    break;
                }
            }
        }
    };
    /**
     * 获取通过关键词筛选后搜索的结果
     * @param node 含有完整子节点信息的根节点
     * @param key 关键词 确保是小写的
     * @param firstCheck [可选] 默认值=true 是否首次检查
     * @return [TreeItemData] 返回允许存在的数组（如果子节点包含关键词则父节点也应该列出）
     */
    TreeItemData.searchByKeyResult = function (node, key, firstCheck) {
        if (firstCheck === void 0) { firstCheck = true; }
        // init
        if (firstCheck) {
            key = key.toLocaleLowerCase();
        }
        node.keyState = null;
        // 如果包含关键词则：该节点为-含有关键词的结果节点
        if (node.label && node.label.toLocaleLowerCase().indexOf(key) != -1) {
            node.keyState = 1;
        }
        // 如果存在子节点则继续探索
        if (node.children.length > 0) {
            for (var i = 0; i < node.children.length; i++) {
                var childNode = node.children[i];
                TreeItemData.searchByKeyResult(childNode, key, false);
            }
        }
        // 如果不存在子节点则开始回升检索，剔除掉不应存在的节点
        else {
            var p = node;
            var startRetain = false;
            while (1) {
                var parentNode = p.parent;
                startRetain = setNodeState(p, startRetain);
                if (!parentNode)
                    break;
                p = parentNode;
            }
        }
        // 根节点的情况：结算
        if (firstCheck) {
            var listArr = [];
            node.getList(listArr);
            for (var i = 0; i < listArr.length; i++) {
                var targetNode = listArr[i];
                if (targetNode.keyState == null) {
                    listArr.splice(i, 1);
                    i--;
                }
            }
            // 存在子节点的需要打开（文件夹）
            for (var i = 0; i < listArr.length; i++) {
                var targetNode = listArr[i];
                if (targetNode.numChildren > 0)
                    targetNode.isOpen = true;
            }
            return listArr;
        }
        function setNodeState(p, startRetain) {
            // -- 如果该节点是强保留，则开始向上保留
            if (p.keyState == 1) {
                startRetain = true;
            }
            // -- 如果该节点无需保留但子节点有强保留的，则该节点是弱保留
            else if (startRetain && p.keyState != 1) {
                p.keyState = 0;
            }
            // -- 否则节点就可能不保留，最终根据可能不保留的节点
            // else {
            //     p.parent.removeChild(p);
            // }
            return startRetain;
        }
    };
    return TreeItemData;
}(ListItemData));
/**
 * 混合模式插件
 * Created by 黑暗之神KDS on 2018-08-08 16:45:53.
 */
(function () {
    var blendFunType = [0x0, 0x1, 0x0300, 0x0301, 0x0306, 0x0307, 0x0302, 0x0303, 0x0304, 0x0305, 0x8001, 0x8002, 0x8003, 0x8004, 0x0308];
    var start = 8;
    var BlendModeCls = eval("BlendMode");
    var fns = [];
    var targetFns = [];
    for (var x in blendFunType) {
        for (var y in blendFunType) {
            BlendModeCls.TOINT["blend" + x + "-" + y] = start++;
            var blendF = fnsFunc(x, y);
            fns.push(blendF);
            targetFns.push(blendF);
        }
    }
    var oldBlendInit = BlendModeCls._init_;
    BlendModeCls._init_ = function (gl) {
        oldBlendInit.call(BlendModeCls, gl);
        BlendModeCls.fns = BlendModeCls.fns.concat(fns);
        BlendModeCls.targetFns = BlendModeCls.targetFns.concat(targetFns);
    };
    function fnsFunc(x, y) {
        var f = function (gl) {
            gl.blendFunc(blendFunType[x], blendFunType[y]);
        };
        return f;
    }
})();
/**
 * 0~-180 红色 红蓝 蓝 蓝绿
 * 0~180 红色 红绿 绿 绿蓝
 *
 * 原理：其中rgb为图片每像素点当前的颜色，而toR为第一行，toG为第二行，toB为第三行，
 * var toR = r * 1 + g * 0 + b * 0; // 1.0 ~ 1.0 ~ 0.0
 * var toG = r * 0 + g * 0 + b * 1; // 1.0 ~ 0.0 ~ 1.0
 * var toB = r * 1 + g * 0 + b * 0; // 1.0 ~ 1.0 ~ 1.0
 * Created by 黑暗之神KDS on 2018-11-20 14:34:53.
 */
var HueFilter = /** @class */ (function (_super) {
    __extends(HueFilter, _super);
    /**
     * -180~180
     * -1~-120 normal -> green
     * -121~-180
     *
     * @param hue
     */
    function HueFilter(hue) {
        if (hue === void 0) { hue = 0; }
        var _this = this;
        if (hue < -180)
            hue = -180;
        if (hue > 180)
            hue = 180;
        var colorArr, toColor;
        if (hue == 0) {
            colorArr = HueFilter.normal;
        }
        else {
            colorArr = [];
            var fromColor;
            var per;
            if (hue < 0 && hue >= -60) {
                fromColor = HueFilter.normal;
                toColor = HueFilter.redblue;
                per = hue / -60;
            }
            else if (hue < -60 && hue >= -120) {
                fromColor = HueFilter.redblue;
                toColor = HueFilter.blue;
                per = (hue + 60) / -60;
            }
            else if (hue < -120) {
                fromColor = HueFilter.blue;
                toColor = HueFilter.bluegreen;
                per = (hue + 120) / -60;
            }
            else if (hue > 0 && hue <= 60) {
                fromColor = HueFilter.normal;
                toColor = HueFilter.redgreen;
                per = hue / 60;
            }
            else if (hue > 60 && hue <= 120) {
                fromColor = HueFilter.redgreen;
                toColor = HueFilter.green;
                per = (hue - 60) / 60;
            }
            else {
                fromColor = HueFilter.green;
                toColor = HueFilter.bluegreen;
                per = (hue - 120) / 60;
            }
            for (var s = 0; s < fromColor.length; s++) {
                colorArr[s] = (toColor[s] - fromColor[s]) * per + fromColor[s];
            }
        }
        _this = _super.call(this, colorArr) || this;
        _this.colorMat = colorArr;
        return _this;
    }
    // red
    HueFilter.normal = [
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        0, 0, 1, 0, 0,
        0, 0, 0, 1, 0 //A
    ];
    // -60
    HueFilter.redblue = [
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 0, 1, 0 //A    
    ];
    // -120
    HueFilter.blue = [
        0, 1, 0, 0, 0,
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 0, 1, 0 //A
    ];
    // -180
    HueFilter.bluegreen = [
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 0, 1, 0 //A
    ];
    // 60
    HueFilter.redgreen = [
        1, 0, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        0, 0, 0, 1, 0 //A 
    ];
    //120
    HueFilter.green = [
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        0, 0, 0, 1, 0 //A 
    ];
    return HueFilter;
}(ColorFilter));
//------------------------------------------------------------------------------------------------------
// 固定拥有 overImg selectImg label
//  *  以下控制器可选择
//  *  mainComp.supportMultiSelect CTRL/SHIFT 多选
//  *  mainComp.mustSelectOne 必须选中一个，否则点击空白处就会取消选择
//------------------------------------------------------------------------------------------------------
var ListRender = /** @class */ (function (_super) {
    __extends(ListRender, _super);
    /**
     * 构造函数
     */
    function ListRender() {
        var _this = _super.call(this) || this;
        new Handler(_this, _this._init).delayRun(0);
        return _this;
    }
    /**
     * 初始化
     */
    ListRender.prototype._init = function () {
        // -- 事件初始化
        this.initEvent();
        // -- 初始化选中
    };
    Object.defineProperty(ListRender.prototype, "mainComp", {
        //------------------------------------------------------------------------------------------------------
        // 可获取的条件
        //------------------------------------------------------------------------------------------------------
        /**
         * 获取主控件：这里是List
         */
        get: function () {
            if (this._mainComp)
                return this._mainComp;
            if (this.parent == null) {
                return null;
            }
            this._mainComp = this.parent.parent;
            return this._mainComp;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ListRender.prototype, "dataList", {
        /**
         * 数据集 - 相对List就是当前可视范围内显示到的数据
         */
        get: function () {
            return this.mainComp.array;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ListRender.prototype, "lastSelected", {
        /**
         * 获取和设置上一个选中的数据，这无关乎多选都是唯一的
         */
        get: function () {
            return this.mainComp ? this.mainComp.selectedItem : null;
        },
        set: function (v) {
            if (this.mainComp) {
                this.mainComp.selectedItem = v;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ListRender.prototype, "dataSource", {
        /**
         * 获取和设置数据源
         */
        //@ts-ignore
        get: function () {
            return this.data;
        },
        set: function (v) {
            var needUpdate = false;
            if (this.data != v) {
                if (this.data) {
                    this.data.remove_SELECTE_CHANGED(this._onDataSelectChange, this);
                }
                this.data = v;
                if (this.data) {
                    this.data.add_SELECTE_CHANGED(this._onDataSelectChange, this);
                    this._onDataSelectChange();
                }
                this.happen_DATACHANGE();
                needUpdate = true;
            }
            else if (v && this.lastLabel != v.label) {
                needUpdate = true;
            }
            this.lastLabel = v ? v.label : null;
            if (needUpdate) {
                this.updateAppearance();
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 重写addChild 根据子对象的名称快速设置我的属性
     * @param node
     */
    ListRender.prototype.addChild = function (node) {
        this[node.name] = node;
        if (node.name == "overImg" || node.name == "selectImg") {
            node.visible = false;
        }
        return _super.prototype.addChild.call(this, node);
    };
    //------------------------------------------------------------------------------------------------------
    // 事件相关
    //------------------------------------------------------------------------------------------------------
    /**
     * 初始化事件
     */
    ListRender.prototype.initEvent = function () {
        // -- 鼠标划动效果
        this.add_MOUSEOVER(this._onMouseOver, this);
        this.add_MOUSEOUT(this._onMouseOut, this);
        // -- 鼠标点击选中事件
        this.add_CLICK(this._onMouseDown, this);
        this.add_RIGHTMOUSEDOWN(this._onMouseDown, this);
        // -- mainComp的
        // 双击
        this.add_DOUBLECLICK(this._onDBClick, this);
        //
    };
    /**
     * 当鼠标在该ListRender上面
     */
    ListRender.prototype._onMouseOver = function () {
        if (this.mainComp["__overImg"])
            this.mainComp["__overImg"].visible = false;
        this.overImg.visible = true;
        this.mainComp["__overImg"] = this.overImg;
    };
    /**
     *  当鼠标离开该ListRender时
     */
    ListRender.prototype._onMouseOut = function () {
        this.overImg.visible = false;
    };
    /**
     * 鼠标按下的情况
     * -- 右键点中已选择的目标就忽略掉选择效果
     * @param e
     * @private
     */
    ListRender.prototype._onMouseDown = function (e) {
        if (!this.data)
            return;
        var mainComp = this.mainComp;
        if (mainComp.disabled)
            return;
        var dataList = this.dataList;
        // 右键点击已选中的对象则忽略掉
        if (e.type == "rightmousedown" && this.data.selected) {
            return;
        }
        // 拥有控制器：支持CTRL/SHIFT多选的功能
        if (mainComp.supportMultiSelect) {
            this.isMultiSelect = e.ctrlKey || e.shiftKey || mainComp.supportMultiSelectSimulationCtrk;
            if (e.shiftKey) {
                if (this.lastSelected) {
                    var lastSelected = this.lastSelected;
                    // -- 选中所有数据
                    var listLen = dataList.length;
                    var lastItemIdx = dataList.indexOf(lastSelected);
                    var thisItemIdx = dataList.indexOf(this.data);
                    if (lastItemIdx != -1 && thisItemIdx != -1) {
                        var formIdx, toIdx;
                        if (lastItemIdx > thisItemIdx) {
                            formIdx = thisItemIdx;
                            toIdx = lastItemIdx;
                        }
                        else {
                            formIdx = lastItemIdx;
                            toIdx = thisItemIdx;
                        }
                        for (var i = formIdx; i <= toIdx; i++) {
                            dataList[i].selected = true;
                        }
                        // -- 其他的取消选中
                        for (var i = 0; i < formIdx; i++) {
                            dataList[i].selected = false;
                        }
                        for (var i = toIdx + 1; i < listLen; i++) {
                            dataList[i].selected = false;
                        }
                        this.lastSelected = lastSelected;
                        return;
                    }
                }
            }
        }
        // -- 存在不能取消最后一个人的话就忽略
        var toSelected = !this.data.selected;
        // -- 拥有控制器：必须多选一个的话且取消选择的话就判断如果只有一个选择就禁止取消
        if (mainComp.mustSelectOne && !toSelected) {
            var selectCount = 0;
            var dataListLen = dataList.length;
            for (var i = 0; i < dataListLen; i++) {
                if (dataList[i].selected)
                    selectCount++;
                if (selectCount > 1)
                    break;
            }
            if (selectCount == 1) {
                return;
            }
        }
        // // 不是多选的话就取消掉其他人的选择
        if (!this.isMultiSelect) {
            var isCancelElse = false;
            for (var i = 0; i < this.dataList.length; i++) {
                var elseData = this.dataList[i];
                if (elseData != this.data && elseData.selected) {
                    elseData.selected = false;
                    isCancelElse = true;
                }
            }
            this.data.selected = !isCancelElse ? toSelected : true;
        }
        else {
            this.data.selected = toSelected;
        }
        // 如果该数据被选择就设置下 lastSelected
        if (this.data.selected)
            this.lastSelected = this.data;
    };
    /**
     * 双击点击
     * @param e
     * @private
     */
    ListRender.prototype._onDBClick = function (e) {
        this.mainComp.event("itemDoubleClick", this.data);
    };
    /**
     * 当对应的数据发生select改变时
     */
    ListRender.prototype._onDataSelectChange = function (e) {
        if (e === void 0) { e = null; }
        this.updateAppearance_selected();
        // -- 当选中时记录上次选中的目标
        if (this.data.selected) {
            this.lastSelected = this.data;
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 效果显示
    //------------------------------------------------------------------------------------------------------
    /**
     * 刷新选中效果
     */
    ListRender.prototype.updateAppearance_selected = function () {
        if (this.data == null) {
            return;
        }
        this.selectImg.visible = this.data.selected;
        if (this["labelStyle"] && this["labelStyle"].labelColors) {
            var cArr = this["labelStyle"].labelColors.split(",");
            if (this.label)
                this.label.color = this.data.selected ? cArr[0] : cArr[1];
        }
        else {
            if (this.label)
                this.label.color = this.data.selected ? "#ffffff" : "#b8b8b8";
        }
    };
    /**
     * 刷新显示效果
     */
    ListRender.prototype.updateAppearance = function () {
        if (this.data == null)
            return;
        // -- 文本
        if (this.label) {
            this.label.text = this.data.label;
            // 渲染层BUG，偶尔会出现不符合text的问题,在所有listRender里面修复，观察看看是否还会出现
            this.label.textField.lines;
        }
        // -- 选中状态
        this.updateAppearance_selected();
        // -- 执行方法
        if (this.data.renderFunc) {
            this.data.renderFunc.apply(this);
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 自定义事件
    //------------------------------------------------------------------------------------------------------
    /**
     * 添加侦听数据改变事件
     * @param onHappen
     * @param thisPtr
     * @param args [可选] 默认值=null
     */
    ListRender.prototype.add_DATACHANGE = function (onHappen, thisPtr, args) {
        if (args === void 0) { args = null; }
        this.on(UIEventObject.DATA_CHANGE, thisPtr, onHappen, args);
    };
    ;
    /**
     * 移除侦听数据改变事件
     * @param onHappen
     * @param thisPtr
     */
    ListRender.prototype.remove_DATACHANGE = function (onHappen, thisPtr) {
        this.off(UIEventObject.DATA_CHANGE, thisPtr, onHappen);
    };
    ;
    /**
     * 派发数据改变事件
     * @param data [可选] 默认值=null
     */
    ListRender.prototype.happen_DATACHANGE = function (data) {
        if (data === void 0) { data = null; }
        this.event(UIEventObject.DATA_CHANGE, data);
    };
    ;
    //------------------------------------------------------------------------------------------------------
    // 销毁
    //------------------------------------------------------------------------------------------------------
    /**
     * 销毁
     */
    ListRender.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        if (this.data && this.data.has_SELECTE_CHANGED()) {
            this.data.remove_SELECTE_CHANGED(this._onDataSelectChange, this);
        }
    };
    return ListRender;
}(Box));
/**
 * 电脑语音系统
 * Created by 黑暗之神KDS on 2017/9/5 0005.
 */
var ComputeTS = /** @class */ (function () {
    function ComputeTS() {
    }
    /**
     * 初始化 初始化后才可以播放
     * @param onFin [可选] 默认值=null
     */
    ComputeTS.init = function (onFin) {
        if (onFin === void 0) { onFin = null; }
        var tsUR = new HttpRequest();
        tsUR.send("http://www.kdsrpg.com/include/getTsTok.php?pid=" + ComputeTS.projectID, "", "post");
        tsUR.add_COMPLETE(function (str) {
            if (str != "error") {
                ComputeTS.kdsrpgTSToken = JSON.parse(str).access_token;
                onFin && onFin(true);
            }
            else {
                onFin && onFin(false);
            }
        }, this);
        tsUR.add_ERROR(function () {
            onFin && onFin(false);
        }, this);
    };
    /**
     * 播放
     * @param content 内容
     * @param per 人声 0女 1男
     * @param speed 速度 0-8
     * @param pit 语调 0-8
     * @param vol 声音 0-8
     */
    ComputeTS.play = function (content, per, speed, pit, vol) {
        if (per === void 0) { per = 0; }
        if (speed === void 0) { speed = 7; }
        if (pit === void 0) { pit = 5; }
        if (vol === void 0) { vol = 8; }
        if (!ComputeTS.kdsrpgTSToken)
            return;
        var lan = "zh";
        var ctp = "1"; // 1=web
        var body = "tex=" + content + "&lan=" + lan + "&tok=" + ComputeTS.kdsrpgTSToken + "&ctp=" + ctp + "&cuid=" + ComputeTS.projectID + "&spd=" + speed + "&pit=" + pit + "&vol=" + vol + "&per=" + per;
        var soundURL = "http://tsn.baidu.com/text2audio?" + body;
        SoundManager.playSound(soundURL);
        return soundURL;
    };
    ComputeTS.projectID = 1;
    return ComputeTS;
}());
// @ts-ignore
var globalThis = this;
Sprite.prototype["getGlobalBounds"] = function () {
    var min = this.localToGlobal(new Point(0, 0));
    var max = this.localToGlobal(new Point(this.width, this.height));
    var resultRect = new Rectangle();
    resultRect.x = min.x;
    resultRect.y = min.y;
    resultRect.width = max.x - min.x;
    resultRect.height = max.y - min.y;
    return resultRect;
};
Sprite.prototype["getGlobalSelfBounds"] = function () {
    var rect = this.getSelfBounds();
    var min = this.localToGlobal(new Point(rect.x, rect.y));
    var max = this.localToGlobal(new Point(rect.right, rect.bottom));
    var resultRect = new Rectangle();
    resultRect.x = min.x;
    resultRect.y = min.y;
    resultRect.width = max.x - min.x;
    resultRect.height = max.y - min.y;
    return resultRect;
};
Point["distance2"] = function (ax, ay, bx, by) {
    return Math.sqrt((bx - ax) * (bx - ax) + (by - ay) * (by - ay));
};
Point["distanceSquare"] = function (p1, p2) {
    return Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2);
};
Point["distanceSquare2"] = function (ax, ay, bx, by) {
    return Math.pow(bx - ax, 2) + Math.pow(by - ay, 2);
};
Point["interpolate2"] = function (toX, toY, fromX, fromY, per) {
    var x = (toX - fromX) * per + fromX;
    var y = (toY - fromY) * per + fromY;
    return [x, y];
};
/**
 * Created by feng on 2019-04-03 16:42:52.
 */
// 处理laya中鼠标右键中键不分bug，把右键事件分离为中键与右键事件。
var oldsendEvents = TouchManager.prototype["sendEvents"];
TouchManager.prototype["sendEvents"] = function (eles, type, touchID) {
    //
    if (type == "rightmousedown") {
        if (this._event.nativeEvent && this._event.nativeEvent.button == 1) {
            type = "middlemousedown";
        }
    }
    if (type == "rightmouseup") {
        if (this._event.nativeEvent && this._event.nativeEvent.button == 1) {
            type = "middlemouseup";
        }
    }
    oldsendEvents.call(this, eles, type, touchID);
};
if (typeof top === "undefined") {
    // @ts-ignore
    top = this;
}
// gcide_common
var mainDomain_gcide_common = _getAttributeFromParentPages('gcide_common');
var mainDomain_LGConfig = mainDomain_gcide_common === null || mainDomain_gcide_common === void 0 ? void 0 : mainDomain_gcide_common.LGConfig;
var mainDomain_kdsrpg = mainDomain_gcide_common === null || mainDomain_gcide_common === void 0 ? void 0 : mainDomain_gcide_common.kdsrpg;
// gcide
var mainDomain_gcide = _getAttributeFromParentPages('gcide');
var mainDomain_LGNative = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGNative;
var mainDomain_TopCanvas = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.TopCanvas;
var mainDomain_LGPromptSigh = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGPromptSigh;
var mainDomain_LGWindow = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGWindow;
var mainDomain_LGProjectDevDataManager = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGProjectDevDataManager;
var mainDomain_CodeIDE = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.CodeIDE;
var mainDomain_FileObject = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.FileObject;
var mainDomain_LGSystem = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGSystem;
var mainDomain_LGQRCode = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGQRCode;
var mainDomain_DownloadFile = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.DownloadFile;
var mainDomain_LGProjectList = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGProjectList;
var mainDomain_ServerConnUtils = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.ServerConnUtils;
var mainDomain_GlobalEvent = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.GlobalEvent;
var mainDomain_LGUser = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGUser;
var mainDomain_LGMainMenu = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGMainMenu;
var mainDomain_setStartupWindowText = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.setStartupWindowText;
var mainDomain_closeStartupWindow = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.closeStartupWindow;
var mainDomain_KDSEncode = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.KDSEncode;
// gcide_core
var mainDomain_gcide_core = _getAttributeFromParentPages('gcide_core');
var mainDomain_frameRef = mainDomain_gcide_core === null || mainDomain_gcide_core === void 0 ? void 0 : mainDomain_gcide_core.frameRef;
var mainDomain_stage = mainDomain_gcide_core === null || mainDomain_gcide_core === void 0 ? void 0 : mainDomain_gcide_core.stage;
var mainDomain_os = mainDomain_gcide_core === null || mainDomain_gcide_core === void 0 ? void 0 : mainDomain_gcide_core.os;
var mainDomain_DateUtils = mainDomain_gcide_core === null || mainDomain_gcide_core === void 0 ? void 0 : mainDomain_gcide_core.DateUtils;
//
var mainDomain_require = _getAttributeFromParentPages('require');
var mainDomain_nw_gui = mainDomain_require === null || mainDomain_require === void 0 ? void 0 : mainDomain_require('nw.gui');
var mainDomain_fs = mainDomain_require === null || mainDomain_require === void 0 ? void 0 : mainDomain_require('fs');
var mainDomain_child_process = mainDomain_require === null || mainDomain_require === void 0 ? void 0 : mainDomain_require('child_process');
//
var mainDomain_process = _getAttributeFromParentPages('process');
//
var mainDomain_nw = _getAttributeFromParentPages('nw');
var mainDomain_serverapi = _getAttributeFromParentPages('serverapi');
var mainDomain_Buffer = _getAttributeFromParentPages('Buffer');
/**
 * 从当前页面或者父页面中的指定属性值到 globalThis 顶级对象上
 *
 * @param attribute
 */
function _getAttributeFromParentPages(attribute) {
    var result = globalThis[attribute];
    // 从top中获取数据存在跨域的风险使用 try-catch 进行规避错误
    try {
        var _host = top;
        while (!result && !!_host) {
            result = _host[attribute];
            if (_host !== _host.top) {
                _host = _host.top;
            }
            else {
                _host = null;
            }
        }
    }
    catch (error) {
    }
    return result;
}
var CommandExecute;
(function (CommandExecute) {
    /**
     * 显示文字命令参数数据
     *
     * 对应命令 command_11
     */
    var SayData = /** @class */ (function () {
        function SayData() {
        }
        /**
         * 解析命令参数
         *
         * @param cmdParams 命令参数
         * @returns 显示文字命令参数数据
         */
        SayData.parse = function (cmdParams) {
            var sayData = new SayData();
            // 0-对话框ID
            sayData.dialogID = cmdParams[0];
            // 1-头像参数
            sayData.headImg = cmdParams[1] ? cmdParams[1] : "";
            // 2-名称
            sayData.name = cmdParams[2];
            // 3-播放速度
            sayData.playSpeed = cmdParams[3];
            // 4-漫画对话框模式  -5数值变量 -4触发者 -3无 -2主角 -1当前执行对象 0-N 场景对象
            sayData.dialogMode = cmdParams[4];
            // 5-内容
            sayData.content = cmdParams[5];
            // 6-语音
            sayData.voice = cmdParams[6];
            // 7-立绘模式下表情
            sayData.standAvatarModeFace = cmdParams[7];
            // 8-漫画对话框指定数值变量ID
            sayData.dialogModeVariableID = cmdParams[8];
            // 9-名字颜色 
            sayData.nameColor = cmdParams[9];
            // 10-修改属性集合
            sayData.modifyVariableGather = cmdParams[10];
            //
            return sayData;
        };
        return SayData;
    }());
    CommandExecute.SayData = SayData;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 if(后期优化为预编译函数，同变量设置,接近原生JS)
     * 0-类型：0-数值 1-开关 2-字符串 3-脚本 4-N=自定义条件分歧
     * 1-数值1的类别
     * 2-数值1的值 [固定值,全局变量,玩家变量,其他]
     * 3-数值1对比符号 0= 1>= 2<= 3> 4< 5!=
     * 4-数值2的类别
     * 5-数值2的值 [固定值,全局变量,玩家变量,其他]
     *
     * 6-开关的类别
     * 7-开关的值 [全局开关,玩家开关,[独立开关(对象，开关,开关变量)]]
     * 8-开关的对比符号 0-开启时 1-关闭时
     *
     * 9-字符串类别 0-全局字符串 1-玩家字符串 2-游戏字符串
     * 10-字符串ID [全局字符串ID,玩家字符串ID]
     * 11-字符串值
     * 20-对比方式[0-等于 1-包含 2-不包含]
     * 21-否使用游戏字符串对比
     * 22-自定义游戏字符串数据1(对比目标)
     * 23-使用游戏字符串对比的自定义字符串数据2(用于对比的字符串数据)
     *
     * 12-脚本TS
     *
     * 13-是否存在else
     *
     * 14-脚本JS
     *
     * 15-对应的自定义条件参数（含有类型数据<4~n>以便）[type,objValue,idValue]
     *
     * 16-数值1的游戏数据值 [id,objValue,idValue]
     * 17-数值2的游戏数据值 [id,objValue,idValue]
     *
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_0(commandPage, cmd, trigger, triggerPlayer) {
        var bool;
        var params = cmd.params;
        switch (params[0]) {
            case 0: // numerical
                var value1 = getValue(params[1], params[2], params[16]);
                var value2 = getValue(params[4], params[5], params[17]);
                switch (params[3]) {
                    case 0:
                        bool = value1 === value2;
                        break;
                    case 1:
                        bool = value1 >= value2;
                        break;
                    case 2:
                        bool = (value1 > value2);
                        break;
                    case 3:
                        bool = (value1 <= value2);
                        break;
                    case 4:
                        bool = (value1 < value2);
                        break;
                    case 5:
                        bool = (value1 !== value2);
                        break;
                }
                break;
            case 1: // switch
                switch (params[6]) {
                    case 0:
                        bool = Command.gameWorld.getWorldSwitch(params[7][0]) == (params[8] == 0 ? 1 : 0);
                        break;
                    case 1:
                        bool = trigger.triggerPlayer ? trigger.triggerPlayer.variable.getSwitch(params[7][1]) === (params[8] == 0 ? 1 : 0) : false;
                        break;
                    case 2:
                        var soIndex = params[7][2][0];
                        if (soIndex == -5)
                            soIndex = triggerPlayer.variable.getVariable(params[7][2][2]);
                        var targetSo = CommandExecute.getSceneObject(soIndex, trigger, triggerPlayer);
                        bool = targetSo ? (targetSo.getSwitchs(params[7][2][1]) === (params[8] == 0 ? 1 : 0)) : false;
                        break;
                }
                break;
            case 2: // string
                var str1 = getString(params[9], params[10], params[22]);
                var str2 = getString2(params[21], params[11], params[23]);
                var csymbol = params[20] ? params[20] : 0;
                switch (csymbol) {
                    case 0:
                        bool = str1 === str2;
                        break;
                    case 1:
                        bool = str1.indexOf(str2) !== -1;
                        break;
                    case 2:
                        bool = str1.indexOf(str2) === -1;
                        break;
                }
                break;
            case 3: // script
                bool = !!eval(params[14]);
                break;
            default: // 自定义
                var customCommandID = MathUtils.int(params[0]) - 3;
                var customFunc = CustomCondition["f" + customCommandID];
                if (customFunc) {
                    bool = customFunc(trigger, params[15][1]);
                }
        }
        if (!bool) {
            if (cmd.gotoLine[0] != null) {
                trigger.goto(cmd.gotoLine[0]);
            }
            else {
                trigger.goto(cmd.gotoLine[1]);
            }
        }
        return;
        /**
         * 获取数值
         * @param valueType 数值类型
         * @param param
         */
        function getValue(valueType, param, customDataDisplay) {
            switch (valueType) {
                case 0: // const
                    return param[0];
                case 1: // world variable
                    return Command.gameWorld.getWorldVariable(param[1]);
                case 2: // player variable
                    if (!trigger || !trigger.triggerPlayer)
                        return 0;
                    return trigger.triggerPlayer.variable.getVariable(param[2]);
                case 3: // gcide_canvasbuilder.System presupposition value
                    return CustomValueFunction["f" + (param[3] + 1)](trigger, triggerPlayer);
                case 4: // 自定义游戏数据显示
                    return CustomGameNumber["f" + customDataDisplay[0]](trigger, customDataDisplay[1]);
            }
        }
        /**
         * 获取字符串
         * @param strType 字符串类型
         * @param param 全局/玩家
         * @param customParam 游戏字符串数据
         */
        function getString(strType, param, customParam) {
            switch (strType) {
                case 0: // 全局字符串
                    return Command.gameWorld.getWorldString(param[0]);
                case 1: // 玩家字符串
                    if (!trigger || !trigger.triggerPlayer)
                        return "";
                    return trigger.triggerPlayer.variable.getString(param[1]);
                case 2: // 游戏字符串
                    if (!trigger || !trigger.triggerPlayer)
                        return "";
                    return CustomGameString["f" + customParam[0]](trigger, customParam[1]);
            }
        }
        function getString2(useGameStr, param, customParam) {
            if (!useGameStr) {
                var compiled = Variable.splitDynamicText(param);
                return Variable.margeDynamicText(compiled, triggerPlayer, trigger);
            }
            else {
                if (!trigger || !trigger.triggerPlayer)
                    return "";
                return CustomGameString["f" + customParam[0]](trigger, customParam[1]);
            }
        }
    }
    CommandExecute.command_0 = command_0;
    /**
     * 预编译
     * @param commandPage 命令页
     * @param cmd 命令
     * @param index 命令所在的索引
     */
    function precompile_0(commandPage, cmd, index) {
        // 向下查找同级别的 else endif命令并
        var len = commandPage.commands.length;
        var indent = 0; // 一旦发现里面嵌套的if的话就+1，结束就-1
        // if 中的条件满足的话应该跳转me
        var elseCmd;
        // elseif else 等
        for (var i = index + 1; i < len; i++) {
            var targetCmd = commandPage.commands[i];
            if (!targetCmd)
                continue;
            // type if
            if (targetCmd.type == 0) {
                indent++;
            }
            // type else
            else if (indent == 0 && targetCmd.type == 1) {
                cmd.gotoLine[0] = (i + 1);
                elseCmd = targetCmd;
                elseCmd.link = elseCmd;
                elseCmd.insertable = true;
            }
            // type endif
            else if (targetCmd.type == 2) {
                if (indent == 0) {
                    if (elseCmd) {
                        elseCmd.gotoLine[0] = (i + 1);
                    }
                    cmd.gotoLine[1] = (i + 1);
                    cmd.link = targetCmd;
                    targetCmd.link = targetCmd;
                    targetCmd.insertable = true;
                    break;
                }
                else {
                    indent--;
                }
            }
        }
    }
    CommandExecute.precompile_0 = precompile_0;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 else
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_1(commandPage, cmd, trigger, triggerPlayer) {
        trigger.goto(cmd.gotoLine[0]);
    }
    CommandExecute.command_1 = command_1;
})(CommandExecute || (CommandExecute = {}));
/**
 * 对话框选项
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 selStart
     * 0-对话框ID
     * 1-默认选中索引
     * 2-取消选项索引
     * 3-选项类型
     * 4-变量索引
     * 5-出现条件
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息（仅当前命令）
     */
    function command_3(commandPage, cmd, trigger, triggerPlayer, playerInput) {
        if (!triggerPlayer)
            return;
        // 如果是真正的selStart，发送文字和选项们给客户端并等待
        if (playerInput.length == 0) {
            var selContents = [];
            var selectedIndex = cmd.params[1];
            var cancelIndex = cmd.params[2];
            var hideIndexs = [];
            for (var i = 0; i < cmd.gotoLine.length; i++) {
                var selCmd = commandPage.commands[cmd.gotoLine[i] - 1];
                if (onConditionCheck(triggerPlayer, selCmd.params[5])) {
                    var name = selCmd.params[0];
                    if (selCmd.params[3] != null && selCmd.params[4] != null && selCmd.params[3] == 1) {
                        name = triggerPlayer.variable.getString(selCmd.params[4]);
                    }
                    selContents.push(name);
                }
                else {
                    hideIndexs.push(i);
                    if (selCmd.params[1] == cmd.params[1])
                        selectedIndex = -1;
                    if (selCmd.params[2] == cmd.params[2])
                        cancelIndex = -1;
                }
            }
            if (selContents.length > 0) {
                cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, [cmd.params[0], selContents, selectedIndex, cancelIndex, hideIndexs]);
                EventUtils.happen(triggerPlayer.sceneObject, Command.EVENT_SYSTEM_COMMAND_START, [1]);
                trigger.pause = true;
            }
            else {
                var next = cmd.paramsCompiled[0];
                trigger.goto(next);
            }
        }
        else {
            var selIndex = playerInput[0];
            if (selIndex < 0 || selIndex >= cmd.gotoLine.length)
                return;
            trigger.goto(cmd.gotoLine[selIndex]);
        }
        /**
         * 检查是否满足条件
         */
        function onConditionCheck(triggerPlayer, conditionList) {
            if (!conditionList || conditionList.length <= 0)
                return true;
            var onsure = true;
            for (var i = 0; i < conditionList.length; i++) {
                var condition = conditionList[i];
                var bool = true;
                if (condition.type == 0) {
                    bool = triggerPlayer.variable.getSwitch(condition.varID) == condition.value;
                }
                else if (condition.type == 4) {
                    // 区分单机网络版
                    if (Config.SINGLE_PLAYER_CORE) {
                        bool = ClientWorld.getWorldSwitch(condition.varID) == condition.value;
                    }
                    else {
                        bool = ServerWorld.getWorldSwitch(condition.varID) == condition.value;
                    }
                }
                else {
                    // 区分单机网络版本
                    var varValue = condition.type == 1 ? triggerPlayer.variable.getVariable(condition.varID) : (Config.SINGLE_PLAYER_CORE ? ClientWorld.getWorldVariable(condition.varID) : ServerWorld.getWorldVariable(condition.varID));
                    if ((condition.compare == 0 && varValue !== condition.value) ||
                        (condition.compare == 1 && varValue < condition.value) ||
                        (condition.compare == 2 && varValue <= condition.value) ||
                        (condition.compare == 3 && varValue > condition.value) ||
                        (condition.compare == 4 && varValue >= condition.value) ||
                        (condition.compare == 5 && varValue === condition.value)) {
                        bool = false;
                    }
                }
                if (!bool) {
                    onsure = false;
                    break;
                }
            }
            return onsure;
        }
    }
    CommandExecute.command_3 = command_3;
    /**
     * 预编译
     * @param commandPage 命令页
     * @param cmd 命令
     * @param index 命令所在的索引
     */
    function precompile_3(commandPage, cmd, index) {
        var len = commandPage.commands.length;
        var indent = 0;
        var selArr = [];
        var firstSel = true;
        for (var i = index + 1; i < len; i++) {
            var targetCmd = commandPage.commands[i];
            if (!targetCmd)
                continue;
            if (targetCmd.type == 3) {
                indent++;
            }
            else if (indent == 0 && targetCmd.type == 4) {
                // 记录跳转到的选项行，有多少个选项就记录多少个
                cmd.gotoLine.push(i + 1);
                selArr.push(targetCmd);
                targetCmd.link = targetCmd;
                if (!firstSel) {
                    targetCmd.insertable = true;
                }
                firstSel = false;
            }
            else if (targetCmd.type == 10) {
                if (indent == 0) {
                    for (var s = 0; s < selArr.length; s++) {
                        selArr[s].gotoLine.push(i + 1);
                    }
                    cmd.link = targetCmd;
                    targetCmd.link = targetCmd;
                    // 记录跳出所有选项的行
                    cmd.paramsCompiled = [i + 1];
                    targetCmd.insertable = true;
                    break;
                }
                else {
                    indent--;
                }
            }
        }
    }
    CommandExecute.precompile_3 = precompile_3;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 sel
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_4(commandPage, cmd, trigger, triggerPlayer) {
        trigger.goto(cmd.gotoLine[0]);
    }
    CommandExecute.command_4 = command_4;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 loop
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_6(commandPage, cmd, trigger, triggerPlayer) {
        trigger.goto(cmd.gotoLine[0]);
    }
    CommandExecute.command_6 = command_6;
    /**
     * 预编译
     * @param commandPage 命令页
     * @param cmd 命令
     * @param index 命令所在的索引
     */
    function precompile_6(commandPage, cmd, index) {
        cmd.insertable = true;
        var len = commandPage.commands.length;
        var indent = 0;
        for (var i = index - 1; i >= 0; i--) {
            var targetCmd = commandPage.commands[i];
            if (!targetCmd)
                continue;
            if (targetCmd.type == 6) {
                indent++;
            }
            else if (indent == 0 && targetCmd.type == 7) {
                targetCmd.gotoLine.push(index + 1);
            }
            else if (targetCmd.type == 5) {
                if (indent == 0) {
                    cmd.gotoLine.push(i + 1);
                    targetCmd.link = cmd;
                    cmd.link = cmd;
                    break;
                }
                else {
                    indent--;
                }
            }
        }
    }
    CommandExecute.precompile_6 = precompile_6;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 sel
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_7(commandPage, cmd, trigger, triggerPlayer) {
        if (cmd.gotoLine[0] != null)
            trigger.goto(cmd.gotoLine[0]);
    }
    CommandExecute.command_7 = command_7;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 goto
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_9(commandPage, cmd, trigger, triggerPlayer) {
        if (cmd.gotoLine[0] != null)
            trigger.goto(cmd.gotoLine[0]);
    }
    CommandExecute.command_9 = command_9;
    /**
     * 预编译
     * @param commandPage 命令页
     * @param cmd 命令
     * @param index 命令所在的索引
     */
    function precompile_9(commandPage, cmd, index) {
        var len = commandPage.commands.length;
        var indent = 0;
        for (var i = 0; i < len; i++) {
            var targetCmd = commandPage.commands[i];
            if (!targetCmd)
                continue;
            if (targetCmd.type == 8 && cmd.params[0] == targetCmd.params[0]) {
                cmd.gotoLine.push(i + 1);
                break;
            }
        }
    }
    CommandExecute.precompile_9 = precompile_9;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 显示文字 say
     * 0-对话框ID
     * 1-头像参数
     * 2-名称
     * 3-播放速度
     * 4-漫画对话框模式  -5数值变量 -4触发者 -3无 -2主角 -1当前执行对象 0-N 场景对象
     * 5-内容
     * 6-语音
     * 7-立绘模式下表情
     * 8-漫画对话框指定数值变量ID
     * 9-名字颜色
     * 10-修改属性集合
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_11(commandPage, cmd, trigger, triggerPlayer) {
        // 暂停主角行动
        if (triggerPlayer) {
            var cmdIndex = commandPage.commands.indexOf(cmd);
            var nextCmd = commandPage.commands[cmdIndex + 1];
            // 如果下一条命令是选项的话并且选项对话框使用最近的或与本对话同对话框则不停止，直接同时发送了选项命令过去，
            // 客户端同时收到两条命令。否则才停止
            if (nextCmd && nextCmd.type == 3 && (nextCmd.params[0] == 0 || nextCmd.params[0] == cmd.params[0])) {
                // 将选项一并发送，这里就不暂停命令执行了
            }
            else {
                trigger.pause = true;
                trigger.offset(1);
            }
            // 派发执行系统命令的事件
            EventUtils.happen(triggerPlayer.sceneObject, Command.EVENT_SYSTEM_COMMAND_START, [0]);
            // 替换文本（如变量）
            var name = Variable.margeDynamicText(cmd.paramsCompiled[0], triggerPlayer, trigger);
            var content = Variable.margeDynamicText(cmd.paramsCompiled[1], triggerPlayer, trigger);
            // 漫画对话框指定对象索引
            var socIndex = -1;
            if (cmd.params[4] != -5) {
                var targetSceneObject = CommandExecute.getSceneObject(cmd.params[4], trigger, triggerPlayer);
                socIndex = targetSceneObject ? targetSceneObject.index : -1;
            }
            else {
                var index = cmd.params[8] ? cmd.params[8] : 0;
                socIndex = triggerPlayer.variable.getVariable(index);
            }
            //
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, [cmd.params[0], cmd.params[1], name, cmd.params[3],
                socIndex, content, cmd.params[6], cmd.params[7], cmd.params[9], cmd.id, cmd.params[10]]);
        }
    }
    CommandExecute.command_11 = command_11;
    /**
     * 预编译
     * @param commandPage 命令页
     * @param cmd 命令
     * @param index 命令所在的索引
     */
    function precompile_11(commandPage, cmd, index) {
        cmd.paramsCompiled = [];
        cmd.paramsCompiled[0] = Variable.splitDynamicText(cmd.params[2]);
        cmd.paramsCompiled[1] = Variable.splitDynamicText(cmd.params[5]);
    }
    CommandExecute.precompile_11 = precompile_11;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 输入文本 inputMessage
     * 0-输入的内容
     *
     *
     *
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息（仅当前命令）
     */
    function command_12(commandPage, cmd, trigger, triggerPlayer, playerInput) {
        // 直接暂停命令执行，然后等待玩家主动提交输入命令才继续执行后续命令 GameCommand.inputMessageAndContinueExecute
        trigger.pause = true;
        trigger.offset(1);
        cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, []);
    }
    CommandExecute.command_12 = command_12;
})(CommandExecute || (CommandExecute = {}));
/**
 * 设置变量：
 *   变量：全局变量、玩家变量
 *   开关：全局开关、玩家开关、独立开关
 *   字符串：全局字符串、玩家字符串
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 设置变量 inputMessage
     * 0-变量类型：0-全局变量 1-全局开关 2-全局字符串 3-玩家变量 4-玩家开关 5-玩家字符串 6-独立开关
     * 1-变量索引
     * 2-符号 0= 1+ 2- 3* 4/ 5% 6^
     * 3-值类型 0-固定值 1-全局变量 2-玩家变量 3-随机数 4-常用函数（旧历史） 5-游戏数值
     * 4-值：固定值：变量操作=数值 开关操作=true/false 字符串操作=字符串/索引
     * 5-值：全局变量
     * 6-值：玩家变量
     * 7-值：随机数[]
     * 8-值：其他的index
     * 9-独立开关的对象index -5数值变量 -4触发者 -1当前执行对象 0-N 场景对象
     * 10-值：游戏数据显示数值 [id,objValue,idValue]
     * 11-是否取整
     * 12-是否取绝对值
     * 13-是否开方
     * 14-开关相关用到的游戏开关值 [id,objValue,idValue]
     * 15-字符串设置成了[游戏字符串]
     * 16-字符串用到的游戏字符串值 [id,objValue,idValue]
     * 17-保留几位小数
     * 18-是否是索引模式
     * 19-随机数(min-max)模式 0-常量1-变量2-仅下限使用变量3-仅下限使用变量
     * 20-下限(min)变量id
     * 21-上限(max)变量id
     * 22-独立开关变量
     *
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_13(commandPage, cmd, trigger, triggerPlayer) {
        cmd.paramsCompiled[0].apply(this, arguments);
    }
    CommandExecute.command_13 = command_13;
    /**
    * 预编译
    * @param commandPage 命令页
    * @param cmd 命令
    * @param index 命令所在的索引
    */
    function precompile_13(commandPage, cmd, index) {
        var symbols = [null, "+", "-", "*", "/", "%", "^"];
        var symbolsForArr = ["=", "+=", "-=", "*=", "/=", "%=", "^="];
        var resultSetTypes = [[0, "Command.gameWorld.setWorldVariable"], [0, "Command.gameWorld.setWorldSwitch"], [0, "Command.gameWorld.setWorldString"],
            [0, "triggerPlayer.variable.setVariable"], [0, "triggerPlayer.variable.setSwitch"], [0, "triggerPlayer.variable.setString"], [0, "CommandExecute.setSwitchs"]];
        var resultGetTypes = [[0, "Command.gameWorld.getWorldVariable"], [0, "Command.gameWorld.getWorldSwitch"], [0, "Command.gameWorld.getWorldString"],
            [0, "triggerPlayer.variable.getVariable"], [0, "triggerPlayer.variable.getSwitch"], [0, "triggerPlayer.variable.getString"], [0, "CommandExecute.getSwitchs"]];
        var resultType = cmd.params[0];
        var varID = cmd.params[1];
        var resultVar = resultSetTypes[resultType];
        var symbolType = symbols[cmd.params[2]];
        var valueType = cmd.params[3];
        var valueExpression;
        var value;
        var finalExpression;
        var secondParamCompiled = "";
        if (valueType == 0) { // 固定值
            if (resultType == 2 || resultType == 5) {
                if (cmd.params[15]) {
                    if (cmd.params[16]) {
                        value = "(CustomGameString.f" + (cmd.params[16][0]) + "(trigger,cmd.params[16][1]))";
                    }
                    else {
                        value = "";
                    }
                }
                else {
                    value = "Variable.margeDynamicText(cmd.paramsCompiled[1],triggerPlayer,trigger)";
                    secondParamCompiled = ",Variable.splitDynamicText(cmd.params[4])";
                }
            }
            else {
                var params4 = cmd.params[4];
                if ((resultType == 1 || resultType == 4 || resultType == 6) && params4 == 2 && cmd.params[14]) {
                    value = "(CustomCondition.f" + (cmd.params[14][0]) + "(trigger,cmd.params[14][1])?1:0)";
                }
                else {
                    value = params4;
                }
            }
        }
        else if (valueType == 1) { // 全局变量
            value = "Command.gameWorld.getWorldVariable(" + cmd.params[5] + ")";
        }
        else if (valueType == 2) { // 玩家变量
            value = "triggerPlayer.variable.getVariable(" + cmd.params[6] + ")";
        }
        else if (valueType == 3) { // 随机数
            //判断是否使用变量
            var min = "triggerPlayer.variable.getVariable(" + cmd.params[20] + ")";
            var max = "triggerPlayer.variable.getVariable(" + cmd.params[21] + ")";
            if (cmd.params[19] == null || cmd.params[19] == 0) {
                value = "(MathUtils.rand(" + (cmd.params[7][1] - cmd.params[7][0]) + "+1)+" + cmd.params[7][0] + ")";
            }
            else if (cmd.params[19] == 1) {
                value = "(MathUtils.rand(" + max + " - " + min + " +1)+" + min + ")";
            }
            else if (cmd.params[19] == 2) {
                value = "(MathUtils.rand(" + cmd.params[7][1] + " - " + min + " +1)+" + min + ")";
            }
            else {
                value = "(MathUtils.rand(" + max + " - " + cmd.params[7][0] + " +1)+" + cmd.params[7][0] + ")";
            }
        }
        else if (valueType == 4) { // 常用函数
            value = "CustomValueFunction.f" + (cmd.params[8] + 1) + "(trigger,triggerPlayer)";
        }
        else if (valueType == 5) { // 自定义游戏数据显示
            value = "CustomGameNumber.f" + (cmd.params[10][0]) + "(trigger,cmd.params[10][1])";
        }
        // 方法
        if (resultVar[0] == 0) {
            if (symbolType) {
                var lastValue = resultGetTypes[resultType][1] + ("(" + varID + ")");
                if (symbolType == "^") {
                    valueExpression = "(Math.pow(" + lastValue + "," + value + "))";
                }
                else {
                    valueExpression = lastValue + symbolType + ("(" + value + ")");
                }
            }
            else {
                valueExpression = value;
            }
            // 最终结果
            if (cmd.params[12])
                valueExpression = "(Math.abs(" + valueExpression + "))";
            if (cmd.params[13])
                valueExpression = "CommandExecute.getSqrtNum(" + valueExpression + ")";
            if (cmd.params[11])
                valueExpression = "(Math.floor(" + valueExpression + "))";
            if (!cmd.params[11] && cmd.params[17]) {
                valueExpression = "CommandExecute.fomatFloat(" + valueExpression + "," + cmd.params[17] + ")";
            }
            if (resultType == 6) {
                finalExpression = resultVar[1] + ("(" + varID + ", " + valueExpression + ", " + cmd.params[9] + "," + cmd.params[22] + ", trigger, triggerPlayer) ");
            }
            else {
                finalExpression = resultVar[1] + ("(" + varID + ", " + valueExpression + ") ");
                //索引模式
                if (cmd.params[18])
                    finalExpression = resultVar[1] + ("(triggerPlayer.variable.getVariable(" + varID + "), " + valueExpression + ") ");
            }
        }
        // 直接设置
        else {
            if (symbolType) {
                valueExpression = value;
            }
            else {
                valueExpression = value;
            }
            // 最终结果
            if (cmd.params[12])
                valueExpression = "(Math.abs(" + valueExpression + "))";
            if (cmd.params[13])
                valueExpression = "CommandExecute.getSqrtNum(" + valueExpression + ")";
            if (cmd.params[11])
                valueExpression = "(Math.floor(" + valueExpression + "))";
            if (!cmd.params[11] && cmd.params[17]) {
                valueExpression = "CommandExecute.fomatFloat(" + valueExpression + "," + cmd.params[17] + ")";
            }
            finalExpression = resultVar[1] + ("[" + varID + "]" + symbolsForArr[cmd.params[2]] + " " + valueExpression + " ");
            if (cmd.params[2] == 4) {
                finalExpression += "; " + resultVar[1] + " [" + varID + "] = Math.floor(" + resultVar[1] + "[" + varID + "]); ";
            }
        }
        var evalStr = "cmd.paramsCompiled = [function (commandPage, cmd, trigger, triggerPlayer) { " + finalExpression + "; }" + secondParamCompiled + "]";
        eval(evalStr);
        // trace("最终编译", evalStr);
    }
    CommandExecute.precompile_13 = precompile_13;
    //------------------------------------------------------------------------------------------------------
    // sqrt开方
    //------------------------------------------------------------------------------------------------------
    function getSqrtNum(num) {
        if (num >= 0)
            return Math.sqrt(num);
        else
            return -Math.sqrt(Math.abs(num));
    }
    CommandExecute.getSqrtNum = getSqrtNum;
    //--------------------------------------------------------
    //保留n位小数
    //---------------------------------------------------------
    function fomatFloat(value, n) {
        var f = value.toFixed(n);
        return parseFloat(f);
    }
    CommandExecute.fomatFloat = fomatFloat;
    //------------------------------------------------------------------------------------------------------
    //独立开关
    //------------------------------------------------------------------------------------------------------
    function setSwitchs(index, value, id, varIndex, trigger, triggerPlayer) {
        //使用数值变量指定对象
        if (id == -5)
            id = triggerPlayer.variable.getVariable(varIndex);
        var targetSo = CommandExecute.getSceneObject(id, trigger, triggerPlayer);
        if (targetSo) {
            targetSo.setSwitchs(index, value);
        }
    }
    CommandExecute.setSwitchs = setSwitchs;
    function getSwitchs(index, id, trigger, triggerPlayer) {
        var targetSo = CommandExecute.getSceneObject(id, trigger, triggerPlayer);
        if (targetSo) {
            return targetSo.getSwitchs(index);
        }
        return null;
    }
    CommandExecute.getSwitchs = getSwitchs;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 终止事件处理
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_14(commandPage, cmd, trigger, triggerPlayer) {
        trigger.cmdReturn = true;
    }
    CommandExecute.command_14 = command_14;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 记录所有的片段事件页
     */
    CommandExecute.fragmentEvents = {};
    /**
     * 片段事件
     * 【使用场合】
     *   事件命令中：
     *      -- 非独立：同公共事件
     *      -- 独立：新触发线
     *   脚本调用：
     *      -- 独立：新触发线
     *
     *   所有正在执行的片段都将片段完整事件写入到存档中，寄生在触发线中，记录
     *   其所在的片段index
     *
     *
     * 0--片段名称
     * 1--是否独立触发线
     * 2--事件集
     * 3--SID
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_15(commandPage, cmd, trigger, triggerPlayer) {
        // 查询对应的片段：这里没有的话则动态创建（这里不做预编译）-根据事件页唯一ID和所在的行数
        var realSID = commandPage.id + "_" + commandPage.commands.indexOf(cmd);
        var fragmentPage = CommandExecute.fragmentEvents[realSID];
        if (!fragmentPage)
            fragmentPage = CommandExecute.fragmentEvents[realSID] = new CommandPage(cmd.params[2]);
        // 独立触发线
        if (cmd.params[1]) {
            // 创建新的触发线去执行：以当前的触发线
            var newFETrigger = new CommandTrigger(CommandTrigger.COMMAND_MAIN_TYPE_FRAGMENT_EVENT, 0, trigger.scene, trigger.trigger, true, trigger.executor);
            fragmentPage.startTriggerEvent(newFETrigger, trigger.inputMessage, cmd.params[2]);
        }
        // 非独立触发线
        else {
            // 停止当前执行，直到新的事件执行完毕再继续
            trigger.commandScope.push({ cmdPage: fragmentPage, index: 0, commonEventID: 0, fragmentCommands: cmd.params[2] });
        }
    }
    CommandExecute.command_15 = command_15;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 call 调用公共事件
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_16(commandPage, cmd, trigger, triggerPlayer) {
        var commonEventID = MathUtils.int(cmd.params[0]);
        if (commonEventID < 0)
            return;
        var cmdPage = Command.gameWorld.commonEventPages[commonEventID];
        if (!cmdPage)
            return;
        if (cmd.params[1]) {
            // 触发者和执行者需要
            var newFETrigger = new CommandTrigger(CommandTrigger.COMMAND_MAIN_TYPE_CALL_COMMON_EVENT, commonEventID, trigger.scene, trigger.trigger, true, trigger.executor);
            cmdPage.startTriggerEvent(newFETrigger, trigger.inputMessage, cmd.params[2]);
        }
        else {
            trigger.commandScope.push({ cmdPage: cmdPage, index: 0, commonEventID: commonEventID, fragmentCommands: null });
        }
    }
    CommandExecute.command_16 = command_16;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 call 调用公共事件
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_17(commandPage, cmd, trigger, triggerPlayer) {
        // 客户端模式
        if (cmd.params[2]) {
            var params = ObjectUtils.depthClone(cmd.params);
            if (cmd.params[3]) {
                params[0] = triggerPlayer.variable.getVariable(cmd.params[0]);
            }
            cmd.callExecuteFunction(trigger.id, triggerPlayer, params);
        }
        // 服务器模式
        else {
            // 停止当前命令并偏移+1
            trigger.pause = true;
            trigger.offset(1);
            // 等待N帧或ms后继续执行该触发线
            if (cmd.params[1] == 1) {
                trigger.waitTime(cmd.params[3] ? triggerPlayer.variable.getVariable(cmd.params[0]) : cmd.params[0]);
            }
            else {
                trigger.waitFrame(cmd.params[3] ? triggerPlayer.variable.getVariable(cmd.params[0]) : cmd.params[0]);
            }
        }
    }
    CommandExecute.command_17 = command_17;
    function commandContinue_17() {
    }
    CommandExecute.commandContinue_17 = commandContinue_17;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 服务器脚本
     * 0-脚本名称
     * 1-typescript代码
     * 2-编译后的javascript代码
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_19(commandPage, cmd, trigger, triggerPlayer) {
        cmd.paramsCompiled[0].apply(this, arguments);
    }
    CommandExecute.command_19 = command_19;
    function precompile_19(commandPage, cmd, index) {
        if (Config.EDIT_MODE)
            return;
        var evalStr = "cmd.paramsCompiled = [function(commandPage,cmd,trigger,triggerPlayer){" + cmd.params[2] + ";}]";
        // evalStr = ServerMain.handleAndRunCode(evalStr,true);
        eval(evalStr);
    }
    CommandExecute.precompile_19 = precompile_19;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 客户端脚本
     * 0-脚本名称
     * 1-typescript代码
     * 2-编译后的javascript代码
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    var serverCallClientCode;
    function command_20(commandPage, cmd, trigger, triggerPlayer, playerInput, customParams) {
        cmd.paramsCompiled[0].apply(this, arguments);
    }
    CommandExecute.command_20 = command_20;
    function precompile_20(commandPage, cmd, index) {
        if (Config.EDIT_MODE)
            return;
        var evalStr;
        if (Config.IS_SERVER) {
            if (serverCallClientCode) {
                cmd.paramsCompiled = serverCallClientCode;
            }
            else {
                evalStr = "cmd.paramsCompiled = [function(commandPage,cmd,trigger,triggerPlayer,playerInput,customParams){if (triggerPlayer)cmd.callExecuteFunction(trigger.id, triggerPlayer, [cmd.params[2]], \"executeScript\");}]";
                eval(evalStr);
                serverCallClientCode = cmd.paramsCompiled;
            }
        }
        else {
            evalStr = "cmd.paramsCompiled = [function(commandPage,cmd,trigger,triggerPlayer,playerInput,customParams){" + cmd.params[2] + ";}]";
            eval(evalStr);
        }
    }
    CommandExecute.precompile_20 = precompile_20;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 场所移动
     * -- 是否使用变量
     * -- 场景ID对应的变量ID（玩家变量）|| 场景ID
     * -- 场景X对应的变量ID（玩家变量）|| 坐标X
     * -- 场景Y对应的变量ID（玩家变量）|| 坐标Y
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_21(commandPage, cmd, trigger, triggerPlayer) {
        // 事件执行完毕后切换场景
        trigger.cmdReturn = true;
        // 派发执行系统命令的事件
        EventUtils.happen(triggerPlayer.sceneObject, Command.EVENT_SYSTEM_COMMAND_START, [2]);
        // 变量模式 or 普通模式
        if (cmd.params[0]) {
            var point = new Point(triggerPlayer.variable.getVariable(cmd.params[2]), triggerPlayer.variable.getVariable(cmd.params[3]));
            if (cmd.params[4])
                point = GameUtils.getGridCenterByGrid(point);
            triggerPlayer.toScene(triggerPlayer.variable.getVariable(cmd.params[1]), point.x, point.y);
        }
        else {
            triggerPlayer.toScene(cmd.params[1], cmd.params[2], cmd.params[3]);
        }
        // }, this, [commandPage, cmd, trigger, triggerPlayer]), true);
    }
    CommandExecute.command_21 = command_21;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 对象行为
     * -- 0-对象 -2玩家 -1当前对象 0-N 指定对象
     * -- 1-是否重复
     * -- 2-行为
     * -- 3-覆盖旧的行为组
     * -- 4-强制停止之前的行为（会立即停止之前正在执行的行为）
     * -- 5-使用玩家变量指定对象
     * -- 6-玩家变量id
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_22(commandPage, cmd, trigger, triggerPlayer) {
        var index = cmd.params[0];
        var isVar = cmd.params[5] ? cmd.params[5] : false;
        if (isVar) {
            var varNum = cmd.params[6] ? cmd.params[6] : false;
            index = triggerPlayer.variable.getVariable(varNum);
        }
        var targetSo = CommandExecute.getSceneObject(index, trigger, triggerPlayer);
        if (!targetSo)
            return;
        var loop = cmd.params[1] == 1;
        // var triggerPlayerSo: SceneObject;
        // if (triggerPlayer) {
        //     triggerPlayerSo = triggerPlayer.sceneObject;
        // }
        var cover = cmd.params[3] ? true : false;
        var forceStopLastBehavior = cmd.params[4] ? true : false;
        // 添加行为，当行为播放完毕后，减少计数
        trigger.addBehavior(targetSo, cmd.params[2], loop, trigger.trigger, cover, 0, true, forceStopLastBehavior, 0, trigger.executor);
        // var soBehavior = targetSo.addBehavior(cmd.params[2], loop, triggerPlayerSo, Callback.New(function (trigger: CommandTrigger, size) {
        //     trigger.removeBehaviorCount();
        // }, this, [trigger, cmd.params[2].length]), cover);
        // 覆盖的情况，清空此前的行为计数
        // 添加行为计数
    }
    CommandExecute.command_22 = command_22;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 等待行为结束
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_23(commandPage, cmd, trigger, triggerPlayer) {
        // 如果该触发器中存在行为的话则暂停并等待行为结束后继续执行
        if (trigger.hasBehavior) {
            trigger.continueWhenBehaviorOver = true;
            trigger.pause = true;
            trigger.offset(1);
        }
    }
    CommandExecute.command_23 = command_23;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 场景震动
     * -- strength 震动强度 1-10
     * -- duration 持续时间 n秒
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_31(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "shake");
        }
    }
    CommandExecute.command_31 = command_31;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 场景色调
     * -- r  -255~255
     * -- g  -255~255
     * -- b  -255~255
     * -- gray 0-100
     * -- t 帧
     * -- mr
     * -- mg
     * -- mb
     * -- 层 -1=全场景 0-n=指定层
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_32(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "tonal");
        }
    }
    CommandExecute.command_32 = command_32;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 镜头管理
     * 0-- 类别  0-使用坐标 1-指定对象
     * 1-- x 坐标
     * 2-- y 坐标
     * 3-- index 对象 -2玩家对象 -4触发者对象 -1当前对象 -5数值变量  0-n场景对象
     * 4-- tween 是否缓动 true/false
     * 5-- f 帧
     * 6--坐标类别(常量/变量)
     * 7--变量索引x
     * 8--变量索引y
     * 9--格子坐标
     * 10--指定场景对象索引id
     *
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_35(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            //坐标
            var tox = cmd.params[1];
            var toy = cmd.params[2];
            if (cmd.params[6] == 1) {
                var xindex = cmd.params[7] ? cmd.params[7] : 0;
                tox = triggerPlayer.variable.getVariable(xindex);
                var yindex = cmd.params[8] ? cmd.params[8] : 0;
                toy = triggerPlayer.variable.getVariable(yindex);
            }
            //格子
            if (cmd.params[9] == 1) {
                tox *= Config.SCENE_GRID_SIZE;
                toy *= Config.SCENE_GRID_SIZE;
            }
            //对象
            var socIndex = -1;
            if (cmd.params[3] != -5) {
                var targetSceneObject = CommandExecute.getSceneObject(cmd.params[3], trigger, triggerPlayer);
                socIndex = targetSceneObject ? targetSceneObject.index : -1;
            }
            else {
                var index = cmd.params[10] ? cmd.params[10] : 0;
                socIndex = triggerPlayer.variable.getVariable(index);
            }
            var newParams = [cmd.params[0], tox, toy, socIndex, cmd.params[4], cmd.params[5]];
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, newParams, "cameraMove");
        }
    }
    CommandExecute.command_35 = command_35;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 雾
     * 0-- 图片地址
     * 1-- 缩放x
     * 2-- 缩放y
     * 3-- 滚动x
     * 4-- 滚动y
     * 5-- 透明度
     * 6-- 混合方式
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_36(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "fogSet");
        }
    }
    CommandExecute.command_36 = command_36;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 图像系统
     * 0-- 命令集
     *   0-显示图片 [type,id,url,pivotType,x,y,w,h,ro,alpha,blendMode]
     *   1-移动图片 [type,id,frame,pivotType,x,y,w,h,ro,alpha,blendMode,tween]
     *   2-自动旋转 [type,id,angle]
     *   3-更改图片色调 [type,id,r,g,b,gray,t,mr,gr,br,tween]
     *   4-消除图片 [type,id]
     *   5-显示动画 [type,id,AniID,x,y,scaleX,scaleY,ro,alpha,loop,fps]
     *   6-移动动画 [type,id,t,x,y,scaleX,scaleY,ro,alpha,tween]
     *
     *   8-等待 [type,frame]
     *   9-显示对话 [type,1-对话框ID 2-头像参数 3-名称 4-播放速度 5-漫画对话框模式 6-内容 [-1] 8-语音 9-立绘表情ID 10-漫画对话框指定数值变量ID] （-5数值变量 -4触发者 -3无 -2主角 -1当前执行对象 0-N 场景对象）
     *   10-播放音效 [type,音乐地址,音量,音调]
     *
     *  11-显示立绘 [type,id,x,y,ro,alpha,scaleX,scaleY,行走图ID,播放帧率,是否播放,起始帧数,动作ID,色相]
     *  12-移动立绘 [type,id,x,y,ro,alpha,scaleX,scaleY,frame,播放帧率,是否播放,起始帧数,动作ID,色相,tween]
     *  13-显示界面 [type,id,x,y,ro,alpha,scaleX,scaleY,id]
     *  14-移动界面 [type,id,x,y,ro,alpha,scaleX,scaleY,frame,tween,uiID]
     *  15-消除界面 [type,uiID]
     *
     *  16-移动界面组件 [type,frame,tweenID,atts,NonTweenType,空,immediately] NonTweenType=无法渐变的属性处理 0/1  atts=变更的属性集，格式 {uiID:number,atts:{ [compID: string]: [number, { [attrName: string]: any }] }} immediately=是否立即
     *
     *  //*-显示行走图 [type,id,x,y,ro,alpha,scaleX,scaleY,行走图ID,面向,播放帧率,是否播放,起始帧数,动作ID,色相]
     *  //*-移动行走图 [type,id,x,y,ro,alpha,scaleX,scaleY,frame,面向,播放帧率,是否播放,起始帧数,动作ID,色相,tween]
     *
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_37(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            // 如果存在对话的话就等待最终的对话提交再继续执行
            var imageInfos = cmd.params[0];
            var dialogs = ArrayUtils.matchAttributes(imageInfos, { "0": 9 }, false);
            if (dialogs.length != 0) {
                // 暂停触发器
                trigger.pause = true;
                trigger.offset(1);
                // 替换漫画模式对象
                for (var i = 0; i < dialogs.length; i++) {
                    var dialogData = dialogs[i];
                    var socIndex = -1;
                    if (dialogData[5] != -5) {
                        var targetSceneObject = CommandExecute.getSceneObject(dialogData[5], trigger, triggerPlayer);
                        socIndex = targetSceneObject ? targetSceneObject.index : -1;
                    }
                    else {
                        var index = cmd.params[10] ? cmd.params[10] : 0;
                        socIndex = triggerPlayer.variable.getVariable(index);
                    }
                    dialogData[7] = socIndex;
                }
            }
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params);
        }
    }
    CommandExecute.command_37 = command_37;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 等待图像系统完毕
     *
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_38(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            // 如果存在对话的话就等待最终的对话提交再继续执行
            trigger.pause = true;
            trigger.offset(1);
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params);
        }
    }
    CommandExecute.command_38 = command_38;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 播放背景音乐
     * -- 音乐地址
     * -- 音量
     * -- 音调
     * -- 淡入时间 0-N 秒
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_63(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "playBGM");
        }
    }
    CommandExecute.command_63 = command_63;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 停止背景音乐
     * -- 淡出时间 N 秒
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_64(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "stopBGM");
        }
    }
    CommandExecute.command_64 = command_64;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 播放环境音效
     * -- 音效地址
     * -- 音量
     * -- 音调
     * -- 淡入时间 0-N 秒
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_65(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "playBGS");
        }
    }
    CommandExecute.command_65 = command_65;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 停止环境音效
     * -- 淡出时间 N 秒
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_66(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "stopBGS");
        }
    }
    CommandExecute.command_66 = command_66;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 播放音效
     * -- 音乐地址
     * -- 音量
     * -- 音调
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_67(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, [-1].concat(cmd.params), "playSE");
        }
    }
    CommandExecute.command_67 = command_67;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 停止音效
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_68(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "stopSE");
        }
    }
    CommandExecute.command_68 = command_68;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by JayLen on 2020-08-01 17:32:13.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 播放语音
     * -- 语音地址
     * -- 音量
     * -- 音调
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_69(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, [-1].concat(cmd.params), "playTS");
        }
    }
    CommandExecute.command_69 = command_69;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by JayLen on 2020-08-01 17:35:57.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 停止播放语音
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_70(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "stopTS");
        }
    }
    CommandExecute.command_70 = command_70;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 播放背景音乐
     * -- 0 时间帧 number
     * -- 1 过渡方式 string=>TransData
     * -- 2 修改的属性集：格式 {uiID:number,atts:{ [compID: string]: [number, { [attrName: string]: any }] }}
     *                  可渐变属性：x/y/width/height/rotation/alpha，
     *                  其余属性过渡的话可配置，如在该事件面板中列举出来勾选：是否允许过渡以及是否支持小数
     *                  其中[number,{ [attrName: string]: any }] 的第一个代表模式（0-默认 1-强制全属性变更）
     * -- 3 无法渐变过渡的属性处理方式：0-在第一帧时变动 1-在最后一帧时变动 nonTweenType
     * -- 4
     * -- 5 类型(立即，渐变)
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_71(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            var imageInfos = [16].concat(cmd.params);
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, [[imageInfos]]);
        }
    }
    CommandExecute.command_71 = command_71;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 打开界面
     * -- 0-界面ID
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_72(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "openUI");
        }
    }
    CommandExecute.command_72 = command_72;
})(CommandExecute || (CommandExecute = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecute;
(function (CommandExecute) {
    /**
     * 处理命令 停止环境音效
     * -- 淡出时间 N 秒
     * @param commandPage 当前执行的命令页
     * @param cmd 当前的命令
     * @param trigger 触发者
     * @param playerInput 玩家的输入信息
     */
    function command_73(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "closeUI");
        }
    }
    CommandExecute.command_73 = command_73;
})(CommandExecute || (CommandExecute = {}));
/**
 * 单一命令
 * ----- 关于触发对象 -----
 * 【client-trigger-单线】场景对象-点击事件 trigger.trigger触发者=玩家场景对象 trigger.executor执行者=NPC
 * 【client-trigger】场景对象-碰触事件 trigger.trigger触发者=玩家场景对象 trigger.executor执行者=NPC
 *                  只有玩家与NPC的碰触
 * 【server-trigger】场景对象-并行事件 trigger.trigger触发者=系统 trigger.executor触发者=系统
 * 【server-trigger】公共事件-并行事件 trigger.trigger触发者=系统 trigger.executor执行者=系统
 * 【client-trigger】UI-点击事件 trigger.trigger触发者=玩家场景对象 trigger.executor执行者=玩家场景对象
 * 【server-trigger-单线】进入场景的事件 trigger.trigger触发者=玩家场景对象 trigger.executor执行者=玩家场景对象
 *
 *  单线表示同时只能执行一个该类别事件。
 *
 * ----- 请求玩家输入 -----
 * 1-对话
 * 2-选项
 * 3-等待玩家输入
 * 当遇到此类命令将会停止执行并且等待玩家输入，当玩家输入完毕后提交后再继续执行下去
 *
 * Created by 黑暗之神KDS on 2018-10-09 16:37:07.
 */
var Command = /** @class */ (function () {
    /**
     * 调用客户端方法
     * @param triggerLineID 触发线ID
     * @param player
     * @param params
     * @param gameFunc [可选] 默认值=null
     */
    // callClient(triggerLineID: number, player: Player, params: any[], gameFunc: string = null): void {
    //     // trace("客户端同步command_" + this.type);
    //     var p = gameFunc ? [gameFunc].concat(params) : params;
    //     ServerMsgSender.rpc(player, "GameCommand", "rpcCall", [triggerLineID, [this.type].concat(p)]);
    //     // ServerMsgSender.rpc(player, "CommandExecuteGame", "command_" + this.type, params);
    // }
    /**
     *
     */
    function Command(type, params, id) {
        if (id === void 0) { id = null; }
        /**
         * 特殊命令跳转可能性：if/else、selStart/sel/endSel、do/loop/break、mark/goto、return
         * if:[0] -> else+1
         * else:[0] -> end+1
         * selStart:[n] -> 第n个sel+1
         * sel:[0] -> selEnd+1
         * loop:[0] -> do+1
         * break:[0] -> loop+1
         * goto:[0] -> mark+1
         * return:-1
         */
        this.gotoLine = [];
        this.type = type;
        if (this.type == -1)
            this.empty = true;
        this.params = params;
        if (!id) {
            id = ObjectUtils.getRandID();
        }
        this.id = id;
    }
    /**
     * 调用执行的方法，该方法适配网络版和单机版引擎，需要在实现类中重写该方法的实现，如：
     * -- 网络版：RPC调用客户端的方法
     * -- 单机版：直接访问方法
     *
     * 客户端自定义命令必须在CommandExecuteGame模块中：
     * module CommandExecuteGame {
     *    export function customCommand_1(param1:any,param2:any): void {
     *         return GameCommand.COMMAND_STATE_CONTINUE;
     *    }
     * }
     * // 关于返回值状态：通常情况下
     * GameCommand.COMMAND_STATE_CONTINUE; 表示命令继续【默认】
     * GameCommand.COMMAND_STATE_STOP; 表示命令终止
     * GameCommand.COMMAND_STATE_NEED_INPUT; 表示命令需要等待玩家输入才能继续
     *
     * @param triggerLineID 触发线ID，使用trigger的ID
     * @param player 玩家对象
     * @param params 参数 执行的方法按顺序排列这些参数，比如[param1,param2] 则对应 customCommand_1(param1:any,param2:any)
     * @param gameFunc [可选] 默认值=null 若存在，则会执行GameFunction的方法，否则需要创建相应的
     */
    Command.prototype.callExecuteFunction = function (triggerLineID, player, params, gameFunc) {
        if (gameFunc === void 0) { gameFunc = null; }
    };
    Object.defineProperty(Command.prototype, "customID", {
        get: function () {
            if (this.type < CommandPage.CUSTOM_COMMAND_START_ID) {
                return null;
            }
            return CommandPage.getCustomCmdDataID(this.type);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 初始化
     * @param gameWorld
     * @param callExecuteFunction
     */
    Command.init = function (gameWorld) {
        Command.gameWorld = gameWorld;
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 将指令参数格式由于ID-Value格式转为Name-Value
     * 是否需要修正
     */
    Command.IDValueToNameValue = function (cmd) {
        var customParams = cmd.params[0];
        var newCustomParams = {};
        if (customParams && typeof customParams == "object") {
            var cmdType = CommandPage.getCustomCmdDataID(MathUtils.int(cmd.type));
            var customCommandTypeData = Common.customCommandTypeList.data[cmdType];
            if (customCommandTypeData) {
                var attrs = CustomCompositeSetting.getAllAttributes(customCommandTypeData, false);
                for (var s = 0; s < attrs.length; s++) {
                    var cusAttr = attrs[s];
                    var paramValue = customParams[cusAttr.id];
                    newCustomParams[cusAttr.varName] = paramValue;
                }
                // 利用typeValue后使用安装存档数据方式来格式化，以便修正为最新值（比如记录的自定义模块数据更改了）
                var typeValues = {};
                for (var s = 0; s < attrs.length; s++) {
                    var cusAttr = attrs[s];
                    typeValues[cusAttr.varName] = CustomAttributeSetting.formatCustomDefaultValue(cusAttr, true);
                }
                var newCustomParams2 = {};
                CustomAttributeSetting.installAttributeFromRecordData(newCustomParams2, newCustomParams, attrs, typeValues, 4);
                return newCustomParams2;
            }
        }
        return null;
    };
    /**
     * 获取指令唯一ID
     */
    Command.getCMDIDByParam = function (cmdParam) {
        if (!cmdParam)
            return null;
        var cmdType = cmdParam[0];
        if (cmdType < CommandPage.CUSTOM_COMMAND_START_ID) {
            var idInfo = cmdParam[cmdParam.length - 1];
            if (idInfo && typeof idInfo == "object" && idInfo.___cmdID) {
                return idInfo;
            }
        }
        else {
            return { ___cmdID: cmdParam[2], disabled: cmdParam[3] };
        }
    };
    /**
     * 判断是否是指令的ID
     * 比如在系统指令参数中新追加参数，可以处理将该参数视为null进行处理并覆盖该参数。
     * 系统会额外再追加
     * @param value
     * @return [boolean]
     */
    Command.isCMDID = function (value) {
        if (value && typeof value == "object") {
            return value.___cmdID ? true : false;
        }
        return false;
    };
    /**
     * 兼容新增的参数
     * @param params 参数集合
     * @param index 索引
     * @param defaultValue 默认值
     */
    Command.ifNullSetDefaultValue = function (params, index, defaultValue) {
        var value = params[index];
        if (value == null || Command.isCMDID(value))
            params[index] = defaultValue;
    };
    /**
    * 系统命令事件开始  onEvent(state)
    * state:0-对话框显示时 1-对话选择框显示时 2-场景更换
    */
    Command.EVENT_SYSTEM_COMMAND_START = "EVENT_SYSTEM_COMMAND_START";
    return Command;
}());
var CommandExecute;
(function (CommandExecute) {
    /**
     * 获取场景对象
     * @param soIndex -4=触发者 -3=空 -2=玩家的对象 -1=当前对象（执行者） 0-N 场景上的对象0-N
     * @param trigger
     * @param triggerPlayer
     * @return [SceneObject]
     */
    function getSceneObject(soIndex, trigger, triggerPlayer) {
        var targetSo;
        // 触发者
        if (soIndex == -4) {
            return trigger.trigger;
        }
        //空
        if (soIndex == -3) {
            return null;
        }
        // 玩家对象
        else if (soIndex == -2) {
            if (triggerPlayer)
                targetSo = triggerPlayer.sceneObject;
        }
        // 执行者
        else if (soIndex == -1) {
            targetSo = trigger.executor;
        }
        // 指定的人
        else {
            targetSo = trigger.scene.sceneObjects[soIndex];
        }
        return targetSo;
    }
    CommandExecute.getSceneObject = getSceneObject;
})(CommandExecute || (CommandExecute = {}));
/**
 * 一个事件页数据
 * Created by 黑暗之神KDS on 2018-10-09 16:23:03.
 */
var CommandPage = /** @class */ (function () {
    /**
     * 构造函数
     */
    function CommandPage(commandDatas) {
        /**
         * 唯一ID
         */
        this.id = ObjectUtils.getInstanceID();
        /**
         * 命令集合
         */
        this.commands = [];
        this.parse(commandDatas);
    }
    /**
     * 获取自定义命令在数据中的ID
     * @param cmdID 该ID会大于 CUSTOM_COMMAND_START_ID
     */
    CommandPage.getCustomCmdDataID = function (cmdID) {
        var type = Math.floor(cmdID / CommandPage.CUSTOM_COMMAND_START_ID);
        var localID = cmdID - CommandPage.CUSTOM_COMMAND_START_ID * type;
        var id = GameListData.getID(type, localID);
        return id;
    };
    /**
     * 获取实际type，根据自定义指令ID
     */
    CommandPage.getTypeByCustomCmdID = function (customCmdID) {
        var t = GameListData.getType(customCmdID);
        var s = GameListData.getLocalID(customCmdID);
        return CommandPage.CUSTOM_COMMAND_START_ID * t + s;
    };
    /**
     * 解析:同时执行预编译
     *    判断 [if][else]
     *    选项 [selStart][sel][selEnd]
     *    循环 [do][loop][break]
     *    跳转 [mark][goto]
     */
    CommandPage.prototype.parse = function (commandDatas) {
        if (!commandDatas || commandDatas.length == 0)
            return;
        var len = commandDatas.length;
        var cmdType;
        for (var i = 0; i < len; i++) {
            var cmdData = commandDatas[i];
            cmdType = cmdData[0];
            // 运行时忽略空指令
            if (!Config.EDIT_MODE) {
                if (cmdType == -1) {
                    continue;
                }
            }
            var cmdIDInfo = Command.getCMDIDByParam(cmdData);
            // 运行时禁用的指令忽略掉
            if (!Config.EDIT_MODE && cmdIDInfo && cmdIDInfo.disabled) {
                continue;
            }
            // 系统指令的话装载后参数中清理掉ID
            if (cmdType < CommandPage.CUSTOM_COMMAND_START_ID) {
                if (cmdIDInfo && cmdIDInfo.___cmdID) {
                    cmdData = cmdData.concat();
                    cmdData.pop();
                }
            }
            var cmd = new Command(cmdType, cmdData.slice(1), cmdIDInfo ? cmdIDInfo.___cmdID : null);
            if (cmdIDInfo)
                cmd.disabled = cmdIDInfo.disabled;
            this.commands.push(cmd);
        }
        len = this.commands.length;
        for (var i = 0; i < len; i++) {
            var cmd = this.commands[i];
            cmdType = cmd.type;
            var customHead, customPreCompileHead;
            // 自定义命令会格式化（目前通过二转来格式化）
            if (cmdType >= CommandPage.CUSTOM_COMMAND_START_ID) {
                customHead = "customCommand_";
                customPreCompileHead = "customCommandPrecompile_";
                cmdType = CommandPage.getCustomCmdDataID(MathUtils.int(cmdType));
                // 游戏中会进行参数转化:由ID --> value 的方式修改为 varName --> 
                if (!Config.EDIT_MODE) {
                    var customParams = cmd.params[0];
                    var newCustomParams = {};
                    if (customParams && typeof customParams == "object") {
                        var customCommandTypeData = Common.customCommandTypeList.data[cmdType];
                        if (customCommandTypeData) {
                            var attrs = CustomCompositeSetting.getAllAttributes(customCommandTypeData, false);
                            for (var s = 0; s < attrs.length; s++) {
                                var cusAttr = attrs[s];
                                var paramValue = customParams[cusAttr.id];
                                newCustomParams[cusAttr.varName] = paramValue;
                            }
                            // 利用typeValue后使用安装存档数据方式来格式化，以便修正为最新值（比如记录的自定义模块数据更改了）
                            var typeValues = CommandPage.cacheCustomCommandTypeValues[cmdType];
                            if (!typeValues) {
                                typeValues = CommandPage.cacheCustomCommandTypeValues[cmdType] = {};
                                for (var s = 0; s < attrs.length; s++) {
                                    var cusAttr = attrs[s];
                                    typeValues[cusAttr.varName] = CustomAttributeSetting.formatCustomDefaultValue(cusAttr, true);
                                }
                            }
                            var newCustomParams2 = {};
                            CustomAttributeSetting.installAttributeFromRecordData(newCustomParams2, newCustomParams, attrs, typeValues, 4);
                            cmd.params[0] = newCustomParams2;
                        }
                    }
                }
            }
            else {
                customHead = "command_";
                customPreCompileHead = "precompile_";
            }
            var executeMethod = CommandExecute[customHead + cmdType];
            if (executeMethod) {
                cmd.exeFunc = executeMethod;
            }
            else {
                cmd.exeFunc = CommandPage.blankMethod;
            }
            var precompileMethod = CommandExecute[customPreCompileHead + cmdType];
            if (precompileMethod)
                precompileMethod(this, cmd, i, cmd.params[0]);
        }
    };
    /**
     * 刷新编译
     */
    CommandPage.prototype.refreshPrecompile = function () {
        for (var i = 0; i < this.commands.length; i++) {
            var cmd = this.commands[i];
            if (!cmd)
                continue;
            cmd.gotoLine.length = 0;
            var precompileMethod = CommandExecute["precompile_" + cmd.type];
            if (precompileMethod)
                precompileMethod(this, cmd, i, cmd.params[0]);
        }
    };
    /**
     * 开始触发片段事件
     * @param feData 片段事件数据
     * @param trigger 触发者-场景对象
     * @param execute 执行者-场景对象
     * @param onCommandExecuteOver [可选] 默认值=null 当命令执行完毕时回调
     * @return [CommandTrigger] 触发器
     */
    CommandPage.startTriggerFragmentEvent = function (feData, trigger, execute, onCommandExecuteOver) {
        if (onCommandExecuteOver === void 0) { onCommandExecuteOver = null; }
        var feCmdInfo = CommandPage.getFormatFeData(feData);
        if (feCmdInfo) {
            var scene = Config.IS_SERVER ? trigger.scene : Game.currentScene;
            var newFETrigger = new CommandTrigger(CommandTrigger.COMMAND_MAIN_TYPE_FRAGMENT_EVENT, 0, scene, trigger, true, execute);
            if (onCommandExecuteOver)
                EventUtils.addEventListener(newFETrigger, CommandTrigger.EVENT_OVER, onCommandExecuteOver, true);
            feCmdInfo.feCmdPage.startTriggerEvent(newFETrigger, [], feCmdInfo.feCommands);
            return;
        }
        return null;
    };
    /**
     * 转换片段事件，根据字符串格式的片段事件转化为可使用格式
     */
    CommandPage.getFormatFeData = function (feData) {
        if (feData || typeof feData == "string") {
            var startIdx = feData.indexOf(String.fromCharCode(5));
            var feName = feData.substr(0, startIdx);
            var startIdx2 = feData.indexOf(String.fromCharCode(5), startIdx + 1);
            if (startIdx2 == -1)
                return null;
            var feSID = feData.substr(startIdx + 1, startIdx2 - startIdx - 1);
            var feCmdPage = CommandPage.cacheCustomFragmentPage[feSID];
            try {
                var feCommands = JSON.parse(feData.substr(startIdx2 + 1));
            }
            catch (e) { }
            if (!feCmdPage) {
                feCmdPage = CommandPage.cacheCustomFragmentPage[feSID] = new CommandPage(feCommands);
            }
            return { feCmdPage: feCmdPage, feCommands: feCommands };
        }
        return null;
    };
    /**
     * 获取片段事件的名字
     */
    CommandPage.getFeDataName = function (feData) {
        if (feData || typeof feData == "string") {
            var startIdx = feData.indexOf(String.fromCharCode(5));
            if (startIdx == -1)
                return "";
            var feName = feData.substr(0, startIdx);
            return feName;
        }
        return "未命名片段";
    };
    /**
     * 开始触发事件（首次）
     * @param commandPage 触发者玩家身份
     * @param trigger 触发者
     * @param playerInput 玩家输入信息
     * @param fragmentCommands 事件片段信息
     */
    CommandPage.prototype.startTriggerEvent = function (trigger, playerInput, fragmentCommands) {
        if (playerInput === void 0) { playerInput = []; }
        if (fragmentCommands === void 0) { fragmentCommands = null; }
        // trace("-----存在",trigger==null)
        // 首次执行的情况
        // 如果是执行中的情况则忽略
        if (trigger.isExecuteing)
            return;
        // 设定触发器的来源
        trigger.initFrom(this);
        // 是否执行中
        trigger.isExecuteing = true;
        // 新增加命令域
        trigger.commandScope.push({ cmdPage: this, index: 0, commonEventID: 0, fragmentCommands: fragmentCommands });
        // 派发命令开始执行的事件
        EventUtils.happen(trigger, CommandTrigger.EVENT_START);
        // 开始执行
        CommandPage.executeEvent(trigger, playerInput);
    };
    /**
     * 执行事件（pause后可中途继续执行）
     * @param trigger 事件目标
     * @param executor
     */
    CommandPage.executeEvent = function (trigger, playerInput) {
        if (playerInput === void 0) { playerInput = []; }
        trigger.inputMessage = playerInput;
        var triggerPlayer = Config.IS_SERVER ? trigger.triggerPlayer : Game.player;
        // player已经不在线的情况则不再执行事件
        if (trigger.trigger && trigger.trigger.playerUID && !triggerPlayer) {
            EventUtils.happen(trigger, CommandTrigger.EVENT_OVER);
            trigger.dispose();
            return;
        }
        trigger.pause = false;
        // 保护不至于死循环：
        var loopTimes = 0;
        var loopStartTime = Date.now();
        var loopTimeout = !Config.IS_SERVER && os.inGC(false) ? 5000 : 10000;
        while (1) {
            loopTimes++;
            if (loopTimes > 10000) {
                loopTimes = 0;
                var d = Date.now() - loopStartTime;
                if (d >= loopTimeout) {
                    alert("事件执行循环卡死，已强制跳出。");
                    break;
                }
            }
            var len = trigger.commandScope.length;
            if (len == 0 || trigger.isDisposed) {
                trigger.isExecuteing = false;
                // 多线执行完毕则释放
                EventUtils.happen(trigger, CommandTrigger.EVENT_OVER);
                if (trigger.multiline) {
                    trigger.dispose();
                }
                break;
            }
            var commandScope = trigger.commandScope[len - 1];
            var cmdPage = commandScope.cmdPage;
            if (commandScope.index == cmdPage.commands.length) {
                trigger.commandScope.pop();
                continue;
            }
            // 已被销毁的情况不在使用
            if (trigger.executor.isDisposed) {
                trigger.commandScope.length = 0;
                continue;
            }
            var cmd = cmdPage.commands[commandScope.index];
            // if (!cmd) break;
            cmd.exeFunc(cmdPage, cmd, trigger, triggerPlayer, playerInput, cmd.params[0]);
            playerInput = [];
            if (trigger.pause) {
                break;
            }
            if (trigger.cmdReturn) {
                trigger.cmdReturn = false;
                trigger.commandScope.pop();
                continue;
            }
            commandScope.index++;
        }
    };
    /**
     * 自定义命令起始ID
     */
    CommandPage.CUSTOM_COMMAND_START_ID = 10000;
    /**
     * 空的方法
     */
    CommandPage.blankMethod = new Function();
    /**
     * 游戏中缓存的自定义命令typeValue格式
     * [自定义命令ID] - typeValue值;
     */
    CommandPage.cacheCustomCommandTypeValues = [];
    /**
     * 游戏中零碎片段事件缓存页（比如自定义控件里的事件片段需要被调用）
     */
    CommandPage.cacheCustomFragmentPage = {};
    return CommandPage;
}());
/**
 * Created by 黑暗之神KDS on 2019-04-12 20:21:17.
 */
var IdentityObject = /** @class */ (function () {
    function IdentityObject() {
        this.id = ++IdentityObject.idCount;
    }
    IdentityObject.idCount = 0;
    return IdentityObject;
}());
/**
 * 事件的触发器
 * 触发器允许多任务同时处理，但如果遇到需要玩家输入的情况会排队等待
 * -- 支持自定义的触发方式（如制作RPG模板时的NPC点击事件、碰触事件）
 * -- 支持同触发类型每次以新的线来触发（如可以设计UI点击事件点击两次，前一次由于有等待事件虽然未执行完毕，但仍然可以触发新的一次事件）
 *
 * Created by 黑暗之神KDS on 2018-10-11 20:48:57.
 */
var CommandTrigger = /** @class */ (function (_super) {
    __extends(CommandTrigger, _super);
    /**
     * 构造函数
     * @param scene
     * @param trigger
     */
    function CommandTrigger(mainType, indexType, scene, trigger, multiline, executor) {
        var _this = _super.call(this) || this;
        /**
         * 命令作用域，记录着执行的命令 commonEventID用于存档记录公共事件 fragmentCommands同理，类型any[]
         */
        _this.commandScope = [];
        /**
         * 派发出去的行为
         */
        _this.behaviors = [];
        /**
         * 等待暂停，如若暂停，等待事件会无期限暂停
         */
        _this._delayPause = false;
        /**
         * 玩家输入值
         */
        _this.inputMessage = [];
        _this.mainType = mainType;
        _this.indexType = indexType;
        _this.scene = scene;
        _this.trigger = trigger;
        _this.multiline = multiline;
        _this.executor = executor;
        trigger.triggerLines[_this.id] = _this;
        return _this;
    }
    Object.defineProperty(CommandTrigger.prototype, "delayPause", {
        get: function () {
            return this._delayPause;
        },
        set: function (v) {
            if (v == this._delayPause)
                return;
            this._delayPause = v;
            // 等待倒计时停止
            if (this.delayTime) {
                if (v) {
                    this.delayStopStartTime = new Date().getTime();
                }
                else {
                    var dt = new Date().getTime() - this.delayStopStartTime;
                    this.delayStartTime += dt;
                }
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 设置来源
     */
    CommandTrigger.prototype.initFrom = function (cmdPage) {
        // 已存在来源的话就忽略
        if (this.from != null)
            return;
        switch (this.mainType) {
            // 1-场景对象：
            case CommandTrigger.COMMAND_MAIN_TYPE_SCENE_OBJECT:
                this.from = this.executor.index;
                return;
            // 2-界面：如果上层未能给定的话需要搜索找到对应的事件页，否则应该在创建时即设置来源
            case CommandTrigger.COMMAND_MAIN_TYPE_UI:
                var uiCustomCommandPages = Config.IS_SERVER ? ServerWorld.uiCustomCommandPages : ClientWorld.uiCustomCommandPages;
                for (var sid in uiCustomCommandPages) {
                    if (uiCustomCommandPages[sid][this.indexType] == cmdPage) {
                        this.from = sid;
                        return;
                    }
                }
        }
        // 3-调用公共事件、4-片段事件
        this.from = this.indexType;
    };
    /**
     * 释放
     * 在非单线事件的话执行完毕需要
     */
    CommandTrigger.prototype.dispose = function () {
        if (this.lock || !this.trigger || !this.trigger.triggerLines)
            return;
        if (!this.isDisposed) {
            this.isDisposed = true;
            delete this.trigger.triggerLines[this.id];
            EventUtils.clear(this);
            if (!Config.IS_SERVER) {
                os.remove_ENTERFRAME(this.doWaitFrame, this);
                os.remove_ENTERFRAME(this.doWaitTime, this);
            }
        }
    };
    /**
     * 等待指定帧数后继续执行命令
     * @param frame 等待的帧数
     */
    CommandTrigger.prototype.waitFrame = function (frame) {
        if (Config.IS_SERVER) {
            setFrameout(CommandPage.executeEvent, frame, this);
            return;
        }
        if (frame < 1)
            frame = 1;
        this.delayFrame = frame;
        os.add_ENTERFRAME(this.doWaitFrame, this);
    };
    CommandTrigger.prototype.doWaitFrame = function () {
        if (this.delayPause || this.lock)
            return;
        this.delayFrame--;
        if (this.delayFrame == 0) {
            os.remove_ENTERFRAME(this.doWaitFrame, this);
            CommandPage.executeEvent(this);
        }
    };
    /**
     * 等待指定时间后继续执行
     * @param time 等待的时间，单位：毫秒
     */
    CommandTrigger.prototype.waitTime = function (time) {
        if (Config.IS_SERVER) {
            setTimeout(CommandPage.executeEvent, time, this);
            return;
        }
        this.delayTime = time;
        this.delayStartTime = new Date().getTime();
        os.add_ENTERFRAME(this.doWaitTime, this);
    };
    CommandTrigger.prototype.doWaitTime = function () {
        if (this.delayPause || this.lock)
            return;
        var now = new Date().getTime();
        if (now - this.delayStartTime >= this.delayTime) {
            this.delayTime = 0;
            os.remove_ENTERFRAME(this.doWaitTime, this);
            CommandPage.executeEvent(this);
        }
    };
    Object.defineProperty(CommandTrigger.prototype, "triggerPlayer", {
        /**
         * 获取触发事件的玩家
         * @return [Player]
         */
        get: function () {
            return this.trigger ? (Config.IS_SERVER ? this.trigger.player : Game.player) : null;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 跳转至
     */
    CommandTrigger.prototype.goto = function (index) {
        this.commandScope[this.commandScope.length - 1].index = index - 1;
    };
    /**
     * 偏移至
     */
    CommandTrigger.prototype.offset = function (i) {
        this.commandScope[this.commandScope.length - 1].index += i;
    };
    /**
     * 结束
     */
    CommandTrigger.prototype.end = function () {
        this.commandScope.pop();
    };
    /**
     * 追加公共事件层级，在当前的触发器中追加执行指定的公共事件，在公共事件执行完毕后会回到原来的事件中继续接着执行
     * @param commonEventID
     * @param cmdPage
     */
    CommandTrigger.prototype.addCommonEventCommandPageLayer = function (commonEventID) {
        if (Config.IS_SERVER) {
            var cmdPage = ServerWorld.commonEventPages[commonEventID];
        }
        else {
            cmdPage = ClientWorld.commonEventPages[commonEventID];
        }
        if (!cmdPage)
            return;
        this.commandScope.push({ cmdPage: cmdPage, index: 0, commonEventID: commonEventID, fragmentCommands: null });
    };
    /**
     * 追加片段事件层级，在当前的触发器中追加执行片段事件，在该片段事件执行完毕后会回到原来的事件中继续接着执行
     * @param feData 片段事件数据
     */
    CommandTrigger.prototype.addFragmentEventCommandPageLayer = function (feData) {
        var feFormatData = CommandPage.getFormatFeData(feData);
        if (feFormatData) {
            this.commandScope.push({ cmdPage: feFormatData.feCmdPage, index: 0, commonEventID: 0, fragmentCommands: feFormatData.feCommands });
        }
    };
    /**
     * 添加行为
     * @param targetSo
     * @param behaviorData 行为数据 [行为ID,参数1,参数2...]
     *                     [[行为1-ID,参数1,参数2],[行为2-ID,参数1,参数2],....]
     *                     由于行为是自定义的，具体行为的作用请参考游戏的模板
     *                     高级制作者可以在：GameCreator编辑器菜单-自定义编辑器-自定义行为中配合脚本来编辑行为
     * @param loop
     * @param targetPlayerSceneObject
     * @param cover
     * @param startIndex [可选] 默认值=0
     * @param Immediate [可选] 默认值=true 立即执行行为，不用等待帧刷再执行
     * @param forceStopLastBehavior  [可选] 默认值=false 是否强制停止此前正在执行的行为
     * @param delayFrame [可选] 默认值=0 行为内部等待的时间
     * @param executor [可选] 默认值=null 执行事件者
     */
    CommandTrigger.prototype.addBehavior = function (targetSo, behaviorData, loop, targetPlayerSceneObject, cover, startIndex, Immediate, forceStopLastBehavior, delayFrame, executor) {
        var _this = this;
        if (startIndex === void 0) { startIndex = 0; }
        if (Immediate === void 0) { Immediate = true; }
        if (forceStopLastBehavior === void 0) { forceStopLastBehavior = false; }
        if (delayFrame === void 0) { delayFrame = 0; }
        if (executor === void 0) { executor = null; }
        // 给对象添加行为并且监听行为完毕的情况
        var isOver = false;
        var soBehavior = targetSo.addBehavior(behaviorData, loop, targetPlayerSceneObject, Callback.New(function (targetSo) {
            isOver = true;
            _this.removeBehaviorCount(targetSo);
        }, this, [targetSo]), cover, startIndex, Immediate, forceStopLastBehavior, delayFrame, executor);
        // 覆盖的情况，只保留除他以外的记录
        if (cover)
            this.behaviors = ArrayUtils.matchAttributes(this.behaviors, { so: targetSo }, false, "!=");
        // 记录列表
        if (!isOver)
            this.behaviors.push({ so: targetSo, behavior: soBehavior });
    };
    /**
     * 减少行为
     */
    CommandTrigger.prototype.removeBehaviorCount = function (targetSo) {
        // 找到最近的并移除掉
        var behaviorsInv = this.behaviors.concat().reverse();
        var lastIndex = ArrayUtils.matchAttributes(behaviorsInv, { so: targetSo }, true, "==", true)[0];
        if (lastIndex != -1) {
            lastIndex = this.behaviors.length - lastIndex - 1;
            this.behaviors.splice(lastIndex, 1);
        }
        // 当行为全部结束时候，如果处于等待行为结束时则暂停
        if (this.behaviors.length == 0) {
            EventUtils.happen(this, CommandTrigger.EVENT_BEHAVIOR_OVER);
            if (this.continueWhenBehaviorOver && this.pause) {
                this.continueWhenBehaviorOver = false;
                CommandPage.executeEvent(this);
            }
        }
    };
    Object.defineProperty(CommandTrigger.prototype, "hasBehavior", {
        /**
         * 是否存在行为
         */
        get: function () {
            return this.behaviors.length > 0;
        },
        enumerable: false,
        configurable: true
    });
    //------------------------------------------------------------------------------------------------------
    // 储存和读取
    //------------------------------------------------------------------------------------------------------
    CommandTrigger.prototype.getSaveData = function () {
        var o = {};
        o.id = this.id; // 用于读取存档时能够映射到GameCommand的cmdTriggerLines记录
        o.mainType = this.mainType;
        o.indexType = this.indexType;
        o.multiline = this.multiline;
        o.continueWhenBehaviorOver = this.continueWhenBehaviorOver;
        o.trigger = this.trigger.index;
        o.executor = this.executor.index;
        o.pause = this.pause;
        o.delayPause = this.delayPause;
        o.inputMessage = this.inputMessage;
        o.delayFrame = this.delayFrame;
        o.delayTime = this.delayTime;
        o.delayStartTime = this.delayStartTime;
        o.delayStopStartTime = this.delayStopStartTime;
        o.from = this.from;
        // 作用域层
        o.commandScope = [];
        for (var i = 0; i < this.commandScope.length; i++) {
            o.commandScope[i] = { index: this.commandScope[i].index, commonEventID: this.commandScope[i].commonEventID, fragmentCommands: this.commandScope[i].fragmentCommands };
        }
        // 行为层
        o.behaviors = [];
        for (var i = 0; i < this.behaviors.length; i++) {
            var behavior = this.behaviors[i];
            // 触发事件者
            var triggerIndex = behavior.behavior.targetSceneObject ? behavior.behavior.targetSceneObject.index : -1;
            // 执行事件者
            var exectorIndex = behavior.behavior.executor ? behavior.behavior.executor.index : -1;
            // 记录
            o.behaviors[i] = { soIndex: behavior.so.index, triggerIndex: triggerIndex, exectorIndex: exectorIndex, behaviorIndex: behavior.so.getBehaviorIndex(behavior.behavior), behaviorData: behavior.behavior.getSaveData() };
        }
        return o;
    };
    /**
     * 恢复存档
     * @param o 触发线数据
     * @param scene 场景
     * @param commonEventPages 公共事件
     * @param intervalTime 当前与存档的间隔时间
     * @return [boolean]
     */
    CommandTrigger.prototype.recoverySaveData = function (o, scene, commonEventPages, intervalTime) {
        this.mainType = o.mainType;
        this.indexType = o.indexType;
        this.multiline = o.multiline;
        this.pause = o.pause;
        this.delayPause = o.delayPause;
        this.inputMessage = o.inputMessage;
        this.continueWhenBehaviorOver = o.continueWhenBehaviorOver;
        this.commandScope = [];
        this.from = o.from;
        for (var i = 0; i < o.commandScope.length; i++) {
            var scope = o.commandScope[i];
            // 本身
            if (i == 0) {
                var cmdPage;
                // 场景事件
                if (this.mainType == CommandTrigger.COMMAND_MAIN_TYPE_SCENE) {
                    cmdPage = scene.customCommandPages[this.indexType];
                }
                // 场景对象事件
                else if (this.mainType == CommandTrigger.COMMAND_MAIN_TYPE_SCENE_OBJECT) {
                    cmdPage = this.executor.customCommandPages[this.indexType];
                }
                // 界面事件
                else if (this.mainType == CommandTrigger.COMMAND_MAIN_TYPE_UI) {
                    var uiCustomCommandPagesFrom = ClientWorld.uiCustomCommandPages[this.from];
                    if (uiCustomCommandPagesFrom) {
                        cmdPage = uiCustomCommandPagesFrom[this.indexType];
                    }
                }
                // 调用公共事件
                else if (this.mainType == CommandTrigger.COMMAND_MAIN_TYPE_CALL_COMMON_EVENT) {
                    cmdPage = commonEventPages[this.from];
                }
                // 调用片段：这里使用可能是旧版本的片段临时页（并不缓存，所以如果当前版本继续遇到此片段可能版本会不一致）
                else if (this.mainType == CommandTrigger.COMMAND_MAIN_TYPE_FRAGMENT_EVENT) {
                    cmdPage = new CommandPage(scope.fragmentCommands);
                }
                if (!cmdPage)
                    return false;
                this.commandScope.push({ cmdPage: cmdPage, index: scope.index, commonEventID: scope.commonEventID, fragmentCommands: scope.fragmentCommands });
            }
            // 调用的公共事件或片段
            else {
                // 片段：这里使用可能是旧版本的片段临时页（并不缓存，所以如果当前版本继续遇到此片段可能版本会不一致）
                if (scope.fragmentCommands) {
                    cmdPage = new CommandPage(scope.fragmentCommands);
                }
                // 公共事件
                else {
                    cmdPage = commonEventPages[scope.commonEventID];
                }
                if (!cmdPage)
                    return false;
                this.commandScope.push({ cmdPage: cmdPage, index: scope.index, commonEventID: scope.commonEventID, fragmentCommands: scope.fragmentCommands });
            }
        }
        this.delayFrame = o.delayFrame;
        this.delayTime = o.delayTime;
        this.delayStartTime = o.delayStartTime + intervalTime;
        this.delayStopStartTime = o.delayStopStartTime + intervalTime;
        if (this.delayFrame) {
            os.add_ENTERFRAME(this.doWaitFrame, this);
        }
        else if (this.delayTime) {
            os.add_ENTERFRAME(this.doWaitTime, this);
        }
        return true;
    };
    /**
     * 恢复：来源存档，理论上储存的事件都是暂停中的。
     */
    CommandTrigger.prototype.recovery = function () {
        // 暂停的话直接执行
        this.isExecuteing = true;
        if (!this.pause) {
            CommandPage.executeEvent(this, this.inputMessage);
        }
        else {
        }
    };
    /** 执行开始 */
    CommandTrigger.EVENT_START = "CommandTrigger_EVENT_START_TRIGGER";
    /** 执行结束 */
    CommandTrigger.EVENT_OVER = "CommandTrigger_EVENT_OVER";
    /** 该事件域此前派发的设置对象的行为结束时派发此事件（同命令中的[等待行为结束]） */
    CommandTrigger.EVENT_BEHAVIOR_OVER = "CommandTrigger_EVENT_BEHAVIOR_OVER";
    /**
      * 事件主类别：场景相关
      */
    CommandTrigger.COMMAND_MAIN_TYPE_SCENE = 0;
    /**
     * 事件主类别：场景对象相关
     */
    CommandTrigger.COMMAND_MAIN_TYPE_SCENE_OBJECT = 1;
    /**
     * 事件主类别：UI相关
     */
    CommandTrigger.COMMAND_MAIN_TYPE_UI = 2;
    /**
     * 事件主类别：调用独立公共事件
     */
    CommandTrigger.COMMAND_MAIN_TYPE_CALL_COMMON_EVENT = 3;
    /**
     * 事件主类别：片段事件（自定义控件中的片段事件）
     */
    CommandTrigger.COMMAND_MAIN_TYPE_FRAGMENT_EVENT = 4;
    return CommandTrigger;
}(IdentityObject));
/**
 * Created by 黑暗之神KDS on 2018-10-09 16:09:29.
 */
var Condition = /** @class */ (function () {
    function Condition() {
    }
    return Condition;
}());
/**
 * 场景：公共数据
 * 逻辑场景，通用于客户端和服务端
 * Created by 黑暗之神KDS on 2018-05-21 01:49:13.
 */
var Scene = /** @class */ (function () {
    /**
     * 构造函数
     */
    function Scene() {
        /**
         * 进入场景时预加载地图资源
         */
        this.preloadMapAsset = true;
        /**
         * 进入场景时预加载全部场景对象资源
         */
        this.preloadSceneObjectAsset = true;
        /**
         * 进入场景后的相关事件
         */
        this.preloadSceneCommandAsset = true;
        /**
         * 数据层数据
         */
        this.dataLayers = [];
        /**
         * 游戏对象列表
         */
        this.sceneObjects = [];
        //------------------------------------------------------------------------------------------------------
        // 系统
        //------------------------------------------------------------------------------------------------------
        /**
         * 场景自定义类别事件
         */
        this.customCommandPages = [];
    }
    Scene.prototype.parse = function (jsonObj, gameData) {
        if (!Config.EDIT_MODE && !Config.BEHAVIOR_EDIT_MODE) {
            var jsonObjClone = ObjectUtils.depthClone(jsonObj);
            ObjectUtils.clone(jsonObjClone, this);
        }
        else {
            ObjectUtils.clone(jsonObj, this);
        }
        // 计算格子宽高
        this.gridWidth = Math.floor(this.width / Config.SCENE_GRID_SIZE);
        this.gridHeight = Math.floor(this.height / Config.SCENE_GRID_SIZE);
    };
    //------------------------------------------------------------------------------------------------------
    // 数据层 
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取数据格子状态
     * @param index 数据层索引
     * @param gridX 格子坐标x
     * @param gridY 格子坐标y
     * @return [number] 该格子的状态
     */
    Scene.prototype.getDataGridState = function (index, gridX, gridY) {
        var xyData = this.dataLayers[index];
        if (!xyData)
            return 0;
        var xData = xyData[gridX];
        if (!xData)
            return 0;
        return xData[gridY];
    };
    /**
     * 设置数据格子状态
     * @param index 数据层索引
     * @param gridX 格子坐标x
     * @param gridY 格子坐标y
     * @param state
     * @return [boolean]
     */
    Scene.prototype.setDataGridState = function (index, gridX, gridY, state) {
        var xyData = this.dataLayers[index];
        var xData = xyData[gridX];
        if (!xData)
            xData = xyData[gridX] = [];
        xData[gridY] = state;
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取以场景格子计算的实际宽高
     */
    Scene.getRealWidth = function (scene) {
        return { width: scene.gridWidth * Config.SCENE_GRID_SIZE, height: scene.gridHeight * Config.SCENE_GRID_SIZE };
    };
    return Scene;
}());
/**
 * 游戏对象：公共库仅表示游戏对象的数值数据
 * 复制时会遍历属性来复制，所以需要满足条件：
 * 由于该类是数据类，不应该存在方法，复制数据时并不会包含该方法，只允许存在静态方法
 * 1-属性有预设值
 * 2-属性是基元属性(string/number/boolean)
 *
 * 旧版本：显示列表属性和变量属性都是该实例的属性 如 so.ui1  so.var1
 * 新版本：公共模块的显示列表和变量属性都是该实例的属性，如 so.ui1 so.var1
 *        模块属性则是 so.getModules(0).ui1 so.getModules(0).ui2 （位于SceneObject）
 *
 * 关于模块的运行规则
 * 1-在生成对象时根据模型的预设自动添加相关模块（默认值），添加后则关系脱离，对象实例可以自行修改模块
 * 2-添加的模块会储存至 moduleIDs（模块ID集合）、modules（SceneObjectEntity的私有模块数据）、
 * 3-更改了模块后还需要刷新 moduleDisplayList
 *
 *
 *
 *
 * Created by 黑暗之神KDS on 2018-05-21 02:34:05.
 */
var SceneObject = /** @class */ (function () {
    function SceneObject() {
        /**
         * 对应的场景对象模型
         */
        this.modelID = 1;
        /**
         * 所在场景的sceneObject列表的位置
         */
        this.index = 0;
        /**
         * 名称
         */
        this.name = "";
        /**
         * 坐标x
         */
        this.x = 0;
        /**
        *  坐标y
        */
        this.y = 0;
        /**
         * 坐标z
         */
        this.z = 0;
        /**
         * 材质
         */
        this.materialData = [{ materials: [] }];
        //------------------------------------------------------------------------------------------------------
        // 行走图
        //------------------------------------------------------------------------------------------------------
        /**
         * 对应的角色ID设定帧
         */
        this.avatarID = 0;
        /**
         * 角色的面向设定帧
         */
        this.avatarOri = 2;
        /**
         * 角色的动作:ID设定帧
         */
        this.avatarAct = 1;
        /**
         * 动作播放频率设定帧
         */
        this.avatarFPS = 12;
        /**
         * 初始设定帧
         */
        this.avatarFrame = 1;
        /**
         * 透明度设定帧
         */
        this.avatarAlpha = 1;
        /**
         * 色相设定帧
         */
        this.avatarHue = 0;
        //------------------------------------------------------------------------------------------------------
        // 影子
        //------------------------------------------------------------------------------------------------------
        /**
        * 影子是否可用
        */
        this.shadowEnable = false;
        /**
         * 影子宽度
         */
        this.shadowWidth = 30;
        /**
         * 影子高度
         */
        this.shadowHeight = 15;
        /**
         * 影子透明度
         */
        this.shadowAlpha = 0.5;
        //------------------------------------------------------------------------------------------------------
        // 显示对象数据
        //------------------------------------------------------------------------------------------------------
        /**
         * （旧版-全部显示列表 新版-公共模块）
         * type 1-指定AVATAR类 2-指定UI 3-指定UI类 4-指定动画 5-指定动画类1
         */
        this.displayList = {};
        /**
         * 当前所有模块的显示列表数据
         */
        this.moduleDisplayList = [];
        //------------------------------------------------------------------------------------------------------
        // 基本设置
        //------------------------------------------------------------------------------------------------------
        /**
         * 显示层 0-最底层 1-中间层 2-最高层
         */
        this.layerLevel = 1;
        /**
         * 自动播放动作
         */
        this.autoPlayEnable = true;
        /**
         * 体型
         */
        this.scale = 1;
        //------------------------------------------------------------------------------------------------------
        // 计算后的属性
        //------------------------------------------------------------------------------------------------------
        /**
         * 拥有控制权的玩家（所属玩家）
         */
        this.playerUID = 0;
        /**
         * 是否拥有事件 [indexType] = 是否拥有事件
         */
        this.hasCommand = [];
    }
    Object.defineProperty(SceneObject, "self", {
        get: function () {
            if (SceneObject.____self)
                return SceneObject.____self;
            SceneObject.____self = new SceneObject();
            return SceneObject.____self;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 安装自定义数据
     * @param so 对象
     * @param presetCustomAttrs 预设的自定义属性值（如场景上NPC的自定义数据值）
     */
    SceneObject.installCustomData = function (so, presetCustomAttrs, recordModelData) {
        if (presetCustomAttrs === void 0) { presetCustomAttrs = null; }
        if (recordModelData === void 0) { recordModelData = true; }
        // 绑定模型数据
        var modelData = Common.sceneObjectModelList.data[so.modelID];
        if (recordModelData)
            so.modelData = modelData;
        // 模型数据设置默认值（基础数据）
        if (modelData) {
            if (Config.useNewSceneObjectModel) {
                var fixModelData = Common.sceneObjectModelList.data[0];
            }
            else {
                fixModelData = modelData;
            }
            var attrSettings = fixModelData.varAttributes;
            if (!presetCustomAttrs) {
                presetCustomAttrs = CustomAttributeSetting.formatCustomData(null, fixModelData.varAttributes);
            }
            CustomAttributeSetting.installAttributeFromEditorSet(so, presetCustomAttrs, attrSettings, false, false, GameData.CUSTOM_ATTR_SCENE_OBJECT_DATA);
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 安装模块属性-在模块构造函数之前（以便在自定义子类的构造函数中即可访问属性）
     * 【不公开的API】
     * @param soModule 模块
     * @param moduleData 对应的模块数据
     * @param presetData 预设值 value格式
     */
    SceneObject.installModuleAttributesBeforeConstructor = function (soe, moduleID, moduleName, moduleData, presetData, soModule) {
        // -- 安装基础信息
        soModule.id = moduleID;
        soModule.name = moduleName;
        soModule.so = soe;
        // -- Editor 专用
        if (Config.EDIT_MODE) {
            soModule.owner = soe;
            soModule.soModule = soModule;
        }
        // -- 安装模块原型
        var attrSettings = moduleData.varAttributes;
        var editorSetAttrs = {};
        CustomAttributeSetting.formatCustomData(editorSetAttrs, attrSettings);
        CustomAttributeSetting.installAttributeFromEditorSet(soModule, editorSetAttrs, attrSettings, false, false, GameData.CUSTOM_ATTR_SCENE_OBJECT_MODULE_DATA);
        // -- 默认的显示列表，以ID记录
        for (var i = 0; i < moduleData.preLayer.length; i++) {
            var p = moduleData.preLayer[i];
            if (p["__dragPresetID"]) { // Editor 专用
                soModule[p.varName] = p["__dragPresetID"];
                delete p["__dragPresetID"];
            }
            else {
                soModule[p.varName] = p.id;
            }
        }
        // -- 安装传递过来预设好的值
        if (presetData)
            ObjectUtils.clone(presetData, soModule);
    };
    /**
     * 创建场景对象模块（按照模块的默认值）
     * @param moduleID 场景对象的模块ID
     * @param soe 需要安装到的场景对象实体
     * @param presetData 预设的值数据，如 { abc: 5, def:6 }
     * @return [SceneObjectModule] 模块
     */
    SceneObject.createModule = function (moduleID, soe, presetData) {
        if (presetData === void 0) { presetData = null; }
        var moduleData = Common.sceneObjectModuleList.data[moduleID];
        if (moduleData) {
            var moduleName = GameListData.getName(Common.sceneObjectModuleList, moduleID);
            var installCB = Callback.New(this.installModuleAttributesBeforeConstructor, this, [soe, moduleID, moduleName, moduleData, presetData]);
            // -- 构造函数即安装属性
            var soModule;
            // -- 编辑器环境下生成 SceneObjectModule
            if (Config.EDIT_MODE && !Config.BEHAVIOR_EDIT_MODE) {
                soModule = SceneObject.editorSceneObjectModule(installCB, moduleID); // new SceneObjectModule(soe as any);
            }
            // -- 运行时环境下生成具体的类实例（如有）
            else {
                var cls;
                // 优先取得运行时
                if (Config.IS_SERVER) {
                    if (moduleData.serverInstanceClassName) {
                        cls = globalThis[moduleData.serverInstanceClassName];
                    }
                }
                else {
                    if (moduleData.clientInstanceClassName) {
                        cls = globalThis[moduleData.clientInstanceClassName];
                    }
                }
                // 否则使用默认生成的类
                if (!cls)
                    cls = SceneObjectModule.moduleClassArr[moduleID];
                // 创建实例
                if (cls) {
                    soModule = new cls(installCB);
                }
                else {
                    soModule = new SceneObjectModule(installCB);
                }
            }
            if (soModule) {
                // // -- 安装模块原型
                // var attrSettings: CustomAttributeSetting[] = moduleData.varAttributes;
                // var editorSetAttrs: { [varName: string]: { varType: number, value: any, copy: boolean } } = {};
                // CustomAttributeSetting.formatCustomData(editorSetAttrs, attrSettings);
                // CustomAttributeSetting.installAttributeFromEditorSet(soModule, editorSetAttrs, attrSettings, false, false, GameData.CUSTOM_ATTR_SCENE_OBJECT_MODULE_DATA);
                // // -- 默认的显示列表，以ID记录
                // for (var i = 0; i < moduleData.preLayer.length; i++) {
                //     var p = moduleData.preLayer[i];
                //     soModule[p.varName] = p.id;
                // }
                // // -- 安装传递过来预设好的值
                // if (presetData) ObjectUtils.clone(presetData, soModule);
                return soModule;
            }
        }
    };
    /**
     * 编辑器中场景对象的模块类
     * 【编辑器专用】SceneObjectModelContentView 编辑器重写实现
     * @param soe
     * @param moduleID
     * @return [SceneObjectModule]
     */
    SceneObject.editorSceneObjectModule = function (installCB, moduleID) {
        return null;
    };
    /**
     * 克隆单个基本数据
     * @param so 数据源
     * @return [SceneObject]
     */
    SceneObject.__gcClone = function (so) {
        var soData = new SceneObject();
        // 复制场景对象基本属性
        for (var i in soData) {
            soData[i] = so[i];
        }
        // 复制场景对象的复合属性（深度复制）
        for (var i in SceneObject.compoundAttributes) {
            var attrName = SceneObject.compoundAttributes[i];
            soData[attrName] = ObjectUtils.depthClone(so[attrName]);
        }
        return soData;
    };
    /**
     * 克隆多个基本数据
     * @param sos 数据源
     * @return [SceneObject]
     */
    SceneObject.__gcClones = function (sos) {
        var len = sos.length;
        var arr = [];
        for (var i = 0; i < len; i++) {
            var so = sos[i];
            if (!so)
                continue;
            var soData = SceneObject.__gcClone(sos[i]);
            arr[i] = soData;
        }
        return arr;
    };
    /**
     * 复合属性：克隆时需要深度克隆
     */
    SceneObject.compoundAttributes = ["displayList", "hasCommand", "materialData", "moduleIDs", "moduleDisplayList"];
    /**
     * 状态页共用的属性
     */
    SceneObject.statusCommonAttributes = {
        x: true,
        y: true,
        z: true,
        name: true,
        index: true,
        playerUID: true,
        modelID: true
    };
    return SceneObject;
}());
/**
 * 场景对象实体
 *
 * 关于状态页：
 * -- 根据当前的环境从后往前推状态页，满足的话切换为当前状态（基础、事件、行为、自定义属性）
 *    并开始记录当前页索引，以便开始监听当前页以及之后页的条件，因为前面页的条件更改不会影响它的出现。
 *
 * -- 刷新状态：以便安装
 * -- 开始监听条件（如果当前状态页与记录值不符的话才需要重新监听，首次肯定不符）
 * --
 *
 * 【关于消失】
 * -- 通过状态页进行消失的还在记录列表中，还占用这个位置
 * -- 如果手动移除并从记录列表中也移除了，是真正意义上的移除了
 * -- 如果有临时让其消失的话则底层追加该属性或上层制作自定义属性
 *
 *
 *
 * 【关于创建对象出现】
 * 1.找到一个源，如预设或指定对应的预设
 * 2.携带档案数据和状态页数据进行创建
 *   -- 创建时安装通用属性（如index、x、y），有档案数据则优先使用档案数据
 *   -- 安装对象开关数据
 *   -- 安装状态页数据并根据当前情况刷新状态页
 *   -- 子类实现的refreshDisappearStatus
 *       -- 需要出现时：如果已在场景的记录列表中才添加
 *       -- 需要消失时：但不需要从记录列表中移除
 *       -- 如果切换了状态页的话：派发事件（同时客户端还要刷新下状态页）
 * 3.添加到场景对象记录列表中
 * 4.如果inScene则添加到显示列表上（显示出来）
 * 5.调用初始化startPlayDefaultBehavior，开始执行默认的行为
 *
 * 这样的话初始刷新坐标不执行其身上的事件，可以等待创建完毕后统一执行事件
 *
 *
 *
 *
 *
 * Created by 黑暗之神KDS on 2020-02-22 03:47:27.
 */
var SceneObjectEntity = /** @class */ (function (_super) {
    __extends(SceneObjectEntity, _super);
    /**
     * 构造函数
     *
     * [安装属性前的初始化]
     * [安装状态页共用属性]
     * [安装对象开关<不派发事件>]
     * [安装状态页数据<根据当前条件切换到指定状态页>]
     * [安装属性后的函数]
     *
     * [可能添加到场景上]
     *
     *
     * @param persetData (sceneObjectData=场景数据 fromSceneObjectindex=对应的对象索引
     *                    soData=主状态页场景对象数据 customAttr=主状态页自定义数据 eventData=主状态页事件数据 )
     */
    function SceneObjectEntity(persetData) {
        if (persetData === void 0) { persetData = null; }
        var _this = _super.call(this) || this;
        /**
         * 是否在添加在场景上
         */
        _this.inScene = false;
        /**
         * 模块
         */
        _this._modules = [];
        /**
         * 场景对象事件页的缓存
         */
        _this.customCommandPagesCache = [];
        /**
         * 场景对象事件页是否存在的缓存
         */
        _this.hasCommandCache = [];
        // 存在预设数据的情况
        if (persetData) {
            // 安装属性前的初始化
            _this.____beforeInstallAttributeInit();
            // 安装状态页共用属性
            for (var s in SceneObject.statusCommonAttributes) {
                if (persetData.recordData)
                    _this[s] = persetData.recordData[s];
                else
                    _this[s] = persetData.soData[s];
            }
            _this.index = persetData.soIndex;
            // 安装对象开关
            _this.installSwitchs(persetData.soSwitchs, false);
            // 安装状态页数据
            _this.installStatusPageData(persetData.sceneObjectData, persetData.fromSceneObjectindex, persetData.soData, persetData.customAttr, persetData.eventData, persetData.recordData, persetData.moduleCustomAttrs);
            // 安装属性后的函数
            _this.____afterInstallAttributeInit();
        }
        return _this;
    }
    Object.defineProperty(SceneObjectEntity.prototype, "isCopy", {
        get: function () { return this._isCopy; },
        enumerable: false,
        configurable: true
    });
    ;
    /**
     * 初始化：在安装属性之前
     */
    SceneObjectEntity.prototype.____beforeInstallAttributeInit = function () {
    };
    /**
     * 初始化：在安装属性之后
     */
    SceneObjectEntity.prototype.____afterInstallAttributeInit = function () {
    };
    //------------------------------------------------------------------------------------------------------
    // 状态页
    //------------------------------------------------------------------------------------------------------
    /**
     * 安装状态页
     * @param sceneObjectData 当前场景的数据
     * @param fromSceneObjectindex 对应的场景对象索引
     * @param soData 主状态页-基本数据
     * @param customAttr 主状态页-自定义属性
     * @param eventData 主状态页-事件页数据
     * @param recordData 来自存档的数据
     * @param moduleCustomAttrs 主状态页-模块自定义属性
     */
    SceneObjectEntity.prototype.installStatusPageData = function (sceneObjectData, fromSceneObjectindex, soData, customAttr, eventData, recordData, moduleCustomAttrs) {
        if (recordData === void 0) { recordData = null; }
        if (moduleCustomAttrs === void 0) { moduleCustomAttrs = null; }
        this.sceneObjectData = sceneObjectData;
        this.fromSceneObjectindex = fromSceneObjectindex;
        // 绑定状态页
        var statusPages = sceneObjectData.statusPages[fromSceneObjectindex];
        if (!statusPages)
            statusPages = sceneObjectData.statusPages[fromSceneObjectindex] = [];
        this.statusPages = statusPages.concat();
        // 主状态页的自定义属性缓存
        var customAttributesCache = sceneObjectData.customAttributesCaches[fromSceneObjectindex];
        var modulesCustomAttributesCaches = sceneObjectData.modulesCustomAttributesCaches[fromSceneObjectindex];
        // 将主状态设置为第一个数据
        this.statusPages.unshift({
            so: soData,
            customAttribute: customAttr,
            event: eventData,
            customAttributesCache: customAttributesCache,
            modulesCustomAttribute: moduleCustomAttrs,
            modulesCustomAttributesCaches: modulesCustomAttributesCaches
        });
        // 刷新状态页
        var st = this.refreshDisappearStatus("rd", recordData);
        // 如不存在切换事件页的话则作为首次监听，否则首次的话未能触发监听
        if (!st.changeStatusPage) {
            this.initCondition();
        }
    };
    /**
     * 获取自定义属性缓存，该缓存是共享的，并且首次会缓存自定义属性的值
     * 如果要使用的话，可以以此作为参考克隆后再复制给实体对象
     * 由于fromSceneObjectindex是来源于克隆源，所以克隆出来的多个对象也只会有一份缓存
     * @param stpIndex 对应0~N事件页
     */
    SceneObjectEntity.prototype.getCustomAttributeCache = function (stpIndex) {
        var stp = this.statusPages[stpIndex];
        var customAttributesCache = stp.customAttributesCache;
        if (!customAttributesCache) {
            if (stpIndex == 0) {
                customAttributesCache = this.sceneObjectData.customAttributesCaches[this.fromSceneObjectindex] = SceneObject.__gcClone(stp.so);
            }
            else {
                customAttributesCache = this.sceneObjectData.statusPages[this.fromSceneObjectindex][stpIndex - 1].customAttributesCache = SceneObject.__gcClone(stp.so);
            }
            SceneObject.installCustomData(customAttributesCache, stp.customAttribute);
            // 清除基本属性，只保留额外的自定义属性
            for (var i in SceneObject.self) {
                delete customAttributesCache[i];
            }
            stp.customAttributesCache = customAttributesCache;
        }
        return customAttributesCache;
    };
    /**
     * 获取该对象来源的指定状态页的指定模块的缓存数据Object，包含显示对象值（以ID记录）
     * @param stpIndex 指定的状态页
     * @param moduleIndex 指定的模块索引
     * @return [any] 缓存的模块数据 如 {属性1:123,显示对象A:6}
     */
    SceneObjectEntity.prototype.getModuleCustomAttributeCache = function (stpIndex, moduleIndex) {
        var stp = this.statusPages[stpIndex];
        var moduleCacheArr = stp.modulesCustomAttributesCaches;
        // -- 获取该对象的当前状态页的模块组
        var stpSceneObjectData;
        if (stpIndex == 0) {
            if (!moduleCacheArr)
                moduleCacheArr = stp.modulesCustomAttributesCaches = this.sceneObjectData.modulesCustomAttributesCaches[this.fromSceneObjectindex] = [];
        }
        else {
            if (!moduleCacheArr)
                moduleCacheArr = stp.modulesCustomAttributesCaches = this.sceneObjectData.statusPages[this.fromSceneObjectindex][stpIndex - 1].modulesCustomAttributesCaches = [];
        }
        var moduleCache = moduleCacheArr[moduleIndex];
        if (!moduleCache) {
            // -- 建立模块数据
            var moduleID = stp.so.moduleIDs[moduleIndex];
            var moduleData = Common.sceneObjectModuleList.data[moduleID];
            if (!moduleData)
                return null;
            var virtualModule = {};
            // -- 记录
            if (stpIndex == 0) {
                moduleCache = this.sceneObjectData.modulesCustomAttributesCaches[this.fromSceneObjectindex][moduleIndex] = virtualModule;
            }
            else {
                moduleCache = this.sceneObjectData.statusPages[this.fromSceneObjectindex][stpIndex - 1].modulesCustomAttributesCaches[moduleIndex] = virtualModule;
            }
            CustomAttributeSetting.installAttributeFromEditorSet(virtualModule, stp.modulesCustomAttribute[moduleIndex], moduleData.varAttributes, false, false, GameData.CUSTOM_ATTR_SCENE_OBJECT_MODULE_DATA);
            moduleCacheArr[moduleIndex] = moduleCache;
            // -- 安装显示列表数据
            for (var i = 0; i < moduleData.preLayer.length; i++) {
                var p = moduleData.preLayer[i];
                var displayInfos = stp.so.moduleDisplayList[moduleIndex];
                if (displayInfos) {
                    var displayInfo = displayInfos[p.varName];
                    if (displayInfo != null) {
                        moduleCache[p.varName] = displayInfo.id;
                    }
                    else {
                        moduleCache[p.varName] = 0;
                    }
                }
            }
        }
        return moduleCache;
    };
    /**
     * 获取对象开关 兼容旧的错误名称API
     * @param index
     * @return [number]
     */
    SceneObjectEntity.prototype.getSwitchs = function (index) {
        return this.switchs[index];
    };
    /**
     * 设置对象开关 兼容旧的错误名称API
     * @param varID 开关编号
     * @param value 开关值 0/1
     */
    SceneObjectEntity.prototype.setSwitchs = function (varID, value) {
    };
    /**
     * 获取对象开关
     * @param index
     * @return [number]
     */
    SceneObjectEntity.prototype.getSwitch = function (index) {
        return this.switchs[index];
    };
    /**
     * 设置对象开关
     * @param varID 开关编号
     * @param value 开关值 0/1
     */
    SceneObjectEntity.prototype.setSwitch = function (varID, value) {
        this.setSwitch(varID, value);
    };
    /**
     * 安装开关
     */
    SceneObjectEntity.prototype.installSwitchs = function (switchs, refreshDisappearStatus) {
        if (refreshDisappearStatus === void 0) { refreshDisappearStatus = true; }
        if (!switchs)
            switchs = [0, 0, 0, 0, 0, 0, 0];
        this.switchs = switchs;
        if (refreshDisappearStatus)
            this.refreshDisappearStatus();
    };
    //------------------------------------------------------------------------------------------------------
    // 自定义属性
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取自定义属性名称集
     * @return [string]
     */
    SceneObjectEntity.prototype.getCustomAttrs = function () {
        // 不存在模型的情况
        var modelData = Common.sceneObjectModelList.data[this.modelID];
        if (!modelData)
            return null;
        var len = modelData.varAttributes.length;
        var varNames = [];
        for (var i = 0; i < len; i++) {
            varNames.push(modelData.varAttributes[i].varName);
        }
        return varNames;
    };
    /**
     * 添加一组行为
     * @param behaviorData 行为数据 [行为ID,参数1,参数2...]
     *                     [[行为1-ID,参数1,参数2],[行为2-ID,参数1,参数2],....]
     * @param loop 是否循环
     * @param targetPlayerSceneObject 存在的玩家目标对象
     * @param onOver 当行为结束时回调
     * @param cover 覆盖旧的行为
     * @param Immediate 立即开始，否则会等待下一帧才开始执行
     * @param forceStopLastBehavior
     * @param delayFrame [可选] 默认值=0 行为内部等待的时间
     * @param executor [可选] 默认值=null 执行事件者
     * @return 返回层次
     */
    SceneObjectEntity.prototype.addBehavior = function (behaviorData, loop, targetPlayerSceneObject, onOver, cover, startIndex, Immediate, forceStopLastBehavior, delayFrame, executor) {
        if (startIndex === void 0) { startIndex = 0; }
        if (Immediate === void 0) { Immediate = true; }
        if (forceStopLastBehavior === void 0) { forceStopLastBehavior = false; }
        if (delayFrame === void 0) { delayFrame = 0; }
        if (executor === void 0) { executor = null; }
        return null;
    };
    /**
     * 获取行为所在组
     */
    SceneObjectEntity.prototype.getBehaviorIndex = function (behavior) {
        return this.behaviors ? this.behaviors.indexOf(behavior) : -1;
    };
    /**
     * 获取行为组
     */
    SceneObjectEntity.prototype.getBehaviors = function () {
        return this.behaviors;
    };
    /**
     * 清理行为
     */
    SceneObjectEntity.prototype.clearBehaviors = function () {
        if (this.behaviors)
            this.behaviors.length = 0;
    };
    /**
     * 获取事件触发器:单线事件拿到的是唯一触发器，而多线事件则新生成触发器
     * @param mainType 0-场景相关 1-场景对象相关 2-UI相关 （对应CommandTrigger.COMMAND_MAIN_TYPE_XXX）
     * @param indexType 对应的小类别 0-N
     * @param scene 场景
     * @param executor 执行者
     * @param uiCompID 界面组件唯一标识
     * @return 事件触发器
     */
    SceneObjectEntity.prototype.getCommandTrigger = function (mainType, indexType, scene, executor, uiCompID) {
        if (uiCompID === void 0) { uiCompID = null; }
        if (mainType < 0 || indexType < 0)
            return null;
        if (executor == null)
            executor = this;
        var trigger;
        // 新线程调用公共事件的触发器
        if (mainType == CommandTrigger.COMMAND_MAIN_TYPE_CALL_COMMON_EVENT) {
            return new CommandTrigger(mainType, indexType, scene, this, true, this);
        }
        // 新线程调用片段事件的触发器
        if (mainType == CommandTrigger.COMMAND_MAIN_TYPE_FRAGMENT_EVENT) {
            return new CommandTrigger(mainType, indexType, scene, this, true, executor);
        }
        var typeCmd = [Common.customSceneEventTypeList, Common.customObjectEventTypeList, Common.customUIEventTypeList][mainType].data[indexType + 1];
        if (typeCmd) {
            // 界面组件的事件
            if (mainType == CommandTrigger.COMMAND_MAIN_TYPE_UI) {
                if (typeCmd.multiline) {
                    return new CommandTrigger(mainType, indexType, scene, this, typeCmd.multiline, executor);
                }
                else {
                    var lineSign = uiCompID + "_" + indexType;
                    var trigger = this.triggerSingleLines[lineSign];
                    if (!trigger)
                        trigger = this.triggerSingleLines[lineSign] = new CommandTrigger(mainType, indexType, scene, this, typeCmd.multiline, executor);
                }
            }
            // 场景和场景对象
            else {
                if (typeCmd.multiline) {
                    return new CommandTrigger(mainType, indexType, scene, this, typeCmd.multiline, executor);
                }
                else {
                    var triggerID = mainType * 1000000 + indexType * 10000 + executor.index;
                    var trigger = this.triggerSingleLines[triggerID];
                    if (!trigger)
                        trigger = this.triggerSingleLines[triggerID] = new CommandTrigger(mainType, indexType, scene, this, typeCmd.multiline, executor);
                }
            }
        }
        return trigger;
    };
    //------------------------------------------------------------------------------------------------------
    //  模块-实例的数据更改
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取模块可储存的数据
     * @param soc 指定的场景对象
     */
    SceneObjectEntity.getModulesSaveData = function (soc) {
        // 遍历所有模块，复制一个模块数据过来（客户端需要替换显示对象）
        var soModuleArr = [];
        for (var i = 0; i < soc._modules.length; i++) {
            var soModule = soc._modules[i];
            var soModuleData;
            if (Config.IS_SERVER) {
                soModuleData = ObjectUtils.depthClone(soModule);
            }
            else {
                soModuleData = {};
                var moduleData = Game.data.sceneObjectModuleList.data[soModule.id];
                for (var s = 0; s < moduleData.varAttributes.length; s++) {
                    var attrSetting = moduleData.varAttributes[s];
                    soModuleData[attrSetting.varName] = soModule[attrSetting.varName];
                }
                for (var s = 0; s < moduleData.preLayer.length; s++) {
                    var preLayer = moduleData.preLayer[s];
                    if (preLayer.type == 2 || preLayer.type == 4) {
                        soModuleData[preLayer.varName] = preLayer.id;
                    }
                    else if (preLayer.type == 3) {
                        var uiRoot = soModule[preLayer.varName];
                        soModuleData[preLayer.varName] = uiRoot ? uiRoot.guiID : 0; // 添加了该参数但未选择具体的界面时是会为null
                    }
                    else if (preLayer.type == 5) {
                        var ani = soModule[preLayer.varName];
                        soModuleData[preLayer.varName] = ani ? ani.id : 0;
                    }
                }
                soModuleData = ObjectUtils.depthClone(soModuleData);
            }
            soModuleArr.push(soModuleData);
        }
        return soModuleArr;
    };
    /**
     * 安装模块，根据制作数据
     * [不公开API]
     * @param moduleIDs 模块集
     * @param modulesCustomAttribute 制作数据
     * @param presetDatas value数据，如来自存档的值，存在的话优先使用此值 如 presetData[0].xxx = 6;
     */
    SceneObjectEntity.prototype.installModulesByTypeValue = function (moduleIDs, moduleDisplayList, modulesCustomAttribute, presetDatas) {
        if (presetDatas === void 0) { presetDatas = null; }
        this.removeAllModules();
        this.moduleIDs = [];
        this.moduleDisplayList = [];
        for (var i = 0; i < moduleIDs.length; i++) {
            var moduleID = moduleIDs[i];
            var soModulePresetData = {};
            var moduleData = Game.data.sceneObjectModuleList.data[moduleID];
            if (moduleData) {
                // -- 制作数据的模块自定义属性
                CustomAttributeSetting.installAttributeFromEditorSet(soModulePresetData, modulesCustomAttribute[i], moduleData.varAttributes, false, false, GameData.CUSTOM_ATTR_SCENE_OBJECT_MODULE_DATA);
                // -- 制作数据的模块显示列表
                for (var s = 0; s < moduleData.preLayer.length; s++) {
                    var p = moduleData.preLayer[s];
                    var displayInfos = moduleDisplayList[i];
                    if (displayInfos) {
                        var displayInfo = displayInfos[p.varName];
                        if (displayInfo != null) {
                            soModulePresetData[p.varName] = displayInfo.id;
                        }
                        else {
                            soModulePresetData[p.varName] = 0;
                        }
                    }
                }
                // -- 如果存在presetData则优先使用presetData（如来自存档的数据）
                if (presetDatas) {
                    var presetData = presetDatas[i];
                    if (presetData) {
                        ObjectUtils.clone(presetData, soModulePresetData);
                    }
                }
                var soModule = SceneObject.createModule(moduleID, this, soModulePresetData);
                if (soModule)
                    this.addModule(soModule);
            }
        }
    };
    /**
     * 添加模块
     * @param soModule 模块
     * @return [boolean] 是否添加成功
     */
    SceneObjectEntity.prototype.addModule = function (soModule, sendEvent) {
        if (sendEvent === void 0) { sendEvent = true; }
        if (ArrayUtils.matchAttributes(this._modules, { id: soModule.id }, true).length == 1)
            return false;
        var moduleData = Common.sceneObjectModuleList.data[soModule.id];
        if (moduleData) {
            this._modules.push(soModule);
            this.moduleIDs.push(soModule.id);
            // 刷新模块的显示列表：遍历模块预设的显示列表，插入进去，具体值参考soModule（如果存在），否则使用默认值
            var moduleIndex = this._modules.length - 1;
            var moduleDisplayInfo = {};
            this.moduleDisplayList.push(moduleDisplayInfo);
            for (var i = 0; i < moduleData.preLayer.length; i++) {
                var p = moduleData.preLayer[i];
                var id;
                var attributeValue = soModule[p.varName];
                if (attributeValue) {
                    id = typeof attributeValue == "number" ? attributeValue : attributeValue.id;
                }
                else {
                    id = p.id;
                }
                moduleDisplayInfo[p.varName] = { type: p.type, id: id };
            }
            soModule.so = this;
            if (sendEvent)
                EventUtils.happen(SceneObjectEntity, SceneObjectEntity.EVENT_ON_ADD_MODULE, [this, soModule]);
            return true;
        }
        return false;
    };
    /**
     * 添加模块-到指定的位置上
     * @param soModule 模块
     * @param index 指定的位置
     * @return [boolean] 是否添加成功
     */
    SceneObjectEntity.prototype.addModuleAt = function (soModule, index, sendEvent) {
        if (sendEvent === void 0) { sendEvent = true; }
        if (index < 0 || index > this._modules.length)
            return false;
        if (ArrayUtils.matchAttributes(this._modules, { id: soModule.id }, true).length == 1)
            return false;
        var bool = this.addModule(soModule, false);
        if (bool) {
            var fromIndex = this._modules.length - 1;
            bool = this.setModuleIndexByIndex(fromIndex, index);
            if (sendEvent)
                EventUtils.happen(SceneObjectEntity, SceneObjectEntity.EVENT_ON_ADD_MODULE, [this, soModule]);
            return bool;
        }
        return false;
    };
    /**
     * 添加模块-根据模块编号
     * -- 模块的属性为默认值
     * @param moduleID 模块编号
     * @return [SceneObjectModule] 被添加的模块，如果不成功则返回null
     */
    SceneObjectEntity.prototype.addModuleByID = function (moduleID, sendEvent) {
        if (sendEvent === void 0) { sendEvent = true; }
        if (ArrayUtils.matchAttributes(this._modules, { id: moduleID }, true).length == 1)
            return null;
        var soModule = SceneObject.createModule(moduleID, this);
        if (!soModule)
            return null;
        var bool = this.addModule(soModule, sendEvent);
        if (bool)
            return soModule;
    };
    /**
     * 添加模块-到指定的位置上-根据模块的编号
     * @param moduleID 模块编号
     * @param index 指定的位置
     * @return [SceneObjectModule] 被添加的模块，如果不成功则返回null
     */
    SceneObjectEntity.prototype.addModuleByIDAt = function (moduleID, index, sendEvent) {
        if (sendEvent === void 0) { sendEvent = true; }
        var soModule = this.addModuleByID(moduleID, sendEvent);
        if (soModule) {
            var fromIndex = this._modules.length - 1;
            var bool = this.setModuleIndexByIndex(fromIndex, index);
            if (bool)
                return soModule;
        }
        return null;
    };
    /**
     * 移除所有模块
     * @param isDispose [可选] 默认值=true 是否销毁模块
     */
    SceneObjectEntity.prototype.removeAllModules = function (isDispose, sendEvent) {
        if (isDispose === void 0) { isDispose = true; }
        if (sendEvent === void 0) { sendEvent = true; }
        if (this._modules) {
            var removeModuleArr = this._modules.concat();
        }
        if (this.moduleDisplayList)
            this.moduleDisplayList.length = 0;
        this._modules.length = 0;
        if (this.moduleIDs)
            this.moduleIDs.length = 0;
        if (removeModuleArr) {
            for (var i = 0; i < removeModuleArr.length; i++) {
                var soModule = removeModuleArr[i];
                soModule.onRemoved();
                if (sendEvent) {
                    EventUtils.happen(SceneObjectEntity, SceneObjectEntity.EVENT_ON_REMOVE_MODULE, [this, soModule]);
                }
                if (isDispose) {
                    soModule.dispose && soModule.dispose();
                }
            }
        }
    };
    /**
     * 移除指定编号的模块
     * @param moduleID 模块的编号
     * @param isDispose [可选] 默认值=true 是否销毁模块
     * @return [SceneObjectModule] 被移除的模块，如果不成功则返回null
     */
    SceneObjectEntity.prototype.removeModuleByID = function (moduleID, isDispose, sendEvent) {
        if (isDispose === void 0) { isDispose = true; }
        if (sendEvent === void 0) { sendEvent = true; }
        var index = ArrayUtils.matchAttributes(this._modules, { id: moduleID }, true, "==", true)[0];
        if (index != null) {
            this.moduleDisplayList.splice(index, 1);
            this.moduleIDs.splice(index, 1);
            var soModule = this._modules.splice(index, 1)[0];
            if (soModule) {
                soModule.onRemoved();
                if (sendEvent) {
                    EventUtils.happen(SceneObjectEntity, SceneObjectEntity.EVENT_ON_REMOVE_MODULE, [this, soModule]);
                }
                if (isDispose) {
                    soModule.dispose && soModule.dispose();
                }
            }
            return soModule;
        }
        return null;
    };
    /**
     * 移除模块-根据其拥有的模块
     * @param soModule 拥有的模块
     * @param isDispose [可选] 默认值=true 是否销毁模块
     * @return [boolean] 是否移除成功
     */
    SceneObjectEntity.prototype.removeModule = function (soModule, isDispose, sendEvent) {
        if (isDispose === void 0) { isDispose = true; }
        if (sendEvent === void 0) { sendEvent = true; }
        var index = this._modules.indexOf(soModule);
        if (index != -1) {
            this.moduleDisplayList.splice(index, 1);
            this.moduleIDs.splice(index, 1);
            this._modules.splice(index, 1);
            soModule.onRemoved();
            if (sendEvent) {
                EventUtils.happen(SceneObjectEntity, SceneObjectEntity.EVENT_ON_REMOVE_MODULE, [this, soModule]);
            }
            if (isDispose) {
                soModule.dispose && soModule.dispose();
            }
            return true;
        }
        return false;
    };
    /**
     * 移除模块-根据指定的位置
     * @param index 指定的位置
     * @param isDispose [可选] 默认值=true 是否销毁
     * @return [boolean] 是否移除成功
     */
    SceneObjectEntity.prototype.removeModuleAt = function (index, isDispose, sendEvent) {
        if (isDispose === void 0) { isDispose = true; }
        if (sendEvent === void 0) { sendEvent = true; }
        if (index < 0 || index >= this._modules.length)
            return false;
        if (index != null) {
            var soModule = this._modules[index];
            this.moduleDisplayList.splice(index, 1);
            this.moduleIDs.splice(index, 1);
            this._modules.splice(index, 1);
            soModule.onRemoved();
            if (sendEvent) {
                EventUtils.happen(SceneObjectEntity, SceneObjectEntity.EVENT_ON_REMOVE_MODULE, [this, soModule]);
            }
            if (isDispose) {
                soModule.dispose && soModule.dispose();
            }
            return true;
        }
        return false;
    };
    /**
     * 设置已拥有的模块到指定位置
     * @param soModule 拥有的模块
     * @param toIndex 设置到达指定的位置
     * @return [boolean] 是否成功
     */
    SceneObjectEntity.prototype.setModuleIndex = function (soModule, toIndex) {
        var index = this._modules.indexOf(soModule);
        if (index != -1)
            return this.setModuleIndexByIndex(index, toIndex);
        return false;
    };
    /**
     * 设置已拥有的模块到指定位置-根据模块编号
     * @param moduleID 已拥有的模块的编号
     * @param toIndex 设置到达指定的位置
     * @return [boolean] 是否成功
     */
    SceneObjectEntity.prototype.setModuleIndexByID = function (moduleID, toIndex) {
        var index = ArrayUtils.matchAttributes(this._modules, { id: moduleID }, true, "==", true)[0];
        if (index != null)
            return this.setModuleIndexByIndex(index, toIndex);
        return false;
    };
    /**
     * 调整模块位置
     * @param fromIndex 模块的原始位置
     * @param toIndex 模块的新位置
     * @return [boolean] 是否成功
     */
    SceneObjectEntity.prototype.setModuleIndexByIndex = function (fromIndex, toIndex) {
        if (fromIndex < 0 || fromIndex >= this._modules.length)
            return false;
        if (toIndex < 0 || toIndex >= this._modules.length)
            return false;
        var fromObj = this._modules.splice(fromIndex, 1)[0];
        this._modules.splice(toIndex, 0, fromObj);
        fromObj = this.moduleIDs.splice(fromIndex, 1)[0];
        this.moduleIDs.splice(toIndex, 0, fromObj);
        fromObj = this.moduleDisplayList.splice(fromIndex, 1)[0];
        this.moduleDisplayList.splice(toIndex, 0, fromObj);
        return true;
    };
    /**
     * 获取已拥有的模块-根据模块编号
     * @param moduleID 模块编号
     * @return [SceneObjectModule] 返回拥有的该模块，如果未拥有则返回null
     */
    SceneObjectEntity.prototype.getModule = function (moduleID) {
        return ArrayUtils.matchAttributes(this._modules, { id: moduleID }, true)[0];
    };
    /**
     * 获取已拥有的模块-根据模块名称
     * @param moduleName 模块名称
     * @return [SceneObjectModule] 返回拥有的该模块，如果未拥有则返回null
     */
    SceneObjectEntity.prototype.getModuleByName = function (moduleName) {
        return ArrayUtils.matchAttributes(this._modules, { name: moduleName }, true)[0];
    };
    /**
     * 获取已拥有的模块-根据模块位置
     * @param index 模块位置
     * @return [SceneObjectModule] 返回拥有的该模块，如果未拥有则返回null
     */
    SceneObjectEntity.prototype.getModuleAt = function (index) {
        if (index >= 0 && index < this._modules.length) {
            return this._modules[index];
        }
    };
    /**
     * 获取已拥有的模块的位置
     * @param soModule 模块
     * @return [number] 已拥有的该模块的位置，如果未拥有则返回-1
     */
    SceneObjectEntity.prototype.getModuleIndex = function (soModule) {
        return this._modules.indexOf(soModule);
    };
    /**
     * 获取已拥有的模块位置-根据模块的编号
     * @param moduleID 模块编号
     * @return [number] 已拥有的该模块的位置，如果未拥有则返回-1
     */
    SceneObjectEntity.prototype.getModuleIndexByID = function (moduleID) {
        var index = ArrayUtils.matchAttributes(this._modules, { id: moduleID }, true, "==", true)[0];
        if (index == null)
            return -1;
        return index;
    };
    Object.defineProperty(SceneObjectEntity.prototype, "moduleLength", {
        /**
         * 获取所有模块的数目
         * @return [number] 模块的数目
         */
        get: function () {
            return this._modules.length;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneObjectEntity.prototype, "world", {
        /**
         * 获取世界 (typeof ServerWorld) | (typeof ClientWorld)
         */
        get: function () {
            return Config.IS_SERVER ? ServerWorld : ClientWorld;
        },
        enumerable: false,
        configurable: true
    });
    SceneObjectEntity.prototype.clearCondition = function () {
        // 清理世界变量监听
        for (var id in this.conditionWorldVars) {
            var varID = parseInt(id);
            this.world.removeListenerVariable(0, varID, this.conditionChangeRefreshCB);
        }
        for (var id in this.conditionWorldSwitchs) {
            var varID = parseInt(id);
            this.world.removeListenerVariable(1, varID, this.conditionChangeRefreshCB);
        }
        for (var id in this.conditionPlayerVars) {
            var varID = parseInt(id);
            if (!Config.IS_SERVER)
                Game.player.removeListenerPlayerVariable(0, varID, this.conditionChangeRefreshCB);
        }
        for (var id in this.conditionPlayerSwitchs) {
            var varID = parseInt(id);
            if (!Config.IS_SERVER)
                Game.player.removeListenerPlayerVariable(1, varID, this.conditionChangeRefreshCB);
        }
        this.conditionPlayerVars = {};
        this.conditionPlayerSwitchs = {};
        this.conditionMySwitchs = {};
        this.conditionWorldSwitchs = {};
        this.conditionWorldVars = {};
    };
    /**
     * 获取全部状态页的条件
     */
    SceneObjectEntity.prototype.____getConditions = function () {
        this.condition;
    };
    /**
     * 初始化条件：独立开关、世界变量、世界开关
     * 当改变了条件设定时可以重新调用此方法来更新条件监控
     * -- 当设置状态页后会进入监听，并开始监听当前状态页~最后的状态页的条件
     */
    SceneObjectEntity.prototype.initCondition = function () {
        // 清理监听条件
        this.clearCondition();
        // 开始监听
        var startStpIndedx = MathUtils.int(this.currentStatusPageIndex);
        var stpLen = this.statusPages.length;
        // 遍历当前状态页至最终页的所有条件开始监听
        for (var i = startStpIndedx; i < stpLen; i++) {
            var stp = this.statusPages[i];
            var conditions = stp.event.condition;
            for (var s = 0; s < conditions.length; s++) {
                var condition = conditions[s];
                // 存在世界变量条件时（数值、开关）初始化Callback
                if (condition.type != 2 && !this.conditionChangeRefreshCB) {
                    this.conditionChangeRefreshCB = Callback.New(this.refreshDisappearStatus, this);
                }
                if (condition.type == 1) {
                    if (!this.conditionPlayerVars[condition.varID]) {
                        this.conditionPlayerVars[condition.varID] = true;
                        if (!Config.IS_SERVER)
                            Game.player.addListenerPlayerVariable(0, condition.varID, this.conditionChangeRefreshCB, false, false);
                    }
                }
                if (condition.type == 0) {
                    if (!this.conditionPlayerVars[condition.varID]) {
                        this.conditionPlayerSwitchs[condition.varID] = true;
                        if (!Config.IS_SERVER)
                            Game.player.addListenerPlayerVariable(1, condition.varID, this.conditionChangeRefreshCB, false, false);
                    }
                }
                if (condition.type == 3) {
                    if (!this.conditionWorldVars[condition.varID]) {
                        this.conditionWorldVars[condition.varID] = true;
                        this.world.addListenerVariable(0, condition.varID, this.conditionChangeRefreshCB);
                    }
                }
                if (condition.type == 4) {
                    if (!this.conditionWorldSwitchs[condition.varID]) {
                        this.conditionWorldSwitchs[condition.varID] = true;
                        this.world.addListenerVariable(1, condition.varID, this.conditionChangeRefreshCB);
                    }
                }
                if (condition.type == 2)
                    this.conditionMySwitchs[condition.varID] = true;
            }
        }
        return;
        // // 清理条件
        // this.clearCondition();
        // // 监听 
        // var hasWorldCondition = false;
        // var hasWorldSwitchCondition = false;
        // for (var s = 0; s < this.condition.length; s++) {
        //     var condition: Condition = this.condition[s];
        //     // 存在世界变量条件时（数值、开关）初始化Callback
        //     if (condition.type != 2 && !hasWorldCondition) {
        //         this.conditionChangeRefreshCB = Callback.New(this.refreshDisappearStatus, this);
        //         hasWorldCondition = true;
        //     }
        //     if (condition.type == 1) {
        //         this.conditionPlayerVars[condition.varID] = true;
        //         if (!Config.IS_SERVER) Game.player.addListenerPlayerVariable(0, condition.varID, this.conditionChangeRefreshCB);
        //     }
        //     if (condition.type == 0) {
        //         this.conditionPlayerSwitchs[condition.varID] = true;
        //         if (!Config.IS_SERVER) Game.player.addListenerPlayerVariable(1, condition.varID, this.conditionChangeRefreshCB);
        //     }
        //     if (condition.type == 3) {
        //         this.conditionWorldVars[condition.varID] = true;
        //         this.world.addListenerVariable(0, condition.varID, this.conditionChangeRefreshCB);
        //     }
        //     if (condition.type == 4) {
        //         this.conditionWorldSwitchs[condition.varID] = true;
        //         this.world.addListenerVariable(1, condition.varID, this.conditionChangeRefreshCB);
        //     }
        //     if (condition.type == 2) this.conditionMySwitchs[condition.varID] = true;
        // }
        // // 根据条件刷新消失状态
        // this.refreshDisappearStatus();
    };
    /**
     * 刷新状态
     * 当我条件发生改变时触发
     * 当没有一个状态页满足的话就是消失的状态，否则只是切换状态。
     * @param sign 标志 为解决传输错误的参数（如监听变量回调后给的参数不匹配） sign=rd 表示还原数据
     * @param recordData 存档数据
     * @return state 0-无变化 1-需要出现 2-需要移除  changeStatusPage=是否更改了状态页
     */
    SceneObjectEntity.prototype.refreshDisappearStatus = function (sign, recordData) {
        if (sign === void 0) { sign = null; }
        if (recordData === void 0) { recordData = null; }
        // 如玩家等不存在事件页的对象忽略执行
        if (!this.statusPages)
            return;
        var stpLen = this.statusPages.length;
        var stpIndex = null;
        var lastInScene = this.inScene;
        var changeStatusPage = false;
        // 解决参数错误的情况
        if (sign != "rd")
            recordData = null;
        for (var s = stpLen - 1; s >= 0; s--) {
            var stp = this.statusPages[s];
            var conditions = stp.event.condition;
            // 如果没有条件的话就忽略该状态页
            if (!conditions)
                continue;
            var len = conditions.length;
            var curStpInScene = true;
            // 遍历全条件，一旦不符合的话则退出
            for (var i = 0; i < len; i++) {
                var condition = conditions[i];
                // 服务端忽略玩家变量
                if (Config.IS_SERVER && condition.type <= 1) {
                    continue;
                }
                // 世界变量判断:如果不符合的话
                if (condition.type == 3 || condition.type == 1) {
                    var varValue = condition.type == 3 ? this.world.getWorldVariable(condition.varID) : Game.player.variable.getVariable(condition.varID);
                    if ((condition.compare == 0 && varValue !== condition.value) ||
                        (condition.compare == 1 && varValue < condition.value) ||
                        (condition.compare == 2 && varValue <= condition.value) ||
                        (condition.compare == 3 && varValue > condition.value) ||
                        (condition.compare == 4 && varValue >= condition.value) ||
                        (condition.compare == 5 && varValue === condition.value)) {
                        curStpInScene = false;
                        break;
                    }
                }
                // 独立开关和世界开关判断:如果不符合的话
                else if ((condition.type == 2 && this.switchs[condition.varID] !== condition.value) ||
                    (condition.type == 4 && this.world.getWorldSwitch(condition.varID) !== MathUtils.int(condition.value)) ||
                    (condition.type == 0 && !Config.IS_SERVER && Game.player.variable.getSwitch(condition.varID) !== MathUtils.int(condition.value))) {
                    curStpInScene = false;
                    break;
                }
            }
            // 不符合出现条件，忽略该状态页
            if (!curStpInScene)
                continue;
            // 符合该状态页，开始执行状态变更
            stpIndex = s;
            // 状态页发生更改的情况
            if (this.currentStatusPageIndex !== stpIndex) {
                // 状态页发生变更事件
                if (this.currentStatusPageIndex != null) {
                    EventUtils.happen(SceneObjectEntity, SceneObjectEntity.EVENT_BEFORE_CHANGE_STATUS_PAGE, [this]);
                    EventUtils.happen(this, SceneObjectEntity.EVENT_BEFORE_CHANGE_STATUS_PAGE_FOR_INSTANCE, [this]);
                }
                // 如果存在存档数据则需要恢复下存档数据
                if (recordData) {
                    var modelData = Common.sceneObjectModelList.data[recordData.modelID];
                    if (modelData) {
                        // 安装基本属性：状态页的公共属性不会重新赋值
                        for (var o in SceneObject.self) {
                            if (SceneObject.statusCommonAttributes[o])
                                continue;
                            this[o] = recordData[o];
                        }
                        for (var o in SceneObject.compoundAttributes) {
                            var attrName = SceneObject.compoundAttributes[o];
                            this[attrName] = ObjectUtils.depthClone(recordData[attrName]);
                        }
                        // 格式化最初的属性
                        SceneObject.installCustomData(this, stp.customAttribute);
                        // 恢复存档数据
                        var fixModelData;
                        if (Config.useNewSceneObjectModel) {
                            fixModelData = Common.sceneObjectModelList.data[0];
                        }
                        else {
                            fixModelData = modelData;
                        }
                        CustomAttributeSetting.installAttributeFromRecordData(this, recordData, fixModelData.varAttributes, null, 3);
                        // 恢复存档数据的模块数据
                        var recoveryModulesData = SceneObjectEntity.recoveryModulesData[this.index];
                        if (recoveryModulesData) {
                            if (recoveryModulesData.needCheckModulesCustomAttributes) {
                                var sceneData = Common.sceneList.data[Game.currentScene.id];
                                var sceneObjDatas = sceneData.sceneObjectData;
                                if (stpIndex == 0) {
                                    var modulesCustomAttributes = sceneObjDatas.modulesCustomAttributes[this.index];
                                }
                                else {
                                    var stps = sceneObjDatas.statusPages[this.index];
                                    if (stps) {
                                        var stp = stps[stpIndex - 1];
                                        modulesCustomAttributes = stp.modulesCustomAttribute;
                                    }
                                }
                            }
                            var moduleIDs = this.moduleIDs.concat();
                            var moduleDisplayList = this.moduleDisplayList.concat();
                            // -- 没有的模块制作数据的话使用模块的默认值
                            if (!modulesCustomAttributes) {
                                modulesCustomAttributes = [];
                                for (var i = 0; i < moduleIDs.length; i++) {
                                    var moduleID = moduleIDs[i];
                                    var moduleData = Common.sceneObjectModuleList.data[moduleID];
                                    if (!moduleData) {
                                        moduleIDs.splice(i, 1);
                                        moduleDisplayList.splice(i, 1);
                                        i--;
                                    }
                                    modulesCustomAttributes.push(CustomAttributeSetting.formatCustomData(null, moduleData.varAttributes));
                                }
                            }
                            this.installModulesByTypeValue(moduleIDs, moduleDisplayList, modulesCustomAttributes, recoveryModulesData.presetData);
                        }
                    }
                }
                else {
                    // 安装基本属性：状态页的公共属性不会重新赋值(忽略模块相关数据，下面会单独进行安装)
                    for (var o in stp.so) {
                        if (SceneObject.statusCommonAttributes[o])
                            continue;
                        if (o == "moduleIDs" || o == "moduleDisplayList")
                            continue;
                        this[o] = stp.so[o];
                    }
                    for (var o in SceneObject.compoundAttributes) {
                        var attrName = SceneObject.compoundAttributes[o];
                        if (attrName == "moduleIDs" || attrName == "moduleDisplayList")
                            continue;
                        this[attrName] = ObjectUtils.depthClone(stp.so[attrName]);
                    }
                    // 安装自定义属性（切换状态页后会重置为预先设置的制作数据，所以此处可以使用缓存）
                    var customAttributesCache = ObjectUtils.depthClone(this.getCustomAttributeCache(stpIndex));
                    ObjectUtils.clone(customAttributesCache, this);
                    // 安装模块（切换状态页后会重置为预先设置的制作数据，所以此处可以使用缓存）
                    if (Config.useNewSceneObjectModel) {
                        if (stp.so.moduleIDs == null)
                            stp.so.moduleIDs = [];
                        if (this.moduleIDs == null)
                            this.moduleIDs = [];
                        this.removeAllModules();
                        for (var i = 0; i < stp.so.moduleIDs.length; i++) {
                            var moduleID = stp.so.moduleIDs[i];
                            var soModulePresetData = ObjectUtils.depthClone(this.getModuleCustomAttributeCache(stpIndex, i));
                            var soModule = SceneObject.createModule(moduleID, this, soModulePresetData);
                            if (soModule)
                                this.addModule(soModule);
                        }
                    }
                }
                // 自定义事件刷新
                this.hasCommand = this.hasCommandCache[stpIndex];
                this.customCommandPages = this.customCommandPagesCache[stpIndex];
                if (!this.hasCommand) {
                    this.hasCommand = this.hasCommandCache[stpIndex] = [];
                    this.customCommandPages = this.customCommandPagesCache[stpIndex] = [];
                    for (var o in stp.event.customCommands) {
                        var customCmd = stp.event.customCommands[o];
                        if (!customCmd)
                            continue;
                        // 缓存事件页
                        this.customCommandPages[o] = new CommandPage(customCmd);
                        if (customCmd.length != 0) {
                            this.hasCommand[o] = true;
                        }
                    }
                }
                // 记录新的状态页并重新监听条件以及派发事件
                this.currentStatusPageIndex = stpIndex;
                this.initCondition();
                changeStatusPage = true;
            }
            break;
        }
        // 判定是否在场景上，当没有任何一页满足的话则表示不在场景上
        var curInScene;
        if (stpIndex == null) {
            curInScene = false;
            // 安装默认属性以便不会造成无法访问的情况（此处兼容旧工程）
            if (!Config.IS_SERVER && Config.compatibleOldProgram) {
                SceneObject.installCustomData(this, this.statusPages[0].customAttribute);
            }
            // 当任意条件都未能满足的话
            if (this.currentStatusPageIndex != null) {
                this.currentStatusPageIndex = null;
                this.initCondition();
                changeStatusPage = true;
            }
        }
        else {
            curInScene = true;
        }
        var state = 0;
        this.inScene = curInScene;
        if (lastInScene != curInScene) {
            if (curInScene) {
                state = 1;
            }
            else {
                state = 2;
            }
        }
        return { state: state, changeStatusPage: changeStatusPage };
        // if (!this.condition) return 0;
        // var lastInScene = this.inScene;
        // var len = this.condition.length;
        // var curInScene = true;
        // for (var i = 0; i < len; i++) {
        //     var condition = this.condition[i];
        //     // 服务端忽略玩家变量
        //     if (Config.IS_SERVER && condition.type <= 1) {
        //         continue;
        //     }
        //     // 世界变量判断
        //     if (condition.type == 3 || condition.type == 1) {
        //         var varValue = condition.type == 3 ? this.world.getWorldVariable(condition.varID) : Game.player.variable.getVariable(condition.varID);
        //         if ((condition.compare == 0 && varValue !== condition.value) ||
        //             (condition.compare == 1 && varValue < condition.value) ||
        //             (condition.compare == 2 && varValue <= condition.value) ||
        //             (condition.compare == 3 && varValue > condition.value) ||
        //             (condition.compare == 4 && varValue >= condition.value) ||
        //             (condition.compare == 5 && varValue === condition.value)) {
        //             curInScene = false;
        //             break;
        //         }
        //     }
        //     // 独立开关和世界开关判断
        //     else if (
        //         (condition.type == 2 && this.switchs[condition.varID] !== condition.value) ||
        //         (condition.type == 4 && this.world.getWorldSwitch(condition.varID) !== MathUtils.int(condition.value)) ||
        //         (condition.type == 0 && !Config.IS_SERVER && Game.player.variable.getSwitch(condition.varID) !== MathUtils.int(condition.value))
        //     ) {
        //         curInScene = false;
        //         break;
        //     }
        // }
        // this.inScene = curInScene;
        // if (lastInScene != curInScene) {
        //     if (curInScene) {
        //         return 1;
        //     }
        //     else {
        //         return 2;
        //     }
        // }
        // return 0;
    };
    /**
     * 事件：当切换状态页前，首次创建时不派发该事件。 对象=SceneObjectEntity
     */
    SceneObjectEntity.EVENT_BEFORE_CHANGE_STATUS_PAGE = "SceneObjectEVENT_BEFORE_CHANGE_STATUS_PAGE";
    /**
     * 事件：当切换状态页前，首次创建时不派发该事件。对象=[Object SceneObjectEntity]
     */
    SceneObjectEntity.EVENT_BEFORE_CHANGE_STATUS_PAGE_FOR_INSTANCE = "SceneObjectEntityEVENT_BEFORE_CHANGE_STATUS_PAGE_FOR_INSTANCE";
    /**
     * 事件：当切换状态页后，首次创建时不派发该事件。 对象=SceneObjectEntity
     */
    SceneObjectEntity.EVENT_CHANGE_STATUS_PAGE = "SceneObjectEVENT_ENABLED_CHANGE";
    /**
     * 事件：当切换状态页后，首次创建时不派发该事件。对象=[Object SceneObjectEntity]
     */
    SceneObjectEntity.EVENT_CHANGE_STATUS_PAGE_FOR_INSTANCE = "SceneObjectEntityEVENT_CHANGE_STATUS_PAGE_FOR_INSTANCE";
    /**
     * 事件：当附加模块时 对象=SceneObjectEntity onAddModule(soe:SceneObjectEntity,soModule:SceneObjectModule)
     */
    SceneObjectEntity.EVENT_ON_ADD_MODULE = "SceneObjectEntityEVENT_ON_ADD_MODULE";
    /**
     * 事件：当移除模块时 对象=SceneObjectEntity onRemoveModule(soe:SceneObjectEntity,soModule:SceneObjectModule)
     */
    SceneObjectEntity.EVENT_ON_REMOVE_MODULE = "SceneObjectEntityEVENT_ON_REMOVE_MODULE";
    /**
     * 档案恢复的数据，使用完则销毁
     */
    SceneObjectEntity.recoveryModulesData = [];
    return SceneObjectEntity;
}(SceneObject));
/**
 * 变量集合
 * Created by 黑暗之神KDS on 2018-04-17 16:48:07.
 */
var Variable = /** @class */ (function () {
    /**
     * 构造函数
     * @param listener 监听者 必须含有onVarChange方法
     */
    function Variable(listener) {
        if (listener === void 0) { listener = null; }
        /**
         * 变量集
         */
        this.variables = [];
        /**
         * 开关集
         */
        this.switchs = [];
        /**
         * 字符串集
         */
        this.strings = [];
        this.listener = listener;
    }
    /**
     * 获取数值变量
     * @param index 变量ID
     */
    Variable.prototype.getVariable = function (varID) {
        var v = this.variables[varID];
        return v == null ? 0 : v;
    };
    /**
     * 设置数值变量
     * @param varID
     * @param v
     */
    Variable.prototype.setVariable = function (varID, v) {
        this.variables[varID] = v;
        this.listener && this.listener.onVarChange(0, varID, v);
    };
    /**
     * 获取开关变量
     * @param index
     */
    Variable.prototype.getSwitch = function (varID) {
        var v = this.switchs[varID];
        return v == null ? 0 : v;
    };
    /**
     * 设置开关变量
     * @param index
     * @param v
     */
    Variable.prototype.setSwitch = function (varID, v) {
        this.switchs[varID] = v;
        this.listener && this.listener.onVarChange(1, varID, v);
    };
    /**
     * 获取字符串变量
     * @param index
     */
    Variable.prototype.getString = function (varID) {
        var v = this.strings[varID];
        return v == null ? "" : v;
    };
    /**
     * 设置字符串变量
     * @param index
     * @param v
     */
    Variable.prototype.setString = function (varID, v) {
        this.strings[varID] = v;
        this.listener && this.listener.onVarChange(2, varID, v);
    };
    /**
     * 分解动态文本：将普通文本和变量分解出来
     * 用于变量设置预编译，优化提速用
     * type:0-普通字符串 1-全局变量 2-全局开关 3-全局字符串 4-玩家变量 5-玩家开关 6-玩家字符串 7-玩家输入 8-常用函数
     */
    Variable.splitDynamicText = function (str) {
        var reg = /\[\$(v|s|w)\d+\]|\[\@(v|s|w|p|f)\d+\]/g;
        var m = str.match(reg);
        if (!m)
            return [[0, str]];
        var startIndex = 0;
        var arr = [];
        for (var i = 0; i < m.length; i++) {
            var keyWord = m[i];
            var keyWordIndex = str.indexOf(keyWord, startIndex);
            // normal string
            if (startIndex != keyWordIndex) {
                arr.push([0, str.substr(startIndex, keyWordIndex - startIndex)]);
            }
            startIndex = keyWordIndex + keyWord.length;
            // key word
            var firstKey = keyWord[1];
            var second = keyWord[2];
            var num = keyWord.substr(3, keyWord.length - 4);
            if (firstKey == "$") {
                if (second == "v") {
                    arr.push([1, num]);
                }
                else if (second == "w") {
                    arr.push([2, num]);
                }
                else {
                    arr.push([3, num]);
                }
            }
            else if (firstKey == "@") {
                if (second == "v") {
                    arr.push([4, num]);
                }
                else if (second == "w") {
                    arr.push([5, num]);
                }
                else if (second == "p") {
                    arr.push([7, num]);
                }
                else if (second == "f") {
                    arr.push([8, num]);
                }
                else {
                    arr.push([6, num]);
                }
            }
        }
        if (startIndex != str.length) {
            arr.push([0, str.substr(startIndex)]);
        }
        return arr;
    };
    /**
     * 合并动态文本，根据当前变量的情况
     * 用于变量设置预编译后，优化提速用，合并文本显示最新值
     */
    Variable.margeDynamicText = function (texts, player, trigger) {
        if (player === void 0) { player = null; }
        if (trigger === void 0) { trigger = null; }
        var len = texts.length;
        var str = "";
        for (var i = 0; i < len; i++) {
            var text = texts[i];
            var type = text[0];
            if (type >= 4 && !player)
                continue;
            if (type == 0) {
                str += text[1];
            }
            else if (type == 1) {
                str += Command.gameWorld.getWorldVariable(text[1]);
            }
            else if (type == 2) {
                str += Command.gameWorld.getWorldSwitch(text[1]);
            }
            else if (type == 3) {
                str += Command.gameWorld.getWorldString(text[1]);
            }
            else if (type == 4) {
                str += player.variable.getVariable(text[1]);
            }
            else if (type == 5) {
                str += player.variable.getSwitch(text[1]);
            }
            else if (type == 6) {
                str += player.variable.getString(text[1]);
            }
            else if (type == 7) {
                str += trigger.inputMessage[text[1]];
            }
            else if (type == 8) {
                var value = CustomValueFunction["f" + (text[1])](trigger, player);
                str += value;
            }
        }
        return str;
    };
    //------------------------------------------------------------------------------------------------------
    // 可用于通道(线程)传输的数据
    //------------------------------------------------------------------------------------------------------
    Variable.prototype.getTransportableData = function () {
        var o = {};
        o.variables = this.variables;
        o.switchs = this.switchs;
        o.strings = this.strings;
        return o;
    };
    return Variable;
}());
/**
 * 原始数据
 * Created by 黑暗之神KDS on 2018-10-19 00:58:17.
 */
var OriginalData = /** @class */ (function () {
    function OriginalData() {
    }
    return OriginalData;
}());
/**
 * 数据列表-树结构-原始数据
 */
var TypeTreeNode = /** @class */ (function () {
    function TypeTreeNode() {
    }
    return TypeTreeNode;
}());
/**
 * Created by feng on 2018-10-17 22:10:34.
 */
var AnimationData = /** @class */ (function (_super) {
    __extends(AnimationData, _super);
    function AnimationData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * 总帧数
         */
        _this.totalFrame = 0;
        /**
         * 图源列表
         */
        _this.imageSources = [null];
        /**
         * 层列表，目标效果层只存在于该列表中
         */
        _this.layers = [];
        /**
         * 是否是粒子
         */
        _this.isParticle = false;
        return _this;
    }
    /**
     * 获取所有动画层
     */
    AnimationData.getAllLayers = function (data) {
        var layers = data.layers.concat();
        var index = 0;
        while (index < layers.length) {
            layers = layers.concat(layers[index].children);
            index++;
        }
        return layers;
    };
    /**
     * 是否空数据
     */
    AnimationData.isEmpty = function (data) {
        // 已经设定了名称的话则不作为空数据
        var aniName = GameListData.getName(Game.data.animationList, data.id, true);
        if (aniName)
            return false;
        return (data.totalFrame == 0 && data.imageSources.length == 1 && data.imageSources[0] == null && data.layers.length == 0 && !data.isParticle && data.particleData == null);
    };
    return AnimationData;
}(OriginalData));
/**
 * 动画元素类型
 */
var AnimationItemType;
(function (AnimationItemType) {
    /**
     * 目标对象 AnimationTargetLayer
     */
    AnimationItemType[AnimationItemType["Target"] = 0] = "Target";
    /**
     * 图片 AnimationImageLayer
     */
    AnimationItemType[AnimationItemType["Image"] = 1] = "Image";
    /**
     * 动画 AnimationAnimationLayer
     */
    AnimationItemType[AnimationItemType["GCAnimation"] = 2] = "GCAnimation";
    /**
     * 音效 AnimationAudioLayer
     */
    AnimationItemType[AnimationItemType["Audio"] = 3] = "Audio";
})(AnimationItemType || (AnimationItemType = {}));
/**
 * 自动元件数据
 * Created by 黑暗之神KDS on 2020-06-08 13:36:16.
 */
var AutoTileData = /** @class */ (function (_super) {
    __extends(AutoTileData, _super);
    function AutoTileData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * 图片路径
         */
        _this.url = "";
        /**
        * 数据层数据-由于自动元件仅视为一格
        * [dataGridIndex] = 1/0
        */
        _this.dataLayers = [];
        /**
         * 规格模式
         * 0-GCAT1的规格
         */
        _this.GCATMode = 0;
        return _this;
    }
    /**
     * 运行时使用，获取图块数据
     */
    AutoTileData.getAutoTileData = function (texID) {
        return Game.data.autoTileList.data[texID];
    };
    /**
     * 是否空数据
     * @param data
     */
    AutoTileData.isEmpty = function (data, plugType) {
        // 已经设定了名称的话则不作为空数据
        var tileName = GameListData.getName(Game.data.autoTileList, data.id, true);
        if (tileName)
            return false;
        return !data.url;
    };
    return AutoTileData;
}(OriginalData));
/**
 * AVATAR的数据
 * Created by 黑暗之神KDS on 2018-10-16 18:09:33.
 */
var AvatarData = /** @class */ (function (_super) {
    __extends(AvatarData, _super);
    function AvatarData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * 所使用到的资源列表
         */
        _this.picUrls = ["editorAsset/img/empty.png"];
        /**
         * 动作模式 1 2 3 4 5 8
         */
        _this.oriMode = 4;
        /**
         * 1,3,5方向自动翻转
         */
        _this.autoFlip = true;
        /**
         * 辅助体
         */
        _this.refObjs = {};
        /**
         * 行走图/立绘参考模式
         */
        _this.referenceMode = false;
        /**
         * 行走图/立绘ID
         */
        _this.referenceID = 1;
        /**
         * parts ... 支持显示对象的属性
         */
        _this.parts = [{ id: 0, showOnEditor: true, mouseEventEnabledInEditor: true }];
        /**
         * 动作列表
         */
        _this.actionListArr = [{
                id: 1,
                frameImageInfo: []
            }];
        return _this;
    }
    /**
     * 是否空数据
     * @param data
     */
    AvatarData.isEmpty = function (data, plugType) {
        // 已经设定了名称的话则不作为空数据
        if (plugType == 0) {
            var avatarName = GameListData.getName(Game.data.avatarList, data.id, true);
            if (avatarName)
                return false;
        }
        else {
            var standAvatarName = GameListData.getName(Game.data.standingList, data.id, true);
            if (standAvatarName)
                return false;
        }
        return ((data.actionListArr.length == 0) || (data.actionListArr.length == 1 && data.actionListArr[0].frameImageInfo.length == 0))
            && data.parts.length == 1 && data.picUrls.length == 1 && data.picUrls[0] == "editorAsset/img/empty.png";
    };
    return AvatarData;
}(OriginalData));
/**
 * 编辑器用的Avatar辅助框，用于标记不同ID不同颜色
 * Created by 黑暗之神KDS on 2018-12-21 17:11:16.
 */
var AvatarRefObjData = /** @class */ (function (_super) {
    __extends(AvatarRefObjData, _super);
    function AvatarRefObjData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * 参考颜色
         */
        _this.color = "#FFFFFF";
        /**
         * 仅显示线框
         */
        _this.line = false;
        return _this;
    }
    return AvatarRefObjData;
}(OriginalData));
/**
 * 公共事件文件数据
 * // 数据格式
 * {
 *	"type":0,
 *	"commands":[[666,"999"]]
 * }
 * Created by 黑暗之神KDS on 2018-10-16 18:10:24.
 */
var CommonEventData = /** @class */ (function (_super) {
    __extends(CommonEventData, _super);
    function CommonEventData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * 允许访问
         */
        _this.allowClient = false;
        /**
         * 开关条件
         */
        _this.conditionSwitch = 1;
        /**
         * 是否并行模式 0-否 1-是
         */
        _this.updateMode = false;
        /**
         * 命令
         */
        _this.commands = [];
        return _this;
    }
    return CommonEventData;
}(OriginalData));
/**
* 自定义数据的变量属性设定:单个属性
* 关于值：
* -- 数字 ：number
* -- 字符串 ：string
* -- 布尔值 ：boolean
* -- 数据结构 ：{}    // 根据设定的数据结构
* -- 自定义模块-仅引用：number
* -- 自定义模块：{}
*
* Created by 黑暗之神KDS on 2018-10-16 18:59:36.
*/
var CustomAttributeSetting = /** @class */ (function () {
    function CustomAttributeSetting() {
    }
    CustomAttributeSetting.getChangeUIAttrsData = function (d) {
        if (!Array.isArray(d) || d[0] != CustomAttributeSetting.DATA_TYPE_UI_CHANGE_ATTRIBUTES)
            return [CustomAttributeSetting.DATA_TYPE_UI_CHANGE_ATTRIBUTES, [30, null, { uiID: 1, atts: [] }, 0, 1, 0]];
        return d;
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取shader uniform 类型映射
     */
    CustomAttributeSetting.getShaderUniformType = function (attr) {
        // 数值
        if (attr.varType == 0 || attr.compData.compType == 41)
            return "float";
        // 颜色拾取器
        if (attr.compData.compType == 12)
            return "vec3";
        // 贴图
        if (attr.compData.compType == 13 || attr.compData.compType == 22 || attr.compData.compType == 14)
            return "sampler2D";
        return null;
    };
    /**
     * 获取shader ts 类型映射
     */
    CustomAttributeSetting.getShaderTSType = function (attr) {
        // 数值
        if (attr.varType == 0)
            return "number";
        // 颜色拾取器
        if (attr.compData.compType == 12)
            return "string";
        // 贴图
        if (attr.compData.compType == 13 || attr.compData.compType == 22 || attr.compData.compType == 14)
            return "string";
        return null;
    };
    /**
     * 获取预计算用的 shader ts 类型映射
     */
    CustomAttributeSetting.getPreShaderTSType = function (attr) {
        // 数值
        if (attr.varType == 0)
            return "number";
        // 颜色拾取器
        if (attr.compData.compType == 12)
            return "number[]";
        return null;
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取组件显示的名称
     */
    CustomAttributeSetting.compName = function (attr) {
        return attr.alias ? attr.alias : attr.varName;
    };
    /**
     * 获取组件的名称最小宽度
     */
    CustomAttributeSetting.compNameTitleWidth = function (attr) {
        var compName = CustomAttributeSetting.compName(attr);
        if (attr.compData.compType == 15) {
            return 0;
        }
        var titleWidth = StringUtils.getRealLength(compName) * 7;
        return titleWidth;
    };
    /**
     * 获取是否是隐藏组件
     */
    CustomAttributeSetting.isHideComp = function (attr) {
        if (attr.hideMode)
            return true;
        // 编辑模式下如果不是对应的专用object组件的话就不允许
        if (Config.EDIT_MODE) {
            if (attr.varType == 5) {
                return EditorDataUICompAttribute.itemVarTypeMapping[attr.compData.compType] != 5;
            }
        }
        return false;
    };
    /**
     * 初始化
     * @param data
     */
    CustomAttributeSetting.init = function (data) {
        data.id = ObjectUtils.getRandID();
        data.varName = "未命名变量";
        data.varType = 0;
        data.compData = { compType: 0, compParam: {} };
        data.defaultValue = "";
        data.hideMode = false;
        data.useCommand = false;
        data.onlyPointTo = false;
        data.moduleID = 1;
        data.dataStructureID = 1;
        data.arrayMode = false;
        data.arrayLength = 100;
        data.arrayAllowDelete = false;
        data.arrayAllowSwap = false;
        data.arrayAllowUpdate = false;
        data.accessMode = 1;
        data.syncMode = 0;
        data.attrTips = "";
        data.alias = "";
        data.onlyConfig = false;
        data.preview = false;
        data.autoTitleWidth = true;
        data.titleWidth = 100;
        data.eyeShow = true;
        data.lockBlock = false;
    };
    /**
     * 获取数据对应的变量代码
     * @param varAttrs 变量属性集合
     * @param jurisdictionRestriction 是否权限限制
     * @param indent 缩进 [可选] 默认值="    "
     */
    CustomAttributeSetting.getAPIRuntimes = function (varAttrs, jurisdictionRestriction, indent) {
        if (jurisdictionRestriction === void 0) { jurisdictionRestriction = false; }
        if (indent === void 0) { indent = "    "; }
        var code = "";
        for (var i in varAttrs) {
            var attr = varAttrs[i];
            if (jurisdictionRestriction && attr.accessMode == 0)
                continue;
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(attr.compData.compType) != -1)
                continue;
            code += indent + this.getAPIRuntime(attr) + "\n";
        }
        return code;
    };
    /**
     * 获取该属性的API运行时
     * xxx:number
     * @param needCreateComboboxItemAPI 是否要创建combobox的Item名称作为API显示
     */
    CustomAttributeSetting.getAPIRuntime = function (attr, isStatic, needCreateComboboxItemAPI) {
        if (isStatic === void 0) { isStatic = false; }
        if (needCreateComboboxItemAPI === void 0) { needCreateComboboxItemAPI = false; }
        var str = "";
        var varTypeStr = "";
        if (needCreateComboboxItemAPI) {
            if (attr.varType < 3 && attr.compData.compType == 2) {
                var compParam = attr.compData.compParam;
                var items = compParam.items;
                if (items) {
                    str += attr.varName + "Items:string[]; // " + items + "\n    ";
                }
            }
        }
        switch (attr.varType) {
            case 0:
                varTypeStr = "number";
                break;
            case 1:
                varTypeStr = "string";
                break;
            case 2:
                varTypeStr = "boolean";
                break;
            case 3:
                varTypeStr = CustomCompositeSetting.getVarTypeInEditorCode(0, attr.dataStructureID);
                break;
            case 4:
                if (attr.onlyPointTo) {
                    varTypeStr = "number";
                }
                else {
                    varTypeStr = CustomCompositeSetting.getVarTypeInEditorCode(1, attr.moduleID);
                }
                break;
            case 5:
                // 特殊：格子数据图
                if (attr.compData.compType == 49) {
                    varTypeStr = "{ size: number, gridData: number[][] }";
                }
                // 特殊：选择界面组件（属性）
                else if (attr.compData.compType == 46) {
                    varTypeStr = "{ uiID: number, compName:string, compID:string, varName:string }";
                }
                // 特殊：材质编辑器
                else if (attr.compData.compType == 43) {
                    varTypeStr = "{ materials: MaterialData[] }[]";
                }
                else {
                    varTypeStr = "any";
                }
                break;
        }
        if (attr.arrayMode) {
            varTypeStr += "[]; // = [];";
        }
        else {
            if (attr.varType == 0) {
                varTypeStr += "; // = " + MathUtils.float(attr.defaultValue) + ";";
            }
            else if (attr.varType == 1) {
                varTypeStr += "; // = \"" + attr.defaultValue + "\";";
            }
            else if (attr.varType == 2) {
                varTypeStr += "; // = " + (attr.defaultValue.toLocaleLowerCase() == "true" || MathUtils.int(attr.defaultValue) ? "true" : "false") + ";";
            }
            else {
                if (attr.varType == 4) {
                    varTypeStr += "; // = " + MathUtils.float(attr.defaultValue) + ";";
                }
                else {
                    varTypeStr += ";";
                }
            }
            if (attr.alias) {
                if (varTypeStr.indexOf("//") == -1)
                    varTypeStr += " //";
                varTypeStr += " " + attr.alias;
            }
        }
        return str + ("" + (isStatic ? "static " : "") + (attr.onlyConfig ? "readonly " : "") + attr.varName + ": " + varTypeStr);
    };
    /**
     * 获取类型名称
     * @param data
     */
    CustomAttributeSetting.getTypeName = function (data) {
        var arr = ["数值", "字符串", "布尔值", "{自定义数据结构}", "{自定义模块}", "对象"];
        var str = arr[data.varType];
        if (data.varType == 3) {
            var datastructure = Common.dataStructureList.data[data.dataStructureID];
            if (datastructure) {
                var name = GameListData.getName(Common.dataStructureList, data.dataStructureID);
                str = "<" + data.dataStructureID + "-" + name + ">";
            }
            else {
                str = "<--/-->";
            }
        }
        else if (data.varType == 4) {
            var customModule = Common.customModuleList.data[data.moduleID];
            if (customModule) {
                var name = GameListData.getName(Common.customModuleList, data.moduleID);
                if (data.onlyPointTo) {
                    str = arr[0] + ("\u3010" + data.moduleID + "-" + name + "\u3011");
                }
                else {
                    str = "\u3010" + data.moduleID + "-" + name + "\u3011";
                }
            }
            else {
                if (data.onlyPointTo) {
                    str = arr[0] + "\u3010--/--\u3011";
                }
                else {
                    str = "\u3010--/--\u3011";
                }
            }
        }
        if (data.arrayMode) {
            str += "[]";
        }
        return str;
    };
    /**
     * 获取序列化的类型 CustomAttributeSetting::ATTR_TYPE_XXXX
     */
    CustomAttributeSetting.getSerializeAttrType = function (data, arrayEnabled) {
        if (arrayEnabled === void 0) { arrayEnabled = true; }
        var serializeAttrType = data.varType;
        if (serializeAttrType == 5) {
            return data.arrayMode ? CustomAttributeSetting.ATTR_TYPE_OBJECT_ARRAY : CustomAttributeSetting.ATTR_TYPE_OBJECT;
        }
        if (serializeAttrType == 4) {
            if (data.onlyPointTo) {
                serializeAttrType = 0;
            }
            else {
                serializeAttrType += 1;
            }
        }
        if (data.arrayMode && arrayEnabled)
            serializeAttrType += 6;
        return serializeAttrType;
    };
    /**
     * 规格化自定义数据：根据原有数据myCustomAttributes与预设数据attrPerSettings格式化，规格不匹配预设的会被重置为默认值
     * 实际应用场景：
     *  -- 保存数据：世界、玩家、场景、场景对象（含出生点）、数据库自定义模块
     *  -- 编辑制作数据：同上
     *  -- 运行时从存档中读取数据后再用此函数规格化数据
     * 规则：
     * 1.旧的设置数据（myCustomAttributes）属性不存在，新的结构（attrPerSettings）属性时直接新增默认值
     * 2.旧的设置数据（myCustomAttributes）属性存在，新的结构（attrPerSettings）属性不存在时则删除属性
     * 3.数据更新，类型不一致时：直接设置为新的结构的默认值
     * 4.数据更新，类型一致时，根据
     *
     * @param myCustomAttributes 属性实际存放的数据集
     * @param attrPerSettings 属性预设集
     */
    CustomAttributeSetting.formatCustomData = function (myCustomAttributes, attrPerSettings) {
        if (!(Array.isArray(attrPerSettings))) {
            attrPerSettings = CustomCompositeSetting.getAllAttributes(attrPerSettings, false);
        }
        // 去除仅供显示的属性
        var newestDataStructureList = Common.dataStructureList;
        var newestCustomModuleList = Common.customModuleList;
        if (!myCustomAttributes)
            myCustomAttributes = {};
        // 遍历预设属性，不存在实际属性的话则追加默认值
        for (var i in attrPerSettings) {
            var attrPerSetting = attrPerSettings[i];
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(attrPerSetting.compData.compType) != -1)
                continue;
            var perVarName = attrPerSetting.varName;
            if (myCustomAttributes[perVarName] == null) {
                myCustomAttributes[perVarName] = CustomAttributeSetting.formatCustomDefaultValue(attrPerSetting, true);
            }
        }
        // 遍历实际存放的数据：删除多余的或根据最新设定修正
        for (var myVarName in myCustomAttributes) {
            // 获取对应的预设属性
            var m = ArrayUtils.matchAttributes(attrPerSettings, { varName: myVarName }, true);
            var perAttr = m[0];
            // 若预设中不存在则清理掉此属性
            if (!perAttr) {
                delete myCustomAttributes[myVarName];
                continue;
            }
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(perAttr.compData.compType) != -1)
                continue;
            // 获取我的属性
            var myAttr = myCustomAttributes[myVarName];
            if (!myAttr) {
                continue;
            }
            // 获取我的序列化实际数据格式 CustomAttributeSetting::ATTR_TYPE_XXXX
            var mySerializeAttrType = myAttr.varType;
            // 获取预设的序列化数据格式 CustomAttributeSetting::ATTR_TYPE_XXXX
            var perSerializeAttrType = CustomAttributeSetting.getSerializeAttrType(perAttr);
            // 类别不一致的情况：重置为默认值
            if (perSerializeAttrType != mySerializeAttrType) {
                myCustomAttributes[myVarName] = CustomAttributeSetting.formatCustomDefaultValue(perAttr, true);
            }
            // 类别一致的情况： 
            else {
                // 自定义数据结构(组)：myAttr.value = { [varName: string]: { varType: number, value: any } } / ({ [varName: string]: { varType: number, value: any } })[]
                if (mySerializeAttrType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE || mySerializeAttrType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE_ID_ARRAY) {
                    var dataStructure = newestDataStructureList.data[perAttr.dataStructureID];
                    // 没有找到[指定数据结构]：清理属性
                    if (!dataStructure) {
                        delete myCustomAttributes[myVarName];
                        continue;
                    }
                    // 获取[指定数据结构]的全部预设的属性
                    var _attrPerSettings = CustomCompositeSetting.getAllAttributes(dataStructure, false);
                    var myAttrValue;
                    // 数组的情况 value:object[]
                    if (mySerializeAttrType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE_ID_ARRAY) {
                        var valueArr = myAttr.value;
                        for (var i in valueArr) {
                            myAttrValue = valueArr[i];
                            CustomAttributeSetting.formatCustomData(myAttrValue, _attrPerSettings);
                        }
                    }
                    // 单一属性 value:object
                    else {
                        myAttrValue = myAttr.value;
                        CustomAttributeSetting.formatCustomData(myAttrValue, _attrPerSettings);
                    }
                }
                // 自定义模块克隆: value:{id:number,data:object}
                else if (mySerializeAttrType == CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE || mySerializeAttrType == CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE_ARRAY) {
                    var customModule = newestCustomModuleList.data[perAttr.moduleID];
                    // 没有找到[自定义模块]：清理属性
                    if (!customModule) {
                        delete myCustomAttributes[myVarName];
                        continue;
                    }
                    // 获取[自定义模块]的全部预设的属性
                    var _attrPerSettings = CustomCompositeSetting.getAllAttributes(customModule, false);
                    var myAttrValue;
                    // 数组的情况 value:object[]
                    if (mySerializeAttrType == CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE_ARRAY) {
                        var valueDataArr = myAttr.value;
                        for (var i in valueDataArr) {
                            myAttrValue = valueDataArr[i].data;
                            CustomAttributeSetting.formatCustomData(myAttrValue, _attrPerSettings);
                        }
                    }
                    // 单一属性 value:object
                    else {
                        myAttrValue = myAttr.value.data;
                        CustomAttributeSetting.formatCustomData(myAttrValue, _attrPerSettings);
                    }
                }
            }
        }
        return myCustomAttributes;
    };
    /**
     * 返回根据自定义属性类型的默认值
     * @param varAttrSetting 属性预设
     * @param arrayEnabled [可选] 默认值=true 启用数组
     * @param newestDataStructureList 数据结构预设
     * @param newestCustomModuleList 自定义模块预设列表
     * @return [any]
     */
    CustomAttributeSetting.formatCustomDefaultValue = function (varAttrSetting, arrayEnabled) {
        var newestDataStructureList = Common.dataStructureList;
        var newestCustomModuleList = Common.customModuleList;
        // 获取实际储存的数据格式
        var perSerializeAttrType = CustomAttributeSetting.getSerializeAttrType(varAttrSetting, arrayEnabled);
        // -- 对象的情况
        if (perSerializeAttrType == CustomAttributeSetting.ATTR_TYPE_OBJECT) {
            return { varType: perSerializeAttrType, value: {}, copy: false };
        }
        // -- 数组的情况
        if (perSerializeAttrType >= CustomAttributeSetting.ATTR_TYPE_NUMBER_ARRAY) {
            return { varType: perSerializeAttrType, value: [], copy: false };
        }
        else {
            // -- 数字的情况
            if (perSerializeAttrType == CustomAttributeSetting.ATTR_TYPE_NUMBER || perSerializeAttrType == CustomAttributeSetting.ATTR_TYPE_MODULE_ID) {
                return { varType: perSerializeAttrType, value: MathUtils.float(varAttrSetting.defaultValue), copy: false };
            }
            // -- 字符串的情况
            else if (perSerializeAttrType == CustomAttributeSetting.ATTR_TYPE_STRING) {
                return { varType: perSerializeAttrType, value: varAttrSetting.defaultValue, copy: false };
            }
            // -- 布尔值的情况
            else if (perSerializeAttrType == CustomAttributeSetting.ATTR_TYPE_BOOLEAN) {
                return { varType: perSerializeAttrType, value: (varAttrSetting.defaultValue.toLocaleLowerCase() == "true" || MathUtils.int(varAttrSetting.defaultValue)) ? true : false, copy: false };
            }
            // -- 数据结构：Object值 递归的方式获取 比如单方法不能高于9634层深度
            else if (perSerializeAttrType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE) {
                var dataStructureID = varAttrSetting.dataStructureID;
                // 数据结构ID不合法的的情形
                if (dataStructureID > 0) {
                    var dataSreucture = newestDataStructureList ? newestDataStructureList.data[dataStructureID] : null;
                    if (dataSreucture) {
                        var attrObjs = {};
                        var dsAttrs = CustomCompositeSetting.getAllAttributes(dataSreucture);
                        for (var i in dsAttrs) {
                            var dsAttr = dsAttrs[i];
                            var typeValue = CustomAttributeSetting.formatCustomDefaultValue(dsAttr.attr, true); // arrayEnabled
                            if (typeValue) {
                                attrObjs[dsAttr.attr.varName] = typeValue;
                            }
                        }
                        return { varType: perSerializeAttrType, value: attrObjs, copy: false };
                    }
                }
                return null;
            }
            // -- 自定义
            // -- 带有ID且可修改内部属性的情况
            else {
                if (varAttrSetting.onlyPointTo) {
                    return { varType: perSerializeAttrType, value: varAttrSetting.defaultValue, copy: false };
                }
                else {
                    var moduleID = varAttrSetting.moduleID;
                    // 数据结构ID不合法的的情形
                    if (moduleID > 0) {
                        var moduleSetting = newestCustomModuleList.data[moduleID];
                        if (moduleSetting) {
                            var mAttrObjs = { varType: perSerializeAttrType, value: { id: varAttrSetting.moduleID, data: {} }, copy: false };
                            var dsAttrs = CustomCompositeSetting.getAllAttributes(moduleSetting);
                            for (var i in dsAttrs) {
                                // 存在具体项时使用具体项数据，否则使用默认数据
                                var dsAttr = dsAttrs[i];
                                var moduleDataID = MathUtils.int(varAttrSetting.defaultValue); //mAttrObjs.value.id;
                                if (moduleDataID == 0)
                                    moduleDataID = 1;
                                mAttrObjs.value.id = moduleDataID;
                                var moduleDataList = Common.getCustomModuleDataList(moduleID);
                                var moduleData = moduleDataList ? moduleDataList.data[moduleDataID] : null;
                                if (moduleData) {
                                    CustomAttributeSetting.formatCustomModuleFromDataBasePereset(moduleData, mAttrObjs.value);
                                }
                                else {
                                    var typeValue = CustomAttributeSetting.formatCustomDefaultValue(dsAttr.attr, true); // arrayEnabled
                                    if (typeValue) {
                                        mAttrObjs.value.data[dsAttr.attr.varName] = typeValue;
                                    }
                                }
                            }
                            return mAttrObjs;
                        }
                    }
                    return null;
                }
            }
        }
    };
    /**
     * 格式化自定义模块，根据数据库中预设
     * @param moduleData 预设数据对象
     * @param value 我的数据
     */
    CustomAttributeSetting.formatCustomModuleFromDataBasePereset = function (moduleData, myValue) {
        if (!moduleData) {
            myValue.data = null;
            return;
        }
        myValue.data = ObjectUtils.depthClone(moduleData.attrs);
    };
    /**
     * 序列化，将 varType 类别的数据改为数组存放值模式（按照预设的顺序）
     * @param typeValue varType属性
     * @param attrPerSettings 预配置属性
     */
    CustomAttributeSetting.serializeCustomData = function (typeValue, attrPerSettings) {
        // 按照预设先格式化
        if (!typeValue)
            typeValue = {};
        this.formatCustomData(typeValue, attrPerSettings);
        // 按照顺序排序
        if (!(attrPerSettings instanceof Array)) {
            attrPerSettings = CustomCompositeSetting.getAllAttributes(attrPerSettings, false);
        }
        var attrSettings = attrPerSettings;
        var target = {};
        this.installAttributeFromEditorSet(target, typeValue, attrSettings);
        var arr = [];
        for (var i in attrSettings) {
            var cusAttr = attrSettings[i];
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(cusAttr.compData.compType) != -1)
                continue;
            var varName = cusAttr.varName;
            arr.push(target[varName]);
        }
        return arr;
    };
    /**
    * 序列化，将 varType 类别的数据改为对象形式的存放值模式（按照id对应值）
    * @param typeValue varType属性
    * @param attrPerSettings 预配置属性
    */
    CustomAttributeSetting.serializeCustomData2 = function (typeValue, attrPerSettings) {
        // 按照预设先格式化                        
        if (!typeValue)
            typeValue = {};
        this.formatCustomData(typeValue, attrPerSettings);
        // 按照顺序排序
        if (!(attrPerSettings instanceof Array)) {
            attrPerSettings = CustomCompositeSetting.getAllAttributes(attrPerSettings, false);
        }
        var attrSettings = attrPerSettings;
        var target = {};
        this.installAttributeFromEditorSet(target, typeValue, attrSettings);
        var obj = {};
        for (var i in attrSettings) {
            var cusAttr = attrSettings[i];
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(cusAttr.compData.compType) != -1)
                continue;
            obj[cusAttr.id] = target[cusAttr.varName];
        }
        return [obj];
    };
    //------------------------------------------------------------------------------------------------------
    // 关于实际属性
    // -- 实际属性不带有varType格式
    // [世界属性][玩家属性][场景属性][场景对象属性]
    //------------------------------------------------------------------------------------------------------
    /**
     * 安装编辑器中设置的属性
     * @param target 要安装属性的目标
     * @param editorSetAttrs 编辑器实际设置的属性
     * @param attrSettings 数据模型参考集
     * @param readOnly 只读限制，比如引用模式下的自定义模块就是只读的，因为其指向的是模型数据
     * @param jurisdictionRestriction 限制权限（如客户端忽略掉禁止访问项）
     * @param customAttrMode 属性模型 GameData.CUSTOM_ATTR_XXX -1-无 0-世界属性 1-玩家属性 2-场景属性 3-场景对象属性
     */
    CustomAttributeSetting.installAttributeFromEditorSet = function (target, editorSetAttrs, attrSettings, readOnly, jurisdictionRestriction, customAttrMode) {
        if (readOnly === void 0) { readOnly = false; }
        if (jurisdictionRestriction === void 0) { jurisdictionRestriction = false; }
        if (customAttrMode === void 0) { customAttrMode = -1; }
        for (var s in attrSettings) {
            var attrSetting = attrSettings[s];
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(attrSetting.compData.compType) != -1)
                continue;
            var varName = attrSetting.varName;
            var editorSetAttr = editorSetAttrs[varName];
            // 限制权限模式下在禁止访问服务器时忽略掉此属性的创建
            if (jurisdictionRestriction && attrSetting.accessMode == 0) {
                continue;
            }
            this.typeValue2RealValue(target, attrSetting, editorSetAttr, readOnly, jurisdictionRestriction, customAttrMode);
        }
    };
    /**
     * typeValue => 实际值
     * @param target 数据
     * @param attrSetting 数据设置值
     * @param editorSetAttr 格式数据
     * @param readOnly [可选] 默认值=false 只读限制，比如引用模式下的自定义模块就是只读的，因为其指向的是模型数据
     * @param jurisdictionRestriction [可选] 默认值=false  限制权限（如客户端忽略掉禁止访问项）
     * @param customAttrMode [可选] 默认值=-1 GameData.CUSTOM_ATTR_XXX -1-无 0-世界属性 1-玩家属性 2-场景属性 3-场景对象属性
     */
    CustomAttributeSetting.typeValue2RealValue = function (target, attrSetting, editorSetAttr, readOnly, jurisdictionRestriction, customAttrMode) {
        if (readOnly === void 0) { readOnly = false; }
        if (jurisdictionRestriction === void 0) { jurisdictionRestriction = false; }
        if (customAttrMode === void 0) { customAttrMode = -1; }
        // 一般不应该存在没有编辑器预设的数据，在保存时就全部格式化了。
        if (!editorSetAttr) {
            // 当没有编辑器预设数据时使用默认值
            editorSetAttr = CustomAttributeSetting.formatCustomDefaultValue(attrSetting, true);
            if (!editorSetAttr) {
                return;
            }
            // target[varName] = value;
            // trace("warning " + varName + " installAttributeFromEditorSet 编辑器保存时未能格式化到此自定义数据，在此重置为默认值。");
        }
        var customModuleList = Common.customModuleList;
        var varName = attrSetting.varName;
        var value = attrSetting.arrayMode && Array.isArray(editorSetAttr.value) ? editorSetAttr.value.concat() : editorSetAttr.value;
        // 数字
        if (attrSetting.varType == 0 || (attrSetting.varType == 4 && attrSetting.onlyPointTo)) {
            setTargetAttr(target, varName, value, attrSetting);
        }
        // 字符串
        else if (attrSetting.varType == 1) {
            setTargetAttr(target, varName, value, attrSetting);
        }
        // 布尔值
        else if (attrSetting.varType == 2) {
            setTargetAttr(target, varName, value, attrSetting);
        }
        // 对象
        else if (attrSetting.varType == 5) {
            setTargetAttr(target, varName, value, attrSetting);
        }
        // 数据结构
        else if (attrSetting.varType == 3) {
            var ds = Common.dataStructureList.data[attrSetting.dataStructureID];
            if (ds) {
                var dsAttrSettings = CustomCompositeSetting.getAllAttributes(ds, false);
                if (attrSetting.arrayMode) {
                    var dsArrObj = [];
                    setTargetAttr(target, varName, dsArrObj, attrSetting, true);
                    for (var i = 0; i < value.length; i++) {
                        var dsObj = {};
                        dsArrObj[i] = dsObj;
                        this.installAttributeFromEditorSet(dsObj, value[i], dsAttrSettings, readOnly, jurisdictionRestriction, customAttrMode);
                    }
                }
                else {
                    var dsObj = {};
                    setTargetAttr(target, varName, dsObj, attrSetting, true);
                    this.installAttributeFromEditorSet(dsObj, editorSetAttr.value, dsAttrSettings, readOnly, jurisdictionRestriction, customAttrMode);
                }
            }
        }
        // 自定义模块
        else if (attrSetting.varType == 4) {
            var customModuleSetting = customModuleList.data[attrSetting.moduleID];
            var customModule = Common.getCustomModuleDataList(attrSetting.moduleID);
            if (customModuleSetting && customModule) {
                var mdAttrSettings = CustomCompositeSetting.getAllAttributes(customModuleSetting, false);
                if (attrSetting.arrayMode) {
                    var mdArrObj = [];
                    setTargetAttr(target, varName, mdArrObj, attrSetting, true);
                    for (var i = 0; i < value.length; i++) {
                        var preSetValue = value[i];
                        var moduleData = customModule.data[preSetValue.id];
                        if (moduleData) {
                            var mdObj;
                            // 非复制的话直接使用预设数据的副本
                            if (!preSetValue.copy) {
                                var mdObj = {};
                                mdArrObj[i] = mdObj;
                                mdObj.id = preSetValue.id;
                                mdObj.name = GameListData.getName(customModule, mdObj.id);
                                var customModuleTypeData = Common.getCustomModuleDataList(attrSetting.moduleID);
                                if (customModuleTypeData) {
                                    var customModuleData = customModuleTypeData.data[preSetValue.id];
                                    if (customModuleData) {
                                        this.installAttributeFromEditorSet(mdObj, customModuleData.attrs, mdAttrSettings, readOnly, jurisdictionRestriction, customAttrMode);
                                    }
                                }
                            }
                            // 否则使用编辑器独立设置的数据
                            else {
                                var mdObj = {};
                                mdArrObj[i] = mdObj;
                                mdObj.id = preSetValue.id;
                                mdObj.name = GameListData.getName(customModule, mdObj.id);
                                this.installAttributeFromEditorSet(mdObj, preSetValue.data, mdAttrSettings, readOnly, jurisdictionRestriction, customAttrMode);
                            }
                        }
                    }
                }
                else {
                    var moduleData = customModule.data[editorSetAttr.value.id];
                    if (moduleData) {
                        if (!editorSetAttr.copy) {
                            var mdObj = {};
                            setTargetAttr(target, varName, mdObj, attrSetting, true);
                            mdObj.id = editorSetAttr.value.id;
                            mdObj.name = GameListData.getName(customModule, mdObj.id);
                            var customModuleTypeData = Common.getCustomModuleDataList(attrSetting.moduleID);
                            if (customModuleTypeData) {
                                var customModuleData = customModuleTypeData.data[editorSetAttr.value.id];
                                if (customModuleData) {
                                    this.installAttributeFromEditorSet(mdObj, customModuleData.attrs, mdAttrSettings, readOnly, jurisdictionRestriction, customAttrMode);
                                }
                            }
                        }
                        else {
                            var mdObj = {};
                            setTargetAttr(target, varName, mdObj, attrSetting, true);
                            mdObj.id = editorSetAttr.value.id;
                            mdObj.name = GameListData.getName(customModule, mdObj.id);
                            this.installAttributeFromEditorSet(mdObj, editorSetAttr.value.data, mdAttrSettings, readOnly, jurisdictionRestriction, customAttrMode);
                        }
                    }
                }
            }
        }
        function setTargetAttr(target, varName, value, attrSetting, dataStructorMode) {
            if (dataStructorMode === void 0) { dataStructorMode = false; }
            target[varName] = value;
        }
    };
    /**
     * 安装来自存档中的属性
     * 一般都先设置了数据，如调用了installAttributeFromEditorSet，已经有了默认值，然后再调用该函数，
     * -- 实际属性不带有varType格式，是直接值
     * -- 实际属性不带有varType格式，是直接值
     * -- 由于存档保留了旧的格式属性，需要格式化（这里碰上新属性则替换为新的属性默认值，丢弃了旧的数据）而自定义模块非复制数据则直接使用预设模型值
     * @param target 目标
     * @param recordDataAttrs 存档数据
     * @param attrSettings 预设参考
     * @param cfgs 格式化配置数据
     * @param customAttrMode 属性模型 GameData.CUSTOM_ATTR_XXX -1-无 0-世界属性 1-玩家属性 2-场景属性 3-场景对象属性 4-自定义命令
     */
    CustomAttributeSetting.installAttributeFromRecordData = function (target, recordDataAttrs, attrSettings, cfgs, customAttrMode) {
        if (customAttrMode === void 0) { customAttrMode = -1; }
        if (recordDataAttrs == null)
            return;
        var varTypeMapping = ["number", "string", "boolean", null, "number"];
        // 遍历属性以便安装
        for (var i in attrSettings) {
            var attrSetting = attrSettings[i];
            // 仅供显示的属性无需还原
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(attrSetting.compData.compType) != -1)
                continue;
            var varName = attrSetting.varName; //  
            var recordValue = recordDataAttrs[varName];
            var recordValueType = typeof recordValue;
            var cfg = cfgs ? cfgs[varName] : null;
            // 如果是配置属性则直接使用配置值而非存档值
            if (attrSetting.onlyConfig) {
                continue;
            }
            // 无此属性的话直接设为默认值，说明预设属性中新增加了该属性
            if (recordValue == null) {
                this.typeValue2RealValue(target, attrSetting, cfg, false, false, customAttrMode);
                continue;
            }
            // 对象类型
            if (attrSetting.varType == 5) {
                // 直接使用
                target[varName] = recordValue;
            }
            // 基元属性
            else if (attrSetting.varType <= 2 || (attrSetting.varType == 4 && attrSetting.onlyPointTo)) {
                var varTypeOf = varTypeMapping[attrSetting.varType];
                // 数组模式：检查数组内数据是否符合格式，不符合的话也视为使用默认值
                if (attrSetting.arrayMode) {
                    if (recordValue instanceof Array) {
                        // 强制清空数组，以便恢复存档时存档元素比设定元素少的时候也不会出现突然加入预设定的数据的错误
                        var targetArr = target[varName] = [];
                        for (var s in recordValue) {
                            var recordArrValue = recordValue[s];
                            if (recordArrValue == null)
                                continue;
                            if (typeof recordArrValue == varTypeOf) {
                                targetArr[s] = recordValue[s];
                            }
                        }
                    }
                }
                // 真基元属性：记录值复合基元属性则直接设置，否则按照预设默认值装载
                else {
                    if (recordValueType == varTypeOf) {
                        target[varName] = recordValue;
                    }
                }
            }
            // 自定义数据结构
            else if (attrSetting.varType == 3) {
                var ds = Common.dataStructureList.data[attrSetting.dataStructureID];
                if (ds) {
                    var dsAttrSettings = CustomCompositeSetting.getAllAttributes(ds, false);
                    // 数组模式下的自定义数据结构：遍历每个值再进行格式化
                    if (attrSetting.arrayMode) {
                        if (recordValue instanceof Array) {
                            // 强制清空数组，以便恢复存档时存档元素比设定元素少的时候也不会出现突然加入预设定的数据的错误
                            var targetArr = target[varName] = [];
                            for (var s in recordValue) {
                                var recordArrValue = recordValue[s];
                                if (recordArrValue == null) {
                                    targetArr[s] = null;
                                }
                                else if (!(recordArrValue instanceof Array || !(recordArrValue instanceof Object))) {
                                    var newObj = targetArr[s] = {};
                                    var cfgValues = cfg ? cfg.value[s] : null;
                                    this.installAttributeFromRecordData(newObj, recordArrValue, dsAttrSettings, cfgValues);
                                }
                            }
                        }
                    }
                    else {
                        // 该值不是数组或非对象时则
                        if (!(recordValue instanceof Array || !(recordValue instanceof Object))) {
                            var cfgValues = cfg ? cfg.value[s] : null;
                            if (target[varName] == null)
                                target[varName] = {};
                            this.installAttributeFromRecordData(target[varName], recordValue, dsAttrSettings, cfgValues);
                        }
                    }
                }
            }
            // 自定义模块
            else if (attrSetting.varType == 4) {
                // 种类
                var customModuleSetting = Common.customModuleList.data[attrSetting.moduleID];
                // 数据
                var customModule = Common.getCustomModuleDataList(attrSetting.moduleID);
                if (customModuleSetting && customModule) {
                    var mdAttrSettings = CustomCompositeSetting.getAllAttributes(customModuleSetting, false);
                    if (attrSetting.arrayMode) {
                        if (recordValue instanceof Array) {
                            // 强制清空数组，以便恢复存档时存档元素比设定元素少的时候也不会出现突然加入预设定的数据的错误
                            var targetArr = target[varName] = [];
                            for (var s in recordValue) {
                                var recordArrValue = recordValue[s];
                                if (recordArrValue == null) {
                                    targetArr[s] = null;
                                }
                                else {
                                    var cfgValue = cfg ? cfg.value : null;
                                    var cfgValueS = cfgValue ? cfgValue[s] : null;
                                    // 引用关系，直接使用预设模型数据的值
                                    if ((cfgValueS && !cfgValueS.copy) || recordArrValue.gcsysref) {
                                        var mdObj = targetArr[s] = { id: recordArrValue.id };
                                        if (recordArrValue.gcsysref) {
                                            mdObj.gcsysref = recordArrValue.gcsysref;
                                        }
                                        mdObj.name = GameListData.getName(customModule, mdObj.id);
                                        var customModuleTypeData = Common.getCustomModuleDataList(attrSetting.moduleID);
                                        if (customModuleTypeData) {
                                            var customModuleData = customModuleTypeData.data[mdObj.id];
                                            if (customModuleData) {
                                                this.installAttributeFromEditorSet(mdObj, customModuleData.attrs, mdAttrSettings, false, !Config.IS_SERVER, customAttrMode);
                                            }
                                        }
                                    }
                                    // 复制关系，直接使用存档的值
                                    else {
                                        var moduleData = customModule.data[recordArrValue.id];
                                        if (moduleData) {
                                            var newCfgs = cfgValueS ? cfgValueS.data : null;
                                            var mdObj = targetArr[s] = { id: recordArrValue.id };
                                            mdObj.name = GameListData.getName(customModule, mdObj.id);
                                            this.installAttributeFromRecordData(mdObj, recordArrValue, mdAttrSettings, newCfgs);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else {
                        // 存在引用关系的情况则直接安装属性为系统预设
                        if ((cfg && !cfg.copy && !recordValue.gcsyscopy) || (recordValue.gcsysref)) {
                            var mdObj = {};
                            target[varName] = mdObj;
                            if (recordValue.gcsysref) {
                                mdObj.gcsysref = recordValue.gcsysref;
                            }
                            mdObj.id = recordValue.id;
                            mdObj.name = GameListData.getName(customModule, mdObj.id);
                            var customModuleTypeData = Common.getCustomModuleDataList(attrSetting.moduleID);
                            if (customModuleTypeData) {
                                var customModuleData = customModuleTypeData.data[recordValue.id];
                                if (customModuleData) {
                                    this.installAttributeFromEditorSet(mdObj, customModuleData.attrs, mdAttrSettings, false, !Config.IS_SERVER, customAttrMode);
                                }
                            }
                        }
                        // 否则是作为副本使用
                        else {
                            var moduleData = customModule.data[recordValue.id];
                            if (moduleData) {
                                var targetAttr = target[varName];
                                if (targetAttr == null) {
                                    var name = GameListData.getName(customModule, recordValue.id);
                                    targetAttr = target[varName] = { id: recordValue.id, name: name };
                                }
                                var newCfgs = cfg ? cfg.value.data : null;
                                this.installAttributeFromRecordData(target[varName], recordValue, mdAttrSettings, newCfgs);
                            }
                        }
                    }
                }
            }
        }
    };
    /**
     * 根据实际值来创建varType格式的数据
     * @param typeAttrs  varType格式的数据
     * @param value 实际值
     */
    CustomAttributeSetting.createVarTypeAttrsByValue = function (attrSetting, values, useVarName) {
        if (useVarName === void 0) { useVarName = false; }
        // 默认设定的数据
        var editAttrSetting = {};
        CustomAttributeSetting.formatCustomData(editAttrSetting, attrSetting);
        docreateVarTypeAttrsByValue(editAttrSetting, values, attrSetting, useVarName);
        function docreateVarTypeAttrsByValue(editAttrSetting, values, attrSetting, useVarName) {
            if (useVarName === void 0) { useVarName = false; }
            var orderAttrs = CustomCompositeSetting.getAllAttributes(attrSetting, false);
            var dIndex = 0;
            // 根据数据装载
            for (var i = 0; i < orderAttrs.length; i++) {
                var cusAttr = orderAttrs[i];
                if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(cusAttr.compData.compType) != -1) {
                    dIndex--;
                    continue;
                }
                var varName = cusAttr.varName;
                var value = (!values ? null : (useVarName ? values[varName] : values[i + dIndex]));
                if (value == null)
                    continue;
                var typeValue = editAttrSetting[varName];
                // 对象
                if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_OBJECT || typeValue.varType == CustomAttributeSetting.ATTR_TYPE_OBJECT_ARRAY) {
                    typeValue.value = value;
                    continue;
                }
                // 
                if (typeValue.varType >= CustomAttributeSetting.ATTR_TYPE_NUMBER_ARRAY && !Array.isArray(value))
                    continue;
                if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_NUMBER) {
                    typeValue.value = MathUtils.float(value);
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_STRING) {
                    typeValue.value = String(value);
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_BOOLEAN) {
                    typeValue.value = value ? true : false;
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE) {
                    var typeValueV = typeValue.value;
                    var ds = Common.dataStructureList.data[cusAttr.dataStructureID];
                    if (ds)
                        docreateVarTypeAttrsByValue(typeValueV, value, ds, true);
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_MODULE_ID) {
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE) {
                    var typeValueV = typeValue.value ? typeValue.value.data : null;
                    if (typeValue.value && value) {
                        typeValue.value.id = value.id;
                    }
                    var customModuleSetting = Common.customModuleList.data[cusAttr.moduleID];
                    var customModule = Common.getCustomModuleDataList(cusAttr.moduleID);
                    if (customModuleSetting && customModule) {
                        docreateVarTypeAttrsByValue(typeValueV, value, customModuleSetting, true);
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_NUMBER_ARRAY) {
                    // 引用的自定义模块的方式
                    var onlyPointTo = (cusAttr.varType == 4 && cusAttr.onlyPointTo && cusAttr.arrayMode) ? true : false;
                    if (onlyPointTo) {
                        if (Array.isArray(value)) {
                            if (!typeValue.value)
                                typeValue.value = [];
                            for (var s in value) {
                                typeValue.value[s] = MathUtils.float(value[s]);
                            }
                        }
                    }
                    // 普通数字
                    else {
                        if (!Array.isArray(typeValue.value))
                            typeValue.value = [];
                        for (var s in value) {
                            typeValue.value[s] = MathUtils.float(value[s]);
                        }
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_STRING_ARRAY) {
                    if (!Array.isArray(typeValue.value))
                        typeValue.value = [];
                    for (var s in value) {
                        typeValue.value[s] = String(value[s]);
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_BOOLEAN_ARRAY) {
                    if (!Array.isArray(typeValue.value))
                        typeValue.value = [];
                    for (var s in value) {
                        typeValue.value[s] = value[s] ? true : false;
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE_ID_ARRAY) {
                    var typeArr = typeValue.value;
                    var ds = Common.dataStructureList.data[cusAttr.dataStructureID];
                    if (ds) {
                        typeArr = typeValue.value = [];
                        for (var s in value) {
                            var typeValueV = {};
                            CustomAttributeSetting.formatCustomData(typeValueV, ds);
                            typeArr.push(typeValueV);
                            docreateVarTypeAttrsByValue(typeValueV, value[s], ds, true);
                        }
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_MODULE_ID_ARRAY) {
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE_ARRAY) {
                    var typeArr = typeValue.value;
                    var customModuleSetting = Common.customModuleList.data[cusAttr.moduleID];
                    var customModule = Common.getCustomModuleDataList(cusAttr.moduleID);
                    if (customModuleSetting && customModule) {
                        typeArr = typeValue.value = [];
                        for (var s in value) {
                            var typeValueVM = { id: value[s].id, data: {} }; //typeArr[s].value ? typeValue.value[s].value.data : null;
                            CustomAttributeSetting.formatCustomData(typeValueVM.data, customModuleSetting);
                            typeArr.push(typeValueVM);
                            docreateVarTypeAttrsByValue(typeValueVM.data, value[s], customModuleSetting, true);
                        }
                    }
                }
            }
        }
        return editAttrSetting;
    };
    /**
     * 根据实际值来创建varType格式的数据
     * @param typeAttrs  varType格式的数据
     * @param value 实际值
     */
    CustomAttributeSetting.createVarTypeAttrsByValue2 = function (attrSetting, values) {
        // 默认设定的数据
        var editAttrSetting = {};
        CustomAttributeSetting.formatCustomData(editAttrSetting, attrSetting);
        var idAttrs = values[0];
        docreateVarTypeAttrsByValue(editAttrSetting, idAttrs, attrSetting);
        function docreateVarTypeAttrsByValue(editAttrSetting, values, attrSetting, useVarName) {
            if (useVarName === void 0) { useVarName = false; }
            var orderAttrs = CustomCompositeSetting.getAllAttributes(attrSetting, false);
            // 根据数据装载
            var dIndex = 0;
            for (var i = 0; i < orderAttrs.length; i++) {
                var cusAttr = orderAttrs[i];
                // 仅供显示的组件忽略掉，同时取值index也减少
                if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(cusAttr.compData.compType) != -1) {
                    dIndex--;
                    continue;
                }
                var varName = cusAttr.varName;
                var value = (!values ? null : (useVarName ? values[varName] : values[cusAttr.id]));
                if (value == null)
                    continue;
                var typeValue = editAttrSetting[varName];
                // 对象
                if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_OBJECT || typeValue.varType == CustomAttributeSetting.ATTR_TYPE_OBJECT_ARRAY) {
                    typeValue.value = value;
                    continue;
                }
                if (typeValue.varType >= CustomAttributeSetting.ATTR_TYPE_NUMBER_ARRAY && !Array.isArray(value))
                    continue;
                if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_NUMBER) {
                    typeValue.value = MathUtils.float(value);
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_STRING) {
                    typeValue.value = String(value);
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_BOOLEAN) {
                    typeValue.value = value ? true : false;
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE) {
                    var typeValueV = typeValue.value;
                    var ds = Common.dataStructureList.data[cusAttr.dataStructureID];
                    if (ds)
                        docreateVarTypeAttrsByValue(typeValueV, value, ds, true);
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_MODULE_ID) {
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE) {
                    var typeValueV = typeValue.value ? typeValue.value.data : null;
                    if (typeValue.value && value) {
                        typeValue.value.id = value.id;
                    }
                    var customModuleSetting = Common.customModuleList.data[cusAttr.moduleID];
                    var customModule = Common.getCustomModuleDataList(cusAttr.moduleID);
                    if (customModuleSetting && customModule) {
                        docreateVarTypeAttrsByValue(typeValueV, value, customModuleSetting, true);
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_NUMBER_ARRAY) {
                    // 引用的自定义模块的方式
                    var onlyPointTo = (cusAttr.varType == 4 && cusAttr.onlyPointTo && cusAttr.arrayMode) ? true : false;
                    if (onlyPointTo) {
                        if (Array.isArray(value)) {
                            if (!typeValue.value)
                                typeValue.value = [];
                            for (var s in value) {
                                typeValue.value[s] = MathUtils.float(value[s]);
                            }
                        }
                    }
                    // 普通数字
                    else {
                        if (!Array.isArray(typeValue.value))
                            typeValue.value = [];
                        for (var s in value) {
                            typeValue.value[s] = MathUtils.float(value[s]);
                        }
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_STRING_ARRAY) {
                    if (!Array.isArray(typeValue.value))
                        typeValue.value = [];
                    for (var s in value) {
                        typeValue.value[s] = String(value[s]);
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_BOOLEAN_ARRAY) {
                    if (!Array.isArray(typeValue.value))
                        typeValue.value = [];
                    for (var s in value) {
                        typeValue.value[s] = value[s] ? true : false;
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE_ID_ARRAY) {
                    var typeArr = typeValue.value;
                    var ds = Common.dataStructureList.data[cusAttr.dataStructureID];
                    if (ds) {
                        typeArr = typeValue.value = [];
                        for (var s in value) {
                            var typeValueV = {};
                            CustomAttributeSetting.formatCustomData(typeValueV, ds);
                            typeArr.push(typeValueV);
                            docreateVarTypeAttrsByValue(typeValueV, value[s], ds, true);
                        }
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_MODULE_ID_ARRAY) {
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE_ARRAY) {
                    var typeArr = typeValue.value;
                    var customModuleSetting = Common.customModuleList.data[cusAttr.moduleID];
                    var customModule = Common.getCustomModuleDataList(cusAttr.moduleID);
                    if (customModuleSetting && customModule) {
                        typeArr = typeValue.value = [];
                        for (var s in value) {
                            var typeValueVM = { id: value[s].id, data: {} }; //typeArr[s].value ? typeValue.value[s].value.data : null;
                            CustomAttributeSetting.formatCustomData(typeValueVM.data, customModuleSetting);
                            typeArr.push(typeValueVM);
                            docreateVarTypeAttrsByValue(typeValueVM.data, value[s], customModuleSetting, true);
                        }
                    }
                }
            }
        }
        return editAttrSetting;
    };
    /** 类型：数字 number */
    CustomAttributeSetting.ATTR_TYPE_NUMBER = 0;
    /** 类型：字符串 string */
    CustomAttributeSetting.ATTR_TYPE_STRING = 1;
    /** 类型：布尔值 boolean */
    CustomAttributeSetting.ATTR_TYPE_BOOLEAN = 2;
    /** 类型：自定义数据结构 { [varName: string]: { varType: number, value: any   } } */
    CustomAttributeSetting.ATTR_TYPE_STRUCTURE = 3;
    /** 类型：自定义模块ID number */
    CustomAttributeSetting.ATTR_TYPE_MODULE_ID = 4;
    /** 类型：自定义模块克隆数据 {id:number,data:{ [varName: string]: { varType: number, value: any,copy:boolean } }} */
    CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE = 5;
    /** 类型：数字-数组 number[] */
    CustomAttributeSetting.ATTR_TYPE_NUMBER_ARRAY = 6;
    /** 类型：字符串-数组 string[] */
    CustomAttributeSetting.ATTR_TYPE_STRING_ARRAY = 7;
    /** 类型：布尔值-数组 boolean[] */
    CustomAttributeSetting.ATTR_TYPE_BOOLEAN_ARRAY = 8;
    /** 类型：自定义数据结构 { [varName: string]: { varType: number, value: any } }[] */
    CustomAttributeSetting.ATTR_TYPE_STRUCTURE_ID_ARRAY = 9;
    /** 类型：自定义模块ID-数组 number[] */
    CustomAttributeSetting.ATTR_TYPE_MODULE_ID_ARRAY = 10;
    /** 类型：自定义模块克隆数据-数组 { [varName: string]: { varType: number, value: [],copy:boolean } } */
    CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE_ARRAY = 11;
    /** 类型：对象 object */
    CustomAttributeSetting.ATTR_TYPE_OBJECT = 12;
    /** 类型：对象数组 object */
    CustomAttributeSetting.ATTR_TYPE_OBJECT_ARRAY = 13;
    //------------------------------------------------------------------------------------------------------
    // Object 实际数据存放校验
    //------------------------------------------------------------------------------------------------------
    /** 类型：修改元件属性 */
    CustomAttributeSetting.DATA_TYPE_UI_CHANGE_ATTRIBUTES = 10000001;
    /** 仅供显示的组件：如Label、Legend */
    CustomAttributeSetting.ONLY_DISPLAY = [32, 33];
    CustomAttributeSetting.shaderFloatUniform = [];
    return CustomAttributeSetting;
}());
/**
 * 自定义复合结构数据设定
 * Created by 黑暗之神KDS on 2019-05-02 15:23:16.
 */
var CustomCompositeSetting = /** @class */ (function (_super) {
    __extends(CustomCompositeSetting, _super);
    function CustomCompositeSetting() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** 指令自动竖版排列时限制的高度 */
        _this.compAutoOrderLimitHeight = 0;
        return _this;
    }
    /**
     * 是否空数据
     * @param data
     */
    CustomCompositeSetting.isEmpty = function (data, plugType) {
        var list = {
            9: Game.data.customModuleList, 10: Game.data.dataStructureList, 11: Game.data.customBehaviorTypeList,
            12: Game.data.customCommandTypeList, 13: Game.data.customConditionList, 16: Game.data.customDataDisplayList,
            20: Game.data.materialList, 21: Game.data.customGameStringList
        };
        var dataName = GameListData.getName(list[plugType], data.id);
        if (dataName)
            return false;
        return data.blockList.length == 1 && CustomCompositeBlock.isEmpty(data.blockList[0]);
    };
    /**
     * 初始化
     */
    CustomCompositeSetting.init = function (data) {
        var block = new CustomCompositeBlock();
        CustomCompositeBlock.init(block);
        data.blockList = [block];
    };
    /**
     * 运行代码
     * @param mode 0-数据结构 1-自定义模块 2-世界属性 3-玩家属性 4-场景属性
     */
    CustomCompositeSetting.runCode = function (gameData) {
        // 定义数据结构
        CustomCompositeSetting.runCodeByList(gameData.dataStructureList, 0, gameData);
        // 定义自定义模块
        CustomCompositeSetting.runCodeByList(gameData.customModuleList, 1, gameData);
        // 定义世界属性
        CustomCompositeSetting.runWorldData();
        // 定义玩家属性
        CustomCompositeSetting.runCodeByItem(gameData.customGameAttribute.playerAttributeSetting, 3, gameData);
        // 自定义模块创建预设数据集一组
        CustomCompositeSetting.createPresetCustomModuleDatas();
    };
    /**
     * 根据列表运行代码
     * @param list
     * @param mode
     */
    CustomCompositeSetting.runCodeByList = function (list, mode, gameData) {
        // 追加类定义
        var dsItems = GameListData.getItems(list);
        for (var i in dsItems) {
            var dsItem = dsItems[i];
            CustomCompositeSetting.runCodeByItem(dsItem, mode, gameData);
        }
    };
    /**
     * 创建全自定义模块预设数据实例（引用只读级别）
     */
    CustomCompositeSetting.createPresetCustomModuleDatas = function () {
        var customModuleList = Common.customModuleList;
        for (var i in customModuleList.data) {
            var moduleIndex = parseInt(i);
            var cmSetting = customModuleList.data[moduleIndex];
            if (cmSetting) {
                var singleModuleDataArr = GameData.customModulePresetDatas[moduleIndex] = [];
                var moduleDataList = Common.getCustomModuleDataList(moduleIndex);
                var cmDatas = moduleDataList.data;
                var attrSettings = CustomCompositeSetting.getAllAttributes(cmSetting, false);
                for (var s in cmDatas) {
                    var dataID = parseInt(s);
                    var cmData = cmDatas[dataID];
                    if (cmData) {
                        var cmObj = {};
                        cmObj.id = dataID;
                        cmObj.name = GameListData.getName(moduleDataList, dataID);
                        singleModuleDataArr[dataID] = cmObj;
                        CustomAttributeSetting.installAttributeFromEditorSet(cmObj, cmData.attrs, attrSettings, true, !Config.IS_SERVER);
                    }
                }
            }
        }
    };
    /**
     * 根据项运行代码
     * @param dsItem
     * @param mode
     */
    CustomCompositeSetting.runCodeByItem = function (dsItem, mode, gameData) {
        var attrs = CustomCompositeSetting.getAllAttributes(dsItem, false);
        var classVarName = this.getVarTypeInEditorCode(mode, dsItem.id);
        if (classVarName == "any")
            return;
        var vars = "";
        var dsCls = "var " + classVarName + " = function(){" + vars;
        for (var i in attrs) {
            var attr = attrs[i];
            // 客户端在无权的环境下创建的对象不会有默认值
            if (!Config.IS_SERVER && attr.accessMode == 0)
                continue;
            // 存在默认值的情况，基元类型赋值
            if (attr.arrayMode) {
                dsCls += "this." + attr.varName + " = [];";
            }
            else {
                if (attr.defaultValue) {
                    // 数值
                    if (attr.varType == 0) {
                        dsCls += "this." + attr.varName + " = " + MathUtils.float(attr.defaultValue) + ";";
                    }
                    // 字符串：带双引号则直接赋值，否则追加双引号
                    else if (attr.varType == 1) {
                        if (attr.defaultValue.length >= 2 && attr.defaultValue[0] == "\"" && attr.defaultValue[attr.defaultValue.length - 1] == "\"") {
                            dsCls += "this." + attr.varName + " = " + attr.defaultValue + ";";
                        }
                        else {
                            dsCls += "this." + attr.varName + " = \"" + attr.defaultValue + "\";";
                        }
                    }
                    // 布尔值
                    else if (attr.varType == 2) {
                        dsCls += "this." + attr.varName + " = " + (attr.defaultValue ? "true" : "false") + ";";
                    }
                }
                // 自定义数据结构（存在该结构则创建）
                if (attr.varType == 3) {
                    if (gameData.dataStructureList.data[attr.dataStructureID]) {
                        var dataStructureCls = this.getVarTypeInEditorCode(0, attr.dataStructureID);
                        if (dataStructureCls != "any")
                            dsCls += "this." + attr.varName + " = new " + dataStructureCls + ";";
                    }
                }
                // 自定义模块
                else if (attr.varType == 4) {
                    if (gameData.customModuleList.data[attr.moduleID]) {
                        var customCls = this.getVarTypeInEditorCode(1, attr.moduleID);
                        if (customCls != "any") {
                            dsCls += "this." + attr.varName + " = new " + customCls + ";this." + attr.varName + ".name = \"\";";
                        }
                    }
                }
            }
        }
        dsCls += "}";
        globalThis.eval(dsCls);
    };
    /**
     * 设置世界数据
     */
    CustomCompositeSetting.runWorldData = function () {
        var customGameAttribute = Common.customGameAttribute;
        globalThis.WorldData = {};
        var attrSettings = CustomCompositeSetting.getAllAttributes(customGameAttribute.worldAttributeSetting, false);
        CustomAttributeSetting.installAttributeFromEditorSet(globalThis.WorldData, customGameAttribute.worldAttributeConfig.attrs, attrSettings, false, !Config.IS_SERVER, GameData.CUSTOM_ATTR_WORLD_DATA);
        if (!Config.EDIT_MODE) {
            if (Config.IS_SERVER) {
                ServerWorld.data = globalThis.WorldData;
                CustomAttributeSetting.installAttributeFromRecordData(ServerWorld.data, ServerSql.recordWorldData, attrSettings, customGameAttribute.worldAttributeConfig.attrs, GameData.CUSTOM_ATTR_WORLD_DATA);
                ServerSql.recordWorldData = null;
            }
            else {
                ClientWorld.data = globalThis.WorldData;
            }
        }
    };
    /**
     * 获取全属性
     * @param data
     * @param dsAttrMode [可选] 默认值=true true则返回[CustomCompositeAttributeSetting]，否则返回[CustomAttributeSetting]
     * @param 获取变量所在的block映射数据
     */
    CustomCompositeSetting.getAllAttributes = function (data, dsAttrMode, varInBlockMapping) {
        if (dsAttrMode === void 0) { dsAttrMode = true; }
        if (varInBlockMapping === void 0) { varInBlockMapping = null; }
        if (data == null) {
            return [];
        }
        var len = data.blockList.length;
        var arr = [];
        for (var i = 0; i < len; i++) {
            var block = data.blockList[i];
            var aLen = block.blockAttrs.length;
            for (var s = 0; s < aLen; s++) {
                var ca = block.blockAttrs[s];
                if (varInBlockMapping)
                    varInBlockMapping[ca.attr.varName] = block;
                if (dsAttrMode) {
                    arr.push(ca);
                }
                else {
                    arr.push(ca.attr);
                }
            }
        }
        return arr;
    };
    /**
     * 获取id-value格式数据
     */
    CustomCompositeSetting.getIDValue = function (varNameValue, setting) {
        // 计算 idValue & varNameValue
        var idValue = {};
        var attrSettings = CustomCompositeSetting.getAllAttributes(setting, false);
        for (var s = 0; s < attrSettings.length; s++) {
            var mAttr = attrSettings[s];
            if (!mAttr)
                continue;
            var value = varNameValue[mAttr.varName];
            idValue[mAttr.id] = value;
        }
        return idValue;
    };
    /**
     * 获取全API运行时
     * @param mode 0-数据结构 1-自定义模块 2-世界属性 3-玩家属性 4-场景属性
     * @param limitJurisdiction 是否限制权限，根据是否可获取来决定是否可以拿该数据(如客户端无法显示禁止访问的属性)
     * @param needCreateComboboxItemAPI 是否要创建combobox的Item名称作为API显示
     */
    CustomCompositeSetting.getAllAPIRunetime = function (mode, limitJurisdiction, needCreateComboboxItemAPI) {
        if (limitJurisdiction === void 0) { limitJurisdiction = false; }
        if (needCreateComboboxItemAPI === void 0) { needCreateComboboxItemAPI = false; }
        if (mode == 0 || mode == 1 || mode == 4) {
            var lists = [Common.dataStructureList, Common.customModuleList, null, null, null];
            var nameHeads = ["DataStructure", "Module", null, null, "SceneModel"];
            var list = lists[mode];
            var datas = GameListData.getItems(list);
            var runtimeStr = "";
            var len = datas.length;
            for (var i = 0; i < len; i++) {
                var data = datas[i];
                // 数据结构和模块如果变量名不存在的话则不生成对应的类
                if (mode == 0 || mode == 1) {
                    if (!data.varName)
                        continue;
                }
                runtimeStr += this.getAPIRuntime(mode, data, limitJurisdiction, false, needCreateComboboxItemAPI);
                if (i != len - 1)
                    runtimeStr += "\n";
            }
            return runtimeStr;
        }
        else if (mode == 2) {
            return this.getAPIRuntime(mode, Common.customGameAttribute.worldAttributeSetting, limitJurisdiction, true);
        }
        else if (mode == 3) {
            return this.getAPIRuntime(mode, Common.customGameAttribute.playerAttributeSetting, limitJurisdiction);
        }
        return "";
    };
    /**
     * 获取API运行时
     * class XXX {
     *   xxx:number;
     *   yyy:string;
     * }
     * @param mode 0-数据结构 1-自定义模块 2-世界属性 3-玩家属性 4-场景属性
     * @param cSetting 对应ID
     */
    CustomCompositeSetting.getAPIRuntime = function (mode, cSetting, limitJurisdiction, isStatic, needCreateComboboxItemAPI) {
        if (limitJurisdiction === void 0) { limitJurisdiction = false; }
        if (isStatic === void 0) { isStatic = false; }
        if (needCreateComboboxItemAPI === void 0) { needCreateComboboxItemAPI = false; }
        var attrs = CustomCompositeSetting.getAllAttributes(cSetting, false);
        var len = attrs.length;
        var className = this.getVarTypeInEditorCode(mode, cSetting.id);
        if (className == "any")
            return "";
        var dataName;
        if (mode == 0) {
            dataName = GameListData.getName(Common.dataStructureList, cSetting.id);
        }
        else if (mode == 1) {
            dataName = GameListData.getName(Common.customModuleList, cSetting.id);
        }
        else {
            dataName = "";
        }
        var runtimeStr = (cSetting.id ? "/**\n * #" + cSetting.id + " " + dataName + "\n */\n" : "") + "class " + className + " {\n";
        if (mode == 1) {
            runtimeStr += "    id: number;\n    name: string;\n";
        }
        else if (mode == 3) {
            runtimeStr += "    sceneObject: SceneObject;\n";
        }
        for (var i = 0; i < len; i++) {
            var attr = attrs[i];
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(attr.compData.compType) != -1)
                continue;
            if (!limitJurisdiction || attr.accessMode != 0) {
                var varStr = CustomAttributeSetting.getAPIRuntime(attr, isStatic, needCreateComboboxItemAPI);
                runtimeStr += "    " + varStr;
                runtimeStr += "\n";
            }
        }
        runtimeStr += "}";
        return runtimeStr;
    };
    /**
     * 获取自定义命令和行为参数的API
     * @return [string]
     */
    CustomCompositeSetting.getCustomCommandBehaviorParamsAPI = function () {
        var api1 = this.getCustomParamsAPIBy(Common.customCommandTypeList, "自定义命令", "CustomCommandParams");
        // var api2 = this.getCustomParamsAPIBy(Common.customBehaviorTypeList, "自定义对象行为", "CustomBehaviorParams");
        return api1;
    };
    /**
     * 获取自定义条件参数的API
     */
    CustomCompositeSetting.getCustomConditionParamsAPI = function () {
        var api1 = this.getCustomParamsAPIBy(Game.data.customConditionList, "自定义条件", "CustomConditionParams");
        return api1;
    };
    /**
     * 获取自定义游戏数据显示参数的API
     */
    CustomCompositeSetting.getCustomDataDisplayParamsAPI = function () {
        var api1 = this.getCustomParamsAPIBy(Game.data.customDataDisplayList, "自定义游戏数值", "CustomGameNumberParams");
        return api1;
    };
    /**
     * 获取自定义游戏字符串的API
     */
    CustomCompositeSetting.getCustomGameStringParamsAPI = function () {
        var api1 = this.getCustomParamsAPIBy(Game.data.customGameStringList, "自定义游戏字符串", "CustomGameStringParams");
        return api1;
    };
    /**
     * 获取自定义命令参数的API
     * @param codePrompt 类提示名
     * @param className 如CustomCommandParams 类名
     * @return [string]
     */
    CustomCompositeSetting.getCustomParamsAPIBy = function (customList, codePrompt, className) {
        if (GameListData.getAllLength(customList) == 0)
            return "";
        var apis = "/**\n * \u8BE5\u6587\u4EF6\u4E3AGameCreator\u7F16\u8F91\u5668\u81EA\u52A8\u751F\u6210\u7684\u4EE3\u7801\n */\n";
        for (var i = 1; i <= 16; i++) {
            var dataLen = GameListData.getLength(customList, i);
            for (var s = 1; s <= dataLen; s++) {
                var id = GameListData.getID(i, s);
                var name = GameListData.getName(customList, id);
                var customCommandTypeData = customList.data[id];
                if (customCommandTypeData) {
                    apis += "/**\n* " + codePrompt + " " + id + "-" + name + "\n*/\n";
                    apis += "class " + className + "_" + id + " {\n";
                    var attrs = CustomCompositeSetting.getAllAttributes(customCommandTypeData, false);
                    for (var p = 0; p < attrs.length; p++) {
                        var cusAttr = attrs[p];
                        if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(cusAttr.compData.compType) != -1)
                            continue;
                        apis += "    " + CustomAttributeSetting.getAPIRuntime(cusAttr) + "\n";
                    }
                    apis += "}\n";
                }
            }
        }
        return apis;
    };
    /**
     * 获取单个实例带类型
     * var a :{xxx:number,yyy:sss};
     * @param instanceName
     * @param ccAttr
     */
    CustomCompositeSetting.getCustomParamsAPIOneInstance = function (instanceName, ccAttr, classMode) {
        if (classMode === void 0) { classMode = false; }
        if (classMode) {
            var varHeadStr = "class " + instanceName;
            var apis = varHeadStr + " {\n";
        }
        else {
            var varHeadStr = "var " + instanceName;
            var apis = varHeadStr + ": {\n";
        }
        var attrs = CustomCompositeSetting.getAllAttributes(ccAttr, false);
        for (var p = 0; p < attrs.length; p++) {
            var cusAttr = attrs[p];
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(cusAttr.compData.compType) != -1)
                continue;
            apis += "    " + CustomAttributeSetting.getAPIRuntime(cusAttr, false, true) + "\n";
        }
        apis += "}";
        return apis;
    };
    //------------------------------------------------------------------------------------------------------
    // Shader
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取着色器运行时
     * shader.xxxx
     */
    CustomCompositeSetting.getPerShaderVar = function (ccAttr) {
        var attrs = CustomCompositeSetting.getAllAttributes(ccAttr, false);
        var str = "var sp:GameSprite; // \u4F7F\u7528\u8BE5\u6750\u8D28\u7684\u663E\u793A\u5BF9\u8C61\nvar shader: {\n";
        for (var p = 0; p < attrs.length; p++) {
            var cusAttr = attrs[p];
            // 忽略仅用于显示的值
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(cusAttr.compData.compType) != -1)
                continue;
            // 隐藏属性或不允许显示的忽略掉
            if (CustomAttributeSetting.isHideComp(cusAttr) || cusAttr.useCommand)
                continue;
            // 非基元类型无法设置
            if (cusAttr.varType >= 3)
                continue;
            // 获取映射的类型
            var tsType = CustomAttributeSetting.getPreShaderTSType(cusAttr);
            if (!tsType)
                continue;
            // 附加uv坐标提供shader内使用
            var varName = " mu" + ccAttr.id + "_" + cusAttr.varName + ": " + tsType;
            if (p != attrs.length - 1) {
                varName += ",";
            }
            var varDesc = "";
            if (cusAttr.alias)
                varDesc += " " + cusAttr.alias;
            if (cusAttr.attrTips)
                varDesc += " " + cusAttr.attrTips;
            if (varDesc) {
                varName += " //" + varDesc;
            }
            str += varName + "\n";
        }
        str += "}";
        return str;
    };
    /**
     * 获取着色器uniform参数
     * -- 提供给Shader编译
     * -- 提供给Shader代码注释
     */
    CustomCompositeSetting.getShaderUniformCodes = function (ccAttr, isNote) {
        if (isNote === void 0) { isNote = false; }
        var attrs = CustomCompositeSetting.getAllAttributes(ccAttr, false);
        var customUniformsNotes = "";
        for (var p = 0; p < attrs.length; p++) {
            var cusAttr = attrs[p];
            // 忽略仅用于显示的值
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(cusAttr.compData.compType) != -1)
                continue;
            // 隐藏属性或不允许显示的忽略掉
            if (CustomAttributeSetting.isHideComp(cusAttr) || cusAttr.useCommand)
                continue;
            // 非基元类型无法设置
            if (cusAttr.varType >= 3)
                continue;
            // 获取映射的类型
            var uniformType = CustomAttributeSetting.getShaderUniformType(cusAttr);
            if (!uniformType)
                continue;
            // 附加uv坐标提供shader内使用
            var varName = " mu" + ccAttr.id + "_" + cusAttr.varName;
            varName += ";";
            var varDesc = "";
            if (isNote) {
                varDesc += " MU" + ccAttr.id + "_" + cusAttr.varName;
                if (cusAttr.alias)
                    varDesc += " " + cusAttr.alias;
                if (cusAttr.attrTips)
                    varDesc += " " + cusAttr.attrTips;
                varDesc = " //" + varDesc;
            }
            customUniformsNotes += "\n" + (isNote ? "// " : "") + "uniform " + uniformType + varName + varDesc;
            // 追加贴图坐标UV
            if (uniformType == "sampler2D") {
                customUniformsNotes += "\n" + (isNote ? "// " : "") + "uniform vec4 mu" + ccAttr.id + "_" + cusAttr.varName + "_UVInfo;";
                if (isNote) {
                    customUniformsNotes += " // mu" + ccAttr.id + "_" + cusAttr.varName + "\u8D34\u56FE\u7684\u539F\u59CB\u5750\u6807\u4FE1\u606F\uFF0C\u83B7\u53D6\u6E32\u67D3\u5750\u6807\uFF1Avec2 a = getDrawUV(v_texcoord,mu" + ccAttr.id + "_" + cusAttr.varName + "_UVInfo);";
                }
            }
        }
        // 追加显示对象尺寸
        if (ccAttr.shaderSize) {
            customUniformsNotes += "\n// uniform vec2 renderTargetSize; // \u6E32\u67D3\u5BF9\u8C61\u5C3A\u5BF8\u4FE1\u606F x=\u5BBD\u5EA6 y=\u9AD8\u5EA6";
        }
        return customUniformsNotes;
    };
    /**
     * 获取shader代码头部注释
     */
    CustomCompositeSetting.getShaderNotes = function (ccAttr) {
        var customUniformsNotes = this.getShaderUniformCodes(ccAttr, true);
        var notes = "//======================================================================================================\n// SYSTEM START \u8BE5\u6BB5\u6CE8\u91CA\u7531\u7CFB\u7EDF\u81EA\u52A8\u751F\u6210\uFF0C\u8BF7\u52FF\u5220\u6539\n//======================================================================================================\n//------------------------------------------------------------------------------------------------------\n// \u56FA\u5B9A\u53C2\u6570\n//------------------------------------------------------------------------------------------------------\n// varying vec2 v_texcoord; //  \u539F\u59CB\u8D34\u56FEUV\u5750\u6807\n// uniform sampler2D texture; // \u539F\u59CB\u8D34\u56FE\n// uniform float alpha; // \u5F53\u524D\u5BF9\u8C61\u5B9E\u9645\u6E32\u67D3\u7684\u900F\u660E\u5EA6\n//------------------------------------------------------------------------------------------------------\n// \u8BE5\u6750\u8D28\u7684\u81EA\u5B9A\u4E49\u53C2\u6570 \u5224\u5B9A\u8BE5\u53D8\u91CF\u5B58\u5728\u7684\u5B8F\uFF1AMU\u6750\u8D28\u7F16\u53F7_\u53D8\u91CF\u540D\u79F0\n//------------------------------------------------------------------------------------------------------" + customUniformsNotes + "\n//------------------------------------------------------------------------------------------------------\n// shader \u4EE3\u7801\u89C4\u5219\uFF1A\n// 1.\u7531\u4E8E\u591A\u6750\u8D28\u5408\u5E76shader\u4EE3\u7801\u8FD0\u884C\uFF0C\u51FD\u6570\u540D\u5FC5\u987B\u4EE5mf${\u6750\u8D28ID}_\u5F00\u5934\u4EE5\u907F\u514D\u51FD\u6570\u540D\u79F0\u51B2\u7A81\uFF0C\u5982 mf" + ccAttr.id + "_myFunc\n// 2.\u5165\u53E3\u51FD\u6570vec4 mf${\u6750\u8D28ID}_main \u5982 vec4 mf" + ccAttr.id + "_main(){return gl_FragColor;}\n// 3.\u539F\u56FE\u91C7\u6837\u5750\u6807\u83B7\u53D6\uFF1Avec2 texCoord = getInRangeTextureCoord(v_texcoord);\n// 4.\u539F\u56FE\u91C7\u6837\uFF1Avec4 color = getTextureColor(texCoord);\n// 5.\u5173\u4E8E\u81EA\u5B9A\u4E49\u8D34\u56FE\u7684\u5750\u6807\u4FE1\u606F\uFF1A\u81EA\u5B9A\u4E49\u8D34\u56FE\u53EF\u80FD\u662F\u56FE\u96C6\u4E2D\u7684\u4E00\u90E8\u5206\uFF0C\u63D0\u4F9B\u4E86\u76F8\u5173\u4FE1\u606F\uFF08mu\u6750\u8D28\u7F16\u53F7_\u53D8\u91CF\u540D_UVInfo\uFF09\n//   \u76F8\u5BF9\u4E8E0~1\u7684\u5750\u6807\u7CFB\u63D0\u4F9B\u4E86\u56FE\u96C6\u7684\u6620\u5C04\u4FE1\u606F vec4 [UV\u5BBD\u5EA6\u7F29\u653E\u6BD4\u4F8B, UV\u9AD8\u5EA6\u7F29\u653E\u6BD4\u4F8B, UV\u6C34\u5E73\u504F\u79FB\u91CF, UV\u5782\u76F4\u504F\u79FB\u91CF]\n// 6.\u53D8\u91CF\u5B8F\uFF08\u53EF\u7528\u4E8E\u5224\u5B9A\u8BE5\u53D8\u91CF\u662F\u5426\u6EE1\u8DB3\u51FA\u73B0\u6761\u4EF6\uFF09\uFF1A#ifdef MU\u6750\u8D28\u7F16\u53F7_\u53D8\u91CF\u540D\u79F0\u3001#else\u3001#endif\n// 7.\u7CFB\u7EDF\u5B8F IN_GC_EDITOR=\u662F\u5426\u5728\u7F16\u8F91\u5668\u4E2D\u8FD0\u884C\n// 8.\u8BED\u6CD5\uFF1AC\u8BED\u8A00 \u66F4\u591A\u8D44\u6599\u8BF7\u53C2\u8003GLSL Shader\n//======================================================================================================\n// SYSTEM END\n//======================================================================================================\n";
        return notes;
    };
    /**
     * 替换shader代码头部注释
     * @param ccAttr
     * @param shaderCode
     * @return [string]
     */
    CustomCompositeSetting.replaceShaderNotes = function (ccAttr, shaderCode, replaceNewCode) {
        if (replaceNewCode === void 0) { replaceNewCode = null; }
        var noteStart = shaderCode.indexOf("//======================================================================================================\n// SYSTEM START");
        var endStr = "SYSTEM END\n//======================================================================================================\n";
        var nodeEnd = shaderCode.indexOf(endStr);
        var needReplace = true;
        if (noteStart == -1 || nodeEnd == -1) {
            needReplace = false;
        }
        if (replaceNewCode == null) {
            replaceNewCode = this.getShaderNotes(ccAttr);
        }
        if (needReplace) {
            var oldStr = shaderCode.substr(noteStart, nodeEnd - noteStart + endStr.length);
            shaderCode = shaderCode.replace(oldStr, replaceNewCode);
        }
        else {
            shaderCode = replaceNewCode + "";
        }
        return shaderCode;
    };
    /**
     * 获取材质TS代码运行时
     */
    CustomCompositeSetting.getShaderDataRuntimes = function () {
        var materialList = Game.data.materialList;
        var len = GameListData.getLength(materialList, 1);
        if (len == 0)
            return "";
        var str = "/**\n * \u8BE5\u6587\u4EF6\u4E3AGameCreator\u7F16\u8F91\u5668\u81EA\u52A8\u751F\u6210\u7684\u4EE3\u7801\n */\n/**\n * \u6750\u8D28\u6570\u636E\u57FA\u7C7B\n */\nclass MaterialData {\n    id: number; // \u6750\u8D28\u7F16\u53F7\n    enable: boolean;//\u662F\u5426\u542F\u7528\n    ____timeInfo: {[varName:string]: number} = {}; // \u50A8\u5B58\u8FC7\u6E21\u7684\u5F53\u524D\u65F6\u95F4/\u5E27\u4FE1\u606F\uFF0C\u82E5\u540C\u4E00\u4E2A\u6750\u8D28\u6570\u636E\u9700\u8981\u91CD\u7F6E\u65F6\u95F4\u590D\u7528\uFF0C\u53EF\u4FEE\u6539\u8BE5\u5C5E\u6027\u540E\u518D\u91CD\u65B0\u6DFB\u52A0\u6750\u8D28\n}\n";
        for (var i = 1; i <= len; i++) {
            var materiaSetting = materialList.data[i];
            var attrs = CustomCompositeSetting.getAllAttributes(materiaSetting, false);
            var varStrs = ["    id: number = " + i + ";"];
            for (var s = 0; s < attrs.length; s++) {
                var attr = attrs[s];
                if (CustomAttributeSetting.isHideComp(attr) || (CustomAttributeSetting.ONLY_DISPLAY.indexOf(attr.compData.compType) != -1))
                    continue;
                var attrTSType = CustomAttributeSetting.getShaderTSType(attr);
                if (!attrTSType) {
                    if (attr.varType == 0)
                        attrTSType = "number";
                    else if (attr.varType == 1)
                        attrTSType = "string";
                    else if (attr.varType == 2)
                        attrTSType = "boolean";
                    else
                        continue;
                }
                var defaultValueStr;
                if (attr.varType == 0 && attr.defaultValue) {
                    defaultValueStr = " = " + MathUtils.float(attr.defaultValue);
                }
                else if (attr.varType == 1) {
                    defaultValueStr = " = \"" + attr.defaultValue + "\"";
                }
                else if (attr.varType == 2 && attr.defaultValue) {
                    defaultValueStr = " = " + (attr.defaultValue == "true" || attr.defaultValue != "false" ? "true" : "false");
                }
                else {
                    defaultValueStr = "";
                }
                varStrs.push("    " + (attr.onlyConfig ? "readonly " : "") + attr.varName + ": " + attrTSType + defaultValueStr + "; // " + attr.alias + " " + attr.attrTips);
            }
            str += "/**\n * \u6750\u8D28" + i + "-" + GameListData.getName(materialList, i) + "\n */\nclass MaterialData" + i + " extends MaterialData {\n" + varStrs.join("\n") + "\n}\n";
        }
        return str;
    };
    /**
     * 获取shader对应的组件相关信息
     */
    CustomCompositeSetting.getShaderCompVars = function (materialID) {
        var resArr = [];
        var materialList = Game.data.materialList;
        var materiaSetting = materialList.data[materialID];
        if (!materiaSetting)
            return resArr;
        var attrs = CustomCompositeSetting.getAllAttributes(materiaSetting, true);
        for (var s = 0; s < attrs.length; s++) {
            var attrComp = attrs[s];
            var attr = attrComp.attr;
            if (CustomAttributeSetting.isHideComp(attr) || (CustomAttributeSetting.ONLY_DISPLAY.indexOf(attr.compData.compType) != -1))
                continue;
            var attrTSType = CustomAttributeSetting.getShaderTSType(attr);
            if (!attrTSType && attr.varType > 2)
                continue;
            var defaultValue;
            if (attr.varType == 0 && attr.defaultValue) {
                defaultValue = MathUtils.float(attr.defaultValue);
            }
            else if (attr.varType == 1) {
                defaultValue = attr.defaultValue;
            }
            else if (attr.varType == 2 && attr.defaultValue) {
                defaultValue = attr.defaultValue == "true" || attr.defaultValue != "false" ? true : false;
            }
            resArr.push({ varName: attr.varName, value: defaultValue, varAttributeSetting: attr, varCompAttributeSetting: attrComp });
        }
        return resArr;
    };
    /**
     * 修正shader值 可能无值或类型不匹配
     * -- 字符串特殊格式修正：如时间等等
     */
    CustomCompositeSetting.fixShaderTsValue = function (materialID, materialData, materiaSetting) {
        if (materiaSetting === void 0) { materiaSetting = null; }
        if (!materialData)
            return;
        if (!materiaSetting) {
            var materialList = Game.data.materialList;
            materiaSetting = materialList.data[materialID];
        }
        if (!materiaSetting)
            return;
        var attrs = CustomCompositeSetting.getAllAttributes(materiaSetting, false);
        for (var s = 0; s < attrs.length; s++) {
            var attr = attrs[s];
            if (CustomAttributeSetting.isHideComp(attr) || (CustomAttributeSetting.ONLY_DISPLAY.indexOf(attr.compData.compType) != -1))
                continue;
            var attrTSType = CustomAttributeSetting.getShaderTSType(attr);
            if (!attrTSType && attr.varType > 2 && attr.compData.compType != 41)
                continue;
            var materialDataValue = materialData[attr.varName];
            if (attr.varType == 0 && typeof materialDataValue != "number") {
                materialData[attr.varName] = MathUtils.float(attr.defaultValue);
            }
            else if (attr.varType == 1) {
                if (typeof materialDataValue != "string") {
                    materialData[attr.varName] = attr.defaultValue;
                }
                else if (attr.compData.compType == 12) {
                    if (materialDataValue.length != 7 || materialDataValue.match(/#[0-9A-Fa-f]{6}/g) == null) {
                        materialData[attr.varName] = "#000000";
                    }
                }
                // 过渡，根据参数修正数值
                else if (attr.compData.compType == 41) {
                    var transData = GameUtils.getTransData(materialDataValue);
                    if (transData) {
                        var oldTimeType = transData.timeType;
                        var oldLoopType = transData.loopType;
                        transData.timeType = MathUtils.int(attr.compData.compParam.timeType);
                        if (!attr.compData.compParam.loopType) {
                            transData.loopType = 0;
                        }
                        if (oldTimeType != transData.timeType || oldLoopType != transData.loopType) {
                            materialData[attr.varName] = JSON.stringify(transData);
                        }
                    }
                }
            }
            else if (attr.varType == 2 && typeof materialData[attr.varName] != "boolean") {
                materialData[attr.varName] = attr.defaultValue == "true" || attr.defaultValue != "false" ? true : false;
            }
        }
    };
    CustomCompositeSetting.getPreShaderClacNotes = function (ccAttr) {
        return "//------------------------------------------------------------------------------------------------------\n// \u6B64\u5904\u53EF\u4EE5\u7F16\u5199\u9700\u8981\u7ECF\u8FC7\u5BA2\u6237\u7AEF\u4EE3\u7801\u9884\u5148\u8BA1\u7B97\u518D\u4F20\u9012\u7684\u989D\u5916Shader uniform\n// \u4EE3\u7801\u88AB\u7CFB\u7EDF\u8C03\u7528\u7684\u60C5\u51B5\uFF1A\u62E5\u6709[41-\u8FC7\u6E21\u7EC4\u4EF6]\u65F6\u4F1A\u6BCF\u5E27\u8C03\u7528\u8BE5\u6BB5\u4EE3\u7801\uFF0C\u5426\u5219\u53EA\u4F1A\u8C03\u7528\u4E00\u6B21\n// \u53EF\u89C6\u5316\u5236\u4F5C\u7684\u81EA\u5B9A\u4E49\u53D8\u91CF\u4F1A\u81EA\u52A8\u8FDB\u884C\u8F6C\u5316\u4E3AShader\u4E2D\u53EF\u7528\u7684uniform\uFF0C\u6B64\u5904\u662F\u7528\u4E8E\u4FEE\u6539\u6216\u65B0\u589E\u8BA1\u7B97\u540E\u7684\u53C2\u6570\u8FDB\u884C\u4F20\u9012\n// -- sp \u53EF\u83B7\u53D6\u4F7F\u7528\u8BE5\u6750\u8D28\u7684\u663E\u793A\u5BF9\u8C61\uFF08GameSprite\uFF09\n// -- shader \u53EF\u83B7\u5F97\u6216\u4FEE\u6539\u5373\u5C06\u4F20\u9012\u7ED9Shader\u4F7F\u7528\u7684\u5BF9\u5E94\u53D8\u91CF\u7684\u503C\uFF08\u7C7B\u578B\u8981\u4FDD\u6301\u4E0D\u53D8\uFF09\uFF0C\u6BD4\u5982 shader.mu3_xxx\n// -- \u65B0\u589E\u52A0\u5C5E\u6027\uFF1A\n//    1.\u76F4\u63A5\u5728\u6B64\u5904\u7F16\u5199\uFF1Ashader[\"mu\u6750\u8D28\u7F16\u53F7_\u81EA\u5B9A\u4E49\u53D8\u91CF\u540D\u79F0\"] \u5982 shader[\"mu3_abc\"] = 5;\n//    2.\u5728Shader\u4EE3\u7801\u4E2D\u9700\u8981\u81EA\u5DF1\u8F93\u5165\u589E\u52A0\u7684\uFF0C\u5982 uniform float mu3_abc;\n// -- \u5982\u679C\u9700\u8981\u7F13\u5B58\u8BA1\u7B97\u7ED3\u679C\u53EF\u4EE5\u81EA\u884C\u6839\u636E\u952E\u503C\u5BF9\u8FDB\u884C\u7F13\u5B58\uFF0C\u4EE5\u4FBF\u51CF\u5C11\u8BA1\u7B97\u91CF\u6765\u63D0\u5347\u6027\u80FD \u5982 this[\"xxxx\"] = \u8BA1\u7B97\u540E\u7684\u7ED3\u679C;\n// \u3010Typescript \u4E0E GLSL \u4E2D\u53D8\u91CF\u6620\u5C04\u3011\n// -- number             => uniform float\n// -- number[]           => uniform vec2/vec3/vec4  \u6839\u636Ets\u4E2D\u6570\u503C\u6570\u7EC4\u7684\u957F\u5EA6\u51B3\u5B9A\n// -- Float32Array(16)   => uniform mat4  \u6309\u987A\u5E8F\u5BF9\u5E944x4\u77E9\u9635\u6570\u636E\n//------------------------------------------------------------------------------------------------------\n";
    };
    //------------------------------------------------------------------------------------------------------
    // 编辑器的指令在事件页预览代码
    //------------------------------------------------------------------------------------------------------
    CustomCompositeSetting.getPreviewCommandCode = function () {
        return "//------------------------------------------------------------------------------------------------------\n// \u7F16\u8F91\u5668\u9884\u89C8\u7A97\u53E3\u8FD0\u884C\u65F6\u63D0\u4F9B\u7684\u7CFB\u7EDF\u53D8\u91CF\n// \u5173\u4E8E\u9884\u89C8\u7684\u6D41\u7A0B\uFF1A\n// -- 1.imageLayerPassageClear \u6BCF\u5DF2\u4F7F\u7528\u7684\u901A\u9053x\u6BCF\u5DF2\u4F7F\u7528\u7684\u6307\u4EE4\n// -- 2.runCommand \u6BCF\u4E2A\u6307\u4EE4\u6309\u987A\u5E8F\u6267\u884C\u4E00\u904D\n// -- 3.imageLayerPassageStart \u6BCF\u5DF2\u4F7F\u7528\u7684\u901A\u9053x\u6BCF\u5DF2\u4F7F\u7528\u7684\u6307\u4EE4\n// \u5173\u4E8E\u64AD\u653E\u7684\u6D41\u7A0B\n// -- 1.imageLayerPassageClear \u6BCF\u5DF2\u4F7F\u7528\u7684\u901A\u9053x\u6BCF\u5DF2\u4F7F\u7528\u7684\u6307\u4EE4\n// -- 2.runCommand \u6BCF\u4E2A\u6307\u4EE4\u6309\u987A\u5E8F\u64AD\u653E\n//------------------------------------------------------------------------------------------------------\n/**\n * \u5F53\u524D\u81EA\u5B9A\u4E49\u6307\u4EE4\u7684\u7F16\u53F7\n */\ndeclare var commandID: number;\n/**\n * \u56FE\u50CF\u5C42\u901A\u9053\u6570\u636E\n */\ndeclare var imageLayerPassageData: any[];\n/**\n * \u6E38\u620F\u5C42\u663E\u793A\u5BF9\u8C61\u5BB9\u5668\uFF08\u5305\u542B\u754C\u9762\u5C42\u4E0E\u56FE\u50CF\u5C42\uFF09\n */\ndeclare var gameLayer: GameSprite;\n/**\n * \u56FE\u50CF\u5C42\u663E\u793A\u5BF9\u8C61\u5BB9\u5668\n */\ndeclare var imageLayer: GameImageLayer;\n/**\n * \u754C\u9762\u5C42\u663E\u793A\u5BF9\u8C61\u5BB9\u5668\n */\ndeclare var uiLayer: GameSprite;\n/**\n * \u9884\u89C8\u7A97\u53E3\n */\ndeclare var previewWin: {\n    /**\n     * \u6E05\u7406\u5168\u90E8\u4E8B\u4EF6\u6307\u4EE4\u4EA7\u751F\u7684\u9884\u89C8\u6548\u679C\n     */\n    clearData: Function;\n    /**\n     * \u8BBE\u7F6E\u6570\u636E\uFF0C\u5237\u65B0\u9884\u89C8\u6548\u679C\u76F4\u5230\u5F53\u524D\u9009\u4E2D\u7684\u6307\u4EE4\u884C\n     */\n    setData: Function;\n    /**\n     * \u5F53\u524D\u9009\u4E2D\u7684\u6307\u4EE4\n     */\n    currentSelectCmd: Command;\n    /**\n     * \u89C6\u56FE\u533A\u57DF\u662F\u5426\u53F3\u952E\u79FB\u52A8\u8FC7\n     */\n    viewAreaRightMouseMove: boolean;\n    /**\n     * \u5141\u8BB8\u663E\u793A\u5168\u90E8\u5BF9\u8C61\n     */\n    allowAllDisplayObject: boolean;\n    /**\n     * \u5BF9\u8C61\u64CD\u4F5C\u5DE5\u5177\n     */\n    operateObjectTool: {\n        // \u5237\u65B0\u5BF9\u8C61\u64CD\u4F5C\u5DE5\u5177\uFF0C\u6BD4\u5982\u6765\u81EA\u5176\u4ED6\u5730\u65B9\u66F4\u6539\u4E86\u5BF9\u8C61\u7684\u4F4D\u7F6E\u6216\u5C3A\u5BF8\u7B49\uFF0C\u53EF\u4F7F\u7528\u8BE5\u51FD\u6570\u5237\u65B0\n        refresh: Function;\n        // \u9009\u4E2D\u5BF9\u8C61\n        selectObjects: (sp: GameSprite[]) => void;\n        // \u9700\u8981\u6392\u9664\u7F29\u653E\u548C\u65CB\u8F6C\u5DE5\u5177\u7684\u5BF9\u8C61\n        addExcludeOperactionObject: (sp: GameSprite) => void\n    }\n    /**\n     * \u56FE\u50CF\u5C42\u955C\u5934\u64CD\u4F5C\u5DE5\u5177\n     * onChange(changeType:number,cameraX:number,cameraY:number,cameraZ:number,cameraRotation:number)\n     */\n    openCameraTools: (onChange: Function) => void;\n    /**\n     * \u5237\u65B0\u56FE\u50CF\u5C42\u955C\u5934\u5DE5\u5177\uFF0C\u6839\u636E\u5F53\u524D\u955C\u5934\u503C\n     */\n    refreshCameraTools: Function;\n    /**\n     * \u9009\u4E2D\u4E8B\u4EF6\u6307\u4EE4\n     * @param cmd \u4E8B\u4EF6\u6307\u4EE4\n     * @param sendEvent \u6D3E\u53D1\u4E8B\u4EF6 \u9ED8\u8BA4=false \u6D3E\u53D1\u4E8B\u4EF6\u4F1A\u5237\u65B0\u5C5E\u6027\u680F\u3001\u9884\u89C8\u7A97\u53E3\u7B49\n     */\n    selectCmdMessageByCmd(cmd: Command, sendEvent?: boolean);\n    /**\n     * \u4FEE\u6539\u6307\u4EE4\u5C5E\u6027\n     * @param cmd \u9700\u8981\u4FEE\u6539\u7684\u6307\u4EE4\n     * @param varName \u53C2\u6570\u53D8\u91CF\u540D\u79F0\n     * @param newValue \u65B0\u7684\u503C\n     */\n    modifyCommandParam: (cmd: Command, varName: string, newValue: any) => void;\n    /**\n     * \u65B0\u589E\u6307\u4EE4 \u9ED8\u8BA4\u662F\u9ED8\u8BA4\u503C\uFF0C\u5982\u679C\u6709\u5199\u5165\u53C2\u6570\u7684\u8BDD\u5219\u4EE5\u53C2\u6570\u4E3A\u51C6 varNameValue\n     * @param customID \u81EA\u5B9A\u4E49ID\n     * @param varNameValue \u989D\u5916\u7684\u53D8\u91CF\u503C\uFF0C\u5982\u5B58\u5728\u5219\u4F18\u5148\u4F7F\u7528\u8BE5\u503C\uFF0C\u5426\u5219\u4F7F\u7528\u81EA\u5B9A\u4E49\u7F16\u8F91\u5668\u4E2D\u7684\u9ED8\u8BA4\u503C\uFF0C\u5982 {dpX:100,dpY:200}\n     * @param selectedIndex [\u53EF\u9009] \u9ED8\u8BA4\u503C=-2  -3=\u5F53\u524D\u9009\u4E2D\uFF08\u4E4B\u540E\uFF09 -2=\u5F53\u524D\u9009\u4E2D\uFF08\u4E4B\u524D\uFF09 -1=\u6700\u5C3E\u7AEF 0-N=\u81EA\u5B9A\u4E49 \n     * @param refreshPreViewArea [\u53EF\u9009] \u9ED8\u8BA4\u503C=true \u5237\u65B0\u9884\u89C8\u533A\n     */\n    insertCustomCMD(customID: number, varNameValue: any, selectedIndex?: number, refreshPreViewArea?: boolean): Command;\n    /**\n     * \u65B0\u589E\u52A0\u7CFB\u7EDF\u6307\u4EE4\n     * @param cmdID \u7CFB\u7EDF\u6307\u4EE4ID\n     * @param params \u53C2\u6570\n     * @param selectedIndex [\u53EF\u9009] \u9ED8\u8BA4\u503C=-2 \u9ED8\u8BA4\u503C=-2  -3=\u5F53\u524D\u9009\u4E2D\uFF08\u4E4B\u540E\uFF09 -2=\u5F53\u524D\u9009\u4E2D\uFF08\u4E4B\u524D\uFF09 -1=\u6700\u5C3E\u7AEF 0-N=\u81EA\u5B9A\u4E49 \n     * @param refreshPreViewArea [\u53EF\u9009] \u9ED8\u8BA4\u503C=false \u5237\u65B0\u9884\u89C8\u533A\n     */\n    insertSystemCMD(cmdID: number, params: any[], selectedIndex?: number, refreshPreViewArea?: boolean): Command;\n    /**\n     * \u66F4\u6539\u663E\u793A\u5C42\n     * @param selectedIndex 0-\u754C\u9762\u5C42 1-\u56FE\u50CF\u5C42\n     */\n    changeLayer(selectedIndex: number):void;\n    /**\n     * \u521B\u5EFA\u83DC\u5355\n     * var menuData:any[] = [\n               {\n                   label:\"\u91CD\u547D\u540D\",\n                   splitLine:false,// \u662F\u5426\u663E\u793A\u5206\u5272\u7EBF\n                   children:[], // \u5B58\u653E\u548C\u672C\u8EAB\u8FD9\u4E2A\u5BF9\u8C61\u662F\u4E00\u6837\u7684\u683C\u5F0F\n                   execute:\"functionName\", // \u70B9\u51FB\u540E\u6267\u884C\u7684\u65B9\u6CD5\u540D\u79F0\n                   shortcutKey:\"\", //\u663E\u793A\u7684\u5FEB\u6377\u952E\u540D\u79F0\n                   menuHotKey:\"\", //\u5B9E\u9645\u4F5C\u7528\u7684\u5FEB\u6377\u952E\u540D\u79F0 \u5BF9\u5E94Laya.KeyBoard\u7684\u503C \u5982A\n                   enabled:true, // \u662F\u5426\u53EF\u7528\uFF0C\u4E0D\u586B\u5199\u8868\u793Atrue\n                   visible:true, // \u662F\u5426\u663E\u793A\uFF0C\u4E0D\u586B\u5199\u8868\u793Atrue\n\t\t\t\t   selected:true, // \u5982\u679C\u5B58\u5728\u5219\u4EE5\u6253\u94A9\u7684\u5F62\u5F0F\u9009\u62E9\u6B64\u9879\n\t\t\t\t   group:\"myGroupName\" // \u914D\u5408selected\uFF0C\u5982\u82E5\u5B58\u5728\u5219\u540C\u7EC4\u5355\u9009\n               }\n           ];\n     * @param menuData \u83DC\u5355\u6570\u636E\n     * @param x \u5168\u5C40\u5750\u6807X\n     * @param y \u5168\u5C40\u5750\u6807Y\n     * @param executeDomain \u51FD\u6570\u4F5C\u7528\u57DF\n     */\n    createMenu(menuData: any[], x: number, y: number, executeDomain: any);\n}\n//------------------------------------------------------------------------------------------------------\n// \u901A\u9053\u6570\u636E\n//------------------------------------------------------------------------------------------------------\ndeclare class PassageData {\n    // ====> system \u5FC5\u8981\u9879\n    /**\n     * \u901A\u9053\u7F16\u53F7\n     */\n    passageID: number;\n    /**\n     * \u7C7B\u522B\uFF0C\u4E00\u822C\u7528\u4E8E\u533A\u5206\u663E\u793A\u5BF9\u8C61\uFF0C\u5982\u56FE\u7247\u3001\u52A8\u753B\u3001\u7ACB\u7ED8\u3001\u754C\u9762\u90FD\u662F\u5C5E\u4E8E\u4E0D\u540C\u7684\u7C7B\u522B\n     */\n    type: string;\n    /**\n     * \u8BB0\u5F55\u5173\u8054\u7684\u6307\u4EE4\n     */\n    cmd: Command;\n    /**\n     * \u5F53\u901A\u9053\u8986\u76D6\u65F6\u8C03\u7528\u7684\u51FD\u6570\uFF0C\u4EE5\u4FBF\u6E05\u7406\u6389\u3002\u5982\u663E\u793A\u4E862\u53F7\u56FE\u7247\u6216\u79FB\u52A8\u4E86\u53F7\u56FE\u7247\uFF0C\u518D\u6B21\u663E\u793A2\u53F7\u56FE\u7247\u65F6\u4F1A\u6E05\u7406\u6389\u6B64\u524D\u663E\u793A\u7684\u56FE\u7247\u6216\u79FB\u52A8\u884C\u4E3A\n     */\n    onCoverPassage: Function;\n    // ====> custom \u81EA\u5B9A\u4E49\u5C5E\u6027\n\n}\n//------------------------------------------------------------------------------------------------------\n// \u81EA\u5B9A\u4E49\u53D8\u91CF\n//------------------------------------------------------------------------------------------------------\nvar passageType = \"gcXXXXX\";\n//------------------------------------------------------------------------------------------------------\n// [everyone used command] \u9010\u6307\u4EE4\u884C\u76EE\u6267\u884C\n//------------------------------------------------------------------------------------------------------\n/**\n * \u9010\u6307\u4EE4\u6267\u884C\uFF1A\u5BF9\u5E94\u4E8B\u4EF6\u4E0B\u6309\u7167\u4ECE\u4E0A\u81F3\u4E0B\u7684\u987A\u5E8F\u9010\u884C\u6267\u884C\uFF0C\u5982\u679C\u662F\u8BE5\u81EA\u5B9A\u4E49\u6307\u4EE4\u65F6\u5219\u4F1A\u6267\u884C\u8BE5\u51FD\u6570\n * \u8BE5\u51FD\u6570\u7528\u4E8E\u7F16\u8F91\u5668\u9884\u89C8\u548C\u64AD\u653E\uFF0C\u5982\u679C\u5206\u6B67\u9762\u677F\u4E2D\u7B5B\u9009\u4E0D\u7ECF\u8FC7\u7684\u4E8B\u4EF6\u6307\u4EE4\u5219\u4E0D\u4F1A\u6267\u884C\u8BE5\u51FD\u6570\u3002\n * \u6BD4\u5982\u4E8B\u4EF6\u9875\u4E2D\u67093\u4E2A\u8BE5\u6307\u4EE4\uFF0C\u5219\u6309\u7167\u987A\u5E8F\u6267\u884C3\u6B21\u8BE5\u51FD\u6570\n * @param cmdParams \u6307\u4EE4\u7684\u81EA\u5B9A\u4E49\u53C2\u6570\u6570\u636E\uFF0C\u6839\u636E\u7528\u6237\u8BBE\u5B9A\u503C\n * @param cmd \u5BF9\u5E94\u7684\u6307\u4EE4\u5BF9\u8C61\n * @param isPlayMode \u662F\u5426\u662F\u64AD\u653E\u6A21\u5F0F\uFF0C\u5426\u5219\u662F\u666E\u901A\u7684\u9884\u89C8\u6A21\u5F0F\n */\nfunction runCommand(cmdParams: ThisCommandParams, cmd: Command, isPlayMode: boolean) {\n\n}\n/**\n * \u7F16\u8F91\u5668\u5185\u9884\u89C8\u64AD\u653E\u65F6\u9884\u52A0\u8F7D\n * @param onFin \u52A0\u8F7D\u5B8C\u6210\u540E\u56DE\u8C03\n * @param cmdParams \u6307\u4EE4\u7684\u81EA\u5B9A\u4E49\u53C2\u6570\u6570\u636E\uFF0C\u6839\u636E\u7528\u6237\u8BBE\u5B9A\u503C\n */\nfunction inEditorPlayPreload(onFin: Function, cmdParams: ThisCommandParams) {\n    // \u5F53\u52A0\u8F7D\u5B8C\u6210\u540E\u8C03\u7528\u56DE\u8C03\n    onFin.apply(this);\n}\n//------------------------------------------------------------------------------------------------------\n// \u5C5E\u6027\u9762\u677F\u4FEE\u6539\uFF1A\u5F53\u4FEE\u6539\u8BE5\u6307\u4EE4\u7684\u5C5E\u6027\u65F6\uFF0C\u53EA\u4F1A\u6267\u884C\u8BE5\u6307\u4EE4\u5BF9\u5E94\u7684\u300C\u6307\u4EE4\u6E90\u300D\u7684\u8FD9\u4E9B\u51FD\u6570\n// \u5982A\u6307\u4EE4\u6765\u81EA\u81EA\u5B9A\u4E49\u6307\u4EE432\u53F7\uFF0C\u6BCF\u6B21\u901A\u8FC7\u5C5E\u6027\u9762\u677F\u5FEB\u901F\u4FEE\u6539A\u6307\u4EE4\u7684\u53C2\u6570b\u65F6\uFF0C\u5219\u4F1A\u6267\u884C32\u53F7\u6307\u4EE4\u7684\u4E0B\u97622\u4E2A\u51FD\u6570\n// [current used command] \n//------------------------------------------------------------------------------------------------------\n/**\n * \u5F53\u5C5E\u6027\u9762\u677F\u4E2D\u7684\u5C5E\u6027\u4FEE\u6539\u524D\n * @param cmd \u5BF9\u5E94\u7684\u6307\u4EE4\n * @param cmdParams \u5BF9\u5E94\u6307\u4EE4\u7684\u53C2\u6570 \n * @param varName \u4FEE\u6539\u7684\u5C5E\u6027\u540D\n */\nfunction onCommandAttributeBeforeChange(cmd: Command, cmdParams: ThisCommandParams, varName: string) {\n\n}\n/**\n * \u5F53\u5C5E\u6027\u9762\u677F\u4E2D\u7684\u5C5E\u6027\u4FEE\u6539\u540E\n * @param cmd \u5BF9\u5E94\u7684\u6307\u4EE4\n * @param cmdParams \u5BF9\u5E94\u6307\u4EE4\u7684\u53C2\u6570 \n * @param varName \u4FEE\u6539\u7684\u5C5E\u6027\u540D\n * @param newValue \u4FEE\u6539\u540E\u7684\u503C\n */\nfunction onCommandAttributeChange(cmd: Command, cmdParams: ThisCommandParams, varName: string, value: any) {\n\n}\n//------------------------------------------------------------------------------------------------------\n// \u5BF9\u8C61\u64CD\u4F5C\u5DE5\u5177\n// [everyone used command type] \u904D\u5386\u6BCF\u4E2A\u6267\u884C\u8FC7\u7684\u81EA\u5B9A\u4E49\u6307\u4EE4\u7C7B\u522B\n//------------------------------------------------------------------------------------------------------\n/**\n * \u5F53\u64CD\u4F5C\u5DE5\u5177\u79FB\u52A8\u5BF9\u8C61\u65F6\n * @param realSelObjs \u9009\u4E2D\u7684\u5BF9\u8C61\n */\nfunction imageLayerOnToolsChangePostion(realSelObjs: GameSprite[]): void {\n\n}\n/**\n * \u5F53\u64CD\u4F5C\u5DE5\u5177\u7F29\u653E\u65F6\n * @param realSelObjs \u9009\u4E2D\u7684\u5BF9\u8C61\n */\nfunction imageLayerOnToolsChangeSize(realSelObjs: GameSprite[]) {\n\n}\n/**\n * \u5F53\u64CD\u4F5C\u5DE5\u5177\u65CB\u8F6C\u65F6\n * @param realSelObjs \u9009\u4E2D\u7684\u5BF9\u8C61\n */\nfunction imageLayerOnToolsChangeRotation(realSelObjs: GameSprite[]) {\n\n}\n/**\n * \u5F53\u64CD\u4F5C\u5DE5\u5177\u5F00\u59CB\u64CD\u4F5C\u65F6\n */\nfunction imageLayerOnToolsChangeStart(realSelObjs: GameSprite[]) {\n\n}\n/**\n * \u5F53\u64CD\u4F5C\u5DE5\u5177\u7ED3\u675F\u64CD\u4F5C\u65F6\n */\nfunction imageLayerOnToolsChangeEnd(realSelObjs: GameSprite[]) {\n\n}\n/**\n * \u5F53\u64CD\u4F5C\u5DE5\u5177\u9009\u4E2D\u5BF9\u8C61\u65F6\n */\nfunction imageLayerOnToolsSelectObject(realSelObjs: GameSprite[]) {\n\n}\n//------------------------------------------------------------------------------------------------------\n// \u56FE\u50CF\u5C42\u76F8\u5173 \u904D\u5386\u6BCF\u4E2A\u5DF2\u4F7F\u7528\u7684\u901A\u9053\uFF0C\u6BCF\u4E2A\u5DF2\u4F7F\u7528\u7684\u901A\u9053\u518D\u904D\u5386\u5DF2\u4F7F\u7528\u7684\u6307\u4EE4\uFF0C\u8C03\u7528\u4E0B\u9762\u7684\u51FD\u6570\n// [everyone passage] x [everyone used command type]\n//------------------------------------------------------------------------------------------------------\n/**\n * \u6E05\u7406\u51FD\u6570\uFF1A\u6BCF\u6B21\u5237\u65B0\u524D\u8C03\u7528\u6B64\u51FD\u6570\u8FDB\u884C\u6E05\u7406\n * @param passageID \u901A\u9053\n * @param passageData \u901A\u9053\u50A8\u5B58\u7684\u6570\u636E\n */\nfunction imageLayerPassageClear(passageID: number, passageData: PassageData) {\n    // -- \u8BE5\u901A\u9053\u6570\u636E\u662F\u5F53\u524D\u6307\u4EE4\u7684\u8BDD\n    if (passageData.type == passageType) {\n\n    }\n}\n/**\n * \u5F00\u59CB\u51FD\u6570\n * @param passageID \u901A\u9053\n * @param passageData \u901A\u9053\u50A8\u5B58\u7684\u6570\u636E\n */\nfunction imageLayerPassageStart(passageID: number, passageData: PassageData) {\n    // -- \u8BE5\u901A\u9053\u6570\u636E\u662F\u5F53\u524D\u6307\u4EE4\u7684\u8BDD\n    if (passageData.type == passageType) {\n\n    }\n}";
    };
    /**
    * 获取变量类型代码显示
    * @param mode 0-数据结构 1-自定义模块 2-世界属性 3-玩家属性 4-场景属性
    * @param id 对应ID -1表示不根据ID获取
    */
    CustomCompositeSetting.getVarTypeInEditorCode = function (mode, id) {
        if (mode == 0 || mode == 1 || mode == 4) {
            var lists = [Common.dataStructureList, Common.customModuleList, null, null, null];
            var nameHeads = ["DataStructure", "Module", null, null, "SceneModel"];
            if (id == -1)
                return nameHeads[mode];
            var list = lists[mode];
            var cSetting = list.data[id];
            if (cSetting) {
                if (mode == 0 || mode == 1) {
                    var settingName = cSetting.varName;
                }
                else {
                    var settingName = GameListData.getName(list, id);
                }
                return nameHeads[mode] + "_" + settingName;
            }
            else {
                return "any";
            }
        }
        else if (mode == 2) {
            return "WorldData";
        }
        else if (mode == 3) {
            return "PlayerData";
        }
    };
    /**
     * 获取依赖条件追加的运行时
     */
    CustomCompositeSetting.getConditionAPI = function (customSetting) {
        if (Array.isArray(customSetting)) {
            var customAttributeSetting = customSetting;
        }
        else {
            var customAttributeSetting = CustomCompositeSetting.getAllAttributes(customSetting, false);
        }
        var attrs = "var attrs:{";
        for (var i = 0; i < customAttributeSetting.length; i++) {
            var cusAttr = customAttributeSetting[i];
            if (cusAttr.varType >= 3)
                continue;
            if (cusAttr.compData.compType == 2 || cusAttr.compData.compType == 15) {
                attrs += "\n    " + cusAttr.varName + ":";
                switch (cusAttr.varType) {
                    case 0:
                        attrs += "number";
                        break;
                    case 1:
                        attrs += "string";
                        break;
                    case 2:
                        attrs += "boolean";
                        break;
                }
                if (i != customAttributeSetting.length - 1) {
                    attrs += ",";
                }
            }
        }
        attrs += "\n    };";
        return attrs;
    };
    return CustomCompositeSetting;
}(OriginalData));
/**
 * 自定义复合结构块数据
 */
var CustomCompositeBlock = /** @class */ (function () {
    function CustomCompositeBlock() {
    }
    /**
     * 初始化
     */
    CustomCompositeBlock.init = function (data) {
        data.name = "未命名块";
        data.blockAttrs = [];
        data.blockCondition = [];
        data.blockHeight = 300;
        data.autoOrder = true;
    };
    /**
     * 是否空数据
     * @param data
     */
    CustomCompositeBlock.isEmpty = function (data) {
        return data.blockAttrs.length == 0 && data.blockCondition.length == 0;
    };
    /**
     * 出现条件-数据版
     * 编辑器专用
     */
    CustomCompositeBlock.meetConditionData = function (block, idValue, varNameValue) {
        var conditions = block.blockCondition;
        // 遍历条件
        for (var s in conditions) {
            // 条件
            var condition = conditions[s];
            // 实际的值
            var paramValue = idValue[condition.attrID];
            // 条件表达式
            if (condition.isExpression) {
                try {
                    var attrs = varNameValue;
                    var res = eval(condition.jsCode);
                    if (!res)
                        return false;
                }
                catch (e) {
                    trace("条件表达式出错-" + condition.codeName + ":" + e);
                }
            }
            // 非条件表达式
            else {
                if (condition.value == null)
                    condition.value = typeof paramValue == "number" ? 0 : false;
                if (condition.value != paramValue) {
                    return false;
                }
            }
        }
        return true;
    };
    return CustomCompositeBlock;
}());
/**
 * 自定义复合结构块中属性数据
 */
var CustomCompositeAttributeSetting = /** @class */ (function () {
    function CustomCompositeAttributeSetting() {
    }
    /**
     * 初始化
     */
    CustomCompositeAttributeSetting.init = function (data) {
        data.attr = new CustomAttributeSetting();
        CustomAttributeSetting.init(data.attr);
        data.attrConditions = [];
        data.x = data.y = 0;
        data.width = 200;
        data.height = 32;
    };
    /**
     * 出现条件-
     */
    // static meetConditionData(){
    // }
    /**
     * 出现条件-数据版
     */
    CustomCompositeAttributeSetting.meetConditionData = function (conditions, idValue, varNameValue, customCompSettings) {
        if (customCompSettings === void 0) { customCompSettings = null; }
        // var conditions = ccAttr.attrConditions;
        // 遍历条件
        for (var s in conditions) {
            // 条件
            var condition = conditions[s];
            // 实际的值
            if (!idValue) {
                var customCompSetting = ArrayUtils.matchAttributes(customCompSettings, { id: condition.attrID }, true)[0];
                if (!customCompSetting)
                    continue;
                var paramValue = varNameValue[customCompSetting.varName];
            }
            else {
                var paramValue = idValue[condition.attrID];
            }
            // 条件表达式
            if (condition.isExpression) {
                try {
                    var attrs = varNameValue;
                    var res = eval(condition.jsCode);
                    if (!res)
                        return false;
                }
                catch (e) {
                    trace("条件表达式出错-" + condition.codeName + ":" + e);
                }
            }
            // 非条件表达式
            else {
                if (condition.value == null)
                    condition.value = typeof paramValue == "number" ? 0 : false;
                if (condition.value != paramValue) {
                    return false;
                }
            }
        }
        return true;
    };
    /**
     * 出现条件-组件版
     * @param attributeComps 控件集
     * @param preSetting 预设格式数据
     * @param isExpression 是否表达式
     * @param jsCode
     * @param tsCode
     * @param codeName
     */
    CustomCompositeAttributeSetting.meetCondition = function (attributeComps, preSetting, conditions) {
        for (var s in conditions) {
            var condition = conditions[s];
            if (condition.isExpression) {
                var persetDataStructor = preSetting;
                var customAttributeSetting = CustomCompositeSetting.getAllAttributes(persetDataStructor, false);
                var attrs = {};
                for (var i in customAttributeSetting) {
                    var cusAttr = customAttributeSetting[i];
                    if (cusAttr.varType >= 3)
                        continue;
                    var comp = attributeComps[cusAttr.id];
                    if (!comp)
                        continue;
                    if (comp instanceof TitleCombobox) {
                        attrs[cusAttr.varName] = comp.comp.selectedIndex;
                    }
                    else if (comp instanceof TitleCheckBox) {
                        attrs[cusAttr.varName] = comp.checkbox.selected;
                    }
                }
                try {
                    var res = eval(condition.jsCode);
                    if (!res)
                        return false;
                }
                catch (e) {
                    trace("条件表达式出错-" + condition.codeName + ":" + e);
                }
            }
            else {
                var comp = attributeComps[condition.attrID];
                if (comp) {
                    if (comp instanceof TitleCombobox) {
                        if (condition.value != comp.comp.selectedIndex) {
                            return false;
                        }
                    }
                    else if (comp instanceof TitleCheckBox) {
                        if (condition.value == null)
                            condition.value = false;
                        if (condition.value != comp.checkbox.selected) {
                            return false;
                        }
                    }
                }
            }
        }
        return true;
    };
    /**
     * 修正数据类型：根据组件匹配数据类型 number/boolean/string
     */
    CustomCompositeAttributeSetting.matchDataTypeByComponent = function (attrs) {
        var len = attrs.length;
        for (var i = 0; i < attrs.length; i++) {
            var attr = attrs[i];
            // number/boolean/string
            if (attr.varType <= 2 && !CustomAttributeSetting.isHideComp(attr)) {
                var newVarType = EditorDataUICompAttribute.itemVarTypeMapping[attr.compData.compType];
                if (newVarType != null) {
                    attr.varType = newVarType;
                }
            }
        }
    };
    return CustomCompositeAttributeSetting;
}());
/**
 * 自定义模块中对已设定的模块中设置的单一数据
 * 同 AvatarData/AnimationData 一样，比如自定义模块-技能中的技能1的数据
 * Created by 黑暗之神KDS on 2019-05-08 19:40:29.
 */
var CustomData = /** @class */ (function (_super) {
    __extends(CustomData, _super);
    function CustomData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * 自定义属性集
         */
        _this.attrs = {};
        return _this;
    }
    return CustomData;
}(OriginalData));
/**
 * 自定义事件类别
 * Created by 黑暗之神KDS on 2019-07-17 18:33:19.
 */
var CustomEventType = /** @class */ (function (_super) {
    __extends(CustomEventType, _super);
    function CustomEventType() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CustomEventType;
}(OriginalData));
/**
 * 自定义游戏属性配置：定义和填充世界属性、玩家属性
 * Created by 黑暗之神KDS on 2019-05-17 20:12:34.
 */
var CustomGameAttribute = /** @class */ (function () {
    function CustomGameAttribute() {
    }
    /**
     * 世界数据同步属性名初始化
     * @param gameAttr
     */
    CustomGameAttribute.getWorldSyncDataAttrNames = function (gameAttr) {
        if (!CustomGameAttribute.cacheWorldDataSyncAttrNames) {
            var attrs = CustomCompositeSetting.getAllAttributes(gameAttr.worldAttributeSetting, false);
            CustomGameAttribute.cacheWorldDataSyncAttrNames = [];
            for (var i in attrs) {
                var attrSetting = attrs[i];
                if (attrSetting.syncMode == 1) {
                    CustomGameAttribute.cacheWorldDataSyncAttrNames.push(attrSetting.varName);
                }
            }
        }
        return CustomGameAttribute.cacheWorldDataSyncAttrNames;
    };
    return CustomGameAttribute;
}());
/**
 * 对话框数据
 * Created by 黑暗之神KDS on 2018-10-16 18:13:48.
 */
var DialogData = /** @class */ (function (_super) {
    __extends(DialogData, _super);
    function DialogData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * 初始化同步数据
         */
        _this.initData = false;
        /**
         * 预览模式
         */
        _this.previewMode = false;
        /**
         * 对话框
         */
        _this.dialogBox = {
            x: 52,
            y: 439,
            width: 891,
            height: 259,
            alpha: 1,
            image: "asset/image/picture/control/dialogBg.png",
            flip: false,
            grid9: "0,0,0,0,0",
            showOnEditor: true,
            mouseEventEnabledInEditor: true,
            materialData: [{ materials: [] }],
            index: 0
        };
        /**
         * 头像
         */
        _this.headBox = {
            x: 60,
            y: 511,
            width: 150,
            height: 140,
            alpha: 1,
            locksize: true,
            adaptation: true,
            previewHeadImg: Config.EDIT_MODE ? Editor.URL_UNKNOW_IMAGE : "",
            flip: false,
            perviewMode: 0,
            previewStandAvatarID: 0,
            previewStandAvatarExp: 0,
            previewAnimationID: 0,
            previewUIID: 0,
            viewscaleX: 1,
            viewscaleY: 1,
            viewFps: 12,
            viewPlayOnce: false,
            showOnEditor: true,
            mouseEventEnabledInEditor: true,
            materialData: [{ materials: [] }],
            index: 1,
        };
        /**
         * 选项框
         */
        _this.optionBox = {
            x: 272,
            y: 191,
            width: 231,
            height: 111,
            alpha: 1,
            column: 4,
            columnSpaceing: 5,
            row: 1,
            rowSpaceing: 5,
            image1: "asset/image/picture/control/dialogNormal.png",
            grid9img1: "0,0,0,0,0",
            image2: "asset/image/picture/control/dialogOpOver.png",
            grid9img2: "0,0,0,0,0",
            image3: "asset/image/picture/control/dialogOpDown.png",
            grid9img3: "0,0,0,0,0",
            overSe: "",
            overVolume: 1,
            overPitch: 1,
            clickSe: "",
            clickVolume: 1,
            clikcPitch: 1,
            selectImageURL: "asset/image/picture/control/dialogSelect.png",
            grid9img4: "0,0,0,0,0",
            showOnEditor: true,
            mouseEventEnabledInEditor: true,
            materialData: [{ materials: [] }],
            index: 2
        };
        /**
         * 对话文本
         */
        _this.dialog = {
            x: 221,
            y: 512,
            width: 699,
            height: 134,
            alpha: 1,
            fontSize: 22,
            color: "#FFFFFF",
            bold: false,
            italic: false,
            smooth: false,
            align: 0,
            leading: 5,
            letterSpacing: 0,
            font: "宋体",
            shadowEnabled: false,
            shadowColor: "#000000",
            shadowDx: 1,
            shadowDy: 1,
            stroke: 0,
            strokeColor: "#000000",
            showOnEditor: true,
            mouseEventEnabledInEditor: true,
            wordWrap: false,
            materialData: [{ materials: [] }],
            index: 3
        };
        /**
        * 选项文本
        */
        _this.option = {
            x: 290,
            y: 226,
            width: 196,
            height: 40,
            alpha: 1,
            fontSize: 24,
            color: "#FFFFFF",
            overColor: "#FFFFFF",
            clickColor: "#FFFFFF",
            bold: false,
            italic: false,
            smooth: false,
            align: 1,
            leading: 0,
            letterSpacing: 0,
            font: "宋体",
            valign: 1,
            shadowEnabled: false,
            shadowColor: "#000000",
            shadowDx: 1,
            shadowDy: 1,
            stroke: 0,
            strokeColor: "#000000",
            showOnEditor: true,
            mouseEventEnabledInEditor: true,
            materialData: [{ materials: [] }],
            index: 4
        };
        /**
         * 姓名文本
         */
        _this.nameBox = {
            x: 121,
            y: 456,
            width: 123,
            height: 28,
            alpha: 1,
            fontSize: 24,
            color: "#FFFFFF",
            bold: false,
            italic: false,
            smooth: false,
            align: 1,
            leading: 0,
            letterSpacing: 0,
            font: "宋体",
            valign: 1,
            shadowEnabled: false,
            shadowColor: "#000000",
            shadowDx: 1,
            shadowDy: 1,
            stroke: 0,
            strokeColor: "#000000",
            showOnEditor: true,
            mouseEventEnabledInEditor: true,
            materialData: [{ materials: [] }],
            index: 5
        };
        /**
         * 跳过
         */
        _this.skipBox = {
            x: 895,
            y: 608,
            width: 0,
            height: 0,
            alpha: 1,
            posIndex: 0,
            posX: 0,
            posY: 0,
            animationID: 0,
            scaleNumber: 1,
            playType: 2,
            delayTime: 0,
            showOnEditor: true,
            mouseEventEnabledInEditor: true,
            index: 6
        };
        return _this;
    }
    DialogData.isEmpty = function (data) {
        if (!DialogData.emptyData)
            DialogData.emptyData = new DialogData();
        var dialogName = GameListData.getName(Game.data.dialogList, data.id, true);
        if (dialogName)
            return false;
        var dataClone = {};
        for (var i in data) {
            if (i == "id" || i == "name")
                continue;
            dataClone[i] = data[i];
        }
        return ObjectUtils.depthSame(dataClone, DialogData.emptyData);
    };
    return DialogData;
}(OriginalData));
/**
 * Created by 黑暗之神KDS on 2018-10-16 17:38:50.
 */
var MapData = /** @class */ (function (_super) {
    __extends(MapData, _super);
    function MapData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * 预加载资源
         * type
         * 0-图片资源 string
         * 1-音频资源 string
         * 2-文本资源 string
         * 3-JSON资源 string
         * 4-avatarID number
         * 5-uiID number
         * 6-animationID number
         * 7-standAvatarID number
         * 8-dialog number
         *
         */
        _this.preLoadAssets = [];
        /**
         * 服务端实现类
         */
        _this.serverInstanceClassName = MapData.SERVER_SCENE_CORE_CLASS;
        /**
         * 客户端实现类
         */
        _this.clientInstanceClassName = MapData.CLIENT_SCENE_CORE_CLASS;
        return _this;
    }
    /**
     * 默认服务端场景实现类
     */
    MapData.SERVER_SCENE_CORE_CLASS = "GameServerScene";
    /**
     * 默认客户端场景实现类
     */
    MapData.CLIENT_SCENE_CORE_CLASS = "GameClientScene";
    return MapData;
}(Scene));
/**
 * 多版本管理数据
 * Created by JayLen on 2020-11-27 20:57:43.
 */
var MultiversionData = /** @class */ (function () {
    function MultiversionData() {
        //版本数据
        this.versionDataList = [];
        //携带版本资源
        this.bringSource = true;
    }
    return MultiversionData;
}());
var versionSouceData = /** @class */ (function () {
    function versionSouceData() {
        //映射数据类型或者关联资源类型
        this.classType = 0;
        //映射规则类型
        this.ruleType = 0;
    }
    return versionSouceData;
}());
/**
 * Created by 黑暗之神KDS on 2018-10-16 17:38:19.
 */
var SceneData = /** @class */ (function (_super) {
    __extends(SceneData, _super);
    function SceneData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * 地图数据 [json object]
         */
        _this.mapData = new MapData();
        /**
         * 场景对象数据 [json object]
         */
        _this.sceneObjectData = new SceneObjectData();
        return _this;
    }
    return SceneData;
}(OriginalData));
/**
 * 场景层对象
 * -- tileData在复制或保存时会经过特殊转换
 * Created by 黑暗之神KDS on 2018-11-06 01:08:56.
 */
var SceneLayerData = /** @class */ (function (_super) {
    __extends(SceneLayerData, _super);
    function SceneLayerData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * 偏移x
         */
        _this.dx = 0;
        /**
         * 偏移y
         */
        _this.dy = 0;
        /**
         * 缩放x
         */
        _this.scaleX = 1;
        /**
         * 缩放y
         */
        _this.scaleY = 1;
        /**
         * 斜率x
         */
        _this.skewX = 0;
        /**
         * 斜率y
         */
        _this.skewY = 0;
        /**
         * 旋转角度
         */
        _this.rotation = 0;
        /**
         * x方向自动滚动速度
         */
        _this.xMove = 0;
        /**
         * y方向自动滚动速度
         */
        _this.yMove = 0;
        /**
         * 远景效果 x
         */
        _this.prospectsPerX = 1;
        /**
         * 远景效果 y
         */
        _this.prospectsPerY = 1;
        /**
         * x方向循环
         */
        _this.xLoop = false;
        /**
         * y方向循环
         */
        _this.yLoop = false;
        /**
         * 透明度
         */
        _this.opacity = 1;
        /**
         * 混合模式 null/lighter/blend1-1(BlendExt::blendFunType)
         */
        _this.blendMode = null;
        /**
         * 绘制模式
         */
        _this.drawMode = false;
        /**
         * 图块数据
         */
        _this.tileData = [];
        /**
         * 缓存的图块数据（用于缓存自动元件计算后的图块信息，并在读取时替换掉实际的显示）
         */
        _this.autoTileDataCache = [];
        /**
         * 全景图地址
         */
        _this.img = null;
        /**
         * 图片图块层编辑模式
         */
        _this.modeType = true;
        /**
         * 图片图块层锁定编辑模式
         */
        _this.modeLock = false;
        return _this;
    }
    return SceneLayerData;
}(OriginalData));
/**
 * 场景的场景对象相关数据
 * -- 用于储存一个场景的：全场景事件、场景对象事件、场景对象属性（含状态页面、自定义属性和模块）
 * -- 安装预设的场景对象时会使用该数据进行安装
 * -- 编辑器中的操作会同步到该数据内，同时场景里预览的对象是实体，也需要同步到实体里面去以便预览，该处仅作为归档使用
 *
 * 【编辑器生成制作数据】
 * typeValue=用于记录类型+值，来自 Game.data.sceneList.data[x].sceneObjectData，出生点来自 Config.BORN
 * [初始] 创建/恢复历史数据时，初始化全状态页公共模块（含显示列表）+自定义模块（含显示列表）+实体
 *      -- SceneObjectData.formatAllStatusPageCommonModule
 *      -- SceneObjectData.formatAllStatusPageModuleCustomData
 *      -- SceneObjectData.formatEntityModules
 * [选定] （新建对象时也会选定，新版本旧数据选定也会顺便被修正） 参考 EUISceneObjectAttribute.ts
 *      -- 格式化[归档数据]和[对象实体]的[当前状态页]的[公共模块数据（含显示对象、moduleIDs）]
 *          -- SceneObjectData.formatOneStatusPageCommonModuleDisplayList 公共模块显示对象数据（旧版本则是当前原型）
 *          -- CustomAttributeSetting.formatCustomData 公共模块自定义属性（旧版本则是当前原型）
 *      -- 格式化[归档数据]和[对象实体]的[当前状态页]的[自定义模块数据（含显示对象、moduleIDs]
 *          -- SceneObjectData.formatOneStatusPageModuleCustomData 归档数据的
 *          -- SceneObjectData.formatEntityModules 实体的
 * [保存] 一旦需要保存该场景的SceneObjectData数据时
 *        全场景对象的归档数据的[全状态页]的[公共模块（含显示对象）]和[自定义模块（含显示对象）]都会被格式化修正
 *      -- SceneObjectData.formatAllStatusPageCommonModule 全状态页的公共模块的显示对象列表
 *      -- CustomAttributeSetting.formatCustomData  全状态页的公共模块的自定义属性
 *      -- SceneObjectData.formatAllStatusPageModuleCustomData
 *
 * [(*)更改设计结构] 当更改了场景对象原型、公共模块、自定义场景对象模块时需要保存时格式化以及当前选中的对象刷新
 *
 * 【实体数据同步】
 *  value=实体对象的值  so.xxx  so.getModule(1).xxx
 *  -- 初始化
 *  	-- 公共显示对象Value    运行时/编辑器：ClientSceneObject::refreshCommonDisplayList
 *  	-- 公共自定义属性Value  运行时：构造函数（soData） 编辑器：ClientSceneObject::installEntityCommonData
 *  	-- 模块显示对象Value    运行时：SceneObjectEntity::refreshDisappearStatus 编辑器：SceneObjectData.formatEntityModules
 *  	-- 模块自定义属性Value  运行时：SceneObjectEntity::refreshDisappearStatus 编辑器：SceneObjectData.formatEntityModules
 *   -- 历史记录还原（仅编辑器）
 *  	-- 公共显示对象Value    ClientSceneObject::refreshCommonDisplayList
 *  	-- 公共自定义属性Value  ClientSceneObject::installEntityCommonData
 *  	-- 模块显示对象Value    EUISceneMain_SO::syncSceneObjectEntityCustomAttributes => SceneObjectData.formatEntityModules
 *  	-- 模块自定义属性Value  EUISceneMain_SO::syncSceneObjectEntityCustomAttributes => SceneObjectData.formatEntityModules
 *   -- 属性变更
 *  	-- 公共显示对象Value    EUISceneObjectAttribute::onDisplayListChange
 *  	-- 公共自定义属性Value  EUISceneObjectAttribute::onCustomAttrChange
 *  	-- 模块显示对象Value    EUISceneObjectAttribute::onDisplayListChange
 *  	-- 模块自定义属性Value  EUISceneObjectAttribute::onCustomAttrChange
 *   -- 模块安装/卸载
 *  	-- 模块显示对象Value    ClientSceneObject::addModule
 *  	-- 模块自定义属性Value  SceneObjectEntity::addModule
 *   -- 原型/模块原型发生变更
 *      -- 原型/公共模块变更事件 EUISceneMain.EVENT_SCENE_OBJECT_MODEL_CHANGE
 *  	-- 自定义场景对象模块变更事件 EUIWindowSceneObjectModule.EVENT_CUSTOM_DATA_CHANGED
 *
 *
 * 【关于显示对象】
 *    公共显示对象在初始化时统一刷新（ClientSceneObject::refreshCommonDisplayList），
 *    模块则在附加到该对象上时创建显示对象并添加至对应的层级上，然后调用刷新层次（）
 *    也就是说添加了模块后可以立即操作该模块中显示对象
 *
 * 【关于行为编辑器】
 *      -- installSoCustomAttributes
 *
 * 【关于网络版本】
 *
 * 【测试】
 *  [编辑器行为]
 *    -- √ 初始化：启动编辑器后两个场景。公共属性√、公共显示列表√、模块属性√、模块显示列表√（含不同的状态页）
 *    -- √ 恢复历史记录 删除对象√、创建对象√、状态页√、增减模块√ 更改属性 √
 *    -- √ 状态页
 *    -- √ 增减模块
 *    -- √ 更改属性
 *    -- √ 更改设计结构 公共属性√、预安装的模块√、模块√
 *    -- √ 选定
 *    -- √ 保存
 *  [运行时行为]
 *  -- 玩家和NPC装载数据：公共属性√、公共显示列表√、模块属性√、模块显示列表√
 *  -- 玩家切换场景：公共属性√、公共显示列表√、模块属性√、模块显示列表√
 *  -- NPC状态页切换：公共属性√、公共显示列表√、模块属性√、模块显示列表√
 *  -- 代码新建NPC对象 √
 *  -- 代码克隆NPC对象 √
 *  -- 增减玩家和NPC的模块 √
 *  -- 更改玩家和NPC的模块内数据和显示对象 √
 *  -- 更改玩家和NPC的公共显示对象 √
 *  -- 更改玩家和NPC的公共数据 √
 *  -- 存档读档-玩家和NPC的数据 √
 *
 * Created by 黑暗之神KDS on 2018-10-16 17:41:43.
 */
var SceneObjectData = /** @class */ (function () {
    function SceneObjectData() {
        /** 场景对象的属性 */
        this.sceneObjects = [];
        /** 场景自定义事件集 */
        this.customCommands = [];
        /** 场景对象的自定义属性：类型参考 CustomAttributeSetting.ATTR_TYPE_XXXX [sceneObjectIndex] = [自定义属性集] */
        this.customAttributes = [];
        /** 场景对象的模块数据设定，与sceneObject::moduleIDs映射：类型参考 CustomAttributeSetting.ATTR_TYPE_XXXX [sceneObjectIndex]=[自定义属性模块数组] */
        this.modulesCustomAttributes = [];
        /** 场景自定义属性的varValue=>value缓存值，每个场景对象预设的配置值可能不一样，并非公共模块默认值（旧版本/公共属性）[sceneObjectIndex] = [缓存值]
         *  缓存的目的在于根据编辑器预设创建/克隆/切换状态页时同一个预设对象时不同每次计算varValue，而是已经有了value
         *  克隆出来的多个对象也只会有一份缓存，只有克隆源缓存（参考SceneObjectEntity）
         *  【仅运行时用到】
         */
        this.customAttributesCaches = [];
        /** 同上，此处是模块自定义数据值（不含显示对象） [该对象的Index][该对象的模块Index] = value */
        this.modulesCustomAttributesCaches = [];
        /**
         * condition 条件
         * click 点击事件 玩家点击NPC
         * collide 碰触事件 玩家碰触NPC
         * update 并行事件 NPC->NPC
         */
        this.events = [];
        /**
         * 多状态页数据（第2页~第N页）
         * 对象中的坐标仍然使用SceneObjectData::sceneObjects的主坐标
         * [soIndex][0~n表示第2页~第N页]
         */
        this.statusPages = [];
        /**
         * 用于记录每个对象当前选中的状态页
         */
        this.statusPagesSelectedIndexs = [];
    }
    /**
     * 获取克隆场景对象
     * @param so
     * @return [SceneObject]
     */
    SceneObjectData.clone = function (soIndex, sceneSoData) {
        var so = sceneSoData.sceneObjects[soIndex];
        var newData = {
            so: new SceneObject(),
            event: null,
            customAttribute: null,
            modulesCustomAttribute: null,
            statusPage: [],
            statusPagesSelectedIndex: 0
        };
        // 复制场景对象基本属性
        newData.so = SceneObject.__gcClone(so);
        // 复制场景对象事件
        newData.event = ObjectUtils.depthClone(sceneSoData.events[so.index]);
        // 复制场景对象自定义属性
        newData.customAttribute = ObjectUtils.depthClone(sceneSoData.customAttributes[so.index]);
        // 复制场景对象模块数据
        newData.modulesCustomAttribute = ObjectUtils.depthClone(sceneSoData.modulesCustomAttributes[so.index]);
        // 复制状态页
        var statusPages = sceneSoData.statusPages[so.index];
        if (statusPages && statusPages.length > 0) {
            // 遍历该对象的状态页
            for (var s = 0; s < statusPages.length; s++) {
                // 数据源
                var statusPage = statusPages[s];
                // 建立新的状态页
                var newStatusData = {
                    so: new SceneObject(),
                    event: null,
                    customAttribute: null,
                    modulesCustomAttribute: null
                };
                // 复制场景对象基本属性
                newStatusData.so = SceneObject.__gcClone(statusPage.so);
                // 复制场景对象事件
                newStatusData.event = ObjectUtils.depthClone(statusPage.event);
                // 复制场景对象自定义属性
                newStatusData.customAttribute = ObjectUtils.depthClone(statusPage.customAttribute);
                // 复制场景对象
                newStatusData.modulesCustomAttribute = ObjectUtils.depthClone(statusPage.modulesCustomAttribute);
                // 添加状态页
                newData.statusPage.push(newStatusData);
            }
        }
        // 复制状态页选中
        newData.statusPagesSelectedIndex = sceneSoData.statusPagesSelectedIndexs[so.index];
        return newData;
    };
    /**
     * 初始化
     */
    SceneObjectData.init = function (sceneObjectData, index) {
        sceneObjectData.events[index] = {
            condition: [],
            customCommands: []
        };
        sceneObjectData.customAttributes[index] = {};
        sceneObjectData.statusPages[index] = [];
        this.formatOneStatusPageModuleCustomData(sceneObjectData, index, 1);
    };
    //------------------------------------------------------------------------------------------------------
    //  获取
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取当前选中的状态页索引 0~N
     * @param sceneObjectData 指定场景的场景对象数据
     * @param soIndex 场景对象索引
     * @return [number]
     */
    SceneObjectData.getStatusPagesSelectedIndex = function (sceneObjectData, soIndex) {
        var soData = sceneObjectData.sceneObjects[soIndex];
        if (soData) {
            var modelData = Game.data.sceneObjectModelList.data[soData.modelID];
            ;
            if (!modelData || !modelData.supportStatusPage)
                return 0;
            var _statusPagesSelectedIndex = MathUtils.int(sceneObjectData.statusPagesSelectedIndexs[soIndex]);
            if (_statusPagesSelectedIndex < 0)
                _statusPagesSelectedIndex = 0;
            var statusPages = sceneObjectData.statusPages[soIndex];
            if (!statusPages)
                return 0;
            var len = statusPages.length + 1;
            if (_statusPagesSelectedIndex >= len - 1)
                _statusPagesSelectedIndex = len - 1;
            return _statusPagesSelectedIndex;
        }
        return 0;
    };
    /**
     * 获取指定场景的指定索引对象的指定状态页数据内容
     * @param sceneID 场景ID
     * @param soIndex 对象索引
     * @param stpIndex 指定事件页 0~N
     */
    SceneObjectData.getStatusPageInfo = function (sceneID, soIndex, stpIndex) {
        // 出生点
        var bornSceneID = EUISceneMain_SO.bornScene ? EUISceneMain_SO.bornScene.id : Config.BORN.sceneID;
        var bornSoIndex = EUISceneMain_SO.bornSo ? EUISceneMain_SO.bornSo.index : Config.BORN.so.index;
        if (bornSceneID == sceneID && soIndex == bornSoIndex) {
            return {
                so: Config.BORN.so,
                customAttribute: Config.BORN.customAttribute,
                event: null,
                modulesCustomAttribute: Config.BORN.bornModulesCustomAttribute
            };
        }
        else {
            var sceneData = Game.data.sceneList.data[sceneID];
            if (sceneData) {
                var sceneObjectData = sceneData.sceneObjectData;
                if (stpIndex == 0) {
                    return {
                        so: sceneObjectData.sceneObjects[soIndex],
                        customAttribute: sceneObjectData.customAttributes[soIndex],
                        event: sceneObjectData.events[soIndex],
                        modulesCustomAttribute: sceneObjectData.modulesCustomAttributes[soIndex]
                    };
                }
                else {
                    var statusPages = sceneObjectData.statusPages[soIndex];
                    return statusPages ? statusPages[stpIndex - 1] : null;
                }
            }
        }
        return null;
    };
    //------------------------------------------------------------------------------------------------------
    //  显示对象数据
    //------------------------------------------------------------------------------------------------------
    /**
     * 格式化全状态页的公共模块（含显示对象）
     * @param sceneObjectData
     * @param soIndex
     */
    SceneObjectData.formatAllStatusPageCommonModule = function (sceneObjectData, soIndex) {
        var fixModelData;
        if (Config.useNewSceneObjectModel) {
            fixModelData = Game.data.sceneObjectModelList.data[0];
        }
        // 主状态页修正
        var soData = sceneObjectData.sceneObjects[soIndex];
        if (soData) {
            if (!Config.useNewSceneObjectModel) {
                fixModelData = Game.data.sceneObjectModelList.data[soData.modelID];
            }
            if (fixModelData) {
                this.formatDisplayList(soData, fixModelData, soData.displayList);
                var customAttributes = sceneObjectData.customAttributes[soIndex];
                if (!customAttributes)
                    customAttributes = sceneObjectData.customAttributes[soIndex] = {};
                sceneObjectData.customAttributes[soIndex] = CustomAttributeSetting.formatCustomData(customAttributes, fixModelData.varAttributes);
            }
        }
        // 其他状态页修正
        var statusPage = sceneObjectData.statusPages[soIndex];
        if (statusPage) {
            for (var stIndex = 0; stIndex < statusPage.length; stIndex++) {
                var stp = statusPage[stIndex];
                if (!Config.useNewSceneObjectModel) {
                    fixModelData = Game.data.sceneObjectModelList.data[soData.modelID];
                }
                if (fixModelData) {
                    this.formatDisplayList(stp.so, fixModelData, stp.so.displayList);
                    var customAttributes = stp.customAttribute;
                    if (!customAttributes)
                        customAttributes = stp.customAttribute = {};
                    stp.customAttribute = CustomAttributeSetting.formatCustomData(customAttributes, fixModelData.varAttributes);
                }
            }
        }
    };
    /**
     * 格式化显示指定状态页的显示对象数据
     * -- 选定对象时格式化「SceneObjectData归档数据」的「当前状态页」的「公共模块中的显示对象数据」
     * -- 选定对象时格式化场景「对象实体」的「公共模块中的显示对象数据」 soc.displayList
     * @param soData 对象（数据）
     * @param refModelData 参考模块数据
     * @param SceneObjectModelData 对应的显示对象列表数据
     */
    SceneObjectData.formatOneStatusPageCommonModuleDisplayList = function (soData, refModelData, displayList) {
        this.formatDisplayList(soData, refModelData, displayList);
    };
    /**
     * 格式化实体的模块显示列表
     * @param soData 归档数据
     * @param soc 实体
     */
    SceneObjectData.formatEntityModules = function (soData, soc, modulesCustomAttributes) {
        if (!Config.useNewSceneObjectModel)
            return;
        // -- 当没有数据时使用原型预设
        if (!soData.moduleIDs) {
            var modelData = Common.sceneObjectModelList.data[soData.modelID];
            if (!modelData)
                return;
            soData.moduleIDs = modelData.presetModules.concat();
        }
        // 初始化数据
        if (!soc.moduleIDs) {
            // -- 如果存在制作数据，以制作数据为准（会安装制作数据中设置的值，如果没有则使用默认值）
            soc.moduleIDs = [];
            soc.moduleDisplayList = [];
            soc.removeAllModules();
            for (var i = 0; i < soData.moduleIDs.length; i++) {
                var moduleID = soData.moduleIDs[i];
                var moduleData = Common.sceneObjectModuleList.data[moduleID];
                if (moduleData) {
                    var modulesCustomAttribute = modulesCustomAttributes ? modulesCustomAttributes[i] : null;
                    var presetData = {};
                    if (!modulesCustomAttribute) {
                        modulesCustomAttribute = {};
                        CustomAttributeSetting.formatCustomData(modulesCustomAttribute, moduleData.varAttributes);
                        modulesCustomAttributes[i] = modulesCustomAttribute;
                    }
                    // -- 安装制作数据的自定义属性设置的值
                    CustomAttributeSetting.installAttributeFromEditorSet(presetData, modulesCustomAttribute, moduleData.varAttributes, false, false, GameData.CUSTOM_ATTR_SCENE_OBJECT_MODULE_DATA);
                    // -- 安装制作数据的显示列表数据设置的值
                    for (var s = 0; s < moduleData.preLayer.length; s++) {
                        var p = moduleData.preLayer[s];
                        if (!soData.moduleDisplayList)
                            soData.moduleDisplayList = [];
                        var displayInfos = soData.moduleDisplayList[i];
                        if (displayInfos) {
                            var displayInfo = displayInfos[p.varName];
                            if (displayInfo != null) {
                                presetData[p.varName] = displayInfo.id;
                            }
                            else {
                                presetData[p.varName] = 0;
                            }
                        }
                    }
                    var soModule = SceneObject.createModule(moduleID, soc, presetData);
                    if (soModule) {
                        soc.addModule(soModule);
                    }
                }
            }
        }
        for (var m = 0; m < soc.moduleIDs.length; m++) {
            var moduleID = soc.moduleIDs[m];
            var modlueData = Common.sceneObjectModuleList.data[moduleID];
            // -- 如果该模块存在的话，则格式化该数据
            if (modlueData) {
                // -- 格式化显示对象数据
                if (!soc.moduleDisplayList)
                    soc.moduleDisplayList = [];
                var displayList = soc.moduleDisplayList[m];
                if (!displayList)
                    displayList = soc.moduleDisplayList[m] = {};
                this.formatDisplayList(soc, modlueData, displayList);
            }
            // -- 不存在则剔除该模块以及对应该模块的显示对象数据
            else {
                var soModuleDisplay = soc.moduleDisplayList[m];
                if (soModuleDisplay) {
                    soc.moduleDisplayList.splice(m, 1);
                }
                soc.moduleIDs.splice(m, 1);
                m--;
            }
        }
    };
    /**
     * 安装对象实体的公共自定义数据
     */
    SceneObjectData.installEntityCommonData = function (soc, customAttribute) {
        if (!Config.useNewSceneObjectModel)
            return;
        var commonModuleData = Game.data.sceneObjectModelList.data[0];
        for (var i = 0; i < commonModuleData.varAttributes.length; i++) {
            var varAttribute = commonModuleData.varAttributes[i];
            var typeValue = customAttribute[varAttribute.varName];
            CustomAttributeSetting.typeValue2RealValue(soc, commonModuleData.varAttributes[i], typeValue, false, false, GameData.CUSTOM_ATTR_SCENE_OBJECT_DATA);
        }
    };
    //------------------------------------------------------------------------------------------------------
    //  模块数据处理
    //------------------------------------------------------------------------------------------------------
    /**
     * 重置出生点为默认模块（对应原型预设）
     */
    SceneObjectData.resetBornDefaultModules = function () {
        var modelData = Common.sceneObjectModelList.data[Config.BORN.so.modelID];
        Config.BORN.so.moduleIDs = modelData.presetModules.concat();
        Config.BORN.bornModulesCustomAttribute = [];
        for (var i = 0; i < Config.BORN.so.moduleIDs.length; i++) {
            var moduleID = Config.BORN.so.moduleIDs[i];
            var moduleData = Game.data.sceneObjectModuleList.data[moduleID];
            if (!moduleData) {
                Config.BORN.so.moduleIDs.splice(i, 1);
                i--;
            }
            Config.BORN.bornModulesCustomAttribute.push(CustomAttributeSetting.formatCustomData(null, moduleData.varAttributes));
        }
        SceneObjectData.formatBornModuleCustomData(Config.BORN.so, Config.BORN.bornModulesCustomAttribute);
        EditorData.updateNeedSaveFile(EditorData.NEED_SAVE_CONFIG);
    };
    /**
     * 重置为默认的模块（场景对象）
     */
    SceneObjectData.resetDefaultModules = function (sceneID, sceneObjectData, sceneObjectIndex) {
        if (!Config.useNewSceneObjectModel)
            return;
        // 主状态页修正
        var mainStatusPageSoData = sceneObjectData.sceneObjects[sceneObjectIndex];
        if (!mainStatusPageSoData)
            return;
        var modelData = Common.sceneObjectModelList.data[Config.BORN.so.modelID];
        if (!modelData)
            return;
        mainStatusPageSoData.moduleIDs = modelData.presetModules.concat();
        var modulesCustomAttributes = sceneObjectData.modulesCustomAttributes[sceneObjectIndex] = [];
        for (var i = 0; i < mainStatusPageSoData.moduleIDs.length; i++) {
            var moduleID = mainStatusPageSoData.moduleIDs[i];
            var moduleData = Game.data.sceneObjectModuleList.data[moduleID];
            if (!moduleData) {
                mainStatusPageSoData.moduleIDs.splice(i, 1);
                i--;
            }
            modulesCustomAttributes.push(CustomAttributeSetting.formatCustomData(null, moduleData.varAttributes));
        }
        this.formatOneStatusPageModuleCustomData(sceneObjectData, sceneObjectIndex, 1);
        // 其他状态页修正
        var statusPage = sceneObjectData.statusPages[sceneObjectIndex];
        if (statusPage) {
            for (var stIndex = 0; stIndex < statusPage.length; stIndex++) {
                var stpSo = statusPage[stIndex].so;
                var modulesCustomAttributes = statusPage[stIndex].modulesCustomAttribute = [];
                stpSo.moduleIDs = modelData.presetModules.concat();
                for (var i = 0; i < stpSo.moduleIDs.length; i++) {
                    var moduleID = stpSo.moduleIDs[i];
                    var moduleData = Game.data.sceneObjectModuleList.data[moduleID];
                    if (!moduleData) {
                        stpSo.moduleIDs.splice(i, 1);
                        i--;
                    }
                    modulesCustomAttributes.push(CustomAttributeSetting.formatCustomData(null, moduleData.varAttributes));
                }
                this.formatOneStatusPageModuleCustomData(sceneObjectData, sceneObjectIndex, stIndex + 2);
            }
        }
        EditorData.updateNeedSaveFile(EditorData.NEED_SAVE_SCENE_OBJECTS, false, sceneID);
    };
    /**
     * 格式化模块自定义数据（比如更改了自定义编辑器设定，则该场景重载无需该属性了或者需要匹配类型）
     * -- 保存时统一格式化
     * -- 选定一个对象查看其属性时
     */
    SceneObjectData.formatAllStatusPageModuleCustomData = function (sceneObjectData, sceneObjectIndex) {
        if (!Config.useNewSceneObjectModel)
            return;
        // 主状态页修正
        this.formatOneStatusPageModuleCustomData(sceneObjectData, sceneObjectIndex, 1);
        // 其他状态页修正
        var statusPage = sceneObjectData.statusPages[sceneObjectIndex];
        if (statusPage) {
            for (var stIndex = 0; stIndex < statusPage.length; stIndex++) {
                this.formatOneStatusPageModuleCustomData(sceneObjectData, sceneObjectIndex, stIndex + 2);
            }
        }
    };
    /**
     * 格式化模块自定义数据（含显示对象），指定的一个状态页
     * @param sceneObjectData 指定场景的SceneObjectData数据
     * @param sceneObjectIndex 对应的场景对象编号
     * @param stPageID 1~N 状态页
     */
    SceneObjectData.formatOneStatusPageModuleCustomData = function (sceneObjectData, sceneObjectIndex, stPageID) {
        if (!Config.useNewSceneObjectModel)
            return;
        if (stPageID == 1) {
            SceneObjectData.initModuleData(sceneObjectData, sceneObjectIndex, 1);
            var soData = sceneObjectData.sceneObjects[sceneObjectIndex];
            if (soData) {
                var customAttributesArr = sceneObjectData.modulesCustomAttributes[sceneObjectIndex];
                if (!customAttributesArr)
                    customAttributesArr = sceneObjectData.modulesCustomAttributes[sceneObjectIndex] = [];
                // 遍历该场景对象数据当前已安装的模块
                this.doFormatOneStatusPageModuleCustomData(soData, customAttributesArr);
            }
        }
        else {
            var statusPage = sceneObjectData.statusPages[sceneObjectIndex];
            if (statusPage) {
                SceneObjectData.initModuleData(sceneObjectData, sceneObjectIndex, stPageID);
                var stIndex = stPageID - 2;
                var stPage = statusPage[stIndex];
                var customAttributesArr = stPage.modulesCustomAttribute;
                if (!customAttributesArr)
                    customAttributesArr = stPage.modulesCustomAttribute = [];
                this.doFormatOneStatusPageModuleCustomData(stPage.so, customAttributesArr);
            }
        }
    };
    /**
     * 格式化出生点的模块数据
     * @param soData
     * @param varName
     * @param varType
     * @param value
     * @param copy
     */
    SceneObjectData.formatBornModuleCustomData = function (soData, customAttributesArr) {
        SceneObjectData.initModuleDataBySceneObjectData(soData);
        this.doFormatOneStatusPageModuleCustomData(soData, customAttributesArr);
    };
    /**
     * 移除归档数据中的模块
     * @param sceneObjectData 场景对应的归档数据
     * @param sceneObjectIndex 场景对象索引
     * @param stPageID 状态页
     * @param moduleIndex 模块位置
     */
    SceneObjectData.removeModule = function (sceneObjectData, sceneObjectIndex, stPageIndex, moduleIndex) {
        if (stPageIndex == 0) {
            var soData = sceneObjectData.sceneObjects[sceneObjectIndex];
            var modulesCustomAttribute = sceneObjectData.modulesCustomAttributes[sceneObjectIndex];
        }
        else {
            var stpInfo = sceneObjectData.statusPages[sceneObjectIndex];
            if (!stpInfo)
                return;
            var stp = stpInfo[stPageIndex - 1];
            if (!stp)
                return;
            var soData = stp.so;
            var modulesCustomAttribute = stp.modulesCustomAttribute;
        }
        this.removeModuleData(soData, moduleIndex, modulesCustomAttribute);
    };
    /**
     * 移除指定的模块数据
     */
    SceneObjectData.removeModuleData = function (soData, moduleIndex, modulesCustomAttribute) {
        if (modulesCustomAttribute) {
            modulesCustomAttribute.splice(moduleIndex, 1);
        }
        if (soData.moduleIDs) {
            soData.moduleIDs.splice(moduleIndex, 1);
        }
        if (soData.moduleDisplayList) {
            soData.moduleDisplayList.splice(moduleIndex, 1);
        }
    };
    /**
     * 添加归档数据中的模块
     * @param sceneObjectData  场景对应的归档数据
     * @param sceneObjectIndex 场景对象索引
     * @param stPageIndex 状态页
     * @param moduleIndex 模块位置
     * @param moduleID 模块ID
     */
    SceneObjectData.addModule = function (sceneObjectData, sceneObjectIndex, stPageIndex, moduleIndex, moduleID) {
        if (stPageIndex == 0) {
            var soData = sceneObjectData.sceneObjects[sceneObjectIndex];
            var modulesCustomAttribute = sceneObjectData.modulesCustomAttributes[sceneObjectIndex];
        }
        else {
            var stpInfo = sceneObjectData.statusPages[sceneObjectIndex];
            if (!stpInfo)
                return;
            var stp = stpInfo[stPageIndex - 1];
            if (!stp)
                return;
            var soData = stp.so;
            var modulesCustomAttribute = stp.modulesCustomAttribute;
        }
        // 遍历该场景对象数据当前已安装的模块
        this.addModuleData(soData, moduleIndex, moduleID, modulesCustomAttribute);
    };
    /**
     * 添加归档数据中的模块数据
     */
    SceneObjectData.addModuleData = function (soData, moduleIndex, moduleID, modulesCustomAttribute) {
        if (!soData.moduleDisplayList)
            soData.moduleDisplayList = [];
        if (!soData.moduleIDs)
            soData.moduleIDs = [];
        soData.moduleIDs.splice(moduleIndex, 0, moduleID);
        soData.moduleDisplayList.splice(moduleIndex, 0, {});
        modulesCustomAttribute.splice(moduleIndex, 0, {});
        this.doFormatOneStatusPageModuleCustomData(soData, modulesCustomAttribute);
    };
    /**
     * 添加归档数据中的模块
     * @param sceneObjectData  场景对应的归档数据
     * @param sceneObjectIndex 场景对象索引
     * @param stPageIndex 状态页
     * @param moduleIndex 模块位置
     * @param moduleID 模块ID
     */
    SceneObjectData.setModuleIndexByIndex = function (sceneObjectData, sceneObjectIndex, stPageIndex, moduleIndex, toIndex) {
        if (stPageIndex == 0) {
            var soData = sceneObjectData.sceneObjects[sceneObjectIndex];
            var modulesCustomAttribute = sceneObjectData.modulesCustomAttributes[sceneObjectIndex];
        }
        else {
            var stpInfo = sceneObjectData.statusPages[sceneObjectIndex];
            if (!stpInfo)
                return;
            var stp = stpInfo[stPageIndex - 1];
            if (!stp)
                return;
            var soData = stp.so;
            var modulesCustomAttribute = stp.modulesCustomAttribute;
        }
        this.setModuleDataIndexByIndex(soData, moduleIndex, toIndex, modulesCustomAttribute);
    };
    /**
     * 添加归档数据中的模块数据
     */
    SceneObjectData.setModuleDataIndexByIndex = function (soData, moduleIndex, toIndex, modulesCustomAttribute) {
        if (modulesCustomAttribute) {
            var m = modulesCustomAttribute.splice(moduleIndex, 1)[0];
            modulesCustomAttribute.splice(toIndex, 0, m);
        }
        if (soData.moduleIDs) {
            var m = soData.moduleIDs.splice(moduleIndex, 1)[0];
            soData.moduleIDs.splice(toIndex, 0, m);
        }
        if (soData.moduleDisplayList) {
            var m = soData.moduleDisplayList.splice(moduleIndex, 1)[0];
            soData.moduleDisplayList.splice(toIndex, 0, m);
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 状态页
    //------------------------------------------------------------------------------------------------------
    /**
     * 新建状态页
     * @param sceneObjectData 场景数据
     * @param soIndex 场景对象的索引
     * @param stpID 状态页ID 2-n
     */
    SceneObjectData.newStatusPage = function (sceneObjectData, soIndex, stpID, stpData) {
        if (stpData === void 0) { stpData = null; }
        if (stpID < 1)
            return;
        // 初始化状态页
        var statusPages = sceneObjectData.statusPages[soIndex];
        if (!statusPages)
            statusPages = sceneObjectData.statusPages[soIndex] = [];
        // 新建状态页
        var statusPageData = stpData ? stpData : {
            // 场景对象基础属性
            so: new SceneObject,
            // 场景对象的自定义属性:类型参考 CustomAttributeSetting.ATTR_TYPE_XXXX
            customAttribute: {},
            // 条件和事件
            event: {
                condition: [],
                customCommands: []
            }
        };
        // 插入到指定的页中
        statusPages.splice(stpID - 1, 0, statusPageData);
        // 
        this.formatOneStatusPageModuleCustomData(sceneObjectData, soIndex, stpID + 1);
    };
    /**
     * 删除状态页数据
     * @param sceneObjectData 场景数据
     * @param soIndex 场景对象的索引
     * @param stpID 状态页ID 0-n
     */
    SceneObjectData.delStatusPage = function (sceneObjectData, soIndex, stpID) {
        if (stpID < 0)
            return;
        var statusPages = sceneObjectData.statusPages[soIndex];
        if (!statusPages || statusPages.length == 0)
            return;
        // 如果删除的状态页是主页的话，将第一个分页顺位到主页
        if (stpID == 0) {
            var stp = statusPages.splice(0, 1)[0];
            sceneObjectData.sceneObjects[soIndex] = stp.so;
            sceneObjectData.events[soIndex] = stp.event;
            sceneObjectData.customAttributes[soIndex] = stp.customAttribute;
            sceneObjectData.modulesCustomAttributes[soIndex] = stp.modulesCustomAttribute;
        }
        // 删除分页：直接删除
        else {
            statusPages.splice(stpID - 1, 1);
        }
    };
    /**
     * 清空状态页数据
     */
    SceneObjectData.clearStatusPage = function (sceneObjectData, soIndex, stpID) {
        if (stpID < 0)
            return;
        var statusPageData = {
            so: new SceneObject,
            customAttribute: {},
            event: {
                condition: [],
                customCommands: []
            },
            customAttributesCache: null,
            modulesCustomAttribute: [],
            modulesCustomAttributesCaches: null
        };
        if (stpID == 0) {
            sceneObjectData.sceneObjects[soIndex] = statusPageData.so;
            sceneObjectData.events[soIndex] = statusPageData.event;
            sceneObjectData.customAttributes[soIndex] = statusPageData.customAttribute;
            sceneObjectData.modulesCustomAttributes[soIndex] = statusPageData.modulesCustomAttribute;
        }
        else {
            var statusPages = sceneObjectData.statusPages[soIndex];
            statusPages[stpID - 1] = statusPageData;
        }
    };
    /**
     * 获取状态页克隆数据
     * @param sceneObjectData 指定的场景的对象数据
     * @param soIndex 对象索引
     * @param stpID 状态页
     * @param cloneSceneObject [可选] 默认值=true 是否克隆场景对象属性
     * @param cloneBehavior [可选] 默认值=true 是否克隆行为
     * @param cloneCustomAttribute [可选] 默认值=true 是否克隆自定义属性
     * @param cloneEvent [可选] 默认值=true 是否克隆条件和事件
     */
    SceneObjectData.getStatusPageCloneData = function (sceneObjectData, soIndex, stpID, cloneSceneObject, cloneBehavior, cloneCustomAttribute, cloneEvent) {
        if (cloneSceneObject === void 0) { cloneSceneObject = true; }
        if (cloneBehavior === void 0) { cloneBehavior = true; }
        if (cloneCustomAttribute === void 0) { cloneCustomAttribute = true; }
        if (cloneEvent === void 0) { cloneEvent = true; }
        if (stpID == 0) {
            statusPageData = {
                // 场景对象基础属性
                so: SceneObject.__gcClone(sceneObjectData.sceneObjects[soIndex]),
                // 场景对象的自定义属性:类型参考 CustomAttributeSetting.ATTR_TYPE_XXXX
                customAttribute: ObjectUtils.depthClone(sceneObjectData.customAttributes[soIndex]),
                // 条件和事件
                event: ObjectUtils.depthClone(sceneObjectData.events[soIndex]),
                // 实例的模块数据设定
                modulesCustomAttribute: ObjectUtils.depthClone(sceneObjectData.modulesCustomAttributes[soIndex])
            };
        }
        else if (stpID >= 1) {
            var statusPages = sceneObjectData.statusPages[soIndex];
            var refStp = statusPages[stpID - 1];
            var statusPageData = {
                // 场景对象基础属性
                so: SceneObject.__gcClone(refStp.so),
                // 场景对象的自定义属性:类型参考 CustomAttributeSetting.ATTR_TYPE_XXXX
                customAttribute: ObjectUtils.depthClone(refStp.customAttribute),
                // 条件和事件
                event: ObjectUtils.depthClone(refStp.event),
                // 实例的模块数据设定
                modulesCustomAttribute: ObjectUtils.depthClone(refStp.modulesCustomAttribute)
            };
        }
        return statusPageData;
    };
    //------------------------------------------------------------------------------------------------------
    //  私有实现
    //------------------------------------------------------------------------------------------------------
    /**
     * 初始化模块数据 moduleIDs
     * 当没有moduleIDs的时候设置为其对应原型预设的模块
     * @param sceneObjectData 指定场景全对象的数据
     * @param sceneObjectIndex 指定场景对象的索引
     * @param statusPageID  场景对象的状态页编号 1~N
     * @return 是否进行了初始化
     */
    SceneObjectData.initModuleData = function (sceneObjectData, sceneObjectIndex, statusPageID) {
        if (Config.useNewSceneObjectModel) {
            if (statusPageID == 1) {
                var soData = sceneObjectData.sceneObjects[sceneObjectIndex];
            }
            else {
                var statusPages = sceneObjectData.statusPages[sceneObjectIndex];
                if (statusPages) {
                    var page = statusPages[statusPageID - 2];
                    if (page)
                        soData = page.so;
                }
            }
            if (soData) {
                this.initModuleDataBySceneObjectData(soData);
            }
        }
        return false;
    };
    /**
     * 初始化模块数据 moduleIDs
     * 没有设定过的话则安装默认值（即模型中预安装的模块）
     * @param sceneObjectData
     */
    SceneObjectData.initModuleDataBySceneObjectData = function (soData) {
        if (soData.moduleIDs == null) {
            var sceneObjectModelList = Common.sceneObjectModelList;
            if (sceneObjectModelList) {
                var modelData = sceneObjectModelList.data[soData.modelID];
                if (modelData) {
                    soData.moduleIDs = modelData.presetModules.concat();
                }
                else {
                    soData.moduleIDs = [];
                }
            }
        }
    };
    /**
     * 格式化单一的显示对象数据（单个对象的单个状态页）
     * @param soData 对象
     * @param refModelData 参考模块
     * @param displayList 对应的显示对象列表数据
     */
    SceneObjectData.formatDisplayList = function (soData, refModelData, displayList) {
        // 剔除多余的无用属性
        for (var varName in displayList) {
            var m = ArrayUtils.matchAttributes(refModelData.preLayer, { varName: varName }, true);
            if (m.length == 0) {
                delete displayList[varName];
            }
        }
        // 增加属性或当类型不对的时候修正为默认值
        for (var i = 0; i < refModelData.preLayer.length; i++) {
            var p = refModelData.preLayer[i];
            var displayInfo = displayList[p.varName];
            // 类型不匹配的情况换成默认值，或者是固定显示对象的情况
            if (displayInfo == null || displayInfo.type != p.type || p.type == 2 || p.type == 4) {
                var valueID = (p.type == SceneObjectModelData.TYPE_UI_TYPE || p.type == SceneObjectModelData.TYPE_ANIMATION_TYPE) ? 0 : p.id;
                displayList[p.varName] = { type: p.type, id: valueID };
            }
        }
    };
    /**
     * 格式化一个状态页的自定义模块数据（含模块中的显示对象）
     * -- SceneObjectData::modulesCustomAttributes 以及状态页的modulesCustomAttributes
     * -- soData.moduleDisplayList 以及状态页的moduleDisplayList
     * @param soData
     * @param customAttributesArr
     */
    SceneObjectData.doFormatOneStatusPageModuleCustomData = function (soData, customAttributesArr) {
        if (!Config.useNewSceneObjectModel)
            return;
        for (var m = 0; m < soData.moduleIDs.length; m++) {
            var moduleID = soData.moduleIDs[m];
            var modlueData = Common.sceneObjectModuleList.data[moduleID];
            // -- 如果该模块存在的话，则格式化该数据
            if (modlueData) {
                // -- 格式化自定义属性
                var customAttributes = customAttributesArr[m];
                if (!customAttributes)
                    customAttributes = customAttributesArr[m] = {};
                CustomAttributeSetting.formatCustomData(customAttributes, modlueData.varAttributes);
                // -- 格式化显示对象数据
                if (!soData.moduleDisplayList)
                    soData.moduleDisplayList = [];
                var displayList = soData.moduleDisplayList[m];
                if (!displayList)
                    displayList = soData.moduleDisplayList[m] = {};
                this.formatDisplayList(soData, modlueData, displayList);
            }
            // -- 不存在则剔除该模块以及对应该模块的显示对象数据
            else {
                var customAttributes = customAttributesArr[m];
                if (customAttributes) {
                    customAttributesArr.splice(m, 1);
                }
                var soModuleDisplay = soData.moduleDisplayList[m];
                if (soModuleDisplay) {
                    soData.moduleDisplayList.splice(m, 1);
                }
                soData.moduleIDs.splice(m, 1);
                m--;
            }
        }
    };
    return SceneObjectData;
}());
/**
 * 场景对象模型数据/场景对象模块数据
 * -- Game.data.sceneObjectModelList 场景对象模型数据，里面可能包含多个场景对象模块数据
 * -- Game.data.sceneObjectModuleList 场景对象模块数据（ALT+F9）
 *
 * Created by 黑暗之神KDS on 2018-10-05 01:49:56.
 */
var SceneObjectModelData = /** @class */ (function (_super) {
    __extends(SceneObjectModelData, _super);
    function SceneObjectModelData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * 预设
         * varName 变量名
         * type 1-指定AVATAR类 2-指定UI 3-指定UI类 4-指定动画 5-指定动画类
         * idList 对应的类别集合-仅供于预览列出使用
         * id 对应
         * isPreView 是否预览
         * inEditorShowMode 0-正常显示 1-仅在游戏运行时显示 2-仅在编辑器中显示
         */
        _this.preLayer = [];
        /**
         * 变量属性集设定
         */
        _this.varAttributes = [];
        /**
         * 控件出现的条件，对应变量属性集设定
         */
        _this.attrConditions = [];
        /**
         * 预先安装的模块（仅场景对象模型使用，模块化数据不需要）
         */
        _this.presetModules = [];
        /**
         * 实现的服务器类
         */
        _this.serverInstanceClassName = SceneObjectModelData.SERVER_SCENE_OBJECT_CORE_CLASS;
        /**
         * 实现的客户端类
         */
        _this.clientInstanceClassName = SceneObjectModelData.CLIENT_SCENE_OBJECT_CORE_CLASS;
        /**
         * 支持的触发事件集 0-表示条件 1-N表示事件集
         */
        _this.supportTriggerTypes = [];
        /**
         * 是否使用状态页
         */
        _this.supportStatusPage = true;
        return _this;
    }
    /**
     * 清理数据
     * -- 目前用于模块数据的清理
     */
    SceneObjectModelData.clear = function (modelData) {
        modelData.preLayer = [];
        modelData.varAttributes = [];
        modelData.serverInstanceClassName = null;
        modelData.clientInstanceClassName = null;
        delete modelData.presetModules;
    };
    /**
     * 初始化公共模块数据
     */
    SceneObjectModelData.initCommonModelData = function (modelData) {
        if (modelData.sysInitCommonModelData)
            return;
        modelData.serverInstanceClassName = SceneObjectModelData.SERVER_SCENE_OBJECT_COMMON_CLASS;
        modelData.clientInstanceClassName = SceneObjectModelData.CLIENT_SCENE_OBJECT_COMMON_CLASS;
        delete modelData.supportTriggerTypes;
        delete modelData.supportStatusPage;
        modelData.sysInitCommonModelData = true;
    };
    Object.defineProperty(SceneObjectModelData, "commonModelData", {
        /**
         * 公共模块
         */
        get: function () {
            return Common.sceneObjectModelList.data[0];
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 获取模型的显示对象和属性（含所有模块）
     * 旧版本：模型数据
     * 新版本：公共模块 + 安装的模块集合
     * @param modelData 模型数据
     * @param getPreLayer 显示列表设定数据
     * @param getVarAttributes 属性设定数据
     * @return [] 0=公共模块 1~N=安装的模块按顺序 moduleID-表示模块ID，0 即公共模块
     */
    SceneObjectModelData.getModelAttributeData = function (modelData) {
        var arr = [];
        if (Config.useNewSceneObjectModel) {
            var commonModelData = Game.data.sceneObjectModelList.data[0];
            arr.push({ moduleID: 0, preLayer: commonModelData.preLayer, varAttributes: commonModelData.varAttributes });
            for (var i = 0; i < modelData.presetModules.length; i++) {
                var moduleID = modelData.presetModules[i];
                var moduleData = Game.data.sceneObjectModuleList.data[moduleID];
                if (!moduleData)
                    continue;
                arr.push({ moduleID: moduleID, preLayer: moduleData.preLayer, varAttributes: moduleData.varAttributes });
            }
        }
        else {
            arr.push({ preLayer: modelData.preLayer, varAttributes: modelData.varAttributes });
        }
        return arr;
    };
    /**
     * 是否空数据 原型/模块
     * @param data
     */
    SceneObjectModelData.isEmpty = function (data, plugType) {
        // 已经设定了名称的话则不作为空数据
        if (plugType == 22) { // 模块
            var dataName = GameListData.getName(Game.data.sceneObjectModuleList, data.id, true);
        }
        else { // 原型
            dataName = GameListData.getName(Game.data.sceneObjectModelList, data.id, true);
        }
        if (dataName)
            return false;
        return data.preLayer.length == 0 && data.varAttributes.length == 0;
    };
    /**
     * 获取服务器版的场景对象模型基类
     * @param modelData 场景对象模型数据
     * @return [string] BASE类代码JS
     */
    SceneObjectModelData.getServerJsBaseCode = function (modelData) {
        return "var ServerSceneObject_" + modelData.id + " = (function (_super) {__extends(ServerSceneObject_" + modelData.id + ", _super);function ServerSceneObject_" + modelData.id + "(soData,presetCustomAttrs,player) {_super.apply(this, [soData,presetCustomAttrs,player]);}return ServerSceneObject_" + modelData.id + ";}(" + this.SERVER_SCENE_OBJECT_CORE_CLASS + "));";
    };
    //------------------------------------------------------------------------------------------------------
    //  新版本支持 模块化 Config.useNewSceneObjectModel
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取全场景对象模块服务器代码
     * @param mode 1-服务端 2-客户端
     */
    SceneObjectModelData.getAllAPICodeInEditorNew = function (mode) {
        var list = Game.data.sceneObjectModuleList;
        var codes = "/**\n * \u8BE5\u6587\u4EF6\u4E3AGameCreator\u7F16\u8F91\u5668\u81EA\u52A8\u751F\u6210\u7684\u4EE3\u7801\uFF0C\u8BF7\u52FF\u4FEE\u6539\n */\n";
        // 场景对象模块基类
        var commonModelData = EUIWindowSceneObjectModel.commonModelDataClone ? EUIWindowSceneObjectModel.commonModelDataClone : Game.data.sceneObjectModelList.data[0];
        var instanceClassName = mode == 1 ? commonModelData.serverInstanceClassName : commonModelData.clientInstanceClassName;
        codes += "/**\n * \u573A\u666F\u5BF9\u8C61\u6A21\u5757\u57FA\u7C7B\n */\nclass SceneObjectModule {\n    static moduleClassArr:(typeof SceneObjectModule)[] = [];\n    id: number; // \u6A21\u5757ID\n    name: string; // \u6A21\u5757\u540D\u79F0\n    so: " + instanceClassName + "; // \u573A\u666F\u5BF9\u8C61\u5B9E\u4F8B\n    isDisposed:boolean; // \u662F\u5426\u5DF2\u88AB\u9500\u6BC1\n    /**\n     * \u6784\u9020\u51FD\u6570\n     * @param installCB \u7528\u4E8E\u5B89\u88C5\u6A21\u5757\u7684\u5C5E\u6027\u503C\n     */\n    constructor(installCB: Callback) {\n        installCB && installCB.runWith([this]);\n    }\n    /**\n     * \u5F53\u79FB\u9664\u6A21\u5757\u65F6\u6267\u884C\u7684\u51FD\u6570\n     */\n    onRemoved():void {\n        \n    }\n    /**\n     * \u5237\u65B0\uFF1A\u901A\u5E38\u5728\u6539\u53D8\u4E86\u5C5E\u6027\u9700\u8981\u8C03\u7528\u6B64\u51FD\u6570\u7EDF\u4E00\u5237\u65B0\u6548\u679C\n     */\n    refresh():void {\n        \n    }\n    /**\n     * \u5F53\u5378\u8F7D\u6A21\u5757\u65F6\u6267\u884C\u7684\u51FD\u6570\n     */\n    dispose():void {\n        this.so = null;\n        this.name = null;\n        this.isDisposed = true;\n    }\n}\n";
        // 公共模块
        var allModuleData = [commonModelData].concat(list.data);
        for (var i in allModuleData) {
            var model = allModuleData[i];
            if (!model)
                continue;
            var modelID = model.id;
            if (EUIWindowSceneObjectModule.cloneData) {
                var newestModel = EUIWindowSceneObjectModule.cloneData.data[modelID];
                if (newestModel)
                    model = newestModel;
            }
            if (mode == 1) {
                var serverCode = this.getServerCodeNew(model, modelID == 0);
                codes += serverCode.serverSoBaseCode + "\n";
            }
            else if (mode == 2) {
                var clientCode = this.getClientCodeNew(model, modelID == 0);
                codes += clientCode.clientSoBaseCode + "\n";
            }
        }
        return codes;
    };
    /**
     * 获取服务器代码
     * @param modelData 场景对象模型数据
     * @param isCommon 是否公共模块
     * @return [BASE类代码,当前类代码]
     */
    SceneObjectModelData.getServerCodeNew = function (modelData, isCommon) {
        var serverVars = CustomAttributeSetting.getAPIRuntimes(modelData.varAttributes);
        if (isCommon) {
            var modelName = "场景对象公共类，任何场景对象都继承该类";
            var serverSoBaseCode = "/**\n * " + modelName + "\n */\nclass SceneObjectCommon extends ServerSceneObject {\n" + serverVars + "    constructor(soData: SceneObject,presetCustomAttrs: { [varName: string]: { varType: number, value: any, copy: boolean } } = null,player: GameServerPlayer) {\n        super(soData,presetCustomAttrs,player);\n    }\n}";
        }
        else {
            var sceneObjectModuleList = EUIWindowSceneObjectModule.cloneData ? EUIWindowSceneObjectModule.cloneData : Game.data.sceneObjectModuleList;
            var modelName_1 = GameListData.getName(sceneObjectModuleList, modelData.id);
            var commonModelData = EUIWindowSceneObjectModel.commonModelDataClone ? EUIWindowSceneObjectModel.commonModelDataClone : Game.data.sceneObjectModelList.data[0];
            var instanceClassName = commonModelData.serverInstanceClassName;
            var serverSoBaseCode = "/**\n * \u573A\u666F\u5BF9\u8C61\u6A21\u5757\uFF1A" + modelName_1 + "\n */\nclass SceneObjectModule_" + modelData.id + " extends SceneObjectModule {\n" + serverVars + "    constructor(installCB: Callback) {\n        super(installCB);\n    }\n    dispose() {\n    }\n}\nSceneObjectModule.moduleClassArr[" + modelData.id + "]=SceneObjectModule_" + modelData.id + ";";
        }
        return { serverSoBaseCode: serverSoBaseCode };
    };
    /**
     * 获取客户端代码
     * @param modelData 场景对象模型数据
     * @param isJS [可选] 默认值=false 是否JS代码
     * @return [BASE类代码,当前类代码]
     */
    SceneObjectModelData.getClientCodeNew = function (modelData, isCommon) {
        var clientVars = CustomAttributeSetting.getAPIRuntimes(modelData.varAttributes, true);
        var clientDisplayVars = "";
        for (var i in modelData.preLayer) {
            var preLayer = modelData.preLayer[i];
            if (preLayer.inEditorShowMode == 2)
                continue;
            var varTypeStr = "";
            if (preLayer.type <= 1) {
                continue;
            }
            else if (preLayer.type == 2) {
                var uiData = Common.uiList.data[preLayer.id];
                if (!uiData)
                    continue;
                if (uiData.uiDisplayData.instanceClassName) {
                    varTypeStr += uiData.uiDisplayData.instanceClassName + ";\n";
                }
                else {
                    varTypeStr += "GUI_" + preLayer.id + ";\n";
                }
            }
            else if (preLayer.type == 3) {
                varTypeStr = "UIRoot;\n";
            }
            else if (preLayer.type <= 5) {
                varTypeStr = "GCAnimation;\n";
            }
            clientDisplayVars += "    " + preLayer.varName + ": " + varTypeStr;
        }
        if (isCommon) {
            var modelName = "场景对象公共类，任何场景对象都继承该类";
            var clientSoBaseCode = "/**\n * " + modelName + "\n */\nclass SceneObjectCommon extends ClientSceneObject {\n" + clientVars + clientDisplayVars + "    constructor(soData: SceneObject, scene: ClientScene) {\n        super(soData,scene);\n    }\n}";
        }
        else {
            var sceneObjectModuleList = EUIWindowSceneObjectModule.cloneData ? EUIWindowSceneObjectModule.cloneData : Game.data.sceneObjectModuleList;
            var modelName_2 = GameListData.getName(sceneObjectModuleList, modelData.id);
            var commonModelData = EUIWindowSceneObjectModel.commonModelDataClone ? EUIWindowSceneObjectModel.commonModelDataClone : Game.data.sceneObjectModelList.data[0];
            var instanceClassName = commonModelData.clientInstanceClassName;
            var clientSoBaseCode = "/**\n * \u573A\u666F\u5BF9\u8C61\u6A21\u578B\uFF1A" + modelName_2 + "\n */\nclass SceneObjectModule_" + modelData.id + " extends SceneObjectModule {\n" + clientVars + clientDisplayVars + "    constructor(installCB: Callback) {\n        super(installCB);\n    }\n}\nSceneObjectModule.moduleClassArr[" + modelData.id + "]=SceneObjectModule_" + modelData.id + ";";
        }
        return { clientSoBaseCode: clientSoBaseCode };
    };
    //------------------------------------------------------------------------------------------------------
    //  旧版本支持
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取全场景对象模型服务器代码
     * @param mode 1-服务端 2-客户端
     */
    SceneObjectModelData.getAllAPICodeInEditor = function (mode) {
        if (Config.useNewSceneObjectModel)
            return SceneObjectModelData.getAllAPICodeInEditorNew(mode);
        var list = Game.data.sceneObjectModelList;
        var codes = "/**\n * \u8BE5\u6587\u4EF6\u4E3AGameCreator\u7F16\u8F91\u5668\u81EA\u52A8\u751F\u6210\u7684\u4EE3\u7801\uFF0C\u8BF7\u52FF\u4FEE\u6539\n */\n";
        for (var i in list.data) {
            var model = list.data[i];
            if (!model)
                continue;
            if (EUIWindowSceneObjectModel.modelData && model.id == EUIWindowSceneObjectModel.modelData.id) {
                model = EUIWindowSceneObjectModel.modelData;
            }
            if (mode == 1) {
                var serverCode = this.getServerCode(model);
                codes += serverCode.serverSoBaseCode + "\n";
            }
            else if (mode == 2) {
                var clientCode = this.getClientCode(model);
                codes += clientCode.clientSoBaseCode + "\n";
            }
        }
        return codes;
    };
    /**
     * 获取服务器代码
     * @param modelData 场景对象模型数据
     * @return [BASE类代码,当前类代码]
     */
    SceneObjectModelData.getServerCode = function (modelData) {
        var serverVars = CustomAttributeSetting.getAPIRuntimes(modelData.varAttributes);
        var modelName = GameListData.getName(Common.sceneObjectModelList, modelData.id);
        var serverSoBaseCode = "/**\n * \u573A\u666F\u5BF9\u8C61\u6A21\u578B\uFF1A" + modelName + "\n */\nclass ServerSceneObject_" + modelData.id + " extends " + this.SERVER_SCENE_OBJECT_CORE_CLASS + " {\n" + serverVars + "    constructor(soData: SceneObject,presetCustomAttrs: { [varName: string]: { varType: number, value: any, copy: boolean } } = null,player: GameServerPlayer) {\n        super(soData,presetCustomAttrs,player);\n    }\n}";
        return { serverSoBaseCode: serverSoBaseCode };
    };
    /**
     * 获取客户端代码
     * @param modelData 场景对象模型数据
     * @param isJS [可选] 默认值=false 是否JS代码
     * @return [BASE类代码,当前类代码]
     */
    SceneObjectModelData.getClientCode = function (modelData) {
        var clientVars = CustomAttributeSetting.getAPIRuntimes(modelData.varAttributes, true);
        var clientDisplayVars = "";
        for (var i in modelData.preLayer) {
            var preLayer = modelData.preLayer[i];
            if (preLayer.inEditorShowMode == 2)
                continue;
            var varTypeStr = "";
            if (preLayer.type <= 1) {
                continue;
            }
            else if (preLayer.type == 2) {
                var uiData = Common.uiList.data[preLayer.id];
                if (!uiData)
                    continue;
                if (uiData.uiDisplayData.instanceClassName) {
                    varTypeStr += uiData.uiDisplayData.instanceClassName + ";\n";
                }
                else {
                    varTypeStr += "GUI_" + preLayer.id + ";\n";
                }
            }
            else if (preLayer.type == 3) {
                varTypeStr = "UIRoot;\n";
            }
            else if (preLayer.type <= 5) {
                varTypeStr = "GCAnimation;\n";
            }
            clientDisplayVars += "    " + preLayer.varName + ": " + varTypeStr;
        }
        var modelName = GameListData.getName(Common.sceneObjectModelList, modelData.id);
        var clientSoBaseCode = "/**\n * \u573A\u666F\u5BF9\u8C61\u6A21\u578B\uFF1A" + modelName + "\n */\nclass ClientSceneObject_" + modelData.id + " extends " + this.CLIENT_SCENE_OBJECT_CORE_CLASS + " {\n" + clientVars + clientDisplayVars + "    constructor(soData: SceneObject, scene: ClientScene) {\n        super(soData,scene);\n    }\n}";
        return { clientSoBaseCode: clientSoBaseCode };
    };
    /**
     * 获取客户端版的场景对象模型基类
     * @param modelData 场景对象模型数据
     * @return [string] BASE类代码JS
     */
    SceneObjectModelData.getClientJsBaseCode = function (modelData) {
        return "var ClientSceneObject_" + modelData.id + " = (function (_super) {__extends(ClientSceneObject_" + modelData.id + ", _super);function ClientSceneObject_" + modelData.id + "(soData,scene) {_super.apply(this, [soData,scene]);}return ClientSceneObject_" + modelData.id + ";}(" + this.CLIENT_SCENE_OBJECT_CORE_CLASS + "));";
    };
    /**
     * 系统指定的上层 ServerSceneObject 基类（兼容旧版）
     */
    SceneObjectModelData.SERVER_SCENE_OBJECT_CORE_CLASS = "GameServerSceneObject_Core";
    /**
     * 系统指定的上层 ClientSceneObject 基类（兼容旧版）
     */
    SceneObjectModelData.CLIENT_SCENE_OBJECT_CORE_CLASS = "GameClientSceneObject_Core";
    /**
     * 新版本模块化场景对象 ServerSceneObject 公共继承类（唯一）
     */
    SceneObjectModelData.SERVER_SCENE_OBJECT_COMMON_CLASS = "GameServerSceneObject";
    /**
     * 新版本模块化场景对象 ClientSceneObject 公共继承类（唯一）
     */
    SceneObjectModelData.CLIENT_SCENE_OBJECT_COMMON_CLASS = "GameClientSceneObject";
    /**
     * 指定AVATAR类别
     */
    SceneObjectModelData.TYPE_AVATAR_TYPE = 1;
    /**
     * 指定的UI
     */
    SceneObjectModelData.TYPE_UI_DESIGNATION = 2;
    /**
     * 指定的UI类别
     */
    SceneObjectModelData.TYPE_UI_TYPE = 3;
    /**
     * 指定动画
     */
    SceneObjectModelData.TYPE_ANIMATION_DESIGNATION = 4;
    /**
     * 指定动画类别
     */
    SceneObjectModelData.TYPE_ANIMATION_TYPE = 5;
    /**
     * 指定对应的类
     */
    SceneObjectModelData.sceneObjectClass = {};
    return SceneObjectModelData;
}(OriginalData));
/**
 * 代替客户端可能不存在的SceneObjectModule
 */
var SceneObjectModuleBase = /** @class */ (function () {
    function SceneObjectModuleBase(installCB) {
        installCB && installCB.runWith([this]);
    }
    SceneObjectModuleBase.prototype.onRemoved = function () { };
    SceneObjectModuleBase.prototype.refresh = function () { };
    SceneObjectModuleBase.prototype.dispose = function () { };
    SceneObjectModuleBase.moduleClassArr = [];
    return SceneObjectModuleBase;
}());
/**
 * Created by 黑暗之神KDS on 2019-03-09 11:38:16.
 */
var ScriptData = /** @class */ (function (_super) {
    __extends(ScriptData, _super);
    function ScriptData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ScriptData;
}(OriginalData));
/**
 * Created by 黑暗之神KDS on 2018-10-16 17:49:10.
 */
var TileData = /** @class */ (function (_super) {
    __extends(TileData, _super);
    function TileData() {
        var _this = _super.call(this) || this;
        /**
         * 图片路径
         */
        _this.url = "";
        /**
        * 数据层数据
        */
        _this.dataLayers = [];
        /**
         * 宽度
         */
        _this.width = 0;
        /**
         * 高度
         */
        _this.height = 0;
        return _this;
    }
    /**
     * 运行时使用，获取图块数据
     */
    TileData.getTileData = function (texID) {
        if (Config.IS_SERVER)
            return ServerWorld.gameData.tileList.data[texID];
        return Game.data.tileList.data[texID];
    };
    /**
     * 是否空数据
     * @param data
     */
    TileData.isEmpty = function (data, plugType) {
        // 已经设定了名称的话则不作为空数据
        var tileName = GameListData.getName(Game.data.tileList, data.id, true);
        if (tileName)
            return false;
        return !data.url;
    };
    return TileData;
}(OriginalData));
/**
 * 过渡数据
 * Created by JayLen on 2020-11-17 21:55:01.
 */
var TransData = /** @class */ (function () {
    function TransData() {
        /**
         * 过渡方式：0-均匀过渡 1-缓动过渡 2-曲线过渡 3-立即
         */
        this.transType = 0;
        /**
         * 循环方式：0-无(一次) 1-循环 2-一次往返-返回时从头过渡 3-一次往返-返回时从尾过渡 4-循环往返-返回时从头过渡 5-循环往返-返回时从尾过渡
         */
        this.loopType = 0;
        /**
         * 时间类别：0-无() 1-帧数 2-秒数 3-可选择单位
         */
        this.timeType = 0;
        /**
         * 时间单位：0-帧数 1-秒数
         */
        this.timeUnit = 1;
        /**
         * 总时间数(帧数或者秒数)
         */
        this.totalTime = 2;
        /**
         * 缓动方式
         */
        this.tweenType = 0;
        /**
         * 缓动方式名称(如backOut)
         */
        this.tweenTypeName = "linearNone";
        /**
         * 曲线数据
         */
        this.curveData = [[0, 0, 0, 99, 1, 1, 1, 3], [0, 100, 100]];
        /**
         * 刷新时间(默认16，表示16毫秒，逐帧刷新)
         */
        this.refreshInterval = 16;
    }
    /**
     * 是否循环
     */
    TransData.isLoop = function (transData) {
        return transData.loopType == 1 || transData.loopType == 4 || transData.loopType == 5;
    };
    /**
     * 是否使用帧
     */
    TransData.isUseFrame = function (transData) {
        return transData.timeType == 1 || (transData.timeType == 3 && transData.timeUnit == 0);
    };
    /**
     * 是否使用时间
     */
    TransData.isUseTime = function (transData) {
        return transData.timeType == 2 || (transData.timeType == 3 && transData.timeUnit == 1);
    };
    return TransData;
}());
/**
 * UI的条件和事件数据
 * Created by 黑暗之神KDS on 2019-02-19 04:29:42.
 */
var UICommandData = /** @class */ (function (_super) {
    __extends(UICommandData, _super);
    function UICommandData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * 条件
         */
        _this.condition = [];
        /**
         * 点击事件
         */
        _this.click = [];
        return _this;
    }
    return UICommandData;
}(OriginalData));
/**
 * UI数据
 * Created by 黑暗之神KDS on 2018-10-17 22:11:07.
 */
var UIData = /** @class */ (function (_super) {
    __extends(UIData, _super);
    function UIData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * UI显示数据，客户端访问
         */
        _this.uiDisplayData = new UIDisplayData();
        /**
         * UI事件数据，服务器访问
         * 控件ID -> {condition:Condition[],commands:any[][]}
         * root -> {commands:any[][]}
         */
        _this.uiCommandData = new OriginalData();
        return _this;
    }
    /**
     * 初始化
     */
    UIData.init = function (item) {
        item.uiDisplayData.id = item.id;
    };
    /**
     * 是否空界面
     */
    UIData.isEmpty = function (data) {
        // 如果名称不为空的话
        var uiName = GameListData.getName(Game.data.uiList, data.id, true);
        if (uiName)
            return false;
        // 确保uiCommandData为空
        var hasUiCommandData;
        for (var i in data.uiCommandData) {
            if (i == "id")
                continue;
            hasUiCommandData = true;
            break;
        }
        if (hasUiCommandData)
            return false;
        // 确保uiDisplayData为空
        return (!data.uiDisplayData.instanceClassName && data.uiDisplayData.root.children.length == 0);
    };
    return UIData;
}(OriginalData));
/**
 * UI的显示对象数据
 * Created by 黑暗之神KDS on 2019-02-19 04:28:40.
 */
var UIDisplayData = /** @class */ (function (_super) {
    __extends(UIDisplayData, _super);
    function UIDisplayData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.root = {
            children: []
        };
        return _this;
    }
    //------------------------------------------------------------------------------------------------------
    // 初始化
    //------------------------------------------------------------------------------------------------------
    /**
     * 初始化：运行UI基类和用户制作的UI类
     */
    UIDisplayData.init = function (data, runScriptDomain) {
        if (!data)
            return;
        // 追加UI基类：解析该UI数据
        var baseCode = "var GUI_" + data.id + " = window[\"GUI_" + data.id + "\"] = (function (_super) {__extends(GUI_" + data.id + ", _super);function GUI_" + data.id + "(isRoot) {if (isRoot === void 0) { isRoot = true; };_super.apply(this, [isRoot," + data.id + "]);\n        var data = Game.data.uiList.data[" + data.id + "];if(!data)return;GameUI.parse(data.uiDisplayData,false,null," + data.id + ",this);}return GUI_" + data.id + ";}(UIComponent.UIRoot));";
        baseCode += "var ListItem_" + data.id + " = (function (_super) {__extends(ListItem_" + data.id + ", _super);function ListItem_" + data.id + "() {_super.apply(this);}return ListItem_" + data.id + ";}(UIListItemData));";
        try {
            runScriptDomain.eval(baseCode);
        }
        catch (e) {
            alert("Initialization ui-" + data.id + " base code error!");
        }
    };
    /**
     * 获取全基类API
     */
    UIDisplayData.getAllBaseCode = function (uiList) {
        var allLen = GameListData.getAllLength(uiList);
        if (allLen == 0)
            return "";
        var runtimeCode = "/**\n * \u8BE5\u6587\u4EF6\u4E3AGameCreator\u7F16\u8F91\u5668\u81EA\u52A8\u751F\u6210\u7684\u4EE3\u7801\uFF0C\u8BF7\u52FF\u4FEE\u6539\n */\n";
        for (var typeID = 1; typeID <= 16; typeID++) {
            var len = GameListData.getLength(uiList, typeID);
            for (var s = 1; s <= len; s++) {
                var uiData = GameListData.getItem(uiList, typeID, s);
                if (!uiData)
                    continue;
                uiData.uiDisplayData.id = GameListData.getID(typeID, s);
                runtimeCode += UIDisplayData.getBaseCode(uiData.uiDisplayData, uiList) + "\n";
            }
        }
        // -- 追加全组件的自定义属性，以便存档使用
        var uicompCustomAttrs = {};
        for (var i = 0; i < Editor.data.editorUIComp.length; i++) {
            var compData = Editor.data.editorUIComp[i];
            var compObj = uicompCustomAttrs[compData.class] = [];
            for (var s = 0; s < compData.attributes.length; s++) {
                var a = compData.attributes[s];
                if (a.enable)
                    compObj.push(a.attribute);
            }
        }
        runtimeCode += "GameUI[\"__compCustomAttributes\"] = " + JSON.stringify(uicompCustomAttrs) + ";\n";
        return runtimeCode;
    };
    /**
     * 获取单个基类API
     */
    UIDisplayData.getBaseCode = function (data, uiList) {
        var varAttributes = "";
        var listItemVarAttributes = "";
        var nameMapping = {};
        var compItemList = ArrayUtils.getTreeNodeArray(data.root, "children");
        compItemList.shift();
        var listItemTypeMapping = {
            UIBitmap: "string",
            UIString: "string",
            UIVariable: "number",
            UIAvatar: "number",
            UIStandAvatar: "number",
            UIAnimation: "number",
            UIInput: "string",
            UICheckBox: "boolean",
            UISwitch: "number",
            UITabBox: "string",
            UISlider: "number",
            UIGUI: "number",
            UIList: "UIListItemData[]"
        };
        for (var i = 0; i < compItemList.length; i++) {
            var compItem = compItemList[i];
            if (nameMapping[compItem.name])
                continue;
            nameMapping[compItem.name] = true;
            var type = compItem.type;
            if (type == "UIGUI") {
                var guiData = uiList.data[compItem.guiID];
                if (!guiData)
                    continue;
                if (compItem.instanceClassName) {
                    type = compItem.instanceClassName;
                }
                else if (guiData.uiDisplayData.instanceClassName) {
                    type = guiData.uiDisplayData.instanceClassName;
                }
                else {
                    type = "GUI_" + compItem.guiID;
                }
            }
            else {
                type = "" + type;
            }
            // 替换类别
            if (type == "UICustomGameNumber" || type == "UICustomGameString") {
                type = "UIString";
            }
            varAttributes += "   " + compItem.name + ":" + type + ";";
            var listItemType = listItemTypeMapping[compItem.type];
            if (listItemType) {
                listItemVarAttributes += "   " + compItem.name + ":" + listItemType + ";";
                if (compItem.type == "UIList") {
                    varAttributes += " // Item=" + compItem.itemModelGUI;
                }
                if (i != compItemList.length - 1)
                    listItemVarAttributes += "\n";
            }
            if (i != compItemList.length - 1)
                varAttributes += "\n";
        }
        var name = GameListData.getName(uiList, data.id);
        var runtimeCode = "\n/**\n * " + data.id + "-" + name + " [BASE]\n */\nclass GUI_" + data.id + " extends GUI_BASE {\n" + varAttributes + "\n   constructor(){\n      super(" + data.id + ");\n   }\n}";
        runtimeCode += "\nclass ListItem_" + data.id + " extends UIListItemData {\n" + listItemVarAttributes + "\n}";
        // -- 增加List-Item 运行时
        return runtimeCode;
    };
    return UIDisplayData;
}(OriginalData));
/**
 * Created by 黑暗之神KDS on 2018-10-16 17:58:39.
 */
var GameListData = /** @class */ (function () {
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     *
     * @param folder
     * @param listName
     * @param listData
     * @param childCls 子项类
     * @param listType 对应 GameData::LIST_TYPE_XXXXX
     */
    function GameListData(folder, listName, listData, listType, arrayModeIndex) {
        if (arrayModeIndex === void 0) { arrayModeIndex = null; }
        /**
         * 数据：列表 dataShowMode：null/0=列表 1=树  typeTreeNode=树模式下的缓存数据  部分数据形态是特殊的，如场景列表原本就是树结构且不支持文件夹等等
         */
        this.listData = {};
        /**
         * 数据：单个数据
         */
        this.data = [];
        this.folder = folder;
        this.listName = listName;
        this.listData = listData;
        this.listType = listType;
        this.arrayModeIndex = arrayModeIndex;
    }
    //------------------------------------------------------------------------------------------------------
    // ID、LocalID、Type
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取ID：根据TYPEID和INDEX
     * @param typeID
     * @param index
     * @return [number]
     */
    GameListData.getID = function (typeID, index) {
        return (typeID - 1) * 1000 + index;
    };
    GameListData.getType = function (id) {
        if (id == 0)
            return 1;
        return Math.floor((id - 1) / 1000) + 1;
    };
    GameListData.getLocalID = function (id) {
        return (id - 1) % 1000 + 1;
    };
    /**
     * 获取数据
     * @gameListData 数据列表
     * @typeID 类别ID
     * @localID 相对ID
     */
    GameListData.getItem = function (gameListData, typeID, localID) {
        var id = GameListData.getID(typeID, localID);
        return gameListData.data[id];
    };
    /**
     * 获取所有数据
     */
    GameListData.getItems = function (gameListData) {
        var arr = [];
        for (var i in gameListData.data) {
            var d = gameListData.data[i];
            if (d)
                arr.push(d);
        }
        return arr;
    };
    /**
     * 获取ID范围，根据TYPEID
     * @param typeID
     * @param from  如1001
     * @param to  如2000
     */
    GameListData.getIDRange = function (typeID) {
        return { from: (typeID - 1) * 1000 + 1, to: (typeID - 1) * 1000 + 1000 };
    };
    //------------------------------------------------------------------------------------------------------
    // 原始数据操作
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取子项数据名称，根据项ID
     * @param gameListData 所属gameListData
     * @param id 数据ID
     * @param emptyName true则显示空，否则显示 --/--
     */
    GameListData.getName = function (gameListData, id, emptyName) {
        if (emptyName === void 0) { emptyName = false; }
        if (!gameListData.listData)
            return null;
        var name;
        if (gameListData.hasType) {
            var typeID = GameListData.getType(id);
            var typeArr = gameListData.listData.list[typeID];
            if (!typeArr)
                return "";
            name = typeArr[GameListData.getLocalID(id)];
        }
        else {
            name = gameListData.listData.list[id];
        }
        return name != null ? name : (emptyName ? "" : "--/--");
    };
    /**
     * 获取常用函数的全部名称数组（目前仅供无类别的列表，从ID=1开始）
     * @param gameListData 所属gameListData
     * @param includeID 是否包含ID
     */
    GameListData.getNames = function (gameListData, includeID) {
        if (includeID === void 0) { includeID = true; }
        if (gameListData.hasType)
            return null;
        var len = GameListData.getLength(gameListData, 1);
        var list = gameListData.listData.list.concat();
        list.shift();
        if (includeID) {
            for (var i = 0; i < list.length; i++) {
                var name = list[i];
                list[i] = (i + 1) + "-" + name;
            }
        }
        return list;
    };
    /**
     * 查询是否有重名
     */
    GameListData.hasSameName = function (gameListData, name) {
        if (gameListData.hasType) {
            for (var i = 0; i < 16; i++) {
                var typeArr = gameListData.listData.list[i];
                if (typeArr && typeArr.indexOf) {
                    if (typeArr.indexOf(name) != -1)
                        return true;
                }
            }
        }
        else {
            var len = GameListData.getLength(gameListData, 1);
            var list = gameListData.listData.list.concat();
            list.shift();
            return list.indexOf(name) != -1;
        }
        return false;
    };
    /**
     * 设置子项数据名称
     * @param gameListData 所属gameListData
     * @param id 数据ID
     */
    GameListData.setName = function (gameListData, id, name) {
        if (!gameListData.listData)
            return null;
        if (gameListData.hasType) {
            var typeID = Math.floor((id - 1) / 1000) + 1;
            gameListData.listData.list[typeID][GameListData.getLocalID(id)] = name;
        }
        else {
            gameListData.listData.list[id] = name;
        }
    };
    /**
     * 修改指定组的数据长度
     * @param cls 子项类型
     * @param gameListData 所属列表
     * @param typeID 类型
     * @param currentListMaximum 当前值
     * @param setMaximum 最大值
     * @param 返回变更的差值
     */
    GameListData.changeMaximum = function (cls, gameListData, typeID, currentListMaximum, setMaximum) {
        // 创建新的数据
        if (currentListMaximum < setMaximum) {
            if (gameListData.hasType) {
                if (!gameListData.listData.list[typeID])
                    gameListData.listData.list[typeID] = [];
            }
            var startID = GameListData.getID(typeID, currentListMaximum) + 1;
            var len = setMaximum - currentListMaximum;
            for (var i = 0; i < len; i++) {
                var itemData = new cls();
                var id = itemData.id = startID + i;
                gameListData.data[id] = itemData;
                if (gameListData.hasType) {
                    gameListData.listData.list[typeID][currentListMaximum + 1 + i] = "";
                }
                else {
                    gameListData.listData.list[currentListMaximum + 1 + i] = "";
                }
            }
        }
        // 删除数据
        else if (currentListMaximum > setMaximum) {
            var range = GameListData.getIDRange(typeID);
            var startID = range.from + setMaximum;
            for (var i = startID; i < range.to; i++) {
                gameListData.data[i] = null;
                if (gameListData.hasType) {
                    if (gameListData.listData.list[typeID]) {
                        gameListData.listData.list[typeID].length = setMaximum + 1;
                    }
                }
                else {
                    gameListData.listData.list.length = setMaximum + 1;
                }
            }
        }
    };
    /**
     * 新增数据
     * @param cls 数据类型
     * @param gameListData 数据列表
     * @param name 新名称
     */
    GameListData.insertNewData = function (cls, gameListData, newName, dataType) {
        if (dataType === void 0) { dataType = null; }
        // 查找空位置插入
        var newItemData = new cls();
        var len = dataType == null ? gameListData.data.length : 16 * 1000;
        var insertID = -1;
        var startIndex = dataType == null ? 1 : ((dataType - 1) * 1000 + 1);
        for (var i = startIndex; i < len; i++) {
            if (!GameListData.getName(gameListData, i, true)) {
                insertID = i;
                break;
            }
        }
        if (insertID == -1) {
            insertID = len == 0 ? 1 : len;
        }
        gameListData.data[insertID] = newItemData;
        newItemData.id = insertID;
        var typeID = GameListData.getType(insertID);
        if (gameListData.hasType) {
            if (!gameListData.listData.list[typeID])
                gameListData.listData.list[typeID] = [];
            var localID = GameListData.getLocalID(insertID);
            gameListData.listData.list[typeID][localID] = newName;
        }
        else {
            gameListData.listData.list[insertID] = newName;
        }
        return insertID;
    };
    /**
     * 获取数据长度（中间可能存在null数据）
     */
    GameListData.getLength = function (gameListData, typeID) {
        if (typeID === void 0) { typeID = null; }
        if (gameListData.hasType) {
            var list = gameListData.listData.list[typeID];
            return list ? list.length - 1 : 0;
        }
        else {
            return gameListData.listData.list.length - 1;
        }
    };
    /**
     * 获取全数据长度（全类别）
     */
    GameListData.getAllLength = function (gameListData) {
        if (gameListData.hasType) {
            var allLen = 0;
            for (var typeID = 1; typeID <= 16; typeID++) {
                var list = gameListData.listData.list[typeID];
                allLen += list ? list.length - 1 : 0;
            }
            return allLen;
        }
        else {
            return gameListData.listData.list.length - 1;
        }
    };
    /**
     * 修改类型名称
     *
     */
    GameListData.changeTypName = function (gameListData, typeID, name) {
        gameListData.listData.type[typeID] = name;
    };
    /**
     * 获取类型名称
     */
    GameListData.getTypName = function (gameListData, typeID) {
        return gameListData.listData.type ? gameListData.listData.type[typeID] : null;
    };
    /**
     * 设置为新的数据
     * @param cls 子项类别
     * @param gameListData 所属组
     * @param id 指定项ID 0-表示新增
     * @param name item名称
     */
    GameListData.setNewData = function (cls, gameListData, id, name) {
        if (id === void 0) { id = 0; }
        if (name === void 0) { name = ""; }
        var itemData = new cls();
        if (id == 0) {
            if (gameListData.hasType)
                return;
            var list = gameListData.listData.list;
            id = list.length;
        }
        itemData.id = id;
        this.setData(gameListData, id, itemData, name);
        return itemData;
    };
    /**
     * 设置数据
     */
    GameListData.setData = function (gameListData, id, itemData, name) {
        if (id === void 0) { id = 0; }
        if (id == 0) {
            var list = gameListData.hasType ? gameListData.listData.list[typeID] : gameListData.listData.list;
            id = list.length;
        }
        if (gameListData.hasType) {
            var typeID = GameListData.getType(id);
            gameListData.listData.list[typeID][GameListData.getLocalID(id)] = name;
        }
        else {
            gameListData.listData.list[id] = name;
        }
        gameListData.data[id] = itemData;
    };
    /**
     * 卸载指定数据
     */
    GameListData.disposeData = function (gameListData, id) {
        if (gameListData.hasType) {
            var typeID = GameListData.getType(id);
            gameListData.listData.list[typeID][GameListData.getLocalID(id)] = null;
        }
        else {
            gameListData.listData.list[id] = null;
        }
        gameListData.data[id] = null;
    };
    /**
     * 抽离指定数据
     * @param gameListData 所属组
     * @param id 指定项ID
     * @param autoOrder 是否自动重新排序，元素确保是连续的
     */
    GameListData.remove = function (gameListData, id, autoOrder) {
        if (autoOrder === void 0) { autoOrder = false; }
        var list;
        var index;
        if (gameListData.hasType) {
            var typeID = GameListData.getType(id);
            list = gameListData.listData.list[typeID];
            index = GameListData.getLocalID(id);
        }
        else {
            list = gameListData.listData.list;
            index = id;
        }
        list[index] = null;
        if (!autoOrder)
            return;
        list.splice(index, 1);
        gameListData.data.splice(index, 1);
        for (var i = id; i < gameListData.data.length; i++) {
            var data = gameListData.data[i];
            if (data)
                data.id = i;
        }
    };
    return GameListData;
}());
/**
 * UIList 使用的数据
 * Created by 黑暗之神KDS on 2019-07-09 15:04:42.
 */
var UIListItemData = /** @class */ (function () {
    function UIListItemData() {
        this._children = [];
        this._isOpen = true;
    }
    /**
     * 提取储存数据
     * @param includeData [可选] 默认值=false 是否包含自定义附加的数据，请保证该数据可以JSON化
     */
    UIListItemData.prototype.getSaveData = function (includeData) {
        if (includeData === void 0) { includeData = false; }
        var dData = {};
        for (var i in this.uiNames) {
            dData[i] = this[i];
        }
        if (includeData)
            dData.data = this.data;
        var len = this._children.length;
        if (len > 0) {
            dData.children = [];
            for (var s = 0; s < this._children.length; s++) {
                var item = this._children[s];
                dData.children.push(item.getSaveData(includeData));
            }
        }
        dData.isOpen = this.isOpen;
        return dData;
    };
    /**
     * 还原储存数据
     * @param saveData
     */
    UIListItemData.recoverySaveData = function (saveData) {
        var d = new UIListItemData();
        for (var i in saveData) {
            if (i == "children")
                continue;
            d[i] = saveData[i];
        }
        for (var i in saveData.children) {
            var saveDataChild = saveData.children[i];
            var dChild = UIListItemData.recoverySaveData(saveDataChild);
            d.addChild(dChild);
        }
        return d;
    };
    Object.defineProperty(UIListItemData.prototype, "isOpen", {
        /** 是否处于打开状态（树节点的情况） */
        get: function () { return this._isOpen; },
        set: function (v) {
            if (v != this._isOpen) {
                this._isOpen = v;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UIListItemData.prototype, "uiNames", {
        /**
         * 获取UI名称
         * @return [string]
         */
        get: function () {
            var _uiNames = [];
            var _attrs = [];
            for (var s in UIListItemData.uiListItemDataHelper) {
                _attrs.push(s);
            }
            for (var i in this) {
                if (_attrs.indexOf(i) != -1)
                    continue;
                _uiNames.push(i);
            }
            return _uiNames;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UIListItemData.prototype, "parent", {
        /**
         * 获取父节点
         * @return [UIListItemData]
         */
        get: function () { return this._parent; },
        enumerable: false,
        configurable: true
    });
    /**
     * 添加节点
     * @param item 节点数据对象
     */
    UIListItemData.prototype.addChild = function (item) { this._children.push(item); item._parent = this; };
    /**
     * 添加节点到指定索引中
     * @param item 节点数据对象
     * @param index 插入所在索引
     */
    UIListItemData.prototype.addChildAt = function (item, index) { this._children.splice(index, 0, item); item._parent = this; };
    /**
     * 移除节点
     * @param item 节点数据对象
     */
    UIListItemData.prototype.removeChild = function (item) { this._children.splice(this._children.indexOf(item), 1); item._parent = null; };
    /**
     * 移除节点至指定索引中
     * @param index 节点所在的索引
     */
    UIListItemData.prototype.removeChildAt = function (index) { var item = this._children.splice(index, 1)[0]; item._parent = null; };
    /**
     * 移除所有节点
     */
    UIListItemData.prototype.removeAll = function () { for (var i in this._children) {
        this._children[i]._parent = null;
    } ; this._children.length = 0; };
    /**
     * 获取节点根据索引
     * @param index 节点所在的索引
     * @return [UIListItemData]
     */
    UIListItemData.prototype.getChildAt = function (index) { return this._children[index]; };
    /**
     * 获取节点索引
     * @param item 节点数据对象
     */
    UIListItemData.prototype.getChildIndex = function (item) { return this._children.indexOf(item); };
    Object.defineProperty(UIListItemData.prototype, "numChildren", {
        /**
         * 子节点总数
         */
        get: function () { return this._children.length; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UIListItemData.prototype, "children", {
        /**
         * 子节点列表
         */
        get: function () { return this._children; },
        enumerable: false,
        configurable: true
    });
    /**
     * 是否继承于指定节点
     */
    UIListItemData.prototype.isInherit = function (data) {
        var p = this.parent;
        while (p) {
            if (p == data)
                return true;
            p = p._parent;
        }
        return false;
    };
    /**
     * 获取树型结构下全部节点中的子节点列表（含自身节点）
     * @param arr
     */
    UIListItemData.prototype.getList = function (arr) {
        if (arr === void 0) { arr = null; }
        return ArrayUtils.getTreeNodeArray(this, "_children", arr);
    };
    Object.defineProperty(UIListItemData.prototype, "root", {
        /**
         * 获取树形结构的根节点
         * @return [UIListItemData]
         */
        get: function () {
            var p = this;
            while (true) {
                if (p._parent) {
                    p = p._parent;
                }
                else {
                    break;
                }
            }
            return p;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UIListItemData.prototype, "depth", {
        /**
         * 获取所在树的深度
         * @return [number]
         */
        get: function () {
            var p = this;
            var d = 0;
            while (1) {
                if (!p.parent)
                    break;
                d++;
                p = p.parent;
            }
            return d;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UIListItemData.prototype, "isHideNode", {
        /**
         * 是否是隐藏节点（即父系节点可能被关闭了）
         */
        get: function () {
            var p = this.parent;
            while (1) {
                if (!p)
                    break;
                if (!p.isOpen)
                    return true;
                p = p.parent;
            }
            return false;
        },
        enumerable: false,
        configurable: true
    });
    /** 参考 */
    UIListItemData.uiListItemDataHelper = new UIListItemData();
    return UIListItemData;
}());
/**
 * 游戏数据：包含游戏中全部数据
 * [server]
 *   -- 每个线程分配数据：sceneList
 *   -- 每个线程都有数据：sceneObjectModelList commonEventList
 *
 * [client]
 *   -- 根据需求动态加载卸载相应的数据
 *
 * [editor]
 *   -- 全部数据操作
 *
 * 后期可以将没有动态加载的数据都一次性合并掉
 * Created by 黑暗之神KDS on 2018-10-16 17:58:04.
 */
var GameData = /** @class */ (function () {
    function GameData() {
        /**
         * 自定义模块数据表：即具体的数据设定，下标对应[customModuleList]的设定
         */
        this.customModuleDataList = [];
    }
    //------------------------------------------------------------------------------------------------------
    // 模块数据
    //------------------------------------------------------------------------------------------------------
    GameData.getModuleData = function (moduleID, dataID) {
        if (moduleID <= 0)
            return null;
        var moduleData = GameData.customModulePresetDatas[moduleID];
        return moduleData ? moduleData[dataID] : null;
    };
    /**
     * 新建一个指定模块的数据
     * @param moduleID 自定义模块ID
     * @param dataID 数据ID
     * @param isCopy [可选] 默认值=true 是否是数据副本，
     *        如果是副本：数据与原数据已脱离关系，原数据的更改不会影响该数据的更改，该数据的值来自存档值。
     *                    比如一件装备原始攻击+10，而极品装备攻击+15，即使调整了原始数据攻击变为25后，该装备攻击仍然是15
     *        如果不是副本：则是引用原数据的关系，数据仍使用原模型数据的值。
     *                    比如一件装备原始攻击+10，你获得后，设计人员调整了攻击变为25后，该件装备会自动变为攻击+25
     */
    GameData.newModuleData = function (moduleID, dataID, isCopy) {
        if (isCopy === void 0) { isCopy = false; }
        var modelData = GameData.getModuleData(moduleID, dataID);
        var oriDataCopy = modelData ? ObjectUtils.depthClone(modelData) : null;
        if (oriDataCopy) {
            if (!isCopy) {
                oriDataCopy["gcsysref"] = [moduleID, dataID];
            }
            else {
                oriDataCopy["gcsyscopy"] = [moduleID, dataID];
            }
        }
        return oriDataCopy;
    };
    /**
     * 更改模块数据为副本模式，使用此函数可以将引用关系的数据转化为副本
     * @param data 模块数据
     * @param moduleID 模块编号
     */
    GameData.changeModuleDataToCopyMode = function (data, moduleID) {
        if (!data || !data.id)
            return;
        delete data["gcsysref"];
        data["gcsyscopy"] = [moduleID, data.id];
    };
    /**
     * 判断数据是否是副本模式
     * @param data 模块数据
     * @return 是否副本模式
     */
    GameData.isCopyModeData = function (data) {
        if (!data || !data.id)
            return false;
        return data["gcsyscopy"] != null;
    };
    /**
     * 获取指定模块的数据总长度
     * @param moduleID 模块 1-N
     * @param typeID [可选] 默认值=1 类型1-16
     * @return [number]
     */
    GameData.getLength = function (moduleID, typeID) {
        if (typeID === void 0) { typeID = 1; }
        var list = Common.getCustomModuleDataList(moduleID);
        if (!list)
            return 0;
        return GameListData.getLength(list, typeID);
    };
    //------------------------------------------------------------------------------------------------------
    // 加载完整数据
    //------------------------------------------------------------------------------------------------------
    /**
     * 加载世界变量名称数据
     */
    GameData.prototype.loadVariableList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_VARIABLE, OriginalData, [], "asset/json/variable/", "variable.json", onFin);
    };
    /**
     * 加载世界开关名称数据
     */
    GameData.prototype.loadSwitchList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_SWITCH, OriginalData, [], "asset/json/variable/", "switch.json", onFin);
    };
    /**
     * 加载世界字符串名称数据
     */
    GameData.prototype.loadStringList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_STRING, OriginalData, [], "asset/json/variable/", "string.json", onFin);
    };
    /**
     * 加载玩家变量名称数据
     */
    GameData.prototype.loadPlayerVariableList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_PLAYER_VARIABLE, OriginalData, [], "asset/json/server/variable/", "variable.json", onFin);
    };
    /**
     * 加载开关名称数据
     */
    GameData.prototype.loadPlayerSwitchList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_PLAYER_SWITCH, OriginalData, [], "asset/json/server/variable/", "switch.json", onFin);
    };
    /**
     * 加载字符串名称数据
     */
    GameData.prototype.loadPlayerStringList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_PLAYER_STRING, OriginalData, [], "asset/json/server/variable/", "string.json", onFin);
    };
    /**
     * 加载场景数据 [editor/server]
     * @param onFin 完成回调 onFin(isSuccess)
     * @param itemNeedMethod [可选]如果存在则根据该方法决定是否需要数据 默认null
     */
    GameData.prototype.loadSceneList = function (onFin, itemNeedMethod) {
        if (itemNeedMethod === void 0) { itemNeedMethod = null; }
        this.onLoadList(GameData.LIST_TYPE_SCENE, SceneData, [
            { childAttribute: "mapData", path: "asset/json/scene/data/scene" },
            { childAttribute: "sceneObjectData", path: "asset/json/server/scene/s" }
        ], "asset/json/scene/", "sceneList.json", onFin, false, itemNeedMethod);
    };
    /**
     * 场景对象模型数据
     * @param onFin 完成回调 onFin(isSuccess)
     */
    GameData.prototype.loadSceneObjectModelList = function (onFin, isServer) {
        var _this = this;
        if (isServer === void 0) { isServer = false; }
        var onRealFin = Callback.New(function () {
            // 加载公共模块
            if (Config.useNewSceneObjectModel) {
                // 同步任务1：加载0号（内部 GameData.loadDataTask）
                _this.onLoadOne(0, GameData.LIST_TYPE_SCENE_OBJECT_MODEL, SceneObjectModelData, [
                    { childAttribute: null, path: "asset/json/scene/model/som" }
                ], "asset/json/scene/", "sceneObjectModelList.json", false, null, null, true);
                // 同步任务2：完成
                new SyncTask(GameData.loadDataTask, function () {
                    // -- 初始化公共模块数据（已初始化则忽略）
                    var commonModelData = _this.sceneObjectModelList.data[0];
                    SceneObjectModelData.initCommonModelData(commonModelData);
                    onFin.run();
                    SyncTask.taskOver(GameData.loadDataTask);
                });
            }
            else {
                onFin.run();
            }
        }, this);
        // 加载常规的列表和专用模型
        this.onLoadList(GameData.LIST_TYPE_SCENE_OBJECT_MODEL, SceneObjectModelData, [
            { childAttribute: null, path: "asset/json/scene/model/som" }
        ], "asset/json/scene/", "sceneObjectModelList.json", onRealFin, false);
    };
    /**
     * 加载场景对象模块化数据
     */
    GameData.prototype.loadSceneObjectModuleList = function (onFin) {
        if (!Config.useNewSceneObjectModel) {
            onFin.delayRun(0);
            return;
        }
        this.onLoadList(GameData.LIST_TYPE_SCENE_OBJECT_MODULE, SceneObjectModelData, [
            { childAttribute: null, path: "asset/json/scene/sceneObjectModule/soModule" }
        ], "asset/json/scene/", "sceneObjectModuleList.json", onFin, false, null, false, null, true);
    };
    /**
     * 加载图块数据
     */
    GameData.prototype.loadTileList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_TILE, TileData, [
            { childAttribute: null, path: "asset/json/scene/tile/tile" }
        ], "asset/json/scene/", "tileList.json", onFin, false);
    };
    /**
     * 加载自动图块元件数据
     */
    GameData.prototype.loadAutoTileList = function (onFin) {
        var childItems = Config.fragmentFileVersion ? [{ childAttribute: null, path: "asset/json/scene/autoTile/autoTile" }] : [];
        this.onLoadList(GameData.LIST_TYPE_AUTO_TILE, AutoTileData, childItems, "asset/json/scene/", "autoTileList.json", onFin, false, null, false, null, true);
    };
    /**
     * 加载avatar
     */
    GameData.prototype.loadAvatarList = function (onFin) {
        var _this = this;
        this.onLoadList(GameData.LIST_TYPE_AVATAR, AvatarData, [
            { childAttribute: null, path: "asset/json/avatar/data/avatar" }
        ], "asset/json/avatar/", "avatarList.json", Callback.New(function () {
            // 升级部件：由原来随意装填升级为按照部件位，由于原来没有部件列表，这里按照顺序装填
            EditorData.avatarJsonVersionUpgrade1(_this, false);
            onFin.run();
        }, this), true, null, true);
    };
    /**
     * 加载avatar action
     */
    GameData.prototype.loadAvatarActList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_AVATAR_ACT, OriginalData, [], "asset/json/avatar/", "avatarActList.json", onFin, false);
    };
    /**
     * 加载avatar部件列表
     */
    GameData.prototype.loadAvatarPartList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_AVATAR_PART, OriginalData, [], "asset/json/avatar/", "avatarPartList.json", onFin, false, null, false, null, true);
    };
    /**
     * 加载avatar refobj
     */
    GameData.prototype.loadAvatarRefObjList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_AVATAR_REF_OBJ, AvatarRefObjData, [], "asset/json/avatar/", "avatarRefObjList.json", onFin, false);
    };
    /**
     * 加载立绘列表
     */
    GameData.prototype.loadStandingList = function (onFin) {
        var _this = this;
        this.onLoadList(GameData.LIST_TYPE_STANDING, AvatarData, [
            { childAttribute: null, path: "asset/json/standAvatar/data/standAvatar" }
        ], "asset/json/standAvatar/", "standAvatarList.json", Callback.New(function () {
            // 升级部件：由原来随意装填升级为按照部件位，由于原来没有部件列表，这里按照顺序装填
            EditorData.avatarJsonVersionUpgrade1(_this, true);
            onFin.run();
        }, this), true, null, false);
    };
    /**
     * 加载立绘表情列表
     */
    GameData.prototype.loadStandingExpressionList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_STANDING_EXPRESSION, OriginalData, [], "asset/json/standAvatar/", "expressionList.json", onFin, false);
    };
    /**
     * 加载立绘部件列表
     */
    GameData.prototype.loadStandingPartList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_STAND_AVATAR_PART, OriginalData, [], "asset/json/standAvatar/", "standAvatarPartList.json", onFin, false, null, false, null, true);
    };
    /**
     * 公共事件数据
     */
    GameData.prototype.loadCommonEventList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_COMMON_EVENT, CommonEventData, [
            { childAttribute: null, path: "asset/json/server/command/data/ws" }
        ], "asset/json/server/command/", "worldCommand.json", onFin);
    };
    /**
     * 对话框
     */
    GameData.prototype.loadDialogList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_DIALOG, DialogData, [
            { childAttribute: null, path: "asset/json/dialog/data/dialog" }
        ], "asset/json/dialog/", "dialogList.json", onFin, false);
    };
    /**
     * 动画
     */
    GameData.prototype.loadAnimationList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_ANIMATION, AnimationData, [
            { childAttribute: null, path: "asset/json/animation/data/ani" }
        ], "asset/json/animation/", "animationList.json", onFin);
    };
    /**
     * 加载Animation Signal
     */
    GameData.prototype.loadAnimationSignalList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_ANIMATION_SIGNAL, OriginalData, [], "asset/json/animation/", "animationSignalList.json", onFin, false);
    };
    /**
     * UI
     */
    GameData.prototype.loadUIList = function (onFin) {
        var childData = [{ childAttribute: "uiCommandData", path: "asset/json/server/ui/sui" }];
        // 单机内核无需加载uiCommandData，目前需要这个来判定是否存在事件，可以优化
        // if (Config.SINGLE_PLAYER_CORE) {
        //     childData = [];
        // }
        childData.unshift({ childAttribute: "uiDisplayData", path: "asset/json/ui/data/ui" });
        this.onLoadList(GameData.LIST_TYPE_UI, UIData, childData, "asset/json/ui/", "uiList.json", onFin);
    };
    /**
     * 加载数据结构
     */
    GameData.prototype.loadDataStructureList = function (onFin) {
        var childItems = Config.fragmentFileVersion ? [{ childAttribute: null, path: "asset/json/custom/dataStructure/ds" }] : [];
        this.onLoadList(GameData.LIST_TYPE_DATA_STRUCTURE, CustomCompositeSetting, childItems, "asset/json/custom/", "dataStructure.json", onFin, true);
    };
    /**
     * 加载自定义模块
     */
    GameData.prototype.loadCustomModuleList = function (onFin) {
        var _this = this;
        var childItems = Config.fragmentFileVersion ? [{ childAttribute: null, path: "asset/json/custom/customModuleSetting/cmSetting" }] : [];
        this.onLoadList(GameData.LIST_TYPE_CUSTOM_MODULE, CustomCompositeSetting, childItems, "asset/json/custom/", "customModuleList.json", Callback.New(function () {
            var customSettingList = _this.customModuleList;
            var len = GameListData.getLength(customSettingList);
            var loadCount = len;
            if (loadCount == 0)
                onFin.run();
            for (var i = 1; i <= len; i++) {
                if (!customSettingList.data[i])
                    continue;
                _this.onLoadList(GameData.LIST_TYPE_CUSTOM_MODULE_DATA, CustomData, [
                    { childAttribute: null, path: "asset/json/custom/customModule/" + i + "/cm" }
                ], "asset/json/custom/customModule/", "customModuleDataList" + i + ".json", Callback.New(function () {
                    loadCount--;
                    if (loadCount == 0) {
                        onFin.run();
                    }
                }, _this), true, null, false, i);
            }
        }, this), false);
    };
    /**
     * 新建立自定义模块中的模块列表
     */
    GameData.newCustomModuleDataList = function (index) {
        var gameListData = new GameListData("asset/json/custom/customModule/", "customModuleDataList" + index + ".json", { list: {}, type: {} }, GameData.LIST_TYPE_CUSTOM_MODULE_DATA, index);
        return gameListData;
    };
    /**
     * 加载自定义游戏属性：世界、玩家
     */
    GameData.prototype.loadGameAttributeConfig = function (onFin) {
        var _this = this;
        if (Config.fragmentFileVersion) {
            FileUtils.loadJsonFile("asset/json/custom/customWorldSetting.json", Callback.New(function (worldSetting) {
                FileUtils.loadJsonFile("asset/json/custom/customPlayerSetting.json", Callback.New(function (playerSetting) {
                    FileUtils.loadJsonFile("asset/json/custom/customWorldData.json", Callback.New(function (worldData) {
                        FileUtils.loadJsonFile("asset/json/custom/customPlayerData.json", Callback.New(function (playerData) {
                            _this.customGameAttribute = new CustomGameAttribute();
                            _this.customGameAttribute.worldAttributeSetting = worldSetting;
                            _this.customGameAttribute.playerAttributeSetting = playerSetting;
                            _this.customGameAttribute.worldAttributeConfig = worldData;
                            _this.customGameAttribute.playerAttributeConfig = playerData;
                            onFin.run();
                        }, _this));
                    }, _this));
                }, _this));
            }, this));
        }
        else {
            FileUtils.loadJsonFile("asset/json/custom/customGameAttribute.json", Callback.New(function (jsonObj) {
                _this.customGameAttribute = new CustomGameAttribute();
                ObjectUtils.clone(jsonObj, _this.customGameAttribute);
                onFin.run();
            }, this));
        }
    };
    /**
     * 加载自定义事件类别
     */
    GameData.prototype.loadCustomEventType = function (onFin) {
        var _this = this;
        this.onLoadList(GameData.LIST_TYPE_CUSTOM_OBJECT_EVENT_TYPE, CustomEventType, [], "asset/json/custom/", "customObjectEventType.json", Callback.New(function () {
            _this.onLoadList(GameData.LIST_TYPE_CUSTOM_UI_EVENT_TYPE, CustomEventType, [], "asset/json/custom/", "customUIEventType.json", Callback.New(function () {
                this.onLoadList(GameData.LIST_TYPE_CUSTOM_SCENE_EVENT_TYPE, CustomEventType, [], "asset/json/custom/", "customSceneEventType.json", onFin, false);
            }, _this), false);
        }, this), false);
    };
    /**
     * 加载自定义命令
     */
    GameData.prototype.loadCustomCommandType = function (onFin) {
        var childItems = Config.fragmentFileVersion ? [{ childAttribute: null, path: "asset/json/custom/cmd/cmd" }] : [];
        this.onLoadList(GameData.LIST_TYPE_CUSTOM_COMMAND_TYPE, CustomCompositeSetting, childItems, "asset/json/custom/", "customCommandType.json", onFin, true);
    };
    /**
     * 加载自定义行为命令
     */
    GameData.prototype.loadCustomBehaviorType = function (onFin) {
        var childItems = Config.fragmentFileVersion ? [{ childAttribute: null, path: "asset/json/custom/behavior/behavior" }] : [];
        this.onLoadList(GameData.LIST_TYPE_CUSTOM_BEHAVIOR_TYPE, CustomCompositeSetting, childItems, "asset/json/custom/", "customBehaviorType.json", onFin, false);
    };
    /**
     * 加载自定义条件
     */
    GameData.prototype.loadCustomCondition = function (onFin) {
        var conditonJSONName = Config.fragmentFileVersion ? "customCondition.json" : "cumtomCondition.json";
        var childItems = Config.fragmentFileVersion ? [{ childAttribute: null, path: "asset/json/custom/condition/condition" }] : [];
        this.onLoadList(GameData.LIST_TYPE_CUSTOM_CONDITION, CustomCompositeSetting, childItems, "asset/json/custom/", conditonJSONName, onFin, false, null, false, null, true);
    };
    /**
     * 加载自定义游戏数值
     */
    GameData.prototype.loadCustomDataDisplayInUI = function (onFin) {
        if (Config.fragmentFileVersion) {
            var childItems = [{ childAttribute: null, path: "asset/json/custom/gameNumber/num" }];
            var listName = "customGameNumberList.json";
        }
        else {
            childItems = [];
            var listName = "customDataDisplayList.json";
        }
        this.onLoadList(GameData.LIST_TYPE_CUSTOM_DATA_DISPLAY, CustomCompositeSetting, childItems, "asset/json/custom/", listName, onFin, false, null, false, null, true);
    };
    /**
     * 加载自定义游戏字符串
     */
    GameData.prototype.loadCustomGameString = function (onFin) {
        var childItems = Config.fragmentFileVersion ? [{ childAttribute: null, path: "asset/json/custom/gameString/str" }] : [];
        this.onLoadList(GameData.LIST_TYPE_CUSTOM_GAME_STRING, CustomCompositeSetting, childItems, "asset/json/custom/", "customGameStringList.json", onFin, false, null, false, null, true);
    };
    /**
     * 加载材质数据
     */
    GameData.prototype.loadMaterialList = function (onFin) {
        var childItems = Config.fragmentFileVersion ? [{ childAttribute: null, path: "asset/json/custom/material/material" }] : [];
        this.onLoadList(GameData.LIST_TYPE_MATERIAL, CustomCompositeSetting, childItems, "asset/json/custom/", "customMaterialList.json", onFin, false, null, false, null, true);
    };
    /**
     * 加载自定义值类型
     */
    GameData.prototype.loadCustomValueFunction = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_CUSTOM_VALUE_FUNCTION, OriginalData, [], "asset/json/custom/", "customValueFunction.json", onFin, false);
    };
    //------------------------------------------------------------------------------------------------------
    // 加载单独数据
    //------------------------------------------------------------------------------------------------------
    /**
     * 加载场景
     * @param id 场景ID
     * @param onFin 返回的数据
     */
    GameData.prototype.loadScene = function (id, onFin) {
        var sceneData = this.sceneList ? this.sceneList.data[id] : null;
        if (sceneData) {
            onFin.delayRun(0);
            return;
        }
        this.onLoadOne(id, "sceneList", SceneData, [
            { childAttribute: "mapData", path: "asset/json/scene/data/scene" },
            { childAttribute: "sceneObjectData", path: "asset/json/server/scene/s" }
        ], "asset/json/scene/", "sceneList.json", false);
        this.onLoadOneOver(id, onFin, "sceneList");
    };
    /**
     * 加载图块
     * @param id 图块ID
     * @param onFin 返回的数据
     */
    GameData.prototype.loadTile = function (id, onFin) {
        this.onLoadOne(id, "tileList", TileData, [
            { childAttribute: null, path: "asset/json/scene/tile/tile" }
        ], "asset/json/scene/", "tileList.json");
        this.onLoadOneOver(id, onFin, "tileList");
    };
    /**
     * 加载AVATAR
     */
    GameData.prototype.loadAvatar = function (id, onFin) {
        this.onLoadOne(id, "avatarList", AvatarData, [
            { childAttribute: null, path: "asset/json/avatar/data/avatar" }
        ], "asset/json/avatar/", "avatarList.json");
        this.onLoadOneOver(id, onFin, "avatarList");
    };
    /**
     * 加载立绘
     */
    GameData.prototype.loadStanding = function (id, onFin) {
        this.onLoadOne(id, "standAvatarList", AvatarData, [
            { childAttribute: null, path: "asset/json/standing/data/standAvatar" }
        ], "asset/json/standAvatar/", "standAvatarList.json");
        this.onLoadOneOver(id, onFin, "standAvatarList");
    };
    //------------------------------------------------------------------------------------------------------
    // 实现
    //------------------------------------------------------------------------------------------------------
    /**
     * 加载列表数据
     * @param saveAttribute 储存到的属性名
     * @param childCls 子项类
     * @param childItems childAttribute=子项储存的属性（null表示直接储存在指定类型中而不是子项） path=子文件夹路径（null表示folder）
     * @param folder 文件夹 如 asset/json/avatar/avatarList.json
     * @param listName 列表名 如 asset/json/avatar/avatarList.json
     * @param onFin 加载完成回调
     * @param hasType [可选]是否拥有类型 默认true
     * @param itemNeedMethod [可选]如果存在则根据该方法决定是否需要该数据 默认null
     * @param loadZero [可选]是否加载ID=0的数据 默认false
     * @param arrayModeIndex [可选]数组模式的列表索引，若存在则存入属性的数组中 默认null
     * @param allowNoFiles [可选] 是否允许没有文件 默认false
     *
     */
    GameData.prototype.onLoadList = function (saveAttribute, childCls, childItems, folder, listName, onFin, hasType, itemNeedMethod, loadZero, arrayModeIndex, allowNoFiles) {
        var _this = this;
        if (hasType === void 0) { hasType = true; }
        if (itemNeedMethod === void 0) { itemNeedMethod = null; }
        if (loadZero === void 0) { loadZero = false; }
        if (arrayModeIndex === void 0) { arrayModeIndex = null; }
        if (allowNoFiles === void 0) { allowNoFiles = false; }
        // load list.json file
        FileUtils.loadJsonFile(folder + listName, new Callback(function (listData) {
            if (!listData) {
                if (!allowNoFiles) {
                    throw ("加载文件失败：" + folder + listName);
                }
                else {
                    if (hasType) {
                        gameListData = new GameListData(folder, listName, { list: {}, type: {} }, saveAttribute, arrayModeIndex);
                    }
                    else {
                        gameListData = new GameListData(folder, listName, { list: {} }, saveAttribute, arrayModeIndex);
                        gameListData.listData.list = [null];
                    }
                    if (arrayModeIndex == null) {
                        _this[saveAttribute] = gameListData;
                    }
                    else {
                        _this[saveAttribute][arrayModeIndex] = gameListData;
                    }
                    gameListData.hasType = hasType;
                    new SyncTask(GameData.loadDataTask, function () {
                        onFin.run();
                        SyncTask.taskOver(GameData.loadDataTask);
                    });
                    return;
                }
            }
            // install list data
            var gameListData = new GameListData(folder, listName, listData, saveAttribute, arrayModeIndex);
            if (arrayModeIndex == null) {
                _this[saveAttribute] = gameListData;
            }
            else {
                _this[saveAttribute][arrayModeIndex] = gameListData;
            }
            gameListData.hasType = hasType;
            // install children data
            var typeList = hasType ? listData.list : { 1: listData.list };
            for (var typeID in typeList) {
                var typeDatas = typeList[typeID];
                for (var i = 0; i < typeDatas.length; i++) {
                    var dataName = typeDatas[i];
                    if (loadZero && i == 0 && typeID == "1") { }
                    else if (dataName == null) {
                        continue;
                    }
                    var id = GameListData.getID(parseInt(typeID), i);
                    if (itemNeedMethod && !itemNeedMethod(id))
                        continue;
                    _this.onLoadOne(id, saveAttribute, childCls, childItems, folder, listName, hasType, listData, arrayModeIndex);
                }
            }
            new SyncTask(GameData.loadDataTask, function () {
                onFin.run();
                SyncTask.taskOver(GameData.loadDataTask);
            });
        }, this), !allowNoFiles);
    };
    /**
     * 加载单一数据
     * @param id 元素ID
     * @param saveAttribute 储存到的属性名
     * @param childCls 子项类
     * @param childItems childAttribute=子项储存的属性（null表示直接储存在指定类型中而不是子项） path=子文件夹路径（null表示folder）
     * @param folder 文件夹 如 asset/json/avatar/avatarList.json
     * @param listName 列表名 如 asset/json/avatar/avatarList.json
     *
     */
    GameData.prototype.onLoadOne = function (id, saveAttribute, childCls, childItems, folder, listName, hasType, listData, arrayModeIndex, allowNoFiles) {
        if (hasType === void 0) { hasType = true; }
        if (listData === void 0) { listData = null; }
        if (arrayModeIndex === void 0) { arrayModeIndex = null; }
        if (allowNoFiles === void 0) { allowNoFiles = false; }
        var gameListData = this[saveAttribute];
        if (arrayModeIndex == null) {
            gameListData = this[saveAttribute];
        }
        else {
            gameListData = this[saveAttribute][arrayModeIndex];
        }
        if (gameListData == null) {
            if (hasType) {
                gameListData = new GameListData(folder, listName, { list: {}, type: {} }, saveAttribute, arrayModeIndex);
            }
            else {
                gameListData = new GameListData(folder, listName, { list: [null] }, saveAttribute, arrayModeIndex);
            }
            gameListData.hasType = hasType;
            if (arrayModeIndex == null) {
                this[saveAttribute] = gameListData;
            }
            else {
                this[saveAttribute][arrayModeIndex] = gameListData;
            }
        }
        // 存在则忽略加载
        if (gameListData.data[id])
            return;
        var gameData = gameListData.data[id] = new childCls();
        gameData.id = id;
        if (listData && listData.data) {
            var attrData = listData.data[id];
            ObjectUtils.clone(attrData, gameData);
        }
        for (var c = 0; c < childItems.length; c++) {
            var childItem = childItems[c];
            new SyncTask(GameData.loadDataTask);
            FileUtils.loadJsonFile(childItem.path + id + ".json", new Callback(function (gameData, id, childAttribute, itemData) {
                // 当没有数据的情况如果允许无文件模式：表示存在，无需复制属性值，默认新建的即可
                if (!itemData && allowNoFiles) {
                    itemData = {};
                }
                // 当仍然没有数据的情况
                if (!itemData) {
                    delete gameListData.data[id];
                    if (gameListData.hasType) {
                        gameListData.listData.list[GameListData.getType(id)][GameListData.getLocalID(id)] = null;
                    }
                    else {
                        gameListData.listData.list[id] = null;
                    }
                }
                else {
                    ObjectUtils.clone(itemData, childAttribute ? gameData[childAttribute] : gameData);
                    childAttribute ? gameData[childAttribute].id = id : gameData.id = id;
                }
                SyncTask.taskOver(GameData.loadDataTask);
            }, this, [gameData, id, childItem.childAttribute]));
        }
    };
    /**
     * 当加载一个完成时
     * @param id
     * @param onFin
     * @param saveAttribute
     */
    GameData.prototype.onLoadOneOver = function (id, onFin, saveAttribute) {
        new SyncTask(GameData.loadDataTask, function () {
            onFin.runWith([this[saveAttribute].data[id]]);
            SyncTask.taskOver(GameData.loadDataTask);
        }, [], this);
    };
    /**
     * 数据组类型
     */
    GameData.LIST_TYPE_VARIABLE = "variableNameList";
    GameData.LIST_TYPE_SWITCH = "switchNameList";
    GameData.LIST_TYPE_STRING = "stringNameList";
    GameData.LIST_TYPE_PLAYER_VARIABLE = "playerVariableNameList";
    GameData.LIST_TYPE_PLAYER_SWITCH = "playerSwitchNameList";
    GameData.LIST_TYPE_PLAYER_STRING = "playerStringNameList";
    GameData.LIST_TYPE_SCENE = "sceneList";
    GameData.LIST_TYPE_SCENE_OBJECT_MODEL = "sceneObjectModelList";
    GameData.LIST_TYPE_SCENE_OBJECT_MODULE = "sceneObjectModuleList";
    GameData.LIST_TYPE_TILE = "tileList";
    GameData.LIST_TYPE_AVATAR = "avatarList";
    GameData.LIST_TYPE_AVATAR_ACT = "avatarActList";
    GameData.LIST_TYPE_AVATAR_REF_OBJ = "avatarRefObjList";
    GameData.LIST_TYPE_STANDING = "standingList";
    GameData.LIST_TYPE_STANDING_EXPRESSION = "standingExpressionList";
    GameData.LIST_TYPE_COMMON_EVENT = "commonEventList";
    GameData.LIST_TYPE_DIALOG = "dialogList";
    GameData.LIST_TYPE_ANIMATION = "animationList";
    GameData.LIST_TYPE_ANIMATION_SIGNAL = "animationSignalList";
    GameData.LIST_TYPE_UI = "uiList";
    GameData.LIST_TYPE_DATA_STRUCTURE = "dataStructureList";
    GameData.LIST_TYPE_CUSTOM_MODULE = "customModuleList";
    GameData.LIST_TYPE_CUSTOM_MODULE_DATA = "customModuleDataList";
    GameData.LIST_TYPE_CUSTOM_OBJECT_EVENT_TYPE = "customObjectEventTypeList";
    GameData.LIST_TYPE_CUSTOM_UI_EVENT_TYPE = "customUIEventTypeList";
    GameData.LIST_TYPE_CUSTOM_SCENE_EVENT_TYPE = "customSceneEventTypeList";
    GameData.LIST_TYPE_CUSTOM_COMMAND_TYPE = "customCommandTypeList";
    GameData.LIST_TYPE_CUSTOM_BEHAVIOR_TYPE = "customBehaviorTypeList";
    GameData.LIST_TYPE_CUSTOM_CONDITION = "customConditionList";
    GameData.LIST_TYPE_CUSTOM_VALUE_FUNCTION = "customValueFunctionList";
    GameData.LIST_TYPE_AUTO_TILE = "autoTileList";
    GameData.LIST_TYPE_CUSTOM_DATA_DISPLAY = "customDataDisplayList";
    GameData.LIST_TYPE_AVATAR_PART = "avatarPartList";
    GameData.LIST_TYPE_STAND_AVATAR_PART = "standAvatarPartList";
    GameData.LIST_TYPE_MATERIAL = "materialList";
    GameData.LIST_TYPE_CUSTOM_GAME_STRING = "customGameStringList";
    /**
     * 自定义属性类别：世界属性
     */
    GameData.CUSTOM_ATTR_WORLD_DATA = 0;
    /**
     * 自定义属性类别：玩家属性
     */
    GameData.CUSTOM_ATTR_PLAYER_DATA = 1;
    /**
      * 自定义属性类别：场景属性
      */
    GameData.CUSTOM_ATTR_SCENE_DATA = 2;
    /**
     * 自定义属性类别：场景对象属性
     */
    GameData.CUSTOM_ATTR_SCENE_OBJECT_DATA = 3;
    /**
     * 自定义属性类别：场景对象模块属性
     */
    GameData.CUSTOM_ATTR_SCENE_OBJECT_MODULE_DATA = 4;
    /**
     * 加载数据任务名
     */
    GameData.loadDataTask = "GameData_loadDataTask";
    /** 自定义模块预设数据列表 [moduleID] = [] */
    GameData.customModulePresetDatas = [];
    return GameData;
}());
/**
 * [私有性：一般内部使用]
 * 文件操作系统：一般用于文本文件 如JSON/XML等储存数据格式的文件
 * -- 通用性：真服务器、虚拟服务器、客户端可用
 * Created by 黑暗之神KDS on 2018-06-22 21:37:50.
 */
var FileUtils = /** @class */ (function () {
    function FileUtils() {
    }
    Object.defineProperty(FileUtils, "hasFileOperationJurisdiction", {
        /**
         * 是否拥有文件系统权限：如写入文件、获取目录下全部文件列表等
         */
        get: function () {
            return Config.IS_SERVER || os.platform == 2 || Config.INDIA_APPLICATION_GAME_INFO != null;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 初始化
     */
    FileUtils.init = function () {
        // 客户端环境
        if (Common.runPlatform == 2) {
            FileUtils.loader = window["loader"];
            FileUtils.Handler = window["Handler"];
            if (os.inGC(false))
                FileUtils.nativePath = mainDomain_LGConfig.WORK_PATH;
            else if (typeof process != "undefined")
                FileUtils.nativePath = (process.cwd()).replace(/[\\\/]{1,999}/g, "/");
        }
        // 服务器环境
        else {
            FileUtils.readFile = eval("readFile");
            FileUtils.nativePath = eval("nativePath");
        }
    };
    //------------------------------------------------------------------------------------------------------
    //  判断
    //------------------------------------------------------------------------------------------------------
    /**
     * 文件（夹）是否存在
     * -- 需要 FileUtils.hasFileOperationJurisdiction
     * @param localURL 相对路径，如asset/json/xxx.json
     * @param onFin 当检查完毕时 onFin(isExists:boolean)
     */
    FileUtils.exists = function (localURL, onFin) {
        localURL = localURL.split("?")[0];
        if (FileUtils.hasFileOperationJurisdiction) {
            // 运行在在测试的独立窗口中的游戏时，以HTTP-SERVER方式传输给GC-IDE进行操作
            var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
            if (indiaAppGameInfo) {
                var rq = new HttpRequest();
                var data = JSON.stringify({ mode: 6, localURL: localURL });
                var IDEHttpServerURL = "http://127.0.0.1:" + indiaAppGameInfo.gcDebugPort + "/kdsrpg_http_indieapp.js?cmd=3";
                rq.send(IDEHttpServerURL, data, "post");
                rq.add_ERROR(function () {
                    onFin.runWith([false]);
                }, this);
                rq.add_COMPLETE(function (str) {
                    onFin.runWith([str == "ok"]);
                }, this);
                return;
            }
            // PC环境
            if (typeof require != "undefined") {
                var fs = mainDomain_fs;
                var isExists = fs.existsSync(FileUtils.nativePath + "/" + localURL);
                onFin.runWith([isExists]);
                return;
            }
        }
        onFin.runWith([true]);
    };
    //------------------------------------------------------------------------------------------------------
    // 读取
    //------------------------------------------------------------------------------------------------------
    /**
     * 加载JSON文件
     * @param localURL 加载文件的地址
     * @param onFin 加载完成或失败时回调（失败:obj=null）onFin(jsonObj) onFin.runWith([obj]);
     * @param onErrorTips 是否输出的错误信息
     */
    FileUtils.loadJsonFile = function (localURL, onFin, onErrorTips) {
        if (onErrorTips === void 0) { onErrorTips = true; }
        var tail = (Common.inGC) ? "?r=" + Math.random() : "";
        FileUtils.loadFile(localURL + tail, new Callback(function (text) {
            // trace("加载",localURL);
            if (!text) {
                onFin.runWith([null]);
                return;
            }
            // 如果是客户端环境且存在缓存的话直接返回
            if (Common.runPlatform == 2 && typeof text != "string") {
                onFin.runWith([text]);
                return;
            }
            try {
                // 去除注释
                text = text.replace(/(\n|^)[ \t]*\/\/.*/g, "");
                var jsonObj = JSON.parse(text);
                if (Common.runPlatform == 2) {
                    loader.cacheRes(localURL, jsonObj);
                }
            }
            catch (e) {
                trace(localURL + " parse error.");
                jsonObj = null;
            }
            onFin.runWith([jsonObj]);
        }, this), true, onErrorTips);
    };
    /**
     * 加载文件（文本格式）
     * @param localURL 加载文件的地址
     * @param onFin 加载完成或失败时回调（失败:text=null） onFin.runWith([text]);
     * @param errorMsg 输出的错误信息
     * @param isJson 是否JSON格式，客户端不缓存，而是转化为JSON后缓存
     * @param onErrorTips 是否输出的错误信息
     */
    FileUtils.loadFile = function (localURL, onFin, isJson, onErrorTips) {
        if (isJson === void 0) { isJson = false; }
        if (onErrorTips === void 0) { onErrorTips = true; }
        function onloaded(onFin, txt, localURL) {
            if (!txt) {
                if (onErrorTips)
                    trace(localURL + " not exist.");
            }
            onFin.runWith([txt]);
        }
        if (!onErrorTips && !Config.IS_SERVER) {
            FileUtils.exists(localURL, Callback.New(doLoadFile, this));
        }
        else {
            doLoadFile.call(this, true);
        }
        function doLoadFile(isExists) {
            if (!isExists) {
                onloaded(onFin, null, localURL);
                return;
            }
            if (Common.runPlatform == 2) {
                loader.load(localURL, Handler.create(this, function (onFin, localURL, txt) {
                    onloaded(onFin, txt, localURL);
                }, [onFin, localURL]), null, Loader.TEXT, 0, isJson ? false : true);
            }
            else {
                var txt = this.readFile(this.nativePath + localURL);
                if (txt == "[no exist]")
                    txt = null;
                onloaded(onFin, txt, localURL);
            }
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 复制粘贴文件
    //------------------------------------------------------------------------------------------------------
    /**
     * 复制粘贴文件
     * @param fromLocalURL 文件来源相对地址
     * @param toLocalURL 需要粘贴到的相对地址
     * @param onFin 完成时回调  onFin(success:boolean,fromLocalURL:string,toLocalURL:string)
     * @param onProgress [可选] 默认值=null 复制过程函数 onProgress(currentNum:number,totalNum:number);
     */
    FileUtils.cloneFile = function (fromLocalURL, toLocalURL, onFin, onProgress) {
        var _this_1 = this;
        if (onProgress === void 0) { onProgress = null; }
        new SyncTask(FileUtils.TASK_MODIFY_FILE, function () {
            var onCloneFileFin = Callback.New(function (success, fromLocalURL, toLocalURL) {
                onFin.runWith([success, fromLocalURL, toLocalURL]);
                SyncTask.taskOver(FileUtils.TASK_MODIFY_FILE);
            }, _this_1);
            // 非PC端环境时覆盖LocalStorage
            if (!Config.EDIT_MODE && (os.platform != 2)) {
                // 运行在在测试的独立窗口中的游戏时，以HTTP-SERVER方式传输给GC-IDE进行操作
                var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
                if (indiaAppGameInfo) {
                    var rq = new HttpRequest();
                    var data = JSON.stringify({ mode: 1, fromLocalURL: fromLocalURL, toLocalURL: toLocalURL });
                    var IDEHttpServerURL = "http://127.0.0.1:" + indiaAppGameInfo.gcDebugPort + "/kdsrpg_http_indieapp.js?cmd=3";
                    rq.send(IDEHttpServerURL, data, "post");
                    rq.add_ERROR(function () {
                        onCloneFileFin.delayRun(0, null, [false, fromLocalURL, toLocalURL]);
                    }, _this_1);
                    rq.add_COMPLETE(function (str) {
                        onCloneFileFin.delayRun(0, null, [str == "ok", fromLocalURL, toLocalURL]);
                    }, _this_1);
                    return;
                }
                // 使用Indexed
                if (IndexedDBManager.support && IndexedDBManager.used) {
                    IndexedDBManager.getIndexDBJson(fromLocalURL, function (value) {
                        if (value) {
                            IndexedDBManager.setIndexDBJson(toLocalURL, value, function (success) {
                                onCloneFileFin.delayRun(0, null, [success, fromLocalURL, toLocalURL]);
                            });
                        }
                        else {
                            onCloneFileFin.delayRun(0, null, [false, fromLocalURL, toLocalURL]);
                        }
                    });
                }
                // 使用LocalStorage
                else {
                    var isCloneFileSuccess = false;
                    try {
                        var fromDataObj = LocalStorage.getJSON(fromLocalURL);
                        if (fromDataObj) {
                            LocalStorage.setJSON(toLocalURL, fromDataObj);
                            isCloneFileSuccess = true;
                        }
                    }
                    catch (e) {
                        isCloneFileSuccess = false;
                        trace("can not clone file [" + fromLocalURL + "] to [" + toLocalURL + "]");
                    }
                    onCloneFileFin.delayRun(0, null, [isCloneFileSuccess, fromLocalURL, toLocalURL]);
                }
                return;
            }
            // 在GC环境下
            if (os.inGC(false)) {
                new mainDomain_FileObject(fromLocalURL, function (fromFo) {
                    if (!fromFo.exists) {
                        onCloneFileFin.delayRun(0, null, [false, fromLocalURL, toLocalURL]);
                        return;
                    }
                    fromFo.clone(toLocalURL, function () {
                        onCloneFileFin.delayRun(0, null, [true, fromLocalURL, toLocalURL]);
                    }, function () {
                        onCloneFileFin.delayRun(0, null, [false, fromLocalURL, toLocalURL]);
                    }, _this_1);
                }, _this_1, function () {
                    onCloneFileFin.delayRun(0, null, [false, fromLocalURL, toLocalURL]);
                });
                return;
            }
            // 非GC环境下的普通PC应用环境
            if (typeof require != "undefined") {
                var fs = require("fs");
                var fromFullPath = FileUtils.nativePath + "/" + fromLocalURL;
                var toFullPath = FileUtils.nativePath + "/" + toLocalURL;
                var fromExist = fs.existsSync(fromFullPath);
                if (!fromExist) {
                    onCloneFileFin.delayRun(0, null, [false, fromLocalURL, toLocalURL]);
                    return;
                }
                var stat = fs.statSync(fromFullPath);
                var fromIsDirectory = stat.isDirectory();
                if (!fromIsDirectory) {
                    FileUtils.doClone(fromLocalURL, toLocalURL, onCloneFileFin, 1);
                }
                else {
                    var _this = _this_1;
                    FileUtils.getAllChildFiles(fromLocalURL, Callback.New(function (fos) {
                        if (!fos) {
                            onCloneFileFin.delayRun(0, null, [false, fromLocalURL, toLocalURL]);
                            return;
                        }
                        FileUtils.doClone(fromLocalURL, toLocalURL, onCloneFileFin, fos.length, onProgress, stat);
                    }, _this_1), stat);
                }
            }
        });
    };
    FileUtils.doClone = function (fromLocalURL, toLocalURL, onFin, copyTotalCount, onProgress, fromStat) {
        if (onProgress === void 0) { onProgress = null; }
        if (fromStat === void 0) { fromStat = null; }
        var _this = this;
        var fs = require('fs'), stat = fs.stat;
        var copyCount = 0;
        function checkCloneOver() {
            copyCount++;
            onProgress && onProgress.runWith([copyCount, copyTotalCount]);
            //trace("---",copyCount + "/" + copyTotalCount);
            if (copyCount == copyTotalCount) {
                onFin.runWith([true, fromLocalURL, toLocalURL]);
            }
        }
        var newPath = toLocalURL;
        var newFullPath;
        if (newPath.search(/[A-za-z]:[\\\/]/g) == 0 || (os.detectOS() == "Mac" && newPath.search("/") == 0)) {
            newFullPath = newPath;
            // 目前不允许这么使用，在工程范围内使用即可
            onFin.runWith([false, fromLocalURL, toLocalURL]);
            return;
        }
        else {
            newFullPath = FileUtils.nativePath + "/" + newPath;
        }
        /*
         * 复制目录中的所有文件包括子目录
         * @param{ String } 需要复制的目录
         * @param{ String } 复制到指定的目录
         */
        var copy = function (src, dst) {
            // 读取目录中的所有文件/目录
            try {
                var paths = fs.readdirSync(src);
            }
            catch (e) {
                onFin.runWith([false, fromLocalURL, toLocalURL]);
                return;
            }
            // trace("paths--",paths.length);
            paths.forEach(function (path) {
                //copyCount++;
                //trace("+++",copyCount,path);
                new SyncTask("plCopyFile", function (path) {
                    // 第1个顺序任务逻辑
                    var _src = src + '/' + path, _dst = dst + '/' + path, readable, writable;
                    try {
                        var stat = fs.statSync(_src);
                    }
                    catch (e) {
                        onFin.runWith([false, fromLocalURL, toLocalURL]);
                        return;
                    }
                    // 判断是否为文件
                    if (stat.isFile()) {
                        // 创建读取流
                        readable = fs.createReadStream(_src);
                        // 创建写入流
                        writable = fs.createWriteStream(_dst);
                        // 通过管道来传输流
                        readable.pipe(writable);
                        // 监控复制完成
                        writable.on('close', function () {
                            checkCloneOver();
                            SyncTask.taskOver("plCopyFile");
                        });
                    }
                    // 如果是目录则递归调用自身
                    else if (stat.isDirectory()) {
                        exists(_src, _dst, copy);
                        checkCloneOver();
                        SyncTask.taskOver("plCopyFile");
                    }
                    else {
                        checkCloneOver();
                        SyncTask.taskOver("plCopyFile");
                    }
                }, [path], this);
            });
        };
        // 在复制目录前需要判断该目录是否存在，不存在需要先创建目录
        var exists = function (src, dst, callback) {
            if (fs.existsSync(dst)) {
                callback(src, dst);
            }
            else {
                try {
                    fs.mkdirSync(dst);
                    callback(src, dst);
                }
                catch (e) {
                    trace("创建文件夹失败!!!!", dst);
                }
            }
        };
        // 复制目录或文件
        var fromFullPath = FileUtils.nativePath + "/" + fromLocalURL;
        var stat = fs.statSync(fromFullPath);
        var isDirectory = stat.isDirectory();
        if (isDirectory) {
            exists(fromFullPath, newFullPath, copy);
        }
        else {
            // 创建读取流
            var readable = fs.createReadStream(fromFullPath);
            // 创建写入流
            var writable = fs.createWriteStream(newFullPath);
            // 通过管道来传输流
            readable.pipe(writable);
            try {
                writable.on('close', function () {
                    checkCloneOver();
                });
            }
            catch (e) {
                alert("错误" + e);
            }
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取指定目录下的所有文件或文件夹（不包含子文件夹内的文件）
     * @param directoryLocalPath 文件目录地址 如 asset/xxx
     * @param onFin 完成时回调 onFin(fos:{localPath:string,fileName:string,isDirectory:boolean}[])  比如fileName=xxx.png localPath=asset/xxx.png，如果fos为空则表示获取失败
     * @param stat [可选] 默认值=null 传递过来的文件夹stat，必须是文件夹
     */
    FileUtils.getDirectoryListing = function (directoryLocalPath, onFin, stat) {
        var _this_1 = this;
        if (stat === void 0) { stat = null; }
        var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
        // 非PC本地版本则延迟执行
        if (os.platform != 2 && indiaAppGameInfo == null) {
            onFin.delayRun(0, null, [null]);
            return;
        }
        // 运行在在测试的独立窗口中的游戏时，以HTTP-SERVER方式传输给GC-IDE进行操作
        if (indiaAppGameInfo) {
            var rq = new HttpRequest();
            var data = JSON.stringify({ mode: 2, directoryLocalPath: directoryLocalPath });
            var IDEHttpServerURL = "http://127.0.0.1:" + indiaAppGameInfo.gcDebugPort + "/kdsrpg_http_indieapp.js?cmd=3";
            rq.send(IDEHttpServerURL, data, "post");
            rq.add_ERROR(function () {
                onFin.delayRun(0, null, [null]);
            }, this);
            rq.add_COMPLETE(function (str) {
                try {
                    var localPaths = JSON.parse(str);
                    for (var i = 0; i < localPaths.length; i++) {
                        var f = localPaths[i];
                        f.lastModifyDate = new Date(f.lastModifyDate);
                    }
                    onFin.delayRun(0, null, [localPaths]);
                }
                catch (e) {
                    onFin.delayRun(0, null, [null]);
                }
            }, this);
            return;
        }
        // 在GC环境下则直接获取
        if (os.inGC(false)) {
            new mainDomain_FileObject(directoryLocalPath, function (directoryLocalFo) {
                if (!directoryLocalFo.exists) {
                    onFin.delayRun(0, null, [null]);
                    return;
                }
                directoryLocalFo.getDirectoryListing(function (directoryLocalFo, fos) {
                    if (!fos) {
                        onFin.delayRun(0, null, [null]);
                    }
                    else {
                        var localPaths = [];
                        for (var i = 0; i < fos.length; i++) {
                            var childFo = fos[i];
                            var localPath = childFo.path;
                            var lastModifyDate = childFo.lastModifyDate;
                            localPaths.push({ lastModifyDate: lastModifyDate, localPath: localPath, fileName: childFo.fileName, isDirectory: childFo.isDirectory });
                        }
                        onFin.delayRun(0, null, [localPaths]);
                    }
                }, function () {
                    onFin.delayRun(0, null, [null]);
                }, _this_1);
            }, this, function () {
                onFin.delayRun(0, null, [null]);
            });
            return;
        }
        // 没有stat的话则使用stat并检测是否文件夹
        var fs = require("fs");
        if (!stat) {
            var directoryLocalExist = fs.existsSync(directoryLocalPath);
            if (!directoryLocalExist) {
                onFin.delayRun(0, null, [null]);
                return;
            }
            var stat = fs.statSync(directoryLocalPath);
            var isDirectory = stat.isDirectory();
            if (!isDirectory) {
                onFin.delayRun(0, null, [null]);
                return;
            }
        }
        // 
        var realFullPath = FileUtils.nativePath + "/" + directoryLocalPath;
        // 获取该文件夹下的所有文件或文件夹数据
        var fileObjectList = [];
        var fsList = fs.readdirSync(realFullPath);
        for (var f in fsList) {
            var file = {};
            file.fileName = fsList[f];
            var stat = fs.statSync(realFullPath + "/" + file.fileName);
            file.isDirectory = stat.isDirectory();
            file.localPath = directoryLocalPath + "/" + file.fileName;
            file.stat = stat;
            file.lastModifyDate = new Date(parseInt(stat.mtimeMs));
            fileObjectList.push(file);
        }
        // 模拟异步
        onFin.delayRun(0, null, [fileObjectList]);
    };
    /**
     * 获取指定目录下的所有文件或文件夹（包含子文件夹内的文件）
     * @param directoryLocalPath 文件目录地址 如 asset/xxx
     * @param onFin 完成时回调 onFin(fos:{localPath:string,fileName:string,isDirectory:boolean}[])  比如fileName=xxx.png localPath=asset/xxx.png，如果fos为空则表示获取失败
     * @param stat [可选] 默认值=null 传递过来的文件夹stat，必须是文件夹
     */
    FileUtils.getAllChildFiles = function (directoryLocalPath, onFin, stat) {
        var _this_1 = this;
        if (stat === void 0) { stat = null; }
        var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
        // 非PC本地版本则延迟执行
        if (os.platform != 2 && indiaAppGameInfo == null) {
            onFin.delayRun(0, null, [null]);
            return;
        }
        // 运行在在测试的独立窗口中的游戏时，以HTTP-SERVER方式传输给GC-IDE进行操作
        if (indiaAppGameInfo) {
            var rq = new HttpRequest();
            var data = JSON.stringify({ mode: 3, directoryLocalPath: directoryLocalPath });
            var IDEHttpServerURL = "http://127.0.0.1:" + indiaAppGameInfo.gcDebugPort + "/kdsrpg_http_indieapp.js?cmd=3";
            rq.send(IDEHttpServerURL, data, "post");
            rq.add_ERROR(function () {
                onFin.delayRun(0, null, [null]);
            }, this);
            rq.add_COMPLETE(function (str) {
                try {
                    var localPaths = JSON.parse(str);
                    onFin.delayRun(0, null, [localPaths]);
                }
                catch (e) {
                    onFin.delayRun(0, null, [null]);
                }
            }, this);
            return;
        }
        // 在GC环境下则直接获取
        if (os.inGC(false)) {
            new mainDomain_FileObject(directoryLocalPath, function (directoryLocalFo) {
                if (!directoryLocalFo.exists) {
                    onFin.delayRun(0, null, [null]);
                    return;
                }
                directoryLocalFo.getAllChildFiles(function (directoryLocalFo, fos) {
                    if (!fos) {
                        onFin.delayRun(0, null, [null]);
                    }
                    else {
                        var localPaths = [];
                        for (var i = 0; i < fos.length; i++) {
                            var childFo = fos[i];
                            var localPath = childFo.path;
                            localPaths.push({ localPath: localPath, fileName: childFo.fileName, isDirectory: childFo.isDirectory });
                        }
                        onFin.delayRun(0, null, [localPaths]);
                    }
                }, function () {
                    onFin.delayRun(0, null, [null]);
                }, _this_1);
            }, this, function () {
                onFin.delayRun(0, null, [null]);
            });
            return;
        }
        // 其他获取，通过递归
        var _this = this;
        var taskCount = 1;
        var childFiles = [];
        function getChildFiles(directoryLocalPath, stat) {
            FileUtils.getDirectoryListing(directoryLocalPath, Callback.New(function (childFos) {
                if (childFos) {
                    childFiles = childFiles.concat(childFos);
                    for (var i in childFos) {
                        var childFo = childFos[i];
                        if (childFo.isDirectory) {
                            taskCount++;
                            getChildFiles.call(_this, childFo.localPath, childFo.stat);
                        }
                    }
                }
                checkOver();
            }, this), stat);
        }
        function checkOver() {
            taskCount--;
            if (taskCount == 0) {
                onFin.runWith([childFiles]);
            }
        }
        getChildFiles.call(this, directoryLocalPath, stat);
    };
    //------------------------------------------------------------------------------------------------------
    // 保存
    //------------------------------------------------------------------------------------------------------
    /**
     * 保存文件
     * @param dataObject 储存数据
     * @param localURL 相对目录
     * @param onFin 完成时回调 onFin(success:boolean,localURL:string)
     * @param format [可选] 默认值=true
     * @param isJson [可选] 默认值=true
     * @param forceCreateFolder [可选] 默认值=false 在编辑器环境下也会检查并创建文件夹
     */
    FileUtils.save = function (dataObject, localURL, onFin, format, isJson, forceCreateFolder) {
        var _this_1 = this;
        if (format === void 0) { format = true; }
        if (isJson === void 0) { isJson = true; }
        if (forceCreateFolder === void 0) { forceCreateFolder = false; }
        new SyncTask(FileUtils.TASK_MODIFY_FILE, function () {
            var onSaveFin = Callback.New(function (success, localURL) {
                onFin && onFin.runWith([success, localURL]);
                SyncTask.taskOver(FileUtils.TASK_MODIFY_FILE);
            }, _this_1);
            // 运行在在测试的独立窗口中的游戏时，以HTTP-SERVER方式传输给GC-IDE
            var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
            if (indiaAppGameInfo) {
                var rq = new HttpRequest();
                var dataString = isJson ? (format ? JSON.stringify(dataObject, null, 4) : JSON.stringify(dataObject)) : dataObject;
                var data = JSON.stringify({ mode: 0, localURL: localURL, content: dataString });
                var IDEHttpServerURL = "http://127.0.0.1:" + indiaAppGameInfo.gcDebugPort + "/kdsrpg_http_indieapp.js?cmd=3";
                rq.send(IDEHttpServerURL, data, "post");
                rq.add_ERROR(function () {
                    onSaveFin && onSaveFin.delayRun(0, null, [false, localURL]);
                }, _this_1);
                rq.add_COMPLETE(function (str) {
                    onSaveFin && onSaveFin.delayRun(0, null, [str == "ok", localURL]);
                }, _this_1);
                return;
            }
            // 运行时非PC平台的话使用cookies储存
            if (!Config.EDIT_MODE && (os.platform != 2)) {
                if (IndexedDBManager.support && IndexedDBManager.used) {
                    IndexedDBManager.setIndexDBJson(localURL, dataObject, function (success) {
                        onSaveFin && onSaveFin.delayRun(0, null, [success, localURL]);
                    });
                }
                else {
                    LocalStorage.setJSON(localURL, dataObject);
                    onSaveFin && onSaveFin.delayRun(0, null, [true, localURL]);
                }
                return;
            }
            // trace("保存文件----", localURL);
            function onSaveOver(onSaveFin, args) {
                try {
                    onSaveFin && onSaveFin.runWith(args);
                }
                catch (e) {
                    trace(e);
                }
            }
            // 处理文件的地址
            var paths = localURL.split("/");
            if (paths.length > 1)
                paths.pop();
            var folderURL = paths.join("/");
            FileUtils.createDirectoryForce(folderURL, Callback.New(function (success) {
                if (!success) {
                    onSaveOver(onSaveFin, [false, localURL]);
                    return;
                }
                try {
                    var dataString = isJson ? (format ? JSON.stringify(dataObject, null, 4) : JSON.stringify(dataObject)) : dataObject;
                }
                catch (e) {
                    trace("打包数据失败:", localURL, e);
                }
                if (typeof mainDomain_FileObject != "undefined") {
                    new mainDomain_FileObject(localURL, function (fo) {
                        if (FileUtils.saveFileExt)
                            dataString = FileUtils.saveFileExt(fo.fullPath, dataString);
                        fo[fo.exists ? "saveFile" : "createFile"](dataString, function () {
                            onSaveOver(onSaveFin, [true, fo.path]);
                        }, function () {
                            onSaveOver(onSaveFin, [false, fo.path]);
                        }, this);
                    }, _this_1, function () {
                        onSaveOver(onSaveFin, [false, localURL]);
                    });
                }
                else {
                    var head = "";
                    if (Browser.onPC) {
                        head = (typeof mainDomain_LGConfig !== "undefined") ? mainDomain_LGConfig.WORK_PATH + "/" : "";
                        var fullURL = head + localURL;
                        // 本地应用
                        if (mainDomain_fs) {
                            mainDomain_fs.writeFile(fullURL, dataString, function (err) {
                                if (err) {
                                    onSaveOver(onSaveFin, [false, localURL]);
                                    return;
                                }
                                onSaveOver(onSaveFin, [true, localURL]);
                            });
                        }
                    }
                }
            }, _this_1), false, forceCreateFolder ? false : true);
        });
    };
    /**
     * 创建文件夹，会创建不存在的目录
     * @param localURL 文件夹相对地址
     * @param onFin 当完成是回调 onFin(success:boolean,localURL:string)
     * @param taskLock [可选] 默认值=true 是否加任务锁
     * @param inEditorIgnore [可选] 默认值=false 在编辑器环境下忽略创建
     */
    FileUtils.createDirectoryForce = function (localURL, onFin, taskLock, inEditorIgnore) {
        var _this_1 = this;
        if (taskLock === void 0) { taskLock = true; }
        if (inEditorIgnore === void 0) { inEditorIgnore = false; }
        var taskF = function () {
            var localURLLen = localURL.length - 1;
            if (localURL[localURLLen] == "/") {
                localURL = localURL.substr(0, localURLLen);
            }
            var onCreateDirectoryFin = Callback.New(function (success, localURL) {
                onFin && onFin.runWith([success, localURL]);
                if (taskLock)
                    SyncTask.taskOver(FileUtils.TASK_MODIFY_FILE);
            }, _this_1);
            // 运行在在测试的独立窗口中的游戏时，以HTTP-SERVER方式传输给GC-IDE进行操作
            var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
            if (indiaAppGameInfo) {
                var rq = new HttpRequest();
                var data = JSON.stringify({ mode: 4, localURL: localURL });
                var IDEHttpServerURL = "http://127.0.0.1:" + indiaAppGameInfo.gcDebugPort + "/kdsrpg_http_indieapp.js?cmd=3";
                rq.send(IDEHttpServerURL, data, "post");
                rq.add_ERROR(function () {
                    onCreateDirectoryFin.runWith([false, localURL]);
                }, _this_1);
                rq.add_COMPLETE(function (str) {
                    onCreateDirectoryFin.runWith([str == "ok", localURL]);
                }, _this_1);
                return;
            }
            // 在编辑器环境下忽略创建，直接返回
            if (Config.EDIT_MODE && inEditorIgnore) {
                onCreateDirectoryFin.runWith([true, localURL]);
                return;
            }
            // 最后没有/的话则补充
            if (localURL[localURL.length - 1] != "/") {
                localURL += "/";
            }
            var head = "";
            if (Browser.onPC) {
                head = (typeof mainDomain_LGConfig != "undefined") ? mainDomain_LGConfig.WORK_PATH + "/" : "";
                var fullURL = head + localURL;
                // 本地应用
                if (mainDomain_fs) {
                    createDirectoryForce(fullURL, function () {
                        onCreateDirectoryFin.runWith([true, localURL]);
                    }, function () {
                        onCreateDirectoryFin.runWith([false, localURL]);
                    }, _this_1);
                }
            }
            // for pc
            function createDirectoryForce(realFullPath, onComplete, onError, thisPtr) {
                var realFullPathArr = realFullPath.split("/");
                realFullPathArr.pop();
                realFullPath = realFullPathArr.join("/");
                // 路径已存在
                if (this._exists) {
                    onError.call(thisPtr, this, null);
                    return;
                }
                var _this = this;
                // 获取文件夹
                realFullPathArr = realFullPath.split("/");
                for (var i = 0; i < realFullPathArr.length; i++) {
                    var path = "";
                    for (var s = 0; s <= i; s++) {
                        path += realFullPathArr[s];
                        if (s != i)
                            path += "/";
                    }
                    if (path == "")
                        continue;
                    var statInfo = mainDomain_fs.existsSync(path);
                    if (!statInfo) {
                        mainDomain_fs.mkdirSync(path);
                    }
                }
                setTimeout(function () {
                    onComplete && onComplete.call(thisPtr, this);
                }, 0);
            }
        };
        if (taskLock) {
            new SyncTask(FileUtils.TASK_MODIFY_FILE, taskF);
        }
        else {
            taskF.apply(this);
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 删除
    //------------------------------------------------------------------------------------------------------
    /**
     * 删除文件
     * @param localURL 文件相对地址
     * @param onFin [可选] 默认值=null 是否删除成功 onFin(success:boolean,localURL:string)
     * @param isFullPath [可选] 默认值=false 是否全路径（不公开的API参数）
     */
    FileUtils.deleteFile = function (localURL, onFin, isFullPath) {
        var _this_1 = this;
        if (onFin === void 0) { onFin = null; }
        if (isFullPath === void 0) { isFullPath = false; }
        new SyncTask(FileUtils.TASK_MODIFY_FILE, function () {
            var onDeleteFileFin = Callback.New(function (success, localURL) {
                onFin && onFin.runWith([success, localURL]);
                SyncTask.taskOver(FileUtils.TASK_MODIFY_FILE);
            }, _this_1);
            // 运行在在测试的独立窗口中的游戏时，以HTTP-SERVER方式传输给GC-IDE进行操作
            var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
            if (indiaAppGameInfo) {
                var rq = new HttpRequest();
                var data = JSON.stringify({ mode: 5, localURL: localURL });
                var IDEHttpServerURL = "http://127.0.0.1:" + indiaAppGameInfo.gcDebugPort + "/kdsrpg_http_indieapp.js?cmd=3";
                rq.send(IDEHttpServerURL, data, "post");
                rq.add_ERROR(function () {
                    onDeleteFileFin.runWith([false, localURL]);
                }, _this_1);
                rq.add_COMPLETE(function (str) {
                    onDeleteFileFin.runWith([str == "ok", localURL]);
                }, _this_1);
                return;
            }
            // 运行时非PC平台的话使用cookies储存
            if (!Config.EDIT_MODE && (os.platform != 2)) {
                if (IndexedDBManager.support && IndexedDBManager.used) {
                    IndexedDBManager.removeIndexDBItem(localURL, function (success) {
                        onDeleteFileFin && onDeleteFileFin.delayRun(0, null, [success, localURL]);
                    });
                }
                else {
                    LocalStorage.removeItem(localURL);
                    onDeleteFileFin && onDeleteFileFin.delayRun(0, null, [true, localURL]);
                }
                return;
            }
            // 本地应用
            if (mainDomain_fs) {
                var head = (typeof mainDomain_LGConfig !== "undefined") ? mainDomain_LGConfig.WORK_PATH + "/" : "";
                var fullURL = isFullPath ? localURL : (head + localURL);
                if (!mainDomain_fs.existsSync(fullURL)) {
                    onDeleteFileFin && onDeleteFileFin.delayRun(0, null, [false, localURL]);
                    return;
                }
                var stat = mainDomain_fs.statSync(fullURL);
                if (stat.isDirectory()) {
                    deleteall(fullURL);
                }
                else {
                    mainDomain_fs.unlinkSync(fullURL);
                }
                // @ts-ignore
                function deleteall(path) {
                    var files = [];
                    if (mainDomain_fs.existsSync(path)) {
                        files = mainDomain_fs.readdirSync(path);
                        files.forEach(function (file, index) {
                            var curPath = path + "/" + file;
                            if (mainDomain_fs.statSync(curPath).isDirectory()) { // recurse
                                deleteall(curPath);
                            }
                            else { // delete file
                                mainDomain_fs.unlinkSync(curPath);
                            }
                        });
                        mainDomain_fs.rmdirSync(path);
                    }
                }
            }
            onDeleteFileFin && onDeleteFileFin.delayRun(0, null, [true, localURL]);
        });
    };
    /**
     * 文件保存删除的保护同步任务，以便同一时间内
     */
    FileUtils.TASK_MODIFY_FILE = "__FileUtils__TASK_MODIFY_FILE";
    return FileUtils;
}());
/**
 * 针对游戏相关的工具
 * Created by 黑暗之神KDS on 2018-08-08 21:12:53.
 */
var GameUtils = /** @class */ (function () {
    function GameUtils() {
    }
    //------------------------------------------------------------------------------------------------------
    // 朝向计算
    //------------------------------------------------------------------------------------------------------
    /**
     * [!]根据索引返回方向
     * @param index 0-7
     * @param oriMode 1 2 3 4 5 8 方向
     * @return [number] 8个方向 根据小键盘
     */
    GameUtils.getOriByIndex = function (index, oriMode) {
        if (oriMode === void 0) { oriMode = 8; }
        var oriMapping;
        switch (oriMode) {
            case 1:
                oriMapping = { 0: 4 };
                break;
            case 2:
                oriMapping = { 0: 4, 1: 6 };
                break;
            case 3:
                oriMapping = { 0: 4, 1: 2, 2: 8 };
                break;
            case 4:
                oriMapping = { 0: 2, 1: 4, 2: 6, 3: 8 };
                break;
            case 5:
                oriMapping = { 0: 2, 1: 1, 2: 4, 3: 7, 4: 8 };
                break;
            case 8:
                oriMapping = { 0: 4, 1: 7, 2: 8, 3: 9, 4: 6, 5: 3, 6: 2, 7: 1 };
                break;
        }
        return oriMapping[index];
    };
    /**
     * 获取实际资源的面向
     * @param ori 面向
     * @param oriMode [可选] 默认值=8
     * @return [number]
     */
    GameUtils.getAssetOri = function (ori, oriMode) {
        if (oriMode === void 0) { oriMode = 8; }
        var oriMapping;
        switch (oriMode) {
            case 1:
                oriMapping = { 1: 4, 2: 4, 3: 4, 4: 4, 6: 4, 7: 4, 8: 4, 9: 4 };
                break;
            case 2:
                oriMapping = { 1: 4, 2: 6, 3: 6, 4: 4, 6: 6, 7: 4, 8: 6, 9: 6 };
                break;
            case 3:
                oriMapping = { 1: 4, 2: 2, 3: 4, 4: 4, 6: 4, 7: 4, 8: 8, 9: 4 };
                break;
            case 4:
                oriMapping = { 1: 4, 2: 2, 3: 6, 4: 4, 6: 6, 7: 4, 8: 8, 9: 6 };
                break;
            case 5:
                oriMapping = { 1: 1, 2: 2, 3: 1, 4: 4, 6: 4, 7: 7, 8: 8, 9: 7 };
                break;
            case 8:
                oriMapping = { 1: 1, 2: 2, 3: 3, 4: 4, 6: 6, 7: 7, 8: 8, 9: 9 };
                break;
        }
        return oriMapping[ori];
    };
    /**
     * 根据方向和方向模式获取真实资源方向
     * @param ori
     * @param oriMode [可选] 默认值=8
     * @return [number]
     */
    GameUtils.getRealOriByOriMode = function (ori, oriMode) {
        if (oriMode === void 0) { oriMode = 8; }
        var oriMapping = [];
        switch (oriMode) {
            case 1:
                oriMapping = [4];
                break;
            case 2:
                oriMapping = [4, 6];
                break;
            case 3:
                oriMapping = [4, 2, 8];
                break;
            case 4:
                oriMapping = [4, 2, 6, 8];
                break;
            case 5:
                oriMapping = [4, 1, 2, 7, 8];
                break;
            case 8:
                oriMapping = [4, 1, 2, 3, 6, 7, 8, 9];
                break;
        }
        //
        if (oriMapping.indexOf(ori) != -1)
            return ori;
        return oriMapping[0];
    };
    /**
     * [!]根据索引返回方向(包含翻转)
     * @param index 0-7
     * @param oriMode 1 2 3 4 5 8 方向
     * @return [number] 8个方向 根据小键盘
     */
    GameUtils.getFlipOriByIndex = function (index, oriMode) {
        if (oriMode === void 0) { oriMode = 8; }
        var oriMapping;
        switch (oriMode) {
            case 1:
                oriMapping = { 0: 4, 1: 6 };
                break;
            case 2:
                oriMapping = { 0: 4, 1: 6 };
                break;
            case 3:
                oriMapping = { 0: 4, 1: 2, 2: 8, 3: 6 };
                break;
            case 4:
                oriMapping = { 0: 2, 1: 4, 2: 6, 3: 8 };
                break;
            case 5:
                oriMapping = { 0: 2, 1: 1, 2: 4, 3: 7, 4: 8, 5: 6 };
                break;
            case 8:
                oriMapping = { 0: 4, 1: 7, 2: 8, 3: 9, 4: 6, 5: 3, 6: 2, 7: 1 };
                break;
        }
        return oriMapping[index];
    };
    /**
     * [!]根据方向(包含翻转)获取对应的索引值
     * @param ori 面向
     * @param oriMode [可选] 默认值=8
     * @return [number]
     */
    GameUtils.getIndexByFlipOri = function (ori, oriMode) {
        if (oriMode === void 0) { oriMode = 8; }
        var oriMapping;
        switch (oriMode) {
            case 1:
                oriMapping = { 1: 0, 2: 0, 3: 0, 4: 0, 6: 1, 7: 0, 8: 0, 9: 0 };
                break;
            case 2:
                oriMapping = { 1: 0, 2: 1, 3: 1, 4: 0, 6: 1, 7: 0, 8: 1, 9: 1 };
                break;
            case 3:
                oriMapping = { 1: 4, 2: 1, 3: 4, 4: 0, 6: 3, 7: 0, 8: 2, 9: 0 };
                break;
            case 4:
                oriMapping = { 1: 1, 2: 0, 3: 2, 4: 1, 6: 2, 7: 1, 8: 3, 9: 2 };
                break;
            case 5:
                oriMapping = { 1: 1, 2: 0, 3: 1, 4: 2, 6: 5, 7: 3, 8: 4, 9: 3 };
                break;
            case 8:
                oriMapping = { 1: 7, 2: 6, 3: 5, 4: 0, 6: 4, 7: 1, 8: 2, 9: 3 };
                break;
        }
        return oriMapping[ori];
    };
    /**
     * 根据0-360角度获取对应的面向
     * @param angle 角度
     * @return [number]
     */
    GameUtils.getOriByAngle = function (angle) {
        if (angle >= 337.5 || angle < 22.5) {
            return 8;
        }
        else if (angle >= 22.5 && angle < 67.5) {
            return 9;
        }
        else if (angle >= 67.5 && angle < 112.5) {
            return 6;
        }
        else if (angle >= 112.5 && angle < 157.5) {
            return 3;
        }
        else if (angle >= 157.5 && angle < 202.5) {
            return 2;
        }
        else if (angle >= 202.5 && angle < 247.5) {
            return 1;
        }
        else if (angle >= 247.5 && angle < 292.5) {
            return 4;
        }
        else if (angle >= 292.5 && angle < 337.5) {
            return 7;
        }
        return 2;
    };
    /**
     * 根据面向获取0-360度
     * @param ori 面向
     * @return [number] 角度
     */
    GameUtils.getAngleByOri = function (ori) {
        switch (ori) {
            case 1:
                return 225;
            case 2:
                return 180;
            case 3:
                return 145;
            case 4:
                return 270;
            case 6:
                return 90;
            case 7:
                return 315;
            case 8:
                return 0;
            case 9:
                return 45;
        }
    };
    /**
     * 获取相反的面向
     */
    GameUtils.getFlipOri = function (ori) {
        var mapping = { 1: 9, 2: 8, 3: 7, 4: 6, 6: 4, 7: 3, 8: 2, 9: 1 };
        return mapping[ori];
    };
    //------------------------------------------------------------------------------------------------------
    // 坐标换算
    //------------------------------------------------------------------------------------------------------
    /**
     * [实际坐标]->[格子坐标]
     * @param p 实际坐标
     * @param helpP [可选] 默认值=null 如果存在则使用该对象来自装载而非创建新的Point对象
     * @return [Point] 格子坐标
     */
    GameUtils.getGridPostion = function (p, helpP) {
        if (helpP === void 0) { helpP = null; }
        var rp = helpP;
        var s = Config.SCENE_GRID_SIZE;
        if (rp) {
            rp.x = Math.floor(p.x / s);
            rp.y = Math.floor(p.y / s);
        }
        else {
            rp = new Point(Math.floor(p.x / s), Math.floor(p.y / s));
        }
        return rp;
    };
    /**
     * [实际坐标]->[实际坐标中心点]
     * @param p 实际坐标
     * @param helpP [可选] 默认值=null 如果存在则使用该对象来自装载而非创建新的Point对象
     * @return [Point]
     */
    GameUtils.getGridCenter = function (p, helpP) {
        if (helpP === void 0) { helpP = null; }
        var rp = helpP;
        var s = Config.SCENE_GRID_SIZE;
        var h = Math.floor(Config.SCENE_GRID_SIZE / 2);
        if (rp) {
            rp.x = Math.floor(p.x / s) * s + h;
            rp.y = Math.floor(p.y / s) * s + h;
        }
        else {
            rp = new Point(Math.floor(p.x / s) * s + h, Math.floor(p.y / s) * s + h);
        }
        return rp;
    };
    /**
     * [格子坐标] -> [实际坐标中心点]
     * @param gridP 格子坐标
     * @param helpP [可选] 默认值=null 如果存在则使用该对象来自装载而非创建新的Point对象
     * @return [Point]
     */
    GameUtils.getGridCenterByGrid = function (gridP, helpP) {
        if (helpP === void 0) { helpP = null; }
        var p = new Point(gridP.x * Config.SCENE_GRID_SIZE, gridP.y * Config.SCENE_GRID_SIZE);
        return GameUtils.getGridCenter(p, helpP);
    };
    //------------------------------------------------------------------------------------------------------
    // 格子计算
    //------------------------------------------------------------------------------------------------------
    /**
     * 查询临近的同状态路径
     * @param mapData 图数据
     * @param gridX 起点格子
     * @param gridY 起点格子
     * @param width 总宽度
     * @param height 总高度
     * @param attributes 判断格子状态相同的属性集，即与mapData数据中的有一种属性不同的话也视为不同的状态 null 则表示直接对比
     * @param limit 默认值=100 限制搜索仅在周围limit距离的正方形范围内
     * @return [Point]
     */
    GameUtils.getSameStateGrid = function (mapData, gridX, gridY, width, height, attributes, limit) {
        if (limit === void 0) { limit = 100; }
        var limit = 100;
        var limitRect = new Rectangle(Math.max(gridX - limit, 0), Math.max(gridY - limit, 0), Math.min(width, gridX + limit), Math.min(height, gridY + limit));
        var points = [];
        var firstGrid = mapData[gridX] ? mapData[gridX][gridY] : null;
        var gridHelpArr = [];
        for (var x = 0; x < width; x++) {
            gridHelpArr[x] = [];
        }
        var dir = [null, null, [8, 0, 1], null, [6, -1, 0], null, [4, 1, 0], null, [2, 0, -1]];
        var dirIndexes = [2, 4, 6, 8];
        var needSearchGrid = [];
        needSearchGrid.push({ gridX: gridX, gridY: gridY, from: 0 });
        var from = 0;
        while (1) {
            if (needSearchGrid.length == 0)
                break;
            var currentGridData = needSearchGrid.shift();
            gridX = currentGridData.gridX;
            gridY = currentGridData.gridY;
            if (gridHelpArr[gridX][gridY])
                continue;
            gridHelpArr[gridX][gridY] = true;
            var currentGrid = mapData[gridX] ? mapData[gridX][gridY] : null;
            if (currentGrid == firstGrid) { }
            else if (currentGrid && firstGrid) {
                var isSame;
                if (attributes) {
                    isSame = true;
                    for (var attr in attributes) {
                        var attribute = attributes[attr];
                        if (currentGrid[attribute] != firstGrid[attribute]) {
                            isSame = false;
                            break;
                        }
                    }
                }
                else {
                    isSame = currentGrid === firstGrid;
                }
                if (!isSame)
                    continue;
            }
            else {
                continue;
            }
            points.push(new Point(gridX, gridY));
            for (var d = 0; d < 4; d++) {
                var toDir = dirIndexes[d];
                var toDirData = dir[toDir];
                if (toDirData[0] == currentGridData.from)
                    continue;
                var toX = gridX + toDirData[1];
                var toY = gridY + toDirData[2];
                if (toX < limitRect.x || toX >= limitRect.width || toY < limitRect.y || toY >= limitRect.height)
                    continue;
                needSearchGrid.push({ gridX: toX, gridY: toY, from: toDir });
            }
        }
        return points;
    };
    /**
     * 获取两个格子之间的补间格子 穷举法
     */
    GameUtils.getMendingGrids = function (grid1, grid2, per) {
        if (per === void 0) { per = 0.1; }
        var gridDetermine = [];
        var grids = [];
        for (var i = 0; i <= 1; i += 0.1) {
            var p = Point.interpolate(grid1, grid2, i);
            p.x = Math.floor(p.x);
            p.y = Math.floor(p.y);
            var xArr = gridDetermine[p.x];
            if (!xArr)
                xArr = gridDetermine[p.x] = [];
            if (xArr[p.y])
                continue;
            xArr[p.y] = true;
            if (grid1.x == p.x && grid1.y == p.y)
                continue;
            grids.push(p);
        }
        return grids;
    };
    //------------------------------------------------------------------------------------------------------
    // 其他
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取最小适配比例
     * @param rect
     * @param canvasRect 画布矩形
     */
    GameUtils.getAutoFitSizePre = function (rect, canvasRect) {
        var xPer = canvasRect.width / rect.width;
        var yPer = canvasRect.height / rect.height;
        var per = Math.min(xPer, yPer);
        return per;
    };
    /**
     * 判断继承于某个节点
     * @param node
     * @param parentNode
     */
    GameUtils.isInheritNode = function (node, parentNode) {
        var p = node.parent;
        while (p) {
            if (p == parentNode)
                return true;
            p = p.parent;
        }
        return false;
    };
    /**
     * 根据特定字符串$n来获取n，不符合的返回0
     * @param value
     */
    GameUtils.getVarID = function (value) {
        if (value && value.toString().search(/\$[0-9]*/g) == 0) {
            var id = parseInt(value.toString().substr(1));
            return id;
        }
        return 0;
    };
    /**
     * 获取缓动方法（目前仅支持客户端）
     * @param tweenID
     */
    GameUtils.getTween = function (tweenID) {
        if (!tweenID)
            return [Ease.linearNone, "linearNone"];
        var arr = ["linearNone", "bounceIn", "bounceInOut", "bounceOut", "backIn",
            "backInOut", "backOut", "elasticIn", "elasticInOut", "elasticOut", "strongIn",
            "strongInOut", "strongOut", "sineIn", "sineInOut", "sineOut", "quintIn",
            "quintInOut", "quintOut", "quartIn", "quartInOut", "quartOut", "cubicIn",
            "cubicInOut", "cubicOut", "quadIn", "quadInOut", "quadOut", "expoIn", "expoInOut",
            "expoOut", "circIn", "circInOut", "circOut"];
        return [Ease[arr[tweenID]], arr[tweenID]];
    };
    /**
     * 获取缓动文本
     */
    GameUtils.getTweenLabels = function () {
        var tweenLabel = "无";
        for (var i = 1; i < GameUtils.tweenCount; i++) {
            var tweenData = GameUtils.getTween(i);
            tweenLabel += "," + tweenData[1];
        }
        return tweenLabel;
    };
    /**
     * 是否合法的变量名
     * @param varName 变量名
     * @param headFont [可选] 默认值=true 是否检查头
     * @return [boolean]
     */
    GameUtils.isLegalVarName = function (varName, headFont) {
        if (headFont === void 0) { headFont = true; }
        if (!varName)
            return false;
        var reg = /([\$_a-zA-Z]|[\u4e00-\u9fa50-9a-zA-Z_$]){1,255}/g;
        var m = varName.match(reg);
        if (headFont && !isNaN(parseInt(varName[0])))
            return false;
        return m != null && m[0] == varName;
    };
    /**
     * 获取曲线数据，根据字符串格式的数据
     * 返回格式：[[0,0,startY,maxLength,maxHeight],[type,startX,startY,endX,endY,ctrlX,ctrlY],[type,startX,startY,endX,endY,ctrlX,ctrlY],...]
     *           maxLength=最大长度（仅供参考） maxHeight=最大高度 起点x始终位于0，终点x始终位于100  type=0-线性线段 1-二次贝塞尔曲线片段(拥有ctrlX,ctrlY)
     * @return groupValue
     */
    GameUtils.getCurveData = function (curveStrData) {
        var def = [[0, 0, 0, 99, 100, 0, 0, 0], [0, 100, 100]];
        if (!curveStrData || typeof curveStrData != "string")
            return def;
        if (curveStrData.indexOf("[[0") == -1)
            return def;
        try {
            return JSON.parse(curveStrData);
        }
        catch (e) {
            return def;
        }
    };
    /**
     * 根据曲线数据获取其中某个点的
     * @param groupValue 格式：[[0,0,startY,maxLength,maxHeight],[type,startX,startY,endX,endY,ctrlX,ctrlY],[type,startX,startY,endX,endY,ctrlX,ctrlY],...]
     *                         maxLength=最大长度（仅供参考） maxHeight=最大高度 起点x始终位于0，终点x始终位于100  type=0-线性线段 1-二次贝塞尔曲线片段(拥有ctrlX,ctrlY)
     * @param x 0~1
     * @return value 值
     */
    GameUtils.getBezierPoint2ByGroupValue = function (groupValue, x) {
        if (!groupValue || !groupValue.length)
            return 0;
        // 获取最大值
        var maxHeight = groupValue[0][4];
        // 将x转换为0-1的值
        var t = Math.min(Math.max(MathUtils.float(x), 0), 1);
        // 找到最近的一段
        var next = ArrayUtils.matchAttributes(groupValue, { 1: t * 100 }, true, ">=", true)[0];
        // 未找到时返回0
        if (next == null)
            return 0;
        // 在第一个点时返回第一个点的值
        if (next == 0)
            return groupValue[0][2] * maxHeight / 100;
        // 返回第一个点和当前点的计算值，区分线性或曲线
        var lastArr = groupValue[next - 1];
        var nextArr = groupValue[next];
        var lastX = lastArr[1];
        var lastY = lastArr[2];
        var nextX = nextArr[1];
        var nextY = nextArr[2];
        var nextType = nextArr[0];
        if (lastX == nextX) {
            var localT = 0;
        }
        else {
            var localT = (t * 100 - lastX) / (nextX - lastX);
        }
        if (nextType == 0) {
            return ((nextY - lastY) * localT + lastY) * maxHeight / 100;
        }
        else {
            return MathUtils.getBezierPoint2(lastX, lastY, nextArr[3], nextArr[4], nextX, nextY, localT).y * maxHeight / 100;
        }
    };
    /**
     * 根据字符串格式的数据,获取过渡组件Object类型数据
     * @param transData 字符串格式数据
     */
    GameUtils.getTransData = function (transDataStr) {
        if (!transDataStr || typeof transDataStr != "string")
            return null;
        try {
            return JSON.parse(transDataStr);
        }
        catch (e) {
            return null;
        }
    };
    /**
     * 根据传入的参数x,获取过渡对应的值
     * @param transData 过渡数据
     * @param x 范围 0-1
     */
    GameUtils.getValueByTransData = function (transData, x) {
        // 将x转换为0-1的值
        var t = Math.min(Math.max(MathUtils.float(x), 0), 1);
        if (!transData) {
            return Ease.linearNone(t, 0, 1, 1);
        }
        //均匀过渡
        if (transData.transType == 0) {
            if (transData.loopType == 0 || transData.loopType == 1) {
                return Ease.linearNone(t, 0, 1, 1);
            }
            else {
                if (t <= 0.5)
                    return Ease.linearNone(t, 0, 1, 0.5);
                else
                    return Ease.linearNone(1 - t, 0, 1, 0.5);
            }
        }
        //缓动
        else if (transData.transType == 1) {
            var normal = [1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31];
            var tail = [2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32];
            var tween = GameUtils.getTween(transData.tweenType + 1)[0];
            if (!tween)
                return 0;
            if (transData.loopType == 0 || transData.loopType == 1) {
                return tween.call(this, t, 0, 1, 1);
            }
            else if (transData.loopType == 2 || transData.loopType == 4) {
                //从头往返
                if (t <= 0.5)
                    return tween.call(this, t, 0, 1, 0.5);
                else {
                    if (normal.indexOf(transData.tweenType) != -1)
                        return tween.call(this, 1 - t, 0, 1, 0.5);
                    else if (tail.indexOf(transData.tweenType) != -1) {
                        var tailTween = GameUtils.getTween(transData.tweenType - 1)[0];
                        if (!tailTween)
                            return 0;
                        return tailTween.call(this, 1 - t, 0, 1, 0.5);
                    }
                    else {
                        var forwwordTween = GameUtils.getTween(transData.tweenType + 3)[0];
                        if (!forwwordTween)
                            return 0;
                        return forwwordTween.call(this, 1 - t, 0, 1, 0.5);
                    }
                }
            }
            else {
                //从尾往返
                if (t <= 0.5)
                    return tween.call(this, t, 0, 1, 0.5);
                else
                    return tween.call(this, 1 - t, 0, 1, 0.5);
            }
        }
        //曲线
        else {
            var curvedata = transData.curveData;
            if (!curvedata)
                return 0;
            if (transData.loopType == 0 || transData.loopType == 1) {
                return GameUtils.getBezierPoint2ByGroupValue(curvedata, t);
            }
            else if (transData.loopType == 2 || transData.loopType == 4) {
                //从头往返
                // if (t <= 0.5) return GameUtils.getBezierPoint2ByGroupValue(curvedata, t * 2);
                // else {
                //     var min = GameUtils.getBezierPoint2ByGroupValue(curvedata, 0);
                //     var max = GameUtils.getBezierPoint2ByGroupValue(curvedata, 1);
                //     var now = t * 2 - 1;
                //     var start = GameUtils.getBezierPoint2ByGroupValue(curvedata, now);
                //     var mstart = Math.abs(start - min);
                //     var mend = Math.abs(max - start);
                //     var time = (mstart - mend) * now / mstart;
                //     t = Math.min(Math.max(now + time, 0), 1);
                //     return GameUtils.getBezierPoint2ByGroupValue(curvedata, 1 - t);
                // }
                if (t <= 0.5)
                    return GameUtils.getBezierPoint2ByGroupValue(curvedata, t * 2);
                else
                    return GameUtils.getBezierPoint2ByGroupValue(curvedata, (2 - t * 2));
            }
            else {
                //从尾往返
                if (t <= 0.5)
                    return GameUtils.getBezierPoint2ByGroupValue(curvedata, t * 2);
                else
                    return GameUtils.getBezierPoint2ByGroupValue(curvedata, (2 - t * 2));
            }
        }
    };
    /**
     * 根据字符串格式的数据,获取选择元件组件Object类型数据
     * @param selectDataStr 字符串格式数据
     */
    GameUtils.getSelectUICompData = function (selectDataStr) {
        if (!selectDataStr || typeof selectDataStr != "string")
            return null;
        try {
            return JSON.parse(selectDataStr);
        }
        catch (e) {
            return null;
        }
    };
    GameUtils.tweenCount = 34;
    return GameUtils;
}());
/**
 * 浏览器IndexedDB大容量存储方式(异步储存)
 * Created by JayLen on 2021-06-15 10:06:05.
 */
var IndexedDBManager = /** @class */ (function () {
    function IndexedDBManager() {
    }
    /**
     * 存储指定键名及其对应的值。
     * @param key 键名
     * @param value 键值(string类型)
     * @param onFin [可选] 默认值=null 回调函数 onFin(success:boolean)
     */
    IndexedDBManager.setIndexDB = function (key, value, onFin) {
        if (onFin === void 0) { onFin = null; }
        if (!IndexedDBManager.used)
            return;
        //打开数据库
        var req = IndexedDBManager.indexedDB.open(IndexedDBManager.databaseName, IndexedDBManager.version);
        req.onupgradeneeded = function (event) {
            // 创建表
            var db = event.target.result;
            if (!db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                db.createObjectStore(IndexedDBManager.tableName, { keyPath: "name" });
            }
        };
        req.onsuccess = function (event) {
            var db = event.target.result;
            if (db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                var transaction = db.transaction([IndexedDBManager.tableName], 'readwrite');
                var store = transaction.objectStore(IndexedDBManager.tableName);
                //存放数据
                var cache = { name: key, value: value };
                //验证数据是否已经存在
                var get_req = store.get(key);
                get_req.onsuccess = function (event) {
                    if (event.target.result) {
                        updataIndexDB(store, cache, onFin);
                    }
                    else {
                        addIndexDB(store, cache, onFin);
                    }
                };
                get_req.onerror = function () {
                    addIndexDB(store, cache, onFin);
                };
            }
            else {
                onFin && onFin.apply(this, [false]);
            }
        };
        req.onerror = function () {
            onFin && onFin.apply(this, [false]);
            // console.log("数据库出错");
        };
        function addIndexDB(store, cache, onFin) {
            var add_req = store.add(cache);
            add_req.onsuccess = function () {
                onFin && onFin.apply(this, [true]);
                // console.log("数据存储成功");
            };
            add_req.onerror = function () {
                onFin && onFin.apply(this, [false]);
                // console.log("数据存储失败");
            };
        }
        function updataIndexDB(store, cache, onFin) {
            var updata_req = store.put(cache);
            updata_req.onsuccess = function () {
                onFin && onFin.apply(this, [true]);
                // console.log("数据更新成功");
            };
            updata_req.onerror = function () {
                onFin && onFin.apply(this, [false]);
                // console.log("数据更新失败");
            };
        }
    };
    /**
     * 获取指定键名对应的值
     * @param key 键名
     * @param onFin 回调 onFin(value:string)
     */
    IndexedDBManager.getIndexDB = function (key, onFin) {
        if (!IndexedDBManager.used)
            return;
        //打开数据库
        var req = IndexedDBManager.indexedDB.open(IndexedDBManager.databaseName, IndexedDBManager.version);
        req.onupgradeneeded = function (event) {
            // 创建表
            var db = event.target.result;
            if (!db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                db.createObjectStore(IndexedDBManager.tableName, { keyPath: "name" });
            }
        };
        req.onsuccess = function (event) {
            var db = event.target.result;
            if (db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                var transaction = db.transaction([IndexedDBManager.tableName], 'readwrite');
                var store = transaction.objectStore(IndexedDBManager.tableName);
                //获取数据
                var store_req = store.get(key);
                store_req.onsuccess = function (event) {
                    if (event.target.result) {
                        onFin.apply(this, [event.target.result.value]);
                        // console.log('Value: ' + event.target.result.value);
                    }
                    else {
                        onFin.apply(this, [null]);
                        // console.log('未获得数据记录');
                    }
                };
                store_req.onerror = function () {
                    onFin.apply(this, [null]);
                    // console.log("获得数据失败");
                };
            }
            else {
                onFin.apply(this, [null]);
                // console.log("数据库表不存在");
            }
        };
        req.onerror = function () {
            onFin.apply(this, [null]);
            // console.log("数据库出错");
        };
    };
    /**
     * 存储指定键名及其对应的值。
     * @param key 键名
     * @param value 键值(Object类型，会被转化为 JSON 字符串存储)
     * @param onFin [可选] 默认值=null 回调函数 onFin(success:boolean)
     */
    IndexedDBManager.setIndexDBJson = function (key, value, onFin) {
        if (onFin === void 0) { onFin = null; }
        if (!IndexedDBManager.used)
            return;
        //打开数据库
        var req = IndexedDBManager.indexedDB.open(IndexedDBManager.databaseName, IndexedDBManager.version);
        req.onupgradeneeded = function (event) {
            // 创建表
            var db = event.target.result;
            if (!db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                db.createObjectStore(IndexedDBManager.tableName, { keyPath: "name" });
            }
        };
        req.onupgradeneeded = function (event) {
            // 创建表
            var db = event.target.result;
            if (!db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                db.createObjectStore(IndexedDBManager.tableName, { keyPath: "name" });
            }
        };
        req.onsuccess = function (event) {
            var db = event.target.result;
            if (db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                var transaction = db.transaction([IndexedDBManager.tableName], 'readwrite');
                var store = transaction.objectStore(IndexedDBManager.tableName);
                //存放数据
                var content = JSON.stringify(value);
                var cache = { name: key, value: content };
                //验证数据是否已经存在
                var get_req = store.get(key);
                get_req.onsuccess = function (event) {
                    if (event.target.result) {
                        updataIndexDBJson(store, cache, onFin);
                    }
                    else {
                        addIndexDBJson(store, cache, onFin);
                    }
                };
                get_req.onerror = function (event) {
                    addIndexDBJson(store, cache, onFin);
                };
            }
            else {
                onFin && onFin.apply(this, [false]);
            }
        };
        req.onerror = function () {
            onFin && onFin.apply(this, [false]);
            // console.log("数据库出错");
        };
        function addIndexDBJson(store, cache, onFin) {
            var add_req = store.add(cache);
            add_req.onsuccess = function () {
                onFin && onFin.apply(this, [true]);
                // console.log("数据存储成功");
            };
            add_req.onerror = function () {
                onFin && onFin.apply(this, [false]);
                // console.log("数据存储失败");
            };
        }
        function updataIndexDBJson(store, cache, onFin) {
            var updata_req = store.put(cache);
            updata_req.onsuccess = function () {
                onFin && onFin.apply(this, [true]);
                // console.log("数据更新成功");
            };
            updata_req.onerror = function () {
                onFin && onFin.apply(this, [false]);
                // console.log("数据更新失败");
            };
        }
    };
    /**
      * 获取指定键名对应的值
      * @param key 键名
      * @param onFin 回调函数 onFin(value:any)
      */
    IndexedDBManager.getIndexDBJson = function (key, onFin) {
        if (!IndexedDBManager.used)
            return;
        //打开数据库
        var req = IndexedDBManager.indexedDB.open(IndexedDBManager.databaseName, IndexedDBManager.version);
        req.onupgradeneeded = function (event) {
            // 创建表
            var db = event.target.result;
            if (!db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                db.createObjectStore(IndexedDBManager.tableName, { keyPath: "name" });
            }
        };
        req.onsuccess = function (event) {
            var db = event.target.result;
            if (db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                var transaction = db.transaction([IndexedDBManager.tableName], 'readwrite');
                var store = transaction.objectStore(IndexedDBManager.tableName);
                //获取数据
                var store_req = store.get(key);
                store_req.onsuccess = function (event) {
                    if (event.target.result) {
                        try {
                            var content = JSON.parse(event.target.result.value);
                            onFin.apply(this, [content]);
                            console.log('Value: ' + content);
                        }
                        catch (e) {
                            onFin.apply(this, [null]);
                            // console.log('数据结构不正确');
                        }
                    }
                    else {
                        onFin.apply(this, [null]);
                        // console.log('未获得数据记录');
                    }
                };
                store_req.onerror = function (event) {
                    onFin.apply(this, [false]);
                    // console.log('获得数据失败');
                };
            }
            else {
                onFin.apply(this, [null]);
                // console.log("数据库表不存在");
            }
        };
        req.onerror = function () {
            onFin.apply(this, [null]);
            // console.log("数据库出错");
        };
    };
    /**
     * 删除指定键名的数据
     * @param key 键名
     * @param onFin [可选] 默认值=null 回调 onFin(success:boolean)
     */
    IndexedDBManager.removeIndexDBItem = function (key, onFin) {
        if (onFin === void 0) { onFin = null; }
        if (!IndexedDBManager.used)
            return;
        //打开数据库
        var req = IndexedDBManager.indexedDB.open(IndexedDBManager.databaseName, IndexedDBManager.version);
        req.onupgradeneeded = function (event) {
            // 创建表
            var db = event.target.result;
            if (!db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                db.createObjectStore(IndexedDBManager.tableName, { keyPath: "name" });
            }
        };
        req.onsuccess = function (event) {
            var db = event.target.result;
            if (db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                var transaction = db.transaction([IndexedDBManager.tableName], 'readwrite');
                var store = transaction.objectStore(IndexedDBManager.tableName);
                //删除数据
                var store_req = store.delete(key);
                store_req.onsuccess = function (event) {
                    onFin && onFin.apply(this, [true]);
                    // console.log('数据删除成功');
                };
                store_req.onerror = function (event) {
                    onFin && onFin.apply(this, [false]);
                    // console.log('数据删除失败');
                };
            }
            else {
                onFin && onFin.apply(this, [false]);
                // console.log("数据库表不存在");
            }
        };
        req.onerror = function () {
            onFin && onFin.apply(this, [false]);
            // console.log("数据库出错");
        };
    };
    /**
     * 获取所有数据
     * @param onFin 回调 onFin(items:{})
     */
    IndexedDBManager.items = function (onFin) {
        if (!IndexedDBManager.used)
            return;
        //打开数据库
        var req = IndexedDBManager.indexedDB.open(IndexedDBManager.databaseName, IndexedDBManager.version);
        req.onupgradeneeded = function (event) {
            // 创建表
            var db = event.target.result;
            if (!db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                db.createObjectStore(IndexedDBManager.tableName, { keyPath: "name" });
            }
        };
        req.onsuccess = function (event) {
            var db = event.target.result;
            if (db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                var transaction = db.transaction([IndexedDBManager.tableName], 'readwrite');
                var store = transaction.objectStore(IndexedDBManager.tableName);
                var store_req = store.openCursor();
                var list = {};
                store_req.onsuccess = function (event) {
                    var cursor = event.target.result;
                    if (cursor) {
                        list[cursor.value.name] = cursor.value.value;
                        cursor.continue();
                    }
                    else {
                        onFin.apply(this, [list]);
                        // console.log('获取所有数据成功');
                    }
                };
                store_req.onerror = function (event) {
                    onFin.apply(this, [{}]);
                    // console.log('获取所有数据失败');
                };
            }
        };
        req.onerror = function () {
            onFin.apply(this, [{}]);
            // console.log("数据库出错");
        };
    };
    /**
     * 清除本地存储信息。
     * @param onFin [可选] 默认值=null 回调 onFin(success:boolean)
     */
    IndexedDBManager.clear = function (onFin) {
        if (onFin === void 0) { onFin = null; }
        if (!IndexedDBManager.used)
            return;
        //打开数据库
        var req = IndexedDBManager.indexedDB.open(IndexedDBManager.databaseName, IndexedDBManager.version);
        req.onupgradeneeded = function (event) {
            // 创建表
            var db = event.target.result;
            if (!db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                db.createObjectStore(IndexedDBManager.tableName, { keyPath: "name" });
            }
        };
        req.onsuccess = function (event) {
            var db = event.target.result;
            if (db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                var transaction = db.transaction([IndexedDBManager.tableName], 'readwrite');
                var store = transaction.objectStore(IndexedDBManager.tableName);
                var store_req = store.clear();
                store_req.onsuccess = function (event) {
                    onFin && onFin.apply(this, [true]);
                    // console.log('清除所有数据成功');
                };
                store_req.onerror = function (event) {
                    onFin && onFin.apply(this, [false]);
                    // console.log('清除所有数据失败');
                };
            }
        };
        req.onerror = function () {
            onFin && onFin.apply(this, [false]);
            // console.log("数据库出错");
        };
    };
    /**
     * 数据库
     */
    IndexedDBManager.indexedDB = (typeof window != "undefined" && (window.indexedDB || window['webkitIndexedDB'] || window['mozIndexedDB'] || window['msIndexedDB']));
    /**
     * 表示是否支持
     */
    IndexedDBManager.support = IndexedDBManager.indexedDB ? true : false;
    /**
     * 是否使用IndexedDB大容量存储方式
     */
    IndexedDBManager.used = false;
    /**
     * 数据库名称
     */
    IndexedDBManager.databaseName = "GameCreator";
    /**
     * 数据库版本号
     */
    IndexedDBManager.version = 1;
    /**
     * 表格名称
     */
    IndexedDBManager.tableName = "GC_Cache";
    return IndexedDBManager;
}());
/**
 * 对象行为
 * Created by 黑暗之神KDS on 2020-02-20 05:34:43.
 */
var SceneObjectBehaviors = /** @class */ (function () {
    /**
     * 构造函数
     * @param so 场景对象
     * @param loop 是否循环
     * @param targetPlayerSceneObject 玩家的场景对象
     * @param onOver 当行为执行完毕时回调
     * @param delayFrame 内部等待的时间
     * @param executor [可选] 默认值=null 执行者场景对象
     */
    function SceneObjectBehaviors(so, loop, targetSceneObject, onOver, startIndex, executor) {
        if (startIndex === void 0) { startIndex = 0; }
        if (executor === void 0) { executor = null; }
        /**
         * 行为 对应的方法 对应的参数
         */
        this.behaviors = [];
        this.so = so;
        this.loop = loop;
        this.index = startIndex;
        this.onOver = onOver;
        // 兼容旧版本，某版本后可不再兼容
        this['targetPlayerSceneObject'] = this.targetSceneObject = targetSceneObject;
        this.executor = executor;
    }
    Object.defineProperty(SceneObjectBehaviors.prototype, "index", {
        get: function () {
            return this._index;
        },
        set: function (v) {
            this._index = v;
            EventUtils.happen(this, SceneObjectBehaviors.EVENT_INDEX_CHANGE, [v]);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 数据转换：将字符串格式的数据转为可使用格式，通常自定义属性中的行为数据需要使用该方法转换后使用
     * @return targetSceneObjectIndex 0-对象 -2玩家 -1当前对象 0-N 指定对象编号
     *         behaviorData 行为数据
     *         loop 是否循环
     *         cover 是否覆盖行为
     *         forceStopLastBehavior 是否强行停止正在执行的行为
     */
    SceneObjectBehaviors.toBehaviorData = function (behaviorStr) {
        var behaviorData = [-1, 0, [], 0, 0];
        // 如果是string格式的话则解析
        if (typeof behaviorStr == "string") {
            var behaviorSymbolIndex = behaviorStr.indexOf(String.fromCharCode(5));
            if (behaviorSymbolIndex != -1) {
                try {
                    var behaviorJson = JSON.parse(behaviorStr.substr(behaviorSymbolIndex + 1));
                    behaviorData = behaviorJson;
                }
                catch (e) { }
            }
        }
        return {
            targetSceneObjectIndex: MathUtils.int(behaviorData[0]),
            behaviorData: behaviorData[2],
            loop: behaviorData[1] == 1,
            cover: behaviorData[3] == 1,
            forceStopLastBehavior: behaviorData[4] == 1
        };
    };
    /**
     * 释放
     */
    SceneObjectBehaviors.prototype.dispose = function () {
        EventUtils.clear(this);
    };
    /**
     * 解析行为，缓存为 behaviors
     * @param behaviorData
     * @param delayFrame
     */
    SceneObjectBehaviors.prototype.setBehaviors = function (behaviorData, delayFrame) {
        if (delayFrame === void 0) { delayFrame = 0; }
        this.delayFrame = delayFrame;
        this.behaviors = [];
        this.behaviorData = behaviorData;
        var len = behaviorData.length;
        for (var i = 0; i < len; i++) {
            var behavior = behaviorData[i].concat();
            var behaviorID = behavior.shift();
            var behaviorParams = behavior;
            var behaviorFunc = this["behavior" + behaviorID];
            // 优先找到模块中的行为方法，以便重写行为
            var globehaviorFunc = null;
            if (globalThis["CustomSceneObjectBehavior"]) {
                globehaviorFunc = globalThis["CustomSceneObjectBehavior"]["f" + behaviorID];
                if (globehaviorFunc && typeof globehaviorFunc == "function") {
                    behaviorFunc = globehaviorFunc;
                }
            }
            if (!behaviorFunc || typeof behaviorFunc != "function")
                continue;
            this.behaviors.push([behaviorFunc, behaviorParams, globehaviorFunc ? true : false]);
        }
    };
    /**
     * 重置：还原到最初始的状态
     * 仅在行为编辑器预览使用
     */
    SceneObjectBehaviors.prototype.reset = function (defSceneObejct) {
    };
    /**
     * 等待指定帧数后继续执行
     * @param frame 等待的帧数
     */
    SceneObjectBehaviors.prototype.waitFrame = function (frame) {
        if (this.ignoreProcess)
            return;
        if (frame < 1)
            frame = 1;
        this.delayFrame = frame;
    };
    /**
     * 等待推进一帧，需要在update中推进，所以停止了update则停止了帧的推进
     */
    SceneObjectBehaviors.prototype.doWaitFrame = function () {
        if (!this.delayFrame)
            return;
        this.delayFrame--;
    };
    /**
     * 更新行为
     * @return [boolean] 是否播放结束
     */
    SceneObjectBehaviors.prototype.update = function () {
        if (this.so.isDisposed)
            return;
        this.doWaitFrame();
        // 无执行对象时不再执行 && !this.newSign
        if (this.delayFrame || !this.so || !this.so.inScene)
            return false;
        // 非立刻执行模式在系统安排的移动或跳跃中不执行
        if (this.logicPause)
            return false;
        var behavior = this.behaviors[this.index];
        if (behavior) {
            var lastIndex = this.index;
            var params = behavior[2] ? [this].concat(behavior[1]) : behavior[1];
            this.index++;
            try {
                behavior[0].apply(this, params);
            }
            catch (e) {
                trace(e.stack);
            }
            // 执行命令后如果处于等待或行为命令的移动中则需要继续等待执行完毕
            if (this.delayFrame || this.logicPause)
                return false;
            // 如果不暂停的话就继续当前帧执行接下来的命令（如果未能推进帧则需要等待一帧，以免无限循环卡死）
            if (!Config.BEHAVIOR_EDIT_MODE && this.index != lastIndex)
                return this.update();
        }
        if (this.index == this.behaviors.length) {
            if (this.loop) {
                this.index = 0;
            }
            else {
                this.onOver && this.onOver.runWith([this]);
                return true;
            }
        }
        return false;
    };
    /**
     * 获取存档数据
     */
    SceneObjectBehaviors.prototype.getSaveData = function () {
        return [this.behaviorData, this.index, this.loop, this.delayFrame, this.targetSceneObject ? this.targetSceneObject.index : -1, this.executor ? this.executor.index : -1];
    };
    /**
     * 索引变更时派发
     */
    SceneObjectBehaviors.EVENT_INDEX_CHANGE = "SceneObjectBehaviorsEVENT_PLAY_NEXT_STEP";
    return SceneObjectBehaviors;
}());
/**
 * 通用
 * Created by 黑暗之神KDS on 2019-05-20 18:25:04.
 */
var Common = /** @class */ (function () {
    function Common() {
    }
    Object.defineProperty(Common, "runPlatform", {
        //------------------------------------------------------------------------------------------------------
        // 运行环境 0-NodeJS服务器环境 1-kdsrpg服务器环境 2-客户端环境（包含PC和WEB）
        //------------------------------------------------------------------------------------------------------
        get: function () {
            if (typeof window != "undefined" && typeof isCrossServer != "undefined" && isCrossServer) {
                return 0;
            }
            else if (typeof window != "undefined") {
                return 2;
            }
            else {
                return 1;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "inGC", {
        /**
         * 是否在GC运行环境中
         */
        get: function () {
            return (typeof window == "undefined" || Config.IS_SERVER) ? false : (typeof mainDomain_gcide != "undefined");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "gameData", {
        //------------------------------------------------------------------------------------------------------
        // 获取数据
        //------------------------------------------------------------------------------------------------------
        /**
         * 游戏数据
         */
        get: function () {
            if (Config.IS_SERVER) {
                return ServerWorld.gameData;
            }
            else {
                return Game.data;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "variableNameList", {
        /**
         * 全局变量
         */
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_VARIABLE);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "switchNameList", {
        /**
         * 全局开关
         */
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_SWITCH);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "stringNameList", {
        /**
         * 全局字符串
         */
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_STRING);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "playerVariableNameList", {
        /**
         * 玩家变量
         */
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_PLAYER_VARIABLE);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "playerSwitchNameList", {
        /**
         * 玩家开关
         */
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_PLAYER_SWITCH);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "playerStringNameList", {
        /**
         * 玩家字符串
         */
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_PLAYER_STRING);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "sceneList", {
        /**
         * 场景数据
         */
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_SCENE);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "sceneObjectModelList", {
        /**
         * 场景对象模型数据
         */
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_SCENE_OBJECT_MODEL);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "sceneObjectModuleList", {
        /**
         * 场景对象模块数据
         */
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_SCENE_OBJECT_MODULE);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "tileList", {
        /**
         * 获取图块数据
         */
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_TILE);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "avatarActList", {
        /**
         * 获取AVATAR动作列表
         */
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_AVATAR_ACT);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "standingExpressionList", {
        /**
         * 获取立绘表情
         */
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_STANDING_EXPRESSION);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "avatarRefObjList", {
        /**
         * 获取AVATAR参考点列表
         */
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_AVATAR_REF_OBJ);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "animationSignalList", {
        /**
          * 获取动画信号数据
          */
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_ANIMATION_SIGNAL);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "dataStructureList", {
        /**
         * 获取最新的数据结构列表
         */
        get: function () {
            if (Config.EDIT_MODE) {
                return EUIWindowDataStructureConfig.dataStructureClone ? EUIWindowDataStructureConfig.dataStructureClone : Game.data.dataStructureList;
            }
            else if (Config.IS_SERVER) {
                return ServerWorld.gameData.dataStructureList;
            }
            else {
                return Game.data.dataStructureList;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "customModuleList", {
        /**
         * 获取最新的模块种类
         */
        get: function () {
            if (Config.EDIT_MODE) {
                return EUIWindowDataStructureConfig.customModuleClone ? EUIWindowDataStructureConfig.customModuleClone : Game.data.customModuleList;
            }
            else if (Config.IS_SERVER) {
                return ServerWorld.gameData.customModuleList;
            }
            else {
                return Game.data.customModuleList;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "customModuleDataList", {
        /**
         * 获取最新的自定义结构实际数据
         */
        get: function () {
            return this.getNewestDBData(GameData.LIST_TYPE_CUSTOM_MODULE_DATA);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 获取最新的自定义模块实际数据
     */
    Common.getCustomModuleDataList = function (moduleID) {
        var attr = GameData.LIST_TYPE_CUSTOM_MODULE_DATA;
        if (Config.EDIT_MODE) {
            var res = Editor.data && Editor.data.dbData && Editor.data.dbData[attr] && Editor.data.dbData[attr][moduleID] ? Editor.data.dbData[attr][moduleID] : Game.data[attr][moduleID];
            return res;
        }
        else if (Config.IS_SERVER) {
            return ServerWorld.gameData[attr][moduleID];
        }
        else {
            return Game.data[attr][moduleID];
        }
    };
    Object.defineProperty(Common, "customSceneModelList", {
        /**
         * 获取最新的场景模块列表数据
         */
        get: function () {
            return null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "customGameAttribute", {
        /**
         * 获取最新的游戏属性
         */
        get: function () {
            if (Config.EDIT_MODE) {
                return Editor.data.dbData && Editor.data.dbData.customGameAttribute ? Editor.data.dbData.customGameAttribute : Game.data.customGameAttribute;
            }
            else if (Config.IS_SERVER) {
                return ServerWorld.gameData.customGameAttribute;
            }
            else {
                return Game.data.customGameAttribute;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "customSceneEventTypeList", {
        /**
         * 获取自定义场景类别
         * @return [GameListData]
         */
        get: function () {
            if (Config.IS_SERVER) {
                return ServerWorld.gameData.customSceneEventTypeList;
            }
            else {
                return Game.data.customSceneEventTypeList;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "customObjectEventTypeList", {
        /**
         * 获取自定义场景类别
         * @return [GameListData]
         */
        get: function () {
            if (Config.IS_SERVER) {
                return ServerWorld.gameData.customObjectEventTypeList;
            }
            else {
                return Game.data.customObjectEventTypeList;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "customUIEventTypeList", {
        /**
         * 获取自定义场景类别
         * @return [GameListData]
         */
        get: function () {
            if (Config.IS_SERVER) {
                return ServerWorld.gameData.customUIEventTypeList;
            }
            else {
                return Game.data.customUIEventTypeList;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "customCommandTypeList", {
        /**
         * 获取自定义命令设定原型
         */
        get: function () {
            if (Config.IS_SERVER) {
                return ServerWorld.gameData.customCommandTypeList;
            }
            else {
                return Game.data.customCommandTypeList;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "customBehaviorTypeList", {
        /**
         * 获取自定义行为设定原型
         */
        get: function () {
            if (Config.IS_SERVER) {
                return ServerWorld.gameData.customBehaviorTypeList;
            }
            else {
                return Game.data.customBehaviorTypeList;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "avatarList", {
        //------------------------------------------------------------------------------------------------------
        // 数据库预设
        //------------------------------------------------------------------------------------------------------
        /**
         * 获取最新的AVATAR列表
         */
        get: function () {
            return this.getNewestDBData(GameData.LIST_TYPE_AVATAR);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "standAvatarList", {
        /**
         * 获取最新的立绘列表
         */
        get: function () {
            return this.getNewestDBData(GameData.LIST_TYPE_STANDING);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "commonEventList", {
        /**
         * 获取最新的公共事件
         */
        get: function () {
            return this.getNewestDBData(GameData.LIST_TYPE_COMMON_EVENT);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "dialogList", {
        /**
         * 获取最新的对话框
         */
        get: function () {
            return this.getNewestDBData(GameData.LIST_TYPE_DIALOG);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "animationList", {
        /**
         * 获取最新的动画
         */
        get: function () {
            return this.getNewestDBData(GameData.LIST_TYPE_ANIMATION);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "uiList", {
        /**
         * 获取最新的UI
         */
        get: function () {
            return this.getNewestDBData(GameData.LIST_TYPE_UI);
        },
        enumerable: false,
        configurable: true
    });
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取GameData里的数据属性
     */
    Common.getGameDataAttrValue = function (attr) {
        if (Config.IS_SERVER) {
            return ServerWorld.gameData[attr];
        }
        else {
            return Game.data[attr];
        }
    };
    /**
     * 获取数据库里GameData里的数据属性
     */
    Common.getNewestDBData = function (attr) {
        if (Config.EDIT_MODE) {
            return Editor.data && Editor.data.dbData && Editor.data.dbData[attr] ? Editor.data.dbData[attr] : Game.data[attr];
        }
        else if (Config.IS_SERVER) {
            return ServerWorld.gameData[attr];
        }
        else {
            return Game.data[attr];
        }
    };
    return Common;
}());
/**
 * 通用配置
 * Created by 黑暗之神KDS on 2018-05-22 20:26:48.
 */
var Config = /** @class */ (function () {
    function Config() {
    }
    Object.defineProperty(Config, "INDIA_APPLICATION_GAME_INFO", {
        /**
         * 是否运行在测试的独立窗口中的游戏（程序项目-新应用打开）
         */
        get: function () {
            return Config.indiaApplicationGameInfo;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Config, "useNewSceneObjectModel", {
        /**
         * 是否使用新的场景对象模型（0.984改版，变为公共模块+专用模块的组合方式）
         */
        get: function () {
            // 版本号0.984以上或开发GC的环境下
            return ((Config.RELEASE_TEMPLATE_GC_VERSION && Config.RELEASE_TEMPLATE_GC_VERSION >= 0.984) || (Config.EDIT_MODE && !Config.BEHAVIOR_EDIT_MODE && !Config.RELEASE_MODE));
        },
        enumerable: false,
        configurable: true
    });
    //------------------------------------------------------------------------------------------------------
    //  for private
    //------------------------------------------------------------------------------------------------------
    /**
     * 初始化
     */
    Config.init = function () {
        var max = 4096;
        Config.IS_SERVER = Common.runPlatform != 2;
        Config.SCENE_GRID_SIZE = Math.min(max, Config.SCENE_GRID_SIZE);
        if (!Config.IS_SERVER) {
            if (!Config.EDIT_MODE && Config.DEFAULT_FONT) {
                Font.defaultFamily = Config.DEFAULT_FONT;
            }
            stage.on(EventObject.RESIZE, this, Config.refreshTileSplitSize, [false]);
            Config.refreshTileSplitSize(true);
        }
    };
    Config.refreshTileSplitSize = function (force) {
        if (force === void 0) { force = false; }
        // 观察一下动态更改Config.TILE_SPLIT_SIZE可能带来的问题（目前在编辑器环境下是不会重新计算的以防止报错出现）
        // 运行时调用：resizeTileSplit、drawTile、flushTile、clearTile会使用到，查看由于尺寸改变后动态更改图块时的报错问题
        if (!force && Config.TILE_SPLIT_SIZE_LOCK && Config.EDIT_MODE)
            return;
        var max = 4096;
        Config.TILE_SPLIT_SIZE = Math.floor(max / Config.SCENE_GRID_SIZE) * Config.SCENE_GRID_SIZE;
        // 根据预设比例获取实际显示区域宽高
        var per = GameUtils.getAutoFitSizePre(new Rectangle(0, 0, Config.WINDOW_WIDTH, Config.WINDOW_HEIGHT), new Rectangle(0, 0, stage.width, stage.height));
        var displayWidth = Math.floor(Math.min(Config.WINDOW_WIDTH, Browser.width) * per);
        var displayHeight = Math.floor(Math.min(Config.WINDOW_HEIGHT, Browser.height) * per);
        if (Config.TILE_SPLIT_SIZE > displayWidth || Config.TILE_SPLIT_SIZE > displayHeight) {
            Config.TILE_SPLIT_SIZE = Math.min(displayWidth, displayHeight);
        }
        var p = 2;
        while (1) {
            p *= 2;
            if (p > Config.TILE_SPLIT_SIZE) {
                break;
            }
        }
        Config.TILE_SPLIT_SIZE = p / 2;
        // 必须是格子的整数倍
        if ((Config.TILE_SPLIT_SIZE / Config.SCENE_GRID_SIZE) != Math.floor(Config.TILE_SPLIT_SIZE / Config.SCENE_GRID_SIZE)) {
            var p = 1;
            while (1) {
                if (Config.SCENE_GRID_SIZE * p > Config.TILE_SPLIT_SIZE) {
                    Config.TILE_SPLIT_SIZE = Config.SCENE_GRID_SIZE * (p - 1);
                    break;
                }
                p++;
            }
        }
        if (Config.TILE_SPLIT_SIZE < 0) {
            alert("网格设定有误!");
        }
        // trace("尺寸大小",Config.TILE_SPLIT_SIZE);
    };
    Object.defineProperty(Config, "indiaApplicationGameInfo", {
        // 实现-是否运行在测试的独立窗口中的游戏（程序项目-新应用打开）
        get: function () {
            if (Config.IS_SERVER)
                return null;
            if (window.location.href.indexOf("gcDebugPort=") == -1)
                return null;
            var params = window.location.href.split("?").pop();
            var paramsArr = params.split("&");
            var res = {};
            for (var i = 0; i < paramsArr.length; i++) {
                var pStr = paramsArr[i];
                var pStrArr = pStr.split("=");
                var pName = pStrArr[0];
                var pValue = pStrArr[1];
                res[pName] = pValue;
            }
            if (res.gcAppID == null || res.gcDebugPort == null)
                return null;
            return res;
        },
        enumerable: false,
        configurable: true
    });
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 使用F1-F12功能键，关闭此项功能后同时也会禁止浏览器环境下的该按键功能
     * -- F5：重置游戏
     * -- F11：全屏化
     * -- F12：开发者工具
     */
    Config.USE_FN = true;
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 需要保存的属性
     */
    Config.saveAttrs = ["verManager", "startupPreloadFonts", "FONTS", "EDITOR_MAG_FILTER", "IMAGE_LAYER_DP_COORD_JS", "IMAGE_LAYER_DP_COORD_TS",
        "CREATED_GC_VERSION", "RELEASE_TEMPLATE_GC_VERSION", "gameSID", "gameProjectName", "gameVersion", "fragmentFileVersion", "GAME_MAG_FILTER"];
    /**
     * 引擎合并启动文件 v0.9836 之后将游戏启动时json合并的功能正式化放到引擎了而非项目层临时
     * 旧工程代码已做好兼容，会自动失效，新版本模板相关代码已删除
     */
    Config.ENGINE_MERGE_STARTUP_FILE = true;
    /**
     * 兼容旧工程
     */
    Config.compatibleOldProgram = true;
    /**
    * JSON数据文件路径
    */
    Config.JSON_PATH = "asset/json";
    /**
     * 配置文件数据
     */
    Config.JSON_CONFIG = Config.JSON_PATH + "/config.json";
    /**
     * 当场景格子数量【宽高任意一个】大于SCENE_BY_DRAWLINES_MAX时，采用贴图fillTexture绘制，否则采用drawlines绘制网格
     */
    Config.SCENE_BY_DRAWLINES_MAX = 500;
    /**
     * 自定义网格数据层配置
     */
    Config.DATA_GRIDS = [];
    /**
     * 字体列表：字体文件名称 对应文件夹 asset/font
     * 【truetype(.ttf)、opentype（.otf）、embedded-opentype(.eot)、svg(.svg)、woff(.woff)】
     */
    Config.FONTS = [];
    /**
     * 预加载字体
     */
    Config.startupPreloadFonts = true;
    /**
     * 多版本管理数据
     */
    Config.verManager = [];
    return Config;
}());
/**
 * Created by 黑暗之神KDS on 2019-05-22 00:25:37.
 */
var Player = /** @class */ (function () {
    /**
     * 构造函数
     * @param dataCls
     */
    function Player(dataCls) {
        if (dataCls === void 0) { dataCls = null; }
        if (dataCls)
            this.data = new dataCls();
        else {
            this.data = {};
        }
        ;
        if (Config.IS_SERVER) {
            this.variable = new Variable(this);
        }
    }
    /**
     * 进入指定场景
     * @param sceneID 场景ID
     * @param x 实际坐标x
     * @param y 实际坐标y
     */
    Player.prototype.toScene = function (sceneID, x, y) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
    };
    /**
     * 安装默认配置属性
     */
    Player.installCustomData = function (player) {
        // 安装玩家属性，根据玩家属性配置预设
        var customGameAttribute = Common.customGameAttribute;
        var attrSettings = CustomCompositeSetting.getAllAttributes(customGameAttribute.playerAttributeSetting, false);
        CustomAttributeSetting.installAttributeFromEditorSet(player.data, customGameAttribute.playerAttributeConfig.attrs, attrSettings, false, false, GameData.CUSTOM_ATTR_PLAYER_DATA);
    };
    /**
     * 安装存档数据
     * -- 从存档中恢复玩家数据
     * -- 从存档中恢复sceneObject数据
     * @param player
     * @param fileData
     */
    Player.installFilePlayerData = function (player, fileData) {
        // 玩家属性默认值
        Player.installCustomData(player);
        // 安装来自存档的玩家数据
        var fileSceneObjectData = fileData.sceneObject;
        delete fileData.sceneObject;
        // 从存档中恢复除sceneObject外的玩家数据
        var customGameAttribute = Common.customGameAttribute;
        var attrSettings = CustomCompositeSetting.getAllAttributes(customGameAttribute.playerAttributeSetting, false);
        CustomAttributeSetting.installAttributeFromRecordData(player.data, fileData, attrSettings, customGameAttribute.playerAttributeConfig.attrs, GameData.CUSTOM_ATTR_PLAYER_DATA);
        // 从存档中恢复sceneObject数据：安装来自存档的场景对象数据：存在模型的话使用模型数据来格式化存档数据
        var modelData = Common.sceneObjectModelList.data[player.data.sceneObject.modelID];
        if (modelData) {
            if (Config.useNewSceneObjectModel) {
                var fixModelData = Common.sceneObjectModelList.data[0];
            }
            else {
                fixModelData = modelData;
            }
            CustomAttributeSetting.installAttributeFromRecordData(player.data.sceneObject, fileSceneObjectData, fixModelData.varAttributes, Config.BORN.customAttribute, GameData.CUSTOM_ATTR_SCENE_OBJECT_DATA);
        }
    };
    return Player;
}());
// 材质初始化
Shader2D.initMaterial = function () {
    // -- 清理shader program缓存
    ShaderValue.kdsMaterialShaders = [];
    Shader.sharders = [];
    Shader.KDSPSShaderLogicArr = {}; // KDS_M1 = 代码
    // -- 计算材质shader program
    var materialUniformCode = "";
    var materialUniformFuncs = "";
    var materialLogicCode = "// KDS_PS_SHADER_LOGICS\n";
    var materialList = Game.data.materialList;
    var len = GameListData.getLength(materialList);
    var exit = false;
    for (var i = 1; i <= len; i++) {
        var material = materialList.data[i];
        // -- 检查shader代码中是否存在 mf材质编号_main
        var mf_mainReg = new RegExp("vec4 +?mf" + i + "_main {0,999}\\(");
        var shaderCode = material.customShader;
        if (!shaderCode)
            continue;
        shaderCode = CustomCompositeSetting.replaceShaderNotes(material, shaderCode, "");
        if (shaderCode.search(mf_mainReg) == -1)
            continue;
        exit = true;
        // -- 宏定义
        var MACRO_START = "\n#ifdef KDS_M" + i + "\n";
        var MACRO_END = "\n#endif\n";
        // -- 定义uniform
        var uniformsCode = CustomCompositeSetting.getShaderUniformCodes(material, false) + "\n";
        materialUniformCode += MACRO_START;
        materialUniformCode += uniformsCode;
        materialUniformCode += MACRO_END;
        // -- 追加uniform 函数
        materialUniformFuncs += MACRO_START;
        materialUniformFuncs += shaderCode + "\n";
        materialUniformFuncs += MACRO_END;
        // -- 追加logic调用main函数
        var KDSShaderLogic = "";
        KDSShaderLogic += MACRO_START;
        KDSShaderLogic += "gl_FragColor=mf" + i + "_main();\n";
        KDSShaderLogic += MACRO_END;
        Shader.KDSPSShaderLogicArr["KDS_M" + i] = KDSShaderLogic;
    }
    if (len == 0 || !exit) {
        Shader.addInclude("parts/KDS_ps_logic.glsl", " ", true);
        Shader.addInclude("parts/KDS_ps_uniform.glsl", " ", true);
    }
    else {
        Shader.addInclude("parts/KDS_ps_logic.glsl", materialLogicCode, true);
        if (materialUniformCode + materialUniformFuncs != "") {
            Shader.addInclude("parts/KDS_ps_uniform.glsl", materialUniformCode + materialUniformFuncs, true);
        }
    }
    var vs, ps;
    // ----
    vs = "\n\tattribute vec4 position;\n\tattribute vec2 texcoord;\n\tuniform vec2 size;\n\t#ifdef WORLDMAT\n\t uniform mat4 mmat;\n\t#endif\n\tvarying vec2 v_texcoord;\n\tvoid main() {\n\t\t  vec2 sizex = size;\n\t\t  #ifdef WORLDMAT\n\t\t   vec4 pos=mmat*position;\n\t\t   gl_Position =vec4((pos.x/sizex.x-0.5)*2.0,(0.5-pos.y/sizex.y)*2.0,pos.z,1.0);\n\t\t  #else\n\t\t   gl_Position =vec4((position.x/sizex.x-0.5)*2.0,(0.5-position.y/sizex.y)*2.0,position.z,1.0);\n\t\t  #endif\n\t\t v_texcoord = texcoord;\n\t}";
    ps = "\n\t" + (Config.EDIT_MODE ? "#define IN_GC_EDITOR" : "") + "\n\tprecision mediump float;\n\t//precision highp float;\n\tvarying vec2 v_texcoord;\n\tuniform sampler2D texture;\n\tuniform float alpha;\n\tuniform vec2 renderTargetSize;\n\tuniform float u_yFilp;\n\n\tvec2 getDrawUV(vec2 texcoord,vec4 p){\n\t\tvec2 drawUV = texcoord;\n\t\tdrawUV.x = fract(drawUV.x);\n\t\tif(u_yFilp==1.0){\n\t\t\tdrawUV.y = fract(drawUV.y);\n\t\t}\n\t\telse{\n\t\t\tdrawUV.y = fract(drawUV.y)*-1.0+1.0;\n\t\t}\n    \t\n\n    \tdrawUV.x *= p.x;\n    \tdrawUV.y *= p.y;\n\n    \tdrawUV.x += p.z;\n    \tdrawUV.y += p.w;\n\n\t\treturn drawUV;\n\t}\n\tvec4 getTextureColor(vec2 texcoord) {\n\t\t vec4 color= texture2D(texture, fract(texcoord));\n\t\t return color;\n\t}\n\n\tvec2 getInRangeTextureCoord(vec2 texcoord){\n\t\treturn fract(texcoord);\n\t}\n\t\n\t#include?KDS  \"parts/KDS_ps_uniform.glsl\";\n\t#include?BLUR_FILTER  \"parts/BlurFilter_ps_uniform.glsl\";\n\t#include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\n\t#include?GLOW_FILTER \"parts/GlowFilter_ps_uniform.glsl\";\n\t#include?COLOR_ADD \"parts/ColorAdd_ps_uniform.glsl\";\n\tvoid main() {\n\n\t\tvec4 color= getTextureColor(v_texcoord);\n\t\tcolor.a*=alpha;\n\t\tcolor.rgb*=alpha;\n\t\tgl_FragColor=color;\n\n\t\t   #include?KDS  \"parts/KDS_ps_logic.glsl\";\n\t\t   #include?COLOR_ADD \"parts/ColorAdd_ps_logic.glsl\"; \n\t\t   #include?BLUR_FILTER  \"parts/BlurFilter_ps_logic.glsl\";\n\t\t   #include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n\t\t   #include?GLOW_FILTER \"parts/GlowFilter_ps_logic.glsl\";\n\n\t\t//    gl_FragColor.g = 1.0;\n\n\t}";
    Shader.preCompile2D(0, /*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/ 0x01, vs, ps, null);
    ////
    vs = "\n\tattribute vec4 position;\n\tattribute vec2 texcoord;\n\tuniform vec2 size;\n\t#ifdef WORLDMAT\n\tuniform mat4 mmat;\n\t#endif\n\tvarying vec2 v_texcoord;\n\tvoid main() {\n\t\t  #ifdef WORLDMAT\n\t\t    vec4 pos=mmat*position;\n\t\t\tgl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n\t\t  #else\n\t\t\tgl_Position =vec4((position.x/size.x-0.5)*2.0,(0.5-position.y/size.y)*2.0,position.z,1.0);\n\t\t  #endif\n\t\t  v_texcoord = texcoord;\n\t}";
    ps = "\n\t" + (Config.EDIT_MODE ? "#define IN_GC_EDITOR" : "") + "\n\t#ifdef FSHIGHPRECISION\n\tprecision highp float;\n\t#else\n\tprecision mediump float;\n\t#endif\n\t//precision highp float;\n\tvarying vec2 v_texcoord;\n\tuniform sampler2D texture;\n\tuniform float alpha;\n\tuniform vec4 u_TexRange;\n\tuniform vec2 u_offset;\n\tuniform vec2 renderTargetSize;\n\n\tvec2 getDrawUV(vec2 texcoord,vec4 p){\n\t\tvec2 drawUV = texcoord;\n\t\tdrawUV.x = fract(drawUV.x);\n\t\tdrawUV.y = fract(drawUV.y); // *-1.0+1.0\n\n    \tdrawUV.x *= p.x;\n    \tdrawUV.y *= p.y;\n\n    \tdrawUV.x += p.z;\n    \tdrawUV.y += p.w;\n\n\t\treturn drawUV;\n\t}\n\t\n\tvec4 getTextureColor(vec2 texcoord) {\n\t\t vec2 newTexCoord;\n\t\t newTexCoord.x = mod(u_offset.x + texcoord.x,u_TexRange.y) + u_TexRange.x;\n\t\t newTexCoord.y = mod(u_offset.y + texcoord.y,u_TexRange.w) + u_TexRange.z;\n\t\t vec4 color = texture2D(texture, newTexCoord);\n\t\t return color;\n\t}\n\n\tvec2 getInRangeTextureCoord(vec2 texcoord){\n\t\tvec2 newTexCoord;\n\t\tnewTexCoord.x = fract(mod(u_offset.x + texcoord.x,u_TexRange.y) + u_TexRange.x);\n\t\tnewTexCoord.y = fract(mod(u_offset.y + texcoord.y,u_TexRange.w) + u_TexRange.z);\n\t\treturn newTexCoord;\n\t}\n\n\t#include?KDS  \"parts/KDS_ps_uniform.glsl\";\n\t#include?BLUR_FILTER  \"parts/BlurFilter_ps_uniform.glsl\";\n\t#include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\n\t#include?GLOW_FILTER \"parts/GlowFilter_ps_uniform.glsl\";\n\t#include?COLOR_ADD \"parts/ColorAdd_ps_uniform.glsl\";\n\tvoid main() {\n\t\tvec4 color= getTextureColor(v_texcoord);\n\t\tcolor.a*=alpha;\n\t\tcolor.rgb*=alpha;\n\t\tgl_FragColor=color;\n\t\t #include?KDS  \"parts/KDS_ps_logic.glsl\";\n\t\t #include?COLOR_ADD \"parts/ColorAdd_ps_logic.glsl\";   \n\t\t #include?BLUR_FILTER  \"parts/BlurFilter_ps_logic.glsl\";\n\t\t #include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n\t\t #include?GLOW_FILTER \"parts/GlowFilter_ps_logic.glsl\";\n\t}";
    Shader.preCompile2D(0, /*laya.webgl.shader.d2.ShaderDefines2D.FILLTEXTURE*/ 0x100, vs, ps, null);
    ShaderDefines2D.reg("KDS", GameSpriteMaterialPass.shaderType);
};
//------------------------------------------------------------------------------------------------------
// 
//------------------------------------------------------------------------------------------------------
// 覆盖 laya中 Shader2D.__init__ ，优化 BlurFilter，模糊0.2-0.3左右时候图片消失了 问题
Shader2D.__init__ = function () {
    Shader.addInclude("parts/ColorFilter_ps_uniform.glsl", "uniform vec4 colorAlpha;\nuniform mat4 colorMat;");
    Shader.addInclude("parts/ColorFilter_ps_logic.glsl", "mat4 alphaMat =colorMat;\n\nalphaMat[0][3] *= gl_FragColor.a;\nalphaMat[1][3] *= gl_FragColor.a;\nalphaMat[2][3] *= gl_FragColor.a;\n\ngl_FragColor = gl_FragColor * alphaMat;\ngl_FragColor += colorAlpha*gl_FragColor.a;\n");
    Shader.addInclude("parts/GlowFilter_ps_uniform.glsl", "\n\tuniform vec4 u_color;\n\tuniform float u_strength;\n\tuniform float u_blurX;\n\tuniform float u_blurY;\n\tuniform float u_offsetX;\n\tuniform float u_offsetY;\n\tuniform float u_textW;\n\tuniform float u_textH;");
    Shader.addInclude("parts/GlowFilter_ps_logic.glsl", "\n\tconst float c_IterationTime = 10.0;\n\tfloat floatIterationTotalTime = c_IterationTime * c_IterationTime;\n\tvec4 vec4Color = vec4(0.0,0.0,0.0,0.0);\n\tvec2 vec2FilterDir = vec2(-(u_offsetX)/u_textW,-(u_offsetY)/u_textH);\n\tvec2 vec2FilterOff = vec2(u_blurX/u_textW/c_IterationTime * 2.0,u_blurY/u_textH/c_IterationTime * 2.0);\n\tfloat maxNum = u_blurX * u_blurY;\n\tvec2 vec2Off = vec2(0.0,0.0);\n\tfloat floatOff = c_IterationTime/2.0;\n\tfor(float i = 0.0;i<=c_IterationTime; ++i){\n\t\t\tfor(float j = 0.0;j<=c_IterationTime; ++j){\n\t\t\t\tvec2Off = vec2(vec2FilterOff.x * (i - floatOff),vec2FilterOff.y * (j - floatOff));\n\t\t\t\tvec4Color += texture2D(texture, v_texcoord + vec2FilterDir + vec2Off)/floatIterationTotalTime;\n\t\t\t}\n\t}\n\tgl_FragColor = vec4(u_color.rgb,vec4Color.a * u_strength);\n\tgl_FragColor.rgb *= gl_FragColor.a;");
    Shader.addInclude("parts/BlurFilter_ps_logic.glsl", "gl_FragColor =   blur();\ngl_FragColor.w*=alpha;");
    // ---------------
    // 注释
    Shader.addInclude("parts/BlurFilter_ps_uniform.glsl", "\n\tuniform vec4 strength_sig2_2sig2_gauss1;\n\tuniform vec2 blurInfo;\n\n\tvec4 blur(){\n\t  float mu3_strength = strength_sig2_2sig2_gauss1[0];\n\t  \n\n\t  // \u5982\u679C\u5F3A\u5EA6\u4E3A0\u5219\u76F4\u63A5\u8FD4\u56DE\n\t   if(mu3_strength==0.0)return gl_FragColor;\n\t  // \u5468\u56F4NxN\u50CF\u7D20\uFF0C\u4EE5\u81EA\u5DF1\u4E3A\u4E2D\u5FC3 blurw\u8D8A\u5927\u5219\u6548\u679C\u8D8A\u597D\uFF0C\u4F46\u8D8A\u6D88\u8017\u6027\u80FD\n      const float blurw = 9.0;\n\t  float blurw10 = (blurw+1.0);\n\t  float blurw5 = blurw10/2.0;\n\t  float blurw100 = blurw10*blurw10;\n\t  float blurw50 =  blurw100/2.0;\n\t  float blurwP1 = 1.0/blurw100;\n\t  // \u83B7\u53D6\u5355\u4F4D\u50CF\u7D20\uFF0C\u5E76\u6839\u636E\u5F3A\u5EA6\u8FDB\u884C\u6269\u6563\n\t  float dx = 1.0/blurInfo.x * mu3_strength/3.0; // 100=(blurw+1)^2\n\t  float dy = 1.0/blurInfo.y * mu3_strength/3.0; // 100=(blurw+1)^2\n\t  // \n\t  vec4 vec4Color = vec4(0.0,0.0,0.0,0.0);\n\t  float halfDx = dx * blurw50;\n\t  float halfDy = dy * blurw50;\n\t  // \u8D77\u59CB\u5750\u6807\uFF1A\u5F53\u524D\u5750\u6807\u70B9 - N/2\n\t  vec2 startpos=vec2(v_texcoord.x-halfDx,v_texcoord.y-halfDy);\n\t  vec2 ctexcoord = startpos;\n\t  // \u5206\u644A\u7684\u989C\u8272\n\t  float pColorPer = blurwP1;\n\t  // \u91C7\u6837\u56FA\u5B9A\u504F\u79FB\n\t  float fixDx = halfDx - dx*blurw5;\n\t  float fixDy = halfDy - dy*blurw5;\n\t  // \u91C7\u6837\u4EE5\u81EA\u5DF1\u4E3A\u4E2D\u5FC3\u91C7\u6837 N x N \u50CF\u7D20\u8FDB\u884C\u6DF7\u5408\n\t  for(float y = 0.0;y<=blurw; ++y){\n\t\t for(float x = 0.0;x<=blurw; ++x){\n           \t  ctexcoord.x = startpos.x + dx*x + fixDx;\n\t          ctexcoord.y = startpos.y + dy*y + fixDy;\n\t\t\t  float xPer = (1.0-abs((x-blurw5)/blurw5));\n\t\t\t  float yPer = (1.0-abs((y-blurw5)/blurw5));\n\t\t\t  vec4Color += getTextureColor(ctexcoord)*pColorPer*xPer*yPer*4.0;\n\t\t  }\n\t }\n\t return vec4Color;\n\t}\n\t\n\t\n\t\n\t");
    // 替换
    // 参考
    // @see https://github.com/layabox/layaair/blob/master/src/webGL/src/laya/webgl/shader/d2/files/parts/BlurFilter_ps_uniform.glsl
    // @see https://github.com/egret-labs/egret-core/blob/master/src/egret/web/rendering/webgl/shaders/blur_frag.glsl
    // @see https://github.com/pixijs/pixi.js/blob/dev/packages/filters/filter-blur/src/generateBlurFragSource.js
    // Shader.addInclude("parts/BlurFilter_ps_uniform.glsl",
    // 	`
    // uniform vec4 strength_sig2_2sig2_gauss1;
    // uniform vec2 blurInfo;
    // // float sigma=strength/3.0;
    // vec4 blur(){
    // 	const int sampleRadius = 5;
    // 	const int samples = sampleRadius * 2 + 1;
    // 	// 
    // 	float GAUSSIAN_VALUES[11];
    // 	GAUSSIAN_VALUES[0] = 0.0093;
    // 	GAUSSIAN_VALUES[1] = 0.028002;
    // 	GAUSSIAN_VALUES[2] = 0.065984;
    // 	GAUSSIAN_VALUES[3] = 0.121703;
    // 	GAUSSIAN_VALUES[4] = 0.175713;
    // 	GAUSSIAN_VALUES[5] = 0.198596;
    // 	GAUSSIAN_VALUES[6] = 0.175713;
    // 	GAUSSIAN_VALUES[7] = 0.121703;
    // 	GAUSSIAN_VALUES[8] = 0.065984;
    // 	GAUSSIAN_VALUES[9] = 0.028002;
    // 	GAUSSIAN_VALUES[10] = 0.0093;
    // 	//
    // 	vec2 blurUv = strength_sig2_2sig2_gauss1.xx / blurInfo;
    // 	vec4 color = vec4(0, 0, 0, 0);
    // 	vec2 uv = vec2(0.0, 0.0);
    // 	blurUv /= float(sampleRadius);
    // 	for (int i = -sampleRadius; i <= sampleRadius; i++) {
    // 		uv.x = v_texcoord.x + float(i) * blurUv.x;
    // 		uv.y = v_texcoord.y + float(i) * blurUv.y;
    // 		color += texture2D(texture, uv) * GAUSSIAN_VALUES[i + sampleRadius];
    // 	}
    // 	return color;
    // }
    // `
    // );
    //------------------------------------------------------------------------------------------------------
    // KKKDDDSSS
    //------------------------------------------------------------------------------------------------------
    var KDSLogin = "\n\t\tgl_FragColor =   cccc();\ngl_FragColor.w*=alpha;\n\t";
    // KDSLogin = `
    // 	gl_FragColor =   cccc();
    // `
    // Shader.addInclude("parts/KDS_ps_logic.glsl", KDSLogin);
    var KDSLogin2 = "\n\t\tgl_FragColor.r = 1.0;\n\t\t// gl_FragColor.w*=alpha;\n\t";
    // Shader.addInclude("parts/KDS_ps_logic.glsl", KDSLogin2, true);
    var KDSUniform = "\n\tuniform vec4 strength_sig2_2sig2_gauss1;\n\tuniform vec2 blurInfo;\n\n\tuniform mat4 colorMatx;\n\tuniform vec4 colorMaty;\n\t\n\t\n\tuniform float xxxxx;\n\tuniform sampler2D tex2;\n\tuniform sampler2D tex3;\n\tuniform vec2 kds_vec2;\n\tuniform vec3 kds_vec3;\n\tuniform vec4 kds_vec4;\n\tuniform float rd;\n\tuniform float rd2;\n\tuniform float fd;\n\tuniform float autoI;\n\n\tuniform float zzzzw;\n\n\t\n\t\n\t\n\t// uniform sampler2D tex4;\n\t// uniform sampler2D tex5;\n\t// uniform sampler2D tex6;\n\t// uniform sampler2D tex7;\n\t// uniform sampler2D tex8;\n\t// uniform sampler2D tex9;\n\t// uniform sampler2D tex10;\n\n\t// uniform sampler2D tex11;\n\t// uniform sampler2D tex12;\n\t// uniform sampler2D tex13;\n\n\t// uniform sampler2D tex14;\n\t// uniform sampler2D tex15;\n\t// uniform sampler2D tex16;\n\n\t// uniform sampler2D tex17;\n\t// uniform sampler2D tex18;\n\t// uniform sampler2D tex19;\n\t\n\t\n\tuniform float mu1_a1;\n\tuniform float mu1_a2;\n\n\t\n\t\n\n\tvec4 bbbb(){\n\t\treturn vec4(1.0,0.5,0.0,1.0);\n\t}\n\tvec4 cccc(){\n\t\tgl_FragColor.g += mu1_a2;\n\t\treturn gl_FragColor;;\n\n\t\t// \u6D4B\u8BD5\u8272\u8C03\n\t\t// mat4 alphaMat =colorMatx;\n\t\t// float lastDr = alphaMat[0][3];\n\t\t// float lastDg = alphaMat[1][3];\n\t\t// float lastDb = alphaMat[2][3];\n\t\t// alphaMat[0][3] =0.0;\n\t\t// alphaMat[1][3] =0.0;\n\t\t// alphaMat[2][3] =0.0;\n\t\t// gl_FragColor = gl_FragColor * alphaMat;\n\t\t// gl_FragColor.r += lastDr*(lastDr<0.0?gl_FragColor.r:1.0);\n\t\t// gl_FragColor.g += lastDg*(lastDr<0.0?gl_FragColor.g:1.0);\n\t\t// gl_FragColor.b += lastDb*(lastDr<0.0?gl_FragColor.b:1.0);\n\t\t// return gl_FragColor;\n\n\t\t\n\t\t// \u53D6\u5F97UV\uFF0C\u5F53\u524D\u9876\u70B9\u662F\u8BE5\u5BF9\u8C61\u7684\u5305\u56F4\u76D2\uFF08\u5982\u679C\u5408\u5E76\u7684\u8BDD\u5219\u4F1A\u5408\u5E76\u8BA1\u7B97\u5305\u56F4\u76D2\uFF09\n\t\tvec2 uvCustom = v_texcoord;\n\t\t// \u622A\u53D6 [0,1] \u8303\u56F4\u5185\n\n// \t\tif(fd!=1.1){\n// \t    vec4 zhujue = texture2D(texture, uvCustom);\n// \t\tzhujue.r = 1.0;\n// \t\treturn zhujue;\n// }\n\t\t\n\t\t\n\t\tuvCustom.x = fract(uvCustom.x);\n\t\tuvCustom.y = fract(uvCustom.y);\n\t\t\n\t\t\n\t\t\n\n\n\t\t// uvCustom.x *= 10000.0;\n\t\t// uvCustom.y *= 10000.0;\n\t\t// uvCustom.x = mod(uvCustom.x,10000.0);\n\t\t// uvCustom.y = mod(uvCustom.y,10000.0);\n\t\t\n\t\t//  uvCustom.x /= 10000.0;\n\t\t//  uvCustom.y /= 10000.0;\n\n\t\t\n\tif(fd!=1.1){\n\t\tif(fd==15.0){\n\t\t\tfloat yyy = floor(uvCustom.y * 400.0);\n\t\t\tif(mod(yyy,2.0)==0.0){\n\t\t\t\tuvCustom.x -= 0.01*autoI*uvCustom.y * yyy/400.0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tuvCustom.x += 0.01*autoI*uvCustom.y * yyy/400.0;\n\t\t\t}\n\n\t\t\t\n\t\t}\n\t\telse{\n\t\t\tuvCustom.x += 0.01*rd*uvCustom.y;\n\t\t\tuvCustom.y += 0.01*rd2*uvCustom.x;\n\t\t}\n\t\n}\n\t\t// uvCustom.x*=uvCustom.x;\n\t\t// uvCustom.y*=uvCustom.y;\n\t\t\n\n\n\t\tvec4 color = texture2D(texture, uvCustom);\n\t\t\n\t\n\t\t\n\t\t// \u7ED8\u5236\u81EA\u5B9A\u4E49\u56FE\u5F621\uFF0C\u6B63\u5E38\u9700\u8981\u98A0\u5012\n\t\tuvCustom.y = fract(uvCustom.y)*-1.0+1.0;\n\t\t\n\t\t\n\t\t\n\t\tvec4 transColor = texture2D(tex3, v_texcoord);\n\t\t// if(fd==1.1){\n\t\t//    color += texture2D(tex2, uvCustom)*0.5;\n\t\t// }\n\t\t//\n\n\t\t// \u6E10\u53D8\n\t\tif(fd==1.1){\n\t\t\t\n\t\t    float transShow = (1.0*autoI-transColor.g);\n\t\t\tif(transShow>1.0)transShow=1.0;\n\t\t\tif(transShow<0.0)transShow=0.0;\n\t\t\tvec4 toColor = transShow*texture2D(tex2, uvCustom);\n\t\t\tif(toColor.r>0.1){\n\t\t\t\tcolor *= 0.2;\n\t\t\t\tcolor += toColor;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\n\t\t\n\t\n\t\tif(color.r==1.0){\n\t\t\t\n\t\t}\n\t\t\n\t\t#ifdef KDS_M1\n\t\t\tcolor.r = 1.0;\n\t\t\t\n\t\t\t\n\t\t#endif\n\n\t\t#ifdef KDS_M2\n\t\t\tcolor.g = 1.0;\n\t\t#endif\n\n\t\t\n\t\t\n\n\t\treturn color;\n\t\t\n\t}\n\n\n\tvec4 dddd(){\n\t\t\n\t\treturn vec4(1.0,0.5,0.0,1.0);\n\n\t\tconst int sampleRadius = 5;\n\t\tconst int samples = sampleRadius * 2 + 1;\n\t\t// \n\t\tfloat GAUSSIAN_VALUES[11];\n\t\tGAUSSIAN_VALUES[0] = 0.0093;\n\t\tGAUSSIAN_VALUES[1] = 0.028002;\n\t\tGAUSSIAN_VALUES[2] = 0.065984;\n\t\tGAUSSIAN_VALUES[3] = 0.121703;\n\t\tGAUSSIAN_VALUES[4] = 0.175713;\n\t\tGAUSSIAN_VALUES[5] = 0.198596;\n\t\tGAUSSIAN_VALUES[6] = 0.175713;\n\t\tGAUSSIAN_VALUES[7] = 0.121703;\n\t\tGAUSSIAN_VALUES[8] = 0.065984;\n\t\tGAUSSIAN_VALUES[9] = 0.028002;\n\t\tGAUSSIAN_VALUES[10] = 0.0093;\n\t\t//\n\t\tvec2 blurUv = vec2(strength_sig2_2sig2_gauss1.x / blurInfo.x,strength_sig2_2sig2_gauss1.x / blurInfo.y);\n\t\tvec4 color = vec4(0, 0, 0, 0);\n\t\tvec2 uv = vec2(0.0, 0.0);\n\t\tblurUv.x /= 5.0;\n\t\n\t\t// for (int i = -sampleRadius; i <= sampleRadius; i++) {\n\t\t// \tuv.x = v_texcoord.x + float(i) * blurUv.x;\n\t\t// \tuv.y = v_texcoord.y + float(i) * blurUv.y;\n\t\t// \tcolor += texture2D(texture, uv) * GAUSSIAN_VALUES[i + sampleRadius];\n\t\t// }\n\t\t// // color.g = 0.0;\n\t\t// color.b = xxxxx;\n\n\t\t// vec2 uvCustom = v_texcoord;\n\t\t// // uvCustom.y *=-1.0;\n\n\t\t// if(uvCustom.y>=1.0)uvCustom.y=1.0;\n\t\t// // else if(uvCustom.y==1.0)uvCustom.y=0.0;\n\n\t\t// color.r += kds_vec3.x;\n\n\t\t// color = texture2D(tex2, uvCustom);\n\t\t\n\t\t// return color;\n\t}\n\n\t";
    // 测试100万可以支持（3W左右个shader），已经需要5-10s的运行时，通常情况下一个游戏可能最多100个左右的自定义shader（3300），
    // for(var i=2;i<3300;i++){
    // 	KDSUniform = `
    // 	float kds${i}Func(){
    // 	return 0.0;
    // 	}
    // ` + KDSUniform;
    // }
    // 测试uniform数目
    // for(var i=1;i<1000;i++){
    // 	KDSUniform = `
    // 	uniform vec4 xxxxx${i};
    // ` + KDSUniform;
    // }
    // Shader.addInclude("parts/KDS_ps_uniform.glsl", KDSUniform);
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    //------------------------------------------------------------------------------------------------------
    // Custom
    //------------------------------------------------------------------------------------------------------
    var kds_customUniform = "\n\t\tuniform vec4 colorAlpha;\n\t\tuniform mat4 colorMat;\n\t\tfloat test;\n\t\tfloat xxxxx;\n\t";
    // 测试uniform数目
    // for (var i = 1; i < 1000; i++) {
    // 	kds_customUniform += `
    // 	uniform vec4 xxxxx${i};
    // `;
    // }
    Shader.addInclude("parts/CUSTOM_ps_logic.glsl", "mat4 alphaMat =colorMat;\n\tfloat lastDr = alphaMat[0][3];\n\tfloat lastDg = alphaMat[1][3];\n\tfloat lastDb = alphaMat[2][3];\n\talphaMat[0][3] =0.0;\n\talphaMat[1][3] =0.0;\n\talphaMat[2][3] =0.0;\n\tgl_FragColor = gl_FragColor * alphaMat;\n\tgl_FragColor.r += lastDr*(lastDr<0.0?gl_FragColor.r:1.0);\n\tgl_FragColor.g += lastDg*(lastDr<0.0?gl_FragColor.g:1.0);\n\tgl_FragColor.b += lastDb*(lastDr<0.0?gl_FragColor.b:1.0);\n\n\t\n\t");
    Shader.addInclude("parts/CUSTOM_ps_uniform.glsl", kds_customUniform);
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    // ---------------
    Shader.addInclude("parts/ColorAdd_ps_uniform.glsl", "uniform vec4 colorAdd;\n");
    Shader.addInclude("parts/ColorAdd_ps_logic.glsl", "gl_FragColor = vec4(colorAdd.rgb,colorAdd.a*gl_FragColor.a);\ngl_FragColor.xyz *= colorAdd.a;");
    var vs, ps;
    vs = "attribute vec4 position;\nuniform vec2 size;\nuniform mat4 mmat;\nvoid main() {\n  vec4 pos=mmat*position;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n}";
    ps = "\n\tprecision mediump float;\n\tuniform vec4 color;\n\tuniform float alpha;\n\t#include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\n\tvoid main() {\n\t\t\tvec4 a = vec4(color.r, color.g, color.b, color.a);\n\t\t\ta.w = alpha;\n\t\t\ta.xyz *= alpha;\n\t\t\tgl_FragColor = a;\n\t\t\t#include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n\t}";
    Shader.preCompile2D(0, /*laya.webgl.shader.d2.ShaderDefines2D.COLOR2D*/ 0x02, vs, ps, null);
    vs = "attribute vec4 position;\nattribute vec3 a_color;\nuniform mat4 mmat;\nuniform mat4 u_mmat2;\nuniform vec2 u_pos;\nuniform vec2 size;\nvarying vec3 color;\nvoid main(){\n  vec4 tPos = vec4(position.x + u_pos.x,position.y + u_pos.y,position.z,position.w);\n  vec4 pos=mmat*u_mmat2*tPos;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  color=a_color;\n}";
    ps = "precision mediump float;\n//precision mediump float;\nvarying vec3 color;\nuniform float alpha;\nvoid main(){\n	//vec4 a=vec4(color.r, color.g, color.b, 1);\n	//a.a*=alpha;\n    gl_FragColor=vec4(color.r, color.g, color.b, alpha);\n	gl_FragColor.rgb*=alpha;\n}";
    Shader.preCompile2D(0, /*laya.webgl.shader.d2.ShaderDefines2D.PRIMITIVE*/ 0x04, vs, ps, null);
    vs = "attribute vec2 position;\nattribute vec2 texcoord;\nattribute vec4 color;\nuniform vec2 size;\nuniform float offsetX;\nuniform float offsetY;\nuniform mat4 mmat;\nuniform mat4 u_mmat2;\nvarying vec2 v_texcoord;\nvarying vec4 v_color;\nvoid main() {\n  vec4 pos=mmat*u_mmat2*vec4(offsetX+position.x,offsetY+position.y,0,1 );\n  gl_Position = vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  v_color = color;\n  v_color.rgb *= v_color.a;\n  v_texcoord = texcoord;  \n}";
    ps = "precision mediump float;\nvarying vec2 v_texcoord;\nvarying vec4 v_color;\nuniform sampler2D texture;\nuniform float alpha;\nvoid main() {\n	vec4 t_color = texture2D(texture, v_texcoord);\n	gl_FragColor = t_color.rgba * v_color;\n	gl_FragColor *= alpha;\n}";
    Shader.preCompile2D(0, /*laya.webgl.shader.d2.ShaderDefines2D.SKINMESH*/ 0x200, vs, ps, null);
};
// 粒子shader
// pShader 表示GPU对每个顶点的并行计算（逐顶点计算）
var pShader = "attribute vec4 a_CornerTextureCoordinate;\n//------------------------------------------------------------------------------------------------------\n// \u9876\u70B9\u6570\u636E vertexBuffer \u4E2D\u7684\u6570\u636E\n//------------------------------------------------------------------------------------------------------\n// \u9876\u70B9\u4F4D\u7F6E x y z\nattribute vec3 a_Position;\n// \u9876\u70B9\u901F\u5EA6\nattribute vec3 a_Velocity;\n// \u9876\u70B9\u8D77\u59CB\u989C\u8272\nattribute vec4 a_StartColor;\n// \u9876\u70B9\u7ED3\u675F\u989C\u8272\nattribute vec4 a_EndColor;\n// \u89D2\u5EA6\uFF1F\nattribute vec3 a_SizeRotation;\n// \u534A\u5F84\nattribute vec2 a_Radius;\n// \u5F27\u5EA6\nattribute vec4 a_Radian;\n// \u751F\u547D\u5468\u671F\u7F29\u653E\u5EA6 \u53731.0 * 1.5 \u8868\u793A+50%\u5BFF\u547D\nattribute float a_AgeAddScale;\n// \u53D1\u51FA\u7684\u65F6\u95F4\nattribute float a_Time;\n//------------------------------------------------------------------------------------------------------\n// \u4F20\u9012\u7ED9\u7247\u6BB5\u7740\u8272\u5668\u7684\u53C2\u6570 \n//------------------------------------------------------------------------------------------------------\nvarying vec4 v_Color;\nvarying vec2 v_TextureCoordinate;\n//------------------------------------------------------------------------------------------------------\n// \u4F20\u9012\u8FDB\u6765\u7684\u5E38\u91CF\uFF0C\u6BD4\u5982u_CurrentTime\u5C31\u662F\u6BCF\u5E27\u90FD\u4F1A\u4F20\u9012\u8FDB\u6765\u7684\u5E38\u91CF\uFF0C\u8868\u793A\u5F53\u524D\u65F6\u95F4\n// \u7247\u6BB5\u7740\u8272\u5668\u548C\u9876\u70B9\u7740\u8272\u5668\u90FD\u4F1A\u7528\u5230\u7684\n//------------------------------------------------------------------------------------------------------\nuniform float u_CurrentTime;\nuniform float u_Duration;\nuniform float u_EndVelocity;\nuniform vec3 u_Gravity;\nuniform vec3 u_xxxx;\n\n\n#ifdef PARTICLE3D\n uniform mat4 u_WorldMat;\n uniform mat4 u_View;\n uniform mat4 u_Projection;\n uniform vec2 u_ViewportScale;\n#else\n uniform vec2 size;\n uniform mat4 mmat;\n uniform mat4 u_mmat;\n#endif\n\nvec4 ComputeParticlePosition(in vec3 position, in vec3 velocity,in float age,in float normalizedAge)\n{\n\n   float startVelocity = length(velocity);//\u8D77\u59CB\u6807\u91CF\u901F\u5EA6\n   float endVelocity = startVelocity * u_EndVelocity;//\u7ED3\u675F\u6807\u91CF\u901F\u5EA6\n\n   float velocityIntegral = startVelocity * normalizedAge +(endVelocity - startVelocity) * normalizedAge *normalizedAge/2.0;//\u8BA1\u7B97\u5F53\u524D\u901F\u5EA6\u7684\u6807\u91CF\uFF08\u5355\u4F4D\u7A7A\u95F4\uFF09\uFF0Cvt=v0*t+(1/2)*a*(t^2)\n   \n   vec3 addPosition = normalize(velocity) * velocityIntegral * u_Duration;//\u8BA1\u7B97\u53D7\u81EA\u8EAB\u901F\u5EA6\u5F71\u54CD\u7684\u4F4D\u7F6E\uFF0C\u8F6C\u6362\u6807\u91CF\u5230\u77E2\u91CF    \n   addPosition += u_Gravity * age * normalizedAge;//\u8BA1\u7B97\u53D7\u91CD\u529B\u5F71\u54CD\u7684\u4F4D\u7F6E\n   \n   float radius=mix(a_Radius.x, a_Radius.y, normalizedAge); //\u8BA1\u7B97\u7C92\u5B50\u53D7\u534A\u5F84\u548C\u89D2\u5EA6\u5F71\u54CD\uFF08\u65E0\u9700\u8BA1\u7B97\u89D2\u5EA6\u548C\u534A\u5F84\u65F6\uFF0C\u53EF\u7528\u5B8F\u5B9A\u4E49\u4F18\u5316\u5C4F\u853D\u6B64\u8BA1\u7B97\uFF09\n   float radianHorizontal =mix(a_Radian.x,a_Radian.z,normalizedAge);\n   float radianVertical =mix(a_Radian.y,a_Radian.w,normalizedAge);\n   \n   float r =cos(radianVertical)* radius;\n   addPosition.y += sin(radianVertical) * radius;\n\t\n   addPosition.x += cos(radianHorizontal) *r + u_xxxx.x;\n   addPosition.z += sin(radianHorizontal) *r;\n  \n   #ifdef PARTICLE3D\n   position+=addPosition;\n    return  u_Projection*u_View*u_WorldMat*(vec4(position, 1.0));\n   #else\n   addPosition.y=-addPosition.y;//2D\u7C92\u5B50\u4F4D\u7F6E\u66F4\u65B0\u9700\u8981\u53D6\u8D1F\uFF0C2D\u7C92\u5B50\u5750\u6807\u7CFBY\u8F74\u6B63\u5411\u671D\u4E0A\n   position+=addPosition;\n    return  vec4(position,1.0);\n   #endif\n}\n\nfloat ComputeParticleSize(in float startSize,in float endSize, in float normalizedAge)\n{    \n    float size = mix(startSize, endSize, normalizedAge);\n    \n\t#ifdef PARTICLE3D\n    //Project the size into screen coordinates.\n     return size * u_Projection[1][1];\n\t#else\n\t return size;\n\t#endif\n}\n\nmat2 ComputeParticleRotation(in float rot,in float age)\n{    \n    float rotation =rot * age;\n    //\u8BA1\u7B972x2\u65CB\u8F6C\u77E9\u9635.\n    float c = cos(rotation);\n    float s = sin(rotation);\n    return mat2(c, -s, s, c);\n}\n\nvec4 ComputeParticleColor(in vec4 startColor,in vec4 endColor,in float normalizedAge)\n{\n\tvec4 color=mix(startColor,endColor,normalizedAge);\n    //\u786C\u7F16\u7801\u8BBE\u7F6E\uFF0C\u4F7F\u7C92\u5B50\u6DE1\u5165\u5F88\u5FEB\uFF0C\u6DE1\u51FA\u5F88\u6162,6.7\u7684\u7F29\u653E\u56E0\u5B50\u628A\u7F6E\u5F52\u4E00\u57280\u52301\u4E4B\u95F4\uFF0C\u53EF\u4EE5\u8C37\u6B4Cx*(1-x)*(1-x)*6.7\u7684\u5236\u56FE\u8868\n    color.a *= normalizedAge * (1.0-normalizedAge) * (1.0-normalizedAge) * 6.7;\n   \n    return color;\n}\n\nvoid main()\n{\n   float age = u_CurrentTime - a_Time;\n   age *= 1.0 + a_AgeAddScale;\n   float normalizedAge = clamp(age / u_Duration,0.0,1.0);\n   gl_Position = ComputeParticlePosition(a_Position, a_Velocity, age, normalizedAge);//\u8BA1\u7B97\u7C92\u5B50\u4F4D\u7F6E\n   float pSize = ComputeParticleSize(a_SizeRotation.x,a_SizeRotation.y, normalizedAge);\n   mat2 rotation = ComputeParticleRotation(a_SizeRotation.z, age);\n\t\n   #ifdef PARTICLE3D\n\tgl_Position.xy += (rotation*a_CornerTextureCoordinate.xy) * pSize * u_ViewportScale;\n   #else\n    mat4 mat=u_mmat*mmat;\n    gl_Position=vec4((mat*gl_Position).xy,0.0,1.0);\n\tgl_Position.xy += (rotation*a_CornerTextureCoordinate.xy) * pSize*vec2(mat[0][0],mat[1][1]);\n    gl_Position=vec4((gl_Position.x/size.x-0.5)*2.0,(0.5-gl_Position.y/size.y)*2.0,0.0,1.0);\n   #endif\n   \n   v_Color = ComputeParticleColor(a_StartColor,a_EndColor, normalizedAge);\n   v_TextureCoordinate =a_CornerTextureCoordinate.zw;\n}\n";
static(ParticleShader, ['vs', function () { return this.vs = pShader; }, 'ps', function () { return this.ps = "#ifdef FSHIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nvarying vec4 v_Color;\nvarying vec2 v_TextureCoordinate;\nuniform sampler2D u_texture;\n\nvoid main()\n{\n	gl_FragColor=texture2D(u_texture,v_TextureCoordinate)*v_Color;\n	gl_FragColor.xyz *= v_Color.w;\n}"; }
]);
/**
 * 映射指定类事件相关方法，将types替换成指定对象的方法
 * @param clsName 类对象
 * @param types 需要替换的类型集合
 * @param toObjName 指定替换至的对象名
 * @param checkMouseEvent 检查鼠标事件，如果存在则若是鼠标事件则将本体的mouseEnabled打开
 */
ObjectUtils.redefinedEventFunc = function redefinedEventFunc(clsName, types, toObjName, checkMouseEvent) {
    if (checkMouseEvent === void 0) { checkMouseEvent = false; }
    var EvArr = ["hasListener", "on", "once", "off", "offAll", "isMouseEvent"]; // , "event"
    if (checkMouseEvent) {
        types = types.concat(___mouseEvent);
    }
    // 鼠标事件不代替
    var typesStr = JSON.stringify(types);
    for (var i in EvArr) {
        // 检查鼠标事件，如果存在则若是鼠标事件则将本体的mouseEnabled打开
        var mouseCheckCode = "";
        if (checkMouseEvent && (i == "2" || i == "3" || i == "4" || i == "5")) {
            // 如果该事件是鼠标事件的话，
            mouseCheckCode = "if(" + ___mouseEventStr + ".indexOf(type)!=-1){\n                if(this." + toObjName + ")this.mouseEnabled = this." + toObjName + ".mouseEnabled;\n            }";
        }
        eval("\n                    " + clsName + ".prototype._" + EvArr[i] + " = " + clsName + ".prototype." + EvArr[i] + ";\n                    " + clsName + ".prototype." + EvArr[i] + " = function(type){\n                        if(" + typesStr + ".indexOf(type)!=-1){\n                            var t = null;\n                            if(this." + toObjName + ")t = this." + toObjName + "." + EvArr[i] + ".apply(this." + toObjName + ",arguments);\n                            " + mouseCheckCode + "\n                            return t;\n                        }\n                        else{\n                            return this._" + EvArr[i] + ".apply(this,arguments);\n                        }\n                    }\n                ");
    }
};
/**
 * Avatar 动作类
 * 一个Avatar可能包含若干个动作，每个动作拥有对应每个方向都有一系列的图集
 */
var AvatarAction = /** @class */ (function () {
    function AvatarAction() {
        /**
         * 图集的帧数据信息
         * [方向](对应小键盘) - 帧图
         */
        this.frameImageInfo = [];
    }
    /**
     * 获取某个方向的帧长度
     * @param ori 方向
     * @param useMapping [可选] 默认值=true 使用映射获取实际面向
     */
    AvatarAction.prototype.getFrameLength = function (ori, useMapping) {
        if (useMapping === void 0) { useMapping = true; }
        var assetOri = useMapping ? GameUtils.getAssetOri(ori, this.oriMode) : ori;
        var frameImageInfo = this.frameImageInfo[assetOri];
        return frameImageInfo && frameImageInfo.length ? frameImageInfo.length : 0;
    };
    /**
     * 获取当前动作中某个方向与某帧的数据图像
     * @param ori 方向
     * @param frame 帧
     * @param useMapping [可选] 默认值=true 使用映射获取实际面向
     * @return [AvatarFrameImage]
     */
    AvatarAction.prototype.getFrameImage = function (ori, frame, useMapping) {
        if (useMapping === void 0) { useMapping = true; }
        var assetOri = useMapping ? GameUtils.getAssetOri(ori, this.oriMode) : ori;
        var arr = this.frameImageInfo[assetOri];
        if (!arr)
            return null;
        return arr[frame];
    };
    /**
     * 是否存在该面向
     * @param ori
     * @return [boolean]
     */
    AvatarAction.prototype.hasOri = function (ori) {
        var frameImageInfo = this.frameImageInfo[ori];
        return frameImageInfo ? true : false;
    };
    return AvatarAction;
}());
/**
 * Avatar帧图像数据
 */
var AvatarFrameImage = /** @class */ (function () {
    function AvatarFrameImage() {
    }
    Object.defineProperty(AvatarFrameImage.prototype, "positiveRect", {
        /**
         * 获取图像的切图正数据
         */
        get: function () {
            if (!this._positiveRect)
                this._positiveRect = new Rectangle(-this.rect.x, -this.rect.y, this.rect.width, this.rect.height);
            return this._positiveRect;
        },
        enumerable: false,
        configurable: true
    });
    return AvatarFrameImage;
}());
/**
 * Avatar辅助体体
 * @author kds
 */
var AvatarRefObj = /** @class */ (function () {
    function AvatarRefObj() {
    }
    return AvatarRefObj;
}());
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecuteGame;
(function (CommandExecuteGame) {
    /**
     * 选择开始
     * @param triggerLineID 头像
     * @param dialogID 对话框ID
     * @param selContents 内容
     * @param defaultIndex 默认选中索引
     * @param cancelIndex 取消索引
     * @param hideIndexs 隐藏的选项索引
     * @return [number]
     */
    function command_3(triggerLineID, dialogID, selContents, defaultIndex, cancelIndex, hideIndexs) {
        // 不处于输入状态时 或 在同一触发线
        if (!GameCommand.isNeedPlayerInput || triggerLineID == GameCommand.inputTriggerLine) {
            GameDialog.showOption(dialogID, selContents, false, defaultIndex, cancelIndex, hideIndexs);
        }
        return GameCommand.COMMAND_STATE_NEED_INPUT;
    }
    CommandExecuteGame.command_3 = command_3;
})(CommandExecuteGame || (CommandExecuteGame = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecuteGame;
(function (CommandExecuteGame) {
    /**
     * 对话
     * @param dialogID 对话框ID
     * @param head 头像参数
     * @param name 名称
     * @param speed 播放速度
     * @param comicSceneObjectIndex 漫画对话框模式 -1无 0-N 场景对象
     * @param msg 内容
     * @param audio 语音
     * @param exp 立绘模式下表情
     * @param nameColor 名字颜色
     * @param cmdID 指令的唯一ID
     * @param changeData 修改属性数据
     */
    function command_11(triggerLineID, dialogID, head, name, speed, comicSceneObjectIndex, msg, audio, exp, nameColor, cmdID, changeData) {
        // 非阻塞玩家输入时才显示对话
        if (!GameCommand.isNeedPlayerInput) {
            GameDialog.fromCommandID = cmdID;
            GameDialog.showDialog(dialogID, head, name, speed, comicSceneObjectIndex, msg, null, audio, exp, nameColor, changeData);
        }
        // if (!GameCommand.isNeedPlayerInput || triggerLineID == GameCommand.inputTriggerLine) {
        //     var inputed = false;
        //     stage.once(EventObject.CLICK, this, (e: EventObject) => {
        //         if (inputed) return;
        //         inputed = true;
        //         GameCommand.inputMessageAndContinueExecute([e.stageX, e.stageY]);
        //     });
        //     // 超出限制时间范围内，提交-1表示超时
        //     setTimeout(() => {
        //         inputed = true;
        //         GameCommand.inputMessageAndContinueExecute([-1, -1]);
        //     }, limitInputTime * 1000);
        // }
        return GameCommand.COMMAND_STATE_NEED_INPUT;
    }
    CommandExecuteGame.command_11 = command_11;
})(CommandExecuteGame || (CommandExecuteGame = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecuteGame;
(function (CommandExecuteGame) {
    /**
     * 等待玩家输入信息
     */
    function command_12(triggerLineID, dialogID, head, name, speed, comicMode, msg) {
        return GameCommand.COMMAND_STATE_NEED_INPUT;
    }
    CommandExecuteGame.command_12 = command_12;
})(CommandExecuteGame || (CommandExecuteGame = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecuteGame;
(function (CommandExecuteGame) {
    /**
     * 处理命令 delay
     * @param cmdID 命令ID
     * @param delay 延迟数
     * @param unit 单位模式 0-帧 1-毫秒
     */
    function command_17(triggerLineID, delay, unit) {
        if (unit == 1) {
            setTimeout(GameCommand.start, delay, [triggerLineID]);
        }
        else {
            setFrameout(GameCommand.start, delay, [triggerLineID]);
        }
        return GameCommand.COMMAND_STATE_STOP;
    }
    CommandExecuteGame.command_17 = command_17;
})(CommandExecuteGame || (CommandExecuteGame = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-09 17:17:50.
 */
var CommandExecuteGame;
(function (CommandExecuteGame) {
    /**
     * 处理命令 图像系统 可以调整到GameFunc,只有输入等利用到triggerLineID需要在此执行
     */
    function command_37(triggerLineID, imageInfos) {
        imageInfos = ObjectUtils.depthClone(imageInfos);
        GameImage.addGroup(triggerLineID, imageInfos);
        return GameCommand.COMMAND_STATE_CONTINUE;
    }
    CommandExecuteGame.command_37 = command_37;
    function command_71(triggerLineID, imageInfos) {
        return command_37(triggerLineID, imageInfos);
    }
    CommandExecuteGame.command_71 = command_71;
    /**
     * 等待图像完成 处理命令 图像系统 可以调整到GameFunc,只有输入等利用到triggerLineID需要在此执行
     */
    function command_38(triggerLineID, imageInfos) {
        // 如果该触发线有图像正在播放的话就等待
        if (GameImage.isPlaying(triggerLineID)) {
            GameImage.listenerImageOver(triggerLineID);
        }
        // 如果该触发线已没有图像正在播放就立刻提交
        else {
            GameCommand.inputMessageAndContinueExecute(null, true, 0, triggerLineID);
        }
        return GameCommand.COMMAND_STATE_CONTINUE;
    }
    CommandExecuteGame.command_38 = command_38;
})(CommandExecuteGame || (CommandExecuteGame = {}));
/**
 * 相机：坐标为镜头中心点
 * Created by 黑暗之神KDS on 2020-03-01 01:32:43.
 */
var Camera = /** @class */ (function () {
    function Camera() {
        /**
         * 包含相机位置和可见宽高
         */
        this.viewPort = new Rectangle(0, 0, 100, 100);
        /**
         * 镜头旋转角度
         */
        this.rotation = 0;
        /**
         * 镜头偏移量x
         */
        this.offsetX = 0;
        /**
         * 镜头偏移量y
         */
        this.offsetY = 0;
        /**
         * 镜头z轴位置
         */
        this.z = 0;
        /**
         * 相机镜头缩放x（场景专用）
         */
        this.scaleX = 1;
        /**
         * 相机镜头缩放y（场景专用）
         */
        this.scaleY = 1;
    }
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取存档信息
     */
    Camera.prototype.getSaveData = function () {
        var o = {};
        ObjectUtils.clone(this, o);
        o.sceneObject = this.sceneObject ? this.sceneObject.index : null;
        o.viewPort = [this.viewPort.x, this.viewPort.y, this.viewPort.width, this.viewPort.height];
        return o;
    };
    /**
     * 恢复存档信息
     */
    Camera.prototype.recoverySaveData = function (o) {
        this.viewPort.x = o.viewPort[0];
        this.viewPort.y = o.viewPort[1];
        this.viewPort.width = o.viewPort[2];
        this.viewPort.height = o.viewPort[3];
        for (var i in o) {
            if (i == "viewPort" || i == "sceneObject")
                continue;
            this[i] = o[i];
        }
        if (o.sceneObject != null) {
            this.sceneObject = Game.currentScene.sceneObjects[o.sceneObject];
        }
    };
    return Camera;
}());
/**
 * 游戏精灵
 * -- 滤镜叠加实现（即父子级滤镜不会被覆盖而是叠加）
 * -- 色调（R+,B+,G+,GRAY,R*,G*,B*）
 * -- 色相
 * Created by 黑暗之神KDS on 2019-02-01 02:34:59.
 */
var GameSprite = /** @class */ (function (_super) {
    __extends(GameSprite, _super);
    function GameSprite() {
        var _this = _super.call(this) || this;
        _this._tonalParams = [0, 0, 0, 0, 1, 1, 1];
        _this._mouseEventEnabledInEditor = true;
        _this._show = true;
        _this._showOnEditor = true;
        _this._opacity = 1;
        _this._opacityPer = 1;
        _this._rotation1 = 0;
        _this._rotation2 = 0;
        _this._animationTargetEffect = [];
        // 唯一ID
        _this.objectID = ObjectUtils.getInstanceID();
        // 不显示任何滤镜效果
        _this._filterEnabled = true;
        //------------------------------------------------------------------------------------------------------
        // 深度坐标系：与普通坐标系以及适配分辨率坐标系互斥
        // 目前仅在图像层支持
        // 根据 dpx dpy dpz dpwidth dpheight 计算出当前的位置和宽高
        // 
        // 最终x/y/width/height 受到dpZ、镜头缩放、镜头位置和偏移影响
        // -- dpZ：受对象的最近、普通、最远距离影响
        // -- 镜头位置和偏移：和dpx dpy 一样作为追加值
        // -- 镜头缩放：
        // 
        // 关于操作工具操作非normal距离的对象：
        // -- *操作x/y 可以反馈到dpx/dpy，而操作dpx/dpy可以反馈到x/y
        // -- *实际值 width/计算后width  1.62 计算后应乘以这个值
        // -- *镜头旋转后修正操作
        // 
        //------------------------------------------------------------------------------------------------------
        _this._dpZ = 100;
        _this._hue = 0;
        _this._blur = 0;
        //------------------------------------------------------------------------------------------------------
        // 关于通道passage：一个对象的多个通道PASS表示多次渲染，同一个通道表示合并为一份shader代码运行
        //------------------------------------------------------------------------------------------------------
        _this.materialPassArr = [];
        return _this;
    }
    /**
     * 释放
     * @param disposeChild [可选] 默认值=false 释放子节点
     */
    GameSprite.prototype.dispose = function () {
        if (!this.__isDisposed) {
            this.clearMaterials();
            this.event(GameSprite.ON_DISPOSE);
            this.offAll();
            EventUtils.clear(this);
            this.removeSelf();
            this._tonalParams = this._tonalFilter = this.tips = null;
            this.destroy(false);
            this.__isDisposed = true;
        }
    };
    Object.defineProperty(GameSprite.prototype, "isDisposed", {
        get: function () {
            return this.__isDisposed || this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "rotation1", {
        get: function () {
            return this._rotation1;
        },
        set: function (v) {
            this._rotation1 = v;
            this.rotation = this._rotation1 + this._rotation2;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "rotation2", {
        get: function () {
            return this._rotation2;
        },
        set: function (v) {
            this._rotation2 = v;
            this.rotation = this._rotation1 + this._rotation2;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "useDPCoord", {
        get: function () {
            return this._useDPCoord;
        },
        set: function (v) {
            this._useDPCoord = v;
            if (this._dpX == null) {
                this._dpX = 0;
                this._dpY = 0;
                this._dpCameraX = 0;
                this._dpCameraY = 0;
                this._dpZ = 100;
                this._dpOpacity = 1;
                this._dpCameraZ = 0;
                this._dpScaleX = 1;
                this._dpScaleY = 1;
                this._dpWidth = this.width;
                this._dpHeight = this.height;
                this._dpDirty = true;
                Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpOpacity", {
        get: function () {
            return this._dpOpacity;
        },
        set: function (v) {
            this._dpOpacity = v;
            this.refreshRealAlpha();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpZ", {
        get: function () {
            return this._dpZ;
        },
        set: function (v) {
            this._dpZ = v;
            this._dpDirty = true;
            Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpX", {
        get: function () {
            return this._dpX;
        },
        set: function (v) {
            this._dpX = v;
            this._dpDirty = true;
            Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpY", {
        get: function () {
            return this._dpY;
        },
        set: function (v) {
            this._dpY = v;
            this._dpDirty = true;
            Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpScaleX", {
        get: function () {
            return this._dpScaleX;
        },
        set: function (v) {
            this._dpScaleX = v;
            this._dpDirty = true;
            Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpScaleY", {
        get: function () {
            return this._dpScaleY;
        },
        set: function (v) {
            this._dpScaleY = v;
            this._dpDirty = true;
            Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpCameraX", {
        get: function () {
            return this._dpCameraX;
        },
        set: function (v) {
            this._dpCameraX = v;
            this._dpDirty = true;
            Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpCameraY", {
        get: function () {
            return this._dpCameraY;
        },
        set: function (v) {
            this._dpCameraY = v;
            this._dpDirty = true;
            Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpCameraZ", {
        get: function () {
            return this._dpCameraZ;
        },
        set: function (v) {
            this._dpCameraZ = v;
            this._dpDirty = true;
            Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpWidth", {
        get: function () {
            return this._dpWidth;
        },
        set: function (v) {
            this._dpWidth = v;
            this._dpDirty = true;
            Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpHeight", {
        get: function () {
            return this._dpHeight;
        },
        set: function (v) {
            this._dpHeight = v;
            this._dpDirty = true;
            Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 根据深度坐标系参数计算出实际坐标系数值（x/y/width/height）
     * 通常情况下更改相关DP坐标系参数会自动刷新，无需手动刷新
     */
    GameSprite.prototype.dpCoordToRealCoord = function () {
        if (Config.EDIT_MODE) {
            try {
                GameImageLayer.dpCoordFuncObject.dpCoordToRealCoord.apply(this, [this]);
            }
            catch (e) {
                console.trace("图像深度坐标系dpCoordToRealCoord代码错误：", e.stack);
            }
        }
        else {
            GameImageLayer.dpCoordFuncObject.dpCoordToRealCoord.apply(this, [this]);
        }
    };
    /**
     * 以当前的坐标计算
     * @param calcCoord 计算坐标
     * @param calcSize 计算尺寸
     */
    GameSprite.prototype.realCoordToDPCoord = function (calcCoord, calcSize) {
        if (Config.EDIT_MODE) {
            try {
                return GameImageLayer.dpCoordFuncObject.realCoordToDPCoord.apply(this, [this, calcCoord, calcSize]);
            }
            catch (e) {
                console.trace("图像深度坐标系realCoordToDPCoord代码错误：", e.stack);
            }
        }
        else {
            return GameImageLayer.dpCoordFuncObject.realCoordToDPCoord.apply(this, [this, calcCoord, calcSize]);
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 适配分辨率坐标系
    // left right top bottom centerX centerY
    //------------------------------------------------------------------------------------------------------
    //------------------------------------------------------------------------------------------------------
    // 动画目标效果：作为目标效果层的话，外部改动其属性会与目标效果的改动冲突，确保目标效果层仅被动画控制
    //------------------------------------------------------------------------------------------------------
    GameSprite.prototype.addAnimationTargetEffect = function (ani) {
        this._animationTargetEffect.push(ani);
        this.refreshTargetEffect();
    };
    GameSprite.prototype.removeAnimationTargetEffect = function (ani) {
        ArrayUtils.remove(this._animationTargetEffect, ani);
        this.refreshTargetEffect();
    };
    /**
     * 重置目标效果
     * @returns
     */
    GameSprite.prototype.resetTargetEffect = function () {
        if (this.isDisposed)
            return; //taget被dispse后不用刷新效果
        var target = {
            x: 0,
            y: 0,
            rotation: 0,
            alpha: 1,
            scaleX: 1,
            scaleY: 1,
            hue: 0,
            blur: 0
        };
        var targetTonal = {
            tonal_r: 0,
            tonal_g: 0,
            tonal_b: 0,
            tonal_gray: 0,
            tonal_mr: 1,
            tonal_mg: 1,
            tonal_mb: 1
        };
        for (var s in target) {
            this[s] = target[s];
        }
        this.setTonal(targetTonal.tonal_r, targetTonal.tonal_g, targetTonal.tonal_b, targetTonal.tonal_gray, targetTonal.tonal_mr, targetTonal.tonal_mb);
    };
    /**
     * 刷新目标效果
     */
    GameSprite.prototype.refreshTargetEffect = function (install) {
        if (install === void 0) { install = true; }
        //
        this.resetTargetEffect();
        //检测所有目标效果层
        var materialAnis = [], rgbAnis = [];
        for (var i = 0; i < this._animationTargetEffect.length; i++) {
            //目标效果层
            var t = this._animationTargetEffect[i];
            if (!t || t.isDisposed)
                continue;
            if (t.materialsDataExit) {
                materialAnis.push(t);
            }
            else if (!Config.EDIT_MODE || !t.inAniEditor || Config.BEHAVIOR_EDIT_MODE) {
                rgbAnis.push(t);
            }
        }
        //材质
        if (install) {
            this.installTargetMaterialsEffect(materialAnis);
        }
        else {
            this.refreshTargetMaterialsEffect(materialAnis);
        }
        //rgb
        this.refreshAnimationTargetEffect(rgbAnis);
    };
    /**
     * 对目标安装材质效果
     */
    GameSprite.prototype.installTargetMaterialsEffect = function (anis) {
        if (this.isDisposed)
            return; //taget被dispse后不用刷新效果
        //先清理在安装
        this.clearMaterials();
        if (anis.length <= 0)
            return;
        var target = {
            x: 0,
            y: 0,
            rotation: 0,
            alpha: 1,
            scaleX: 1,
            scaleY: 1,
        };
        var materialGroups = [{ materials: [] }];
        for (var i = 0; i < anis.length; i++) {
            var t = anis[i];
            target.x += t.x;
            target.y += t.y;
            target.rotation += t.rotation;
            target.alpha *= t.alpha;
            target.scaleX *= t.scaleX;
            target.scaleY *= t.scaleY;
            if (t.materialData) {
                materialGroups = materialGroups.concat(t.materialData);
            }
        }
        for (var s in target) {
            this[s] = target[s];
        }
        this.installMaterialData(materialGroups);
    };
    /**
     * 刷新目标的材质效果
     */
    GameSprite.prototype.refreshTargetMaterialsEffect = function (anis) {
        if (this.isDisposed)
            return; //taget被dispse后不用刷新效果
        if (anis.length <= 0)
            return;
        var target = {
            x: 0,
            y: 0,
            rotation: 0,
            alpha: 1,
            scaleX: 1,
            scaleY: 1,
        };
        var materialGroups = [{ materials: [] }];
        for (var i = 0; i < anis.length; i++) {
            var t = anis[i];
            target.x += t.x;
            target.y += t.y;
            target.rotation += t.rotation;
            target.alpha *= t.alpha;
            target.scaleX *= t.scaleX;
            target.scaleY *= t.scaleY;
            if (t.materialData) {
                materialGroups = materialGroups.concat(t.materialData);
            }
        }
        for (var s in target) {
            this[s] = target[s];
        }
        //材质效果
        for (var j = 0; j < materialGroups.length; j++) {
            var materials = materialGroups[j].materials;
            for (var m = 0; m < materials.length; m++) {
                var materialValues = {};
                var materialData = materials[m];
                for (var key in materialData) {
                    var value = materialData[key];
                    //材质只支持fast设置number类型的数据
                    if (typeof value == "number") {
                        materialValues["mu" + materialData.id + "_" + key] = value;
                    }
                }
                //设置材质效果
                this.setMaterialValueFast(materialValues, j);
            }
        }
    };
    /**
     * 刷新目标效果
     */
    GameSprite.prototype.refreshAnimationTargetEffect = function (anis) {
        if (this.isDisposed)
            return; //taget被dispse后不用刷新效果
        if (anis.length <= 0)
            return;
        var target = {
            x: this.x,
            y: this.y,
            rotation: this.rotation,
            alpha: this.alpha,
            scaleX: this.scaleX,
            scaleY: this.scaleY,
            hue: 0,
            blur: 0
        };
        var targetTonal = {
            tonal_r: 0,
            tonal_g: 0,
            tonal_b: 0,
            tonal_gray: 0,
            tonal_mr: 1,
            tonal_mg: 1,
            tonal_mb: 1
        };
        for (var i = 0; i < anis.length; i++) {
            var t = anis[i];
            target.x += t.x;
            target.y += t.y;
            target.rotation += t.rotation;
            target.alpha *= t.alpha;
            target.scaleX *= t.scaleX;
            target.scaleY *= t.scaleY;
            target.hue = t.hue;
            target.blur += t.blur;
            targetTonal.tonal_r += t.tonal_r;
            targetTonal.tonal_g += t.tonal_g;
            targetTonal.tonal_b += t.tonal_b;
            targetTonal.tonal_gray += t.tonal_gray;
            targetTonal.tonal_mr *= t.tonal_mr;
            targetTonal.tonal_mg *= t.tonal_mg;
            targetTonal.tonal_mb *= t.tonal_mb;
        }
        for (var s in target) {
            this[s] = target[s];
        }
        this.setTonal(targetTonal.tonal_r, targetTonal.tonal_g, targetTonal.tonal_b, targetTonal.tonal_gray, targetTonal.tonal_mr, targetTonal.tonal_mb);
    };
    Object.defineProperty(GameSprite.prototype, "filterEnabled", {
        get: function () {
            return this._filterEnabled;
        },
        //------------------------------------------------------------------------------------------------------
        // 滤镜
        //------------------------------------------------------------------------------------------------------
        set: function (v) {
            this._filterEnabled = v;
            this.refreshFilters();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "gameFilters", {
        get: function () {
            return [];
        },
        //------------------------------------------------------------------------------------------------------
        // 兼容旧API，以防报错 ver<=0.9809
        //------------------------------------------------------------------------------------------------------
        set: function (v) {
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 追加一个滤镜，已存在的则忽略
     */
    GameSprite.prototype.appendGameFilter = function (gameFilter) {
    };
    /**
     * 减少一个滤镜，滤镜不存在则忽略
     */
    GameSprite.prototype.subtractGameFilter = function (gameFilter) {
    };
    //------------------------------------------------------------------------------------------------------
    // 色调 
    //------------------------------------------------------------------------------------------------------
    /**
     * 更改色调
     * @param r 红色+ -255~255
     * @param g 绿色+ -255~255
     * @param b 蓝色+ -255~255
     * @param gray 灰度 0-100
     * @param mr [可选] 默认值=1 0~5
     * @param mg [可选] 默认值=1 0~5
     * @param mb [可选] 默认值=1 0~5
     */
    GameSprite.prototype.setTonal = function (r, g, b, gray, mr, mg, mb) {
        if (mr === void 0) { mr = 1; }
        if (mg === void 0) { mg = 1; }
        if (mb === void 0) { mb = 1; }
        r || (r = 0);
        g || (g = 0);
        b || (b = 0);
        gray || (gray = 0);
        if (mr == null)
            mr = 1;
        if (mg == null)
            mr = 1;
        if (mb == null)
            mr = 1;
        if (this._tonalFilter) {
            this._tonalFilter = null;
        }
        this._tonalParams[0] = r;
        this._tonalParams[1] = g;
        this._tonalParams[2] = b;
        this._tonalParams[3] = gray;
        this._tonalParams[4] = mr;
        this._tonalParams[5] = mg;
        this._tonalParams[6] = mb;
        if (r == 0 && g == 0 && b == 0 && gray == 0 && mr == 1 && mg == 1 && mb == 1) {
            this.refreshFilters();
            return;
        }
        var rt1 = 1 - (1 - 0.3086) * gray / 100;
        var gt1 = 1 - (1 - 0.6094) * gray / 100;
        var bt1 = 1 - (1 - 0.0820) * gray / 100;
        var rt0 = 0 - (0 - 0.3086) * gray / 100;
        var gt0 = 0 - (0 - 0.6094) * gray / 100;
        var bt0 = 0 - (0 - 0.0820) * gray / 100;
        this._tonalFilter = new ColorFilter([
            rt1 * mr, gt0, bt0, 0, r / 255,
            rt0, gt1 * mg, bt0, 0, g / 255,
            rt0, gt0, bt1 * mb, 0, b / 255,
            0, 0, 0, 1, 0
        ]);
        this.refreshFilters();
    };
    /**
     * 获取色调参数：r g b gray mr mg mb
     */
    GameSprite.prototype.getTonal = function () {
        return this._tonalParams.concat();
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    GameSprite.prototype.isInherit = function (sp) {
        var p = this.parent;
        while (p) {
            if (p == sp)
                return true;
            p = p.parent;
        }
        return false;
    };
    Object.defineProperty(GameSprite.prototype, "disabled", {
        /**
         * 设置不可用状态，将禁用mouseEnabled并且调整为灰度
         * 这里使用了色调的灰度实现方式，如果同时使用色调，会有冲突
         */
        get: function () {
            return !this.mouseEnabled;
        },
        set: function (v) {
            this.mouseEnabled = !v;
            if (v)
                this.setTonal(0, 0, 0, 100);
            else
                this.setTonal(0, 0, 0, 0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tips", {
        get: function () {
            return this._tips ? this._tips : "";
        },
        //------------------------------------------------------------------------------------------------------
        // 设置TIPS
        //------------------------------------------------------------------------------------------------------
        set: function (v) {
            if (!Config.EDIT_MODE)
                return;
            this._tips = v;
            if (v)
                Tips.reg(this, v, true);
            else
                Tips.cancelReg(this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "show", {
        //------------------------------------------------------------------------------------------------------
        // 
        //------------------------------------------------------------------------------------------------------
        /**
        * 显示
        */
        get: function () {
            return this._show;
        },
        set: function (v) {
            this._show = v;
            this.visible = this._show && this._showOnEditor;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "showOnEditor", {
        /**
         * 显示（编辑器用）
         */
        get: function () {
            return this._showOnEditor;
        },
        set: function (v) {
            if (!Config.EDIT_MODE)
                return;
            this._showOnEditor = v;
            this.visible = this._show && this._showOnEditor;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "opacity", {
        /**
         * 透明度
         */
        get: function () {
            return this._opacity;
        },
        set: function (v) {
            this._opacity = v;
            this.refreshRealAlpha();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "opacityPer", {
        /**
         * 透明度比例（编辑器使用）
         */
        get: function () {
            return this._opacityPer;
        },
        set: function (v) {
            this._opacityPer = v;
            this.refreshRealAlpha();
        },
        enumerable: false,
        configurable: true
    });
    GameSprite.prototype.refreshRealAlpha = function () {
        if (this.useDPCoord) {
            this.alpha = this._opacity * this._opacityPer * this._dpOpacity;
        }
        else {
            this.alpha = this._opacity * this._opacityPer;
        }
    };
    Object.defineProperty(GameSprite.prototype, "mouseEventEnabled", {
        /**
         * 鼠标不可用
         */
        get: function () {
            return this._mouseEventEnabled;
        },
        set: function (v) {
            this._mouseEventEnabled = v;
            this.mouseEnabled = this._mouseEventEnabled && this._mouseEventEnabledInEditor;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "mouseEventEnabledInEditor", {
        /**
         * 显示（编辑器用）
         */
        get: function () {
            return this._mouseEventEnabledInEditor;
        },
        set: function (v) {
            this._mouseEventEnabledInEditor = v;
            this.mouseEnabled = this._mouseEventEnabled && this._mouseEventEnabledInEditor;
        },
        enumerable: false,
        configurable: true
    });
    //------------------------------------------------------------------------------------------------------
    // private 
    //------------------------------------------------------------------------------------------------------
    /**
     * 刷新滤镜，计算当前我的最终滤镜
     */
    GameSprite.prototype.refreshFilter = function () {
    };
    /**
     * 减少滤镜，主要用于同步滤镜（父容器的独有滤镜减少）
     * @param subtract
     */
    GameSprite.prototype.subtractFilter = function (subtract) {
    };
    /**
     * 增加滤镜，主要用于同步滤镜（父容器的独有滤镜增加）
     * @param appended
     */
    GameSprite.prototype.appended = function (appended, childLayer) {
        if (childLayer === void 0) { childLayer = false; }
    };
    Object.defineProperty(GameSprite.prototype, "hue", {
        //------------------------------------------------------------------------------------------------------
        // 色相色调
        //------------------------------------------------------------------------------------------------------
        /**
        * 色相，使用HueFilter实现
        */
        get: function () {
            return this._hue;
        },
        set: function (v) {
            v || (v = 0);
            v = Math.floor(v);
            this._hue = v;
            this._hueFilter = null;
            if (this._hue) {
                this._hueFilter = new HueFilter(this._hue);
            }
            this.refreshFilters();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "blur", {
        /**
         * 模糊，使用BlurFilter实现
         */
        get: function () {
            return this._blur;
        },
        set: function (v) {
            v || (v = 0);
            this._blur = v;
            this._blurFilter = null;
            if (this._blur) {
                this._blurFilter = new BlurFilter(this._blur);
            }
            this.refreshFilters();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tonal_r", {
        /**
         * 色调（R+,B+,G+,GRAY,R*,G*,B*）
         *
         * GameSprite.setTonal
         */
        get: function () {
            return this._tonalParams[0];
        },
        set: function (v) {
            v || (v = 0);
            this._tonalParams[0] = v;
            this.setTonal(this.tonal_r, this._tonalParams[1], this._tonalParams[2], this._tonalParams[3], this._tonalParams[4], this._tonalParams[5], this._tonalParams[6]);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tonal_g", {
        get: function () {
            return this._tonalParams[1];
        },
        set: function (v) {
            v || (v = 0);
            this._tonalParams[1] = v;
            this.setTonal(this.tonal_r, this._tonalParams[1], this._tonalParams[2], this._tonalParams[3], this._tonalParams[4], this._tonalParams[5], this._tonalParams[6]);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tonal_b", {
        get: function () {
            return this._tonalParams[2];
        },
        set: function (v) {
            v || (v = 0);
            this._tonalParams[2] = v;
            this.setTonal(this.tonal_r, this._tonalParams[1], this._tonalParams[2], this._tonalParams[3], this._tonalParams[4], this._tonalParams[5], this._tonalParams[6]);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tonal_gray", {
        get: function () {
            return this._tonalParams[3];
        },
        set: function (v) {
            v || (v = 0);
            this._tonalParams[3] = v;
            this.setTonal(this.tonal_r, this._tonalParams[1], this._tonalParams[2], this._tonalParams[3], this._tonalParams[4], this._tonalParams[5], this._tonalParams[6]);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tonal_mr", {
        get: function () {
            return this._tonalParams[4];
        },
        set: function (v) {
            if (v == null)
                v = 1;
            this._tonalParams[4] = v;
            this.setTonal(this.tonal_r, this._tonalParams[1], this._tonalParams[2], this._tonalParams[3], this._tonalParams[4], this._tonalParams[5], this._tonalParams[6]);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tonal_mb", {
        get: function () {
            return this._tonalParams[6];
        },
        set: function (v) {
            if (v == null)
                v = 1;
            this._tonalParams[6] = v;
            this.setTonal(this.tonal_r, this._tonalParams[1], this._tonalParams[2], this._tonalParams[3], this._tonalParams[4], this._tonalParams[5], this._tonalParams[6]);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tonal_mg", {
        get: function () {
            return this._tonalParams[5];
        },
        set: function (v) {
            if (v == null)
                v = 1;
            this._tonalParams[5] = v;
            this.setTonal(this.tonal_r, this._tonalParams[1], this._tonalParams[2], this._tonalParams[3], this._tonalParams[4], this._tonalParams[5], this._tonalParams[6]);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 获取当前拥有的全材质数据，可用于储存，同时可使用 installMaterialData 安装该材质数据 (materialData: { materials: any[] }[])
     */
    GameSprite.prototype.getAllMaterialDatas = function () {
        var materialPassDataArr = [];
        for (var i = 0; i < this.materialPassArr.length; i++) {
            var d = this.materialPassArr[i];
            if (!d)
                continue;
            materialPassDataArr.push({ materials: d.materials });
        }
        return materialPassDataArr;
    };
    /**
     * 安装材质
     * @param materials
     */
    GameSprite.prototype.installMaterialData = function (materialData, resetTime) {
        if (resetTime === void 0) { resetTime = true; }
        if (!materialData)
            return;
        for (var i = 0; i < materialData.length; i++) {
            var passData = materialData[i];
            for (var s = 0; s < passData.materials.length; s++) {
                var mData = passData.materials[s];
                if (resetTime)
                    mData.____timeInfo = {};
                this.addMaterial(mData, i);
            }
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 添加材质
    //------------------------------------------------------------------------------------------------------
    /**
     * 添加材质，根据材质数据
     * @param material 材质数据
     * @param passage [可选] 默认值=0 所在的通道
     * @return [boolean] 是否成功
     */
    GameSprite.prototype.addMaterial = function (materialData, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass)
            return false;
        pass.materials.push(materialData);
        this.setMaterialDirty();
        return true;
    };
    /**
     * 添加材质到指定的位置上，根据材质数据
     * @param material 材质数据
     * @param index 位置
     * @param passage [可选] 默认值=0 所在的通道
     * @return [boolean] 是否成功
     */
    GameSprite.prototype.addMaterialAt = function (materialData, index, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass || index < 0)
            return false;
        pass.materials.splice(index, 0, materialData);
        this.setMaterialDirty();
        return true;
    };
    /**
     * 添加材质，根据材质ID，材质参数使用默认值
     * @param material 材质数据
     * @param passage [可选] 默认值=0 所在的通道
     * @return [boolean] 是否成功
     */
    GameSprite.prototype.addMaterialByID = function (materialID, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass)
            return false;
        var cls = window["MaterialData" + materialID];
        if (!cls)
            return false;
        var materialData = new cls;
        pass.materials.push(materialData);
        this.setMaterialDirty();
        return true;
    };
    /**
     * 添加材质，根据材质ID，材质参数使用默认值
     * @param material 材质数据
     * @param index 位置
     * @param passage [可选] 默认值=0 所在的通道
     * @return [boolean] 是否成功
     */
    GameSprite.prototype.addMaterialAtByID = function (materialID, index, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass || index < 0)
            return false;
        var cls = window["MaterialData" + materialID];
        if (!cls)
            return false;
        var materialData = new cls;
        pass.materials.splice(index, 0, materialData);
        this.setMaterialDirty();
        return true;
    };
    //------------------------------------------------------------------------------------------------------
    // 移除材质
    //------------------------------------------------------------------------------------------------------
    /**
     * 移除材质，根据材质数据，如若该数据已存在里面则会被移除
     * @param materialData 材质数据
     * @param passage [可选] 默认值=0 所在的通道
     * @return [boolean] 是否成功
     */
    GameSprite.prototype.removeMaterial = function (materialData, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass)
            return false;
        var idx = pass.materials.indexOf(materialData);
        if (idx == -1)
            return false;
        pass.materials.splice(idx, 1);
        this.setMaterialDirty();
        return true;
    };
    /**
     * 移除材质，根据材质所在的位置
     * @param index 材质数据所在的位置索引
     * @param passage [可选] 默认值=0 所在的通道
     * @return [boolean] 是否成功
     */
    GameSprite.prototype.removeMaterialAt = function (index, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass || index < 0 || index >= pass.materials.length)
            return false;
        pass.materials.splice(index, 1);
        this.setMaterialDirty();
        return true;
    };
    /**
     * 移除材质，根据材质ID
     * @param materialID 材质数据ID
     * @param passage [可选] 默认值=0 所在的通道
     * @return [boolean] 是否成功
     */
    GameSprite.prototype.removeMaterialByID = function (materialID, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass)
            return false;
        var idx = ArrayUtils.matchAttributes(pass.materials, { id: materialID }, true, "==", true)[0];
        if (idx != null) {
            pass.materials.splice(idx, 1);
            this.setMaterialDirty();
            return true;
        }
        return false;
    };
    //------------------------------------------------------------------------------------------------------
    // 获取材质
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取材质数据，根据ID
     * @param materialID 材质数据ID
     * @param passage [可选] 默认值=0 所在的通道
     * @return [MaterialData] 材质数据
     */
    GameSprite.prototype.getMaterialByID = function (materialID, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass)
            return null;
        return ArrayUtils.matchAttributes(pass.materials, { id: materialID }, true)[0];
    };
    /**
     * 获取材质数据，根据位置索引
     * @param index 所在的位置索引
     * @param passage [可选] 默认值=0 所在的通道
     * @return [MaterialData] 材质数据
     */
    GameSprite.prototype.getMaterialAt = function (index, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass || index < 0)
            return null;
        return pass.materials[index];
    };
    /**
     * 获取指定通道内的材质数据总数
     * @param passage [可选] 默认值=0 所在的通道
     * @return [number]
     */
    GameSprite.prototype.getMaterialLength = function (passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass)
            return 0;
        return pass.materials.length;
    };
    /**
     * 获取材质通道总数
     * @return [number]
     */
    GameSprite.prototype.getMaterialPassLength = function () {
        return this.materialPassArr.length;
    };
    //------------------------------------------------------------------------------------------------------
    // 清理材质
    //------------------------------------------------------------------------------------------------------
    /**
     * 清空所有材质
     */
    GameSprite.prototype.clearMaterials = function () {
        for (var i = 0; i < this.materialPassArr.length; i++) {
            this.materialPassArr[i].dispose();
        }
        this.materialPassArr.length = 0;
        this.setMaterialDirty();
    };
    /**
     * 清空指定通道里的材质
     * @param passage 所在的通道
     * @param deletePass 删除通道
     */
    GameSprite.prototype.clearMaterialsInPass = function (passage, deletePass) {
        if (deletePass === void 0) { deletePass = false; }
        if (passage < 0)
            return;
        var pass = this.materialPassArr[passage];
        if (pass) {
            pass.materials.length = 0;
            this.setMaterialDirty();
            if (deletePass) {
                this.materialPassArr.splice(passage, 1);
                pass.dispose();
            }
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 更换材质位置
    //------------------------------------------------------------------------------------------------------
    /**
     * 更换同一个通道内的材质位置
     * @param material 材质数据
     * @param toIndex 所在的位置索引
     * @param passage [可选] 默认值=0 所在的通道
     * @return [boolean] 是否更换成功
     */
    GameSprite.prototype.setMaterialIndex = function (material, toIndex, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass)
            return false;
        var fromIndex = pass.materials.indexOf(material);
        if (fromIndex == -1)
            return false;
        if (toIndex < 0 || toIndex > pass.materials.length)
            return false;
        ArrayUtils.setIndex(pass.materials, pass, toIndex);
        this.setMaterialDirty();
        return true;
    };
    /**
     * 更换材质位置
     * @param fromIndex 材质所在的原始位置
     * @param toIndex 材质需要更换至的新位置
     * @param passage [可选] 默认值=0 所在的通道
     * @return [boolean] 是否更换成功
     */
    GameSprite.prototype.swapMaterialIndex = function (fromIndex, toIndex, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass)
            return false;
        if (fromIndex < 0 || fromIndex >= pass.materials.length)
            return false;
        if (toIndex < 0 || toIndex >= pass.materials.length)
            return false;
        ArrayUtils.swap(pass.materials, fromIndex, toIndex);
        this.setMaterialDirty();
        return true;
    };
    /**
     * 更换通道顺序，通道顺序影响渲染先后顺序
     * @param passFromIndex 材质通道所在的原始位置
     * @param passToIndex 材质通道需要更换至的新位置
     * @return [boolean] 是否更换成功
     */
    GameSprite.prototype.swapMaterialPass = function (passFromIndex, passToIndex) {
        if (passFromIndex < 0 || passFromIndex >= this.materialPassArr.length)
            return false;
        if (passToIndex < 0 || passToIndex >= this.materialPassArr.length)
            return false;
        ArrayUtils.swap(this.materialPassArr, passFromIndex, passToIndex);
        this.setMaterialDirty();
        return true;
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 设置为指定的GameSprite相同的材质
     * @param gameSprite 指定的参考GameSprite
     * @param cloneMode 是否克隆模式，如果是则表示使用克隆的方式复制材质数据（MaterialData），否则是引用
     */
    GameSprite.prototype.setMaterialsByGameSprite = function (gameSprite, cloneMode) {
        if (gameSprite.isDisposed || this.isDisposed)
            return;
        this.clearMaterials();
        for (var i = 0; i < gameSprite.materialPassArr.length; i++) {
            var mPass = gameSprite.materialPassArr[i];
            var newPass = new GameSpriteMaterialPass(this);
            newPass.materials = cloneMode ? ObjectUtils.depthClone(mPass.materials) : mPass.materials.concat();
            this.materialPassArr.push(newPass);
        }
        this.setMaterialDirty();
    };
    /**
     * 调用此函数表示更改了材质，让系统根据最新的材质计算来进行渲染
     */
    GameSprite.prototype.setMaterialDirty = function () {
        Callback.CallLaterBeforeRender(this.doSetMaterialDirty, this);
    };
    GameSprite.prototype.doSetMaterialDirty = function () {
        if (this.isDisposed)
            return;
        for (var i = 0; i < this.materialPassArr.length; i++) {
            this.materialPassArr[i].refreshRenderData();
        }
        this.refreshFilters();
        // this.repaint();
    };
    /**
     * 调用此函数快速设置传递给shader的值，比直接修改材质后调用setMaterialDirty效率要更高一些，减少了数据的转换计算。
     * 比如需要帧刷只更新少数几个数值时可以调用该函数进行优化计算。
     *
     * 【关于变量名】
     * -- 变量名规格：mu材质编号_变量属性
     *
     * 【关于值】
     * -- number 类型的属性直接设置
     * -- 颜色属性请设置为 [r,g,b] 其中r/g/b取值范围为0~1
     * -- 不支持贴图设置，更改贴图仍然需要
     *
     * 【materialValues参数规格】
     * {
     *    mu2_abc: 1,
     *    mu3_color: [0.5,0.5,1]
     * }
     *
     * @param materialValues 需要更新的材质数据
     * @param passage [可选] 默认值=0 所在的通道
     */
    GameSprite.prototype.setMaterialValueFast = function (materialValues, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass || !pass.shaderData)
            return;
        for (var i in materialValues) {
            pass.shaderData[i] = materialValues[i];
        }
        Callback.CallLaterBeforeRender(this.doRepaint, this);
    };
    GameSprite.prototype.doRepaint = function () {
        if (this.isDisposed)
            return;
        this.repaint();
    };
    //------------------------------------------------------------------------------------------------------
    // 材质内部实现
    // 根据当前的材质合并成对应的滤镜,一个PASS对应一个滤镜
    //------------------------------------------------------------------------------------------------------
    GameSprite.prototype.getMaterialPassage = function (passage, ifNotExistCreate) {
        if (passage < 0)
            return null;
        for (var i = 0; i < passage; i++) {
            if (this.materialPassArr[i])
                continue;
            var pass = this.materialPassArr[i] = new GameSpriteMaterialPass(this);
        }
        var passageArr = this.materialPassArr[passage];
        // 只能创建下一个通道
        if (ifNotExistCreate && !passageArr && this.materialPassArr.length == passage) {
            this.materialPassArr[passage] = passageArr = new GameSpriteMaterialPass(this);
        }
        return passageArr;
    };
    /**
     * 刷新滤镜，根据当前的材质、色调、模糊、色相等（项目层只有材质）
     */
    GameSprite.prototype.refreshFilters = function () {
        var filters = [];
        if (this._tonalFilter) {
            filters.push(this._tonalFilter);
        }
        if (this._hueFilter) {
            filters.push(this._hueFilter);
        }
        if (this._blurFilter) {
            filters.push(this._blurFilter);
        }
        if (this._filterEnabled) {
            filters = this.materialPassArr.concat(filters);
        }
        this.filters = filters;
    };
    /**
     * 当释放时派发的事件
     */
    GameSprite.ON_DISPOSE = "GameSpriteON_DISPOSE";
    return GameSprite;
}(Sprite));
// 重新定义GameSprite的width/height
Object.defineProperty(GameSprite.prototype, 'width', {
    get: function () {
        if (!this.autoSize)
            return this._width;
        return this.getSelfBounds().width;
    },
    set: function (value) {
        if (this._width !== value) {
            this._width = value;
            this.conchModel && this.conchModel.size(value, this._height);
            this.repaint();
            this.event(EventObject.RESIZE);
        }
    }
});
Object.defineProperty(GameSprite.prototype, 'height', {
    get: function () {
        if (!this.autoSize)
            return this._height;
        return this.getSelfBounds().height;
    },
    set: function (value) {
        if (this._height !== value) {
            this._height = value;
            this.conchModel && this.conchModel.size(this._width, value);
            this.repaint();
            this.event(EventObject.RESIZE);
        }
    }
});
/**
 * 地图层
 */
var ClientSceneLayer = /** @class */ (function (_super) {
    __extends(ClientSceneLayer, _super);
    function ClientSceneLayer(scene, autoUpdate) {
        if (autoUpdate === void 0) { autoUpdate = true; }
        var _this = _super.call(this) || this;
        /**
         * 偏移值-X
         */
        _this.dx = 0;
        /**
         * 偏移值-Y
         */
        _this.dy = 0;
        /**
         * X方向流动
         */
        _this.xMove = 0;
        /**
         * Y方向流动
         */
        _this.yMove = 0;
        /**
         * X方向流动当前值
         */
        _this.dxMove = 0;
        /**
         * Y方向流动当前值
         */
        _this.dyMove = 0;
        /**
         * 远景比例X轴 1.0 表示 100% 普通地图是100%，值越小则移动越慢
         */
        _this.prospectsPerX = 1.0;
        /**
         * 远景比例Y轴 1.0 表示 100% 普通地图是100%，值越小则移动越慢
         */
        _this.prospectsPerY = 1.0;
        /**
         * 自动刷新（视窗和渲染）
         */
        _this.autoUpdate = true;
        /**
         * 图块层
         */
        _this.tileLayer = new Sprite();
        /**
         * 图块数据 xGrid yGrid = [data]
         */
        _this.tileData = [];
        /**
         * 图片宽
         */
        _this.imgWidth = 0;
        /**
         * 图片高
         */
        _this.imgHeight = 0;
        /**
         * 缓存图片大的宽度：用于循环时减去该尺寸
         */
        _this.imgBigWidth = 0;
        /**
         * 缓存图片大的高度：用于循环时减去该尺寸
         */
        _this.imgBigHeight = 0;
        /**
         * 图片图块层编辑模式
         */
        _this.modeType = true;
        /**
         * 图片图块层锁定编辑模式
         */
        _this.modeLock = false;
        /**
         * 切割图块数据
         */
        _this.tileSplitMap = [];
        /**
         * 需要更新的切割图块
         */
        _this.needFlushTileSplit = {};
        /**
         * 需要更新的自动元件坐标点
         */
        _this.needFlushAutoPos = [];
        _this.hasTilingAttribute = true;
        _this.scene = scene;
        _this.autoUpdate = autoUpdate;
        _this.addChild(_this.tileLayer);
        return _this;
    }
    /**
     * 安装数据
     */
    ClientSceneLayer.prototype.install = function (layerData, onFin) {
        var _this = this;
        if (onFin === void 0) { onFin = null; }
        // 设置属性
        ObjectUtils.clone(layerData, this);
        // 设置材质
        this.installMaterialData(layerData.materialData);
        // 初始化缓存的图块信息
        if (this.drawMode && !this.autoTileDataCache) {
            this.autoTileDataCache = layerData.autoTileDataCache = [];
        }
        // 图块模式
        if (this.drawMode && layerData.tileData) {
            var urls = [];
            if (!Config.EDIT_MODE) {
                for (var id in layerData.tileTexIDs) {
                    if (!layerData.tileTexIDs[id])
                        continue;
                    var tileID = MathUtils.int(id);
                    if (tileID > 0) {
                        var tileData = Game.data.tileList.data[id];
                        if (tileData && tileData.url)
                            urls.push(tileData.url);
                    }
                    else {
                        var autoTileData = Game.data.autoTileList.data[-tileID];
                        if (autoTileData && autoTileData.url)
                            urls.push(autoTileData.url);
                    }
                }
            }
            else {
                for (var id in Game.data.tileList.data) {
                    var tileData = Game.data.tileList.data[id];
                    if (tileData && tileData.url)
                        urls.push(tileData.url);
                }
                for (var id in Game.data.autoTileList.data) {
                    var autoTileData = Game.data.autoTileList.data[id];
                    if (autoTileData && autoTileData.url)
                        urls.push(autoTileData.url);
                }
            }
            if (urls.length == 0) {
                onFin && onFin.run();
                return;
            }
            this.__loadImages = urls;
            AssetManager.loadImages(urls, Callback.New(function () {
                if (_this.isDisposed)
                    return;
                _this.setTilefromJsonData();
                onFin && onFin.run();
            }, this), !Config.EDIT_MODE);
        }
        // 全景图模式
        else {
            if (layerData.img) {
                this.__loadImages = [layerData.img];
                AssetManager.loadImage(layerData.img, Callback.New(function () {
                    if (_this.isDisposed)
                        return;
                    _this.setBigImage(layerData.img);
                    onFin && onFin.run();
                }, this), false, true);
            }
            else {
                onFin && onFin.run();
            }
        }
    };
    /**
     * 设置数据来自
     */
    ClientSceneLayer.prototype.setTilefromJsonData = function () {
        var wGrid = this.scene.gridWidth;
        var hGrid = this.scene.gridHeight;
        // 恢复数据，如果存在缓存则使用缓存
        for (var x = 0; x < wGrid; x++) {
            if (!this.tileData[x])
                continue;
            for (var y = 0; y < hGrid; y++) {
                var myTileData = this.tileData[x][y];
                if (myTileData && myTileData.texID) {
                    var texID = myTileData.texID;
                    if (texID > 0) {
                        var tileData = Game.data.tileList.data[myTileData.texID];
                        if (!tileData)
                            continue;
                        var url = tileData.url;
                    }
                    else {
                        var autoTileData = Game.data.autoTileList.data[-texID];
                        if (!autoTileData)
                            continue;
                        var url = autoTileData.url;
                        // 如果存在自动元件缓存
                        var autoTileDataCacheX = this.autoTileDataCache[x];
                        if (autoTileDataCacheX) {
                            var autoTileDataCache = autoTileDataCacheX[y];
                            if (autoTileDataCache) {
                                var atOriTex = AssetManager.getImage(url);
                                if (!atOriTex)
                                    continue;
                                if (autoTileData.GCATMode == 0) {
                                    var atMarginTex = ClientSceneLayer.getGCAT1Texture(texID, atOriTex, autoTileDataCache.gridInfo);
                                    if (!atMarginTex)
                                        continue;
                                    myTileData.tex = atOriTex;
                                    this.drawTile(x, y, { tex: atMarginTex, texID: 0, x: 0, y: 0, w: Config.SCENE_GRID_SIZE, h: Config.SCENE_GRID_SIZE }, true);
                                    // trace("使用缓存建立");
                                    continue;
                                }
                            }
                        }
                    }
                    var tex = AssetManager.getImage(url);
                    if (!tex)
                        continue;
                    myTileData.tex = tex;
                    this.drawTile(x, y, myTileData);
                }
            }
        }
        this.flushTile();
    };
    /**
     * 重置大小
     */
    ClientSceneLayer.prototype.resizeTileSplit = function (wGrid, hGrid) {
        // 去除超出的数据
        for (var w = 0; w < this.tileData.length; w++) {
            if (!this.tileData[w])
                continue;
            if (this.tileData[w].length > hGrid) {
                this.tileData[w].splice(hGrid);
            }
        }
        if (this.tileData.length > wGrid)
            this.tileData.splice(wGrid);
        // 处理Spilt块
        var wSplit = Math.ceil(wGrid / (Config.TILE_SPLIT_SIZE / Config.SCENE_GRID_SIZE));
        var hSplit = Math.ceil(hGrid / (Config.TILE_SPLIT_SIZE / Config.SCENE_GRID_SIZE));
        // 销毁超出的块，同时当前块超出的格子全部清除掉
        this.tileLayer.removeChildren();
        var len = this.tileSplitMap.length;
        for (var x = 0; x < len; x++) {
            var tileDataColumn = this.tileSplitMap[x];
            if (!tileDataColumn)
                continue;
            for (var y = 0; y < tileDataColumn.length; y++) {
                if (!tileDataColumn[y])
                    continue;
                if (x >= wSplit || y >= hSplit) {
                    if (tileDataColumn[y].texture)
                        tileDataColumn[y].texture.destroy(true);
                }
            }
            tileDataColumn.length = hSplit;
        }
        if (isNaN(wSplit) || wSplit < 0 || wSplit == Infinity) {
            return;
        }
        this.tileSplitMap.length = wSplit;
        // 创建对应的块
        for (var x = 0; x < wSplit; x++) {
            var tileDataColumn = this.tileSplitMap[x];
            if (!tileDataColumn) {
                tileDataColumn = this.tileSplitMap[x] = [];
            }
            for (var y = 0; y < hSplit; y++) {
                var splitData = this.tileSplitMap[x][y];
                if (!splitData) {
                    splitData = this.tileSplitMap[x][y] = {
                        graphics: new Graphics(),
                        graphicsMapping: [],
                        texture: null,
                        sprite: new Sprite()
                    };
                    splitData.sprite.x = x * Config.TILE_SPLIT_SIZE;
                    splitData.sprite.y = y * Config.TILE_SPLIT_SIZE;
                    var localGridSize = Config.TILE_SPLIT_SIZE / Config.SCENE_GRID_SIZE;
                    for (var g = 0; g < localGridSize; g++) {
                        splitData.graphicsMapping[g] = [];
                    }
                }
                this.tileLayer.addChild(splitData.sprite);
            }
        }
        var realSize = Scene.getRealWidth(this.scene);
        this.imgWidth = realSize.width;
        this.imgHeight = realSize.height;
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 刷新循环显示：后期可优化，不必每次重载
     */
    ClientSceneLayer.prototype.refreshLoopShow = function () {
        if (this.drawMode) {
            this.reloadTile();
        }
        else {
            this.setBigImage(this.mapUrl);
        }
    };
    /**
     * 重载图块
     */
    ClientSceneLayer.prototype.reloadTile = function () {
        this.clearTile(false);
        this.install({ tileData: this.tileData, tileTexIDs: this["tileTexIDs"] });
    };
    //------------------------------------------------------------------------------------------------------
    // 图块
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取数据化的图块数据
     */
    ClientSceneLayer.prototype.getTileData = function () {
        var tileData = [];
        var tileTexIDs = {};
        var wGrid = this.scene.gridWidth;
        var hGrid = this.scene.gridHeight;
        for (var x = 0; x < wGrid; x++) {
            if (!this.tileData[x])
                continue;
            if (!tileData[x])
                tileData[x] = [];
            for (var y = 0; y < hGrid; y++) {
                var oneTileData = this.tileData[x][y];
                if (oneTileData) {
                    tileData[x][y] = {
                        texID: oneTileData.texID,
                        x: oneTileData.x,
                        y: oneTileData.y
                    };
                    if (oneTileData.texID && !tileTexIDs[oneTileData.texID]) {
                        tileTexIDs[oneTileData.texID] = true;
                    }
                }
            }
        }
        return [tileData, tileTexIDs];
    };
    /**
     * 绘制图块
     * @param xGrid
     * @param yGrid
     * @param texture
     * @param dx 贴图偏移x
     * @param dy 贴图偏移y
     * @param onlyDisplay 仅用于显示
     */
    ClientSceneLayer.prototype.drawTile = function (xGrid, yGrid, tileData, onlyDisplay) {
        if (onlyDisplay === void 0) { onlyDisplay = false; }
        if (tileData && tileData.texID < 0) {
            if (!this.tileData[xGrid])
                this.tileData[xGrid] = [];
            this.tileData[xGrid][yGrid] = tileData;
            var gridP = new Point(xGrid, yGrid);
            this.needFlushAutoPos.push({ grid: gridP, gridData: tileData, refreshGrid9: true });
            return;
        }
        if (xGrid < 0 || xGrid >= this.scene.gridWidth || yGrid < 0 || yGrid >= this.scene.gridHeight)
            return;
        // 刷新自身以及周围8个格子(如果周围格子存在自动元件的话)
        var needRefreshGrids = ClientSceneLayer.gridCheckModes[2];
        var len = needRefreshGrids.length;
        for (var i = 0; i < len; i++) {
            var d = needRefreshGrids[i];
            var dx = d[0] + xGrid;
            var dy = d[1] + yGrid;
            var gridData = this.tileData[dx];
            if (!gridData)
                continue;
            gridData = gridData[dy];
            if (!gridData)
                continue;
            // 如果目标格子图块与当前图块不一致的话且目标是自动元件则
            if (gridData.texID < 0) {
                this.needFlushAutoPos.push({ grid: new Point(dx, dy), gridData: gridData, refreshGrid9: false });
                continue;
            }
        }
        // 
        var splitGridSize = Math.ceil(Config.TILE_SPLIT_SIZE / Config.SCENE_GRID_SIZE);
        var splitX = Math.floor(xGrid / splitGridSize);
        var splitY = Math.floor(yGrid / splitGridSize);
        var splitData = this.tileSplitMap[splitX][splitY];
        var graphics = splitData.graphics;
        var localGridX = xGrid % splitGridSize;
        var localGridY = yGrid % splitGridSize;
        var localX = localGridX * Config.SCENE_GRID_SIZE;
        var localY = localGridY * Config.SCENE_GRID_SIZE;
        var gCmdIndex = splitData.graphicsMapping[localGridX][localGridY];
        if (gCmdIndex == null) {
            if (tileData) {
                var w = Config.SCENE_GRID_SIZE;
                var h = Config.SCENE_GRID_SIZE;
                if (localGridX == splitGridSize - 1)
                    w += 1;
                if (localGridY == splitGridSize - 1)
                    h += 1;
                graphics.fillTexture(tileData.tex, localX, localY, w, h, null, new Point(-tileData.x, -tileData.y));
                gCmdIndex = splitData.graphicsMapping[localGridX][localGridY] = graphics.cmds ? graphics.cmds.length - 1 : 0;
            }
        }
        else {
            var gCmdData = gCmdIndex == 0 && graphics.cmds == null ? graphics["_one"] : graphics.cmds[gCmdIndex];
            if (tileData) {
                if (gCmdData) {
                    gCmdData[0] = tileData.tex;
                    gCmdData[1] = localX;
                    gCmdData[2] = localY;
                    gCmdData[6].x = -tileData.x;
                    gCmdData[6].y = -tileData.y;
                }
            }
            else {
                splitData.graphicsMapping[localGridX][localGridY] = null;
                if (graphics.cmds) {
                    graphics.cmds.splice(gCmdIndex, 1);
                    for (var x = 0; x < splitGridSize; x++) {
                        for (var y = 0; y < splitGridSize; y++) {
                            if (splitData.graphicsMapping[x][y] > gCmdIndex) {
                                splitData.graphicsMapping[x][y]--;
                            }
                        }
                    }
                    if (graphics.cmds.length == 0) {
                        graphics.clear();
                    }
                }
                else {
                    if (gCmdIndex == 0)
                        graphics.clear();
                }
            }
        }
        var tileSplitIndex = splitX + "_" + splitY;
        if (!this.needFlushTileSplit[tileSplitIndex]) {
            this.needFlushTileSplit[tileSplitIndex] = splitData;
        }
        if (!onlyDisplay) {
            if (!this.tileData[xGrid])
                this.tileData[xGrid] = [];
            this.tileData[xGrid][yGrid] = tileData;
        }
    };
    /**
     * 绘制自动图块元件
     */
    ClientSceneLayer.prototype.drawAutoTile = function (xGrid, yGrid, autoTileID, texture) {
        if (xGrid < 0 || xGrid >= this.scene.gridWidth || yGrid < 0 || yGrid >= this.scene.gridHeight)
            return;
        var tileDataX = this.tileData[xGrid];
        if (!tileDataX)
            tileDataX = this.tileData[xGrid] = [];
        var tileDataY = tileDataX[yGrid] = { tex: texture, texID: -autoTileID, x: 0, y: 0, w: 0, h: 0 };
        var gridP = new Point(xGrid, yGrid);
        this.needFlushAutoPos.push({ grid: gridP, gridData: tileDataY, refreshGrid9: true });
    };
    /**
     * 计算并绘制自动图块
     */
    ClientSceneLayer.prototype.calcDrawAutoTile = function (xGrid, yGrid) {
    };
    /**
     * 冲洗图块：将此前绘制过的图块统一显示出来
     */
    ClientSceneLayer.prototype.flushTile = function () {
        // 更新自动元件
        this.flushAutoTile();
        // 更新图：将切割大块缓存为整张图进行显示
        var realSize = Scene.getRealWidth(this.scene);
        for (var i in this.needFlushTileSplit) {
            var splitData = this.needFlushTileSplit[i];
            if (!splitData.graphics.cmds && !splitData.graphics["_one"]) {
                splitData.graphics.clear();
            }
            if (splitData.texture)
                splitData.texture.destroy(true);
            var texture = AssetManager.drawToTexture(splitData.graphics, Config.TILE_SPLIT_SIZE, Config.TILE_SPLIT_SIZE, 0, 0, false, Config.TILE_LINEAR_MIN ? 0x2601 : 0x2600, Config.TILE_LINEAR_MAG ? 0x2601 : 0x2600);
            var splitSprite = splitData.sprite;
            splitSprite.removeChildren();
            var drawArea = [];
            if (this.xLoop) {
                drawArea.push([1, 0], [-1, 0]);
            }
            if (this.yLoop) {
                drawArea.push([0, 1], [0, -1]);
            }
            if (this.xLoop && this.yLoop) {
                drawArea.push([-1, -1], [1, -1], [1, 1], [-1, 1]);
            }
            for (var s = 0; s < drawArea.length; s++) {
                var loopSp = new Sprite();
                loopSp.texture = texture;
                splitSprite.addChild(loopSp);
                var drawAreaS = drawArea[s];
                loopSp.x = drawAreaS[0] * realSize.width;
                loopSp.y = drawAreaS[1] * realSize.height;
            }
            splitData.sprite.texture = texture;
            splitData.texture = texture;
            // splitData.sprite.graphics.drawRect(0,0,511,511,"#FF0000")
        }
        this.needFlushTileSplit = [];
    };
    /**
     * 冲洗自动图块
     * -- 将之前填入了数据的自动元件块刷新其以及周围的自动元件数据
     * -- 将这些涉及的格子重新渲染
     */
    ClientSceneLayer.prototype.flushAutoTile = function () {
        var _this = this;
        // 需要冲洗的图块格子（计算后的值）
        var needFlushTileGrids = [];
        // 根据需要冲洗的自动元件格子坐标去计算实际的模样（needFlushAutoPos会由于refreshAutoTileGridX而动态增加）
        var autoTileListDatas = Game.data.autoTileList.data;
        for (var i = 0; i < this.needFlushAutoPos.length; i++) {
            var posInfo = this.needFlushAutoPos[i];
            var pos = posInfo.grid;
            var tileData = posInfo.gridData;
            if (!tileData)
                continue;
            var atID = -tileData.texID;
            var atData = autoTileListDatas[atID];
            if (atData) {
                if (!atData.url)
                    tileData.tex = null;
                if (atData.GCATMode == 0)
                    this.refreshAutoTileGrid1(tileData, pos.x, pos.y, needFlushTileGrids, posInfo.refreshGrid9);
            }
        }
        // 根据计算后的值直接绘制
        needFlushTileGrids.forEach(function (needFlushTileGrid, index) {
            _this.drawTile(needFlushTileGrid.grid.x, needFlushTileGrid.grid.y, { tex: needFlushTileGrid.tex, texID: 0, x: needFlushTileGrid.x, y: needFlushTileGrid.y, w: needFlushTileGrid.w, h: needFlushTileGrid.h }, true);
        }, this);
        this.needFlushAutoPos.length = 0;
    };
    /**
     * 清理图块
     * @param isDispose [可选] 默认值=true 销毁
     */
    ClientSceneLayer.prototype.clearTile = function (isDispose) {
        if (isDispose === void 0) { isDispose = false; }
        this.needFlushAutoPos.length = 0;
        var len = this.tileSplitMap.length;
        var localGridSize = Config.TILE_SPLIT_SIZE / Config.SCENE_GRID_SIZE;
        for (var x = 0; x < len; x++) {
            for (var y = 0; y < this.tileSplitMap[x].length; y++) {
                var tileData = this.tileSplitMap[x][y];
                tileData.graphics.clear();
                for (var g = 0; g < localGridSize; g++) {
                    tileData.graphicsMapping[g] = [];
                }
                if (!tileData || !tileData.texture)
                    continue;
                tileData.texture.destroy(true);
            }
        }
        if (isDispose)
            this.tileSplitMap.length = 0;
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 设置编辑器模式
     * @param bool 是否编辑器模式
     * @param forceShow 是否强行显示（不透明）
     */
    ClientSceneLayer.prototype.setEditorMode = function (bool, forceShow) {
        if (forceShow === void 0) { forceShow = false; }
        if (bool == this.editorMode || !this.drawMode)
            return;
        if (bool) {
            this.lastStates = {
                scaleX: this.scaleX,
                scaleY: this.scaleY,
                rotation: this.rotation,
                opacityPer: this.opacityPer,
                filterEnabled: this.filterEnabled,
                skewX: this.skewX,
                skewY: this.skewY
            };
            this.scaleX = this.scaleY = 1;
            this.skewX = this.skewY = 0;
            this.rotation = 0;
            this.opacityPer = 1;
            this.filterEnabled = false;
        }
        else {
            if (!this.lastStates)
                return;
            this.scaleX = this.lastStates.scaleX;
            this.scaleY = this.lastStates.scaleY;
            this.rotation = this.lastStates.rotation;
            this.opacityPer = forceShow ? 1 : this.lastStates.opacityPer;
            this.filterEnabled = true;
            this.dxMove = 0;
            this.dyMove = 0;
            this.skewX = this.lastStates.skewX;
            this.skewY = this.lastStates.skewY;
        }
        this.editorMode = bool;
        this.onRender(true);
    };
    Object.defineProperty(ClientSceneLayer.prototype, "drawMode", {
        get: function () {
            return this._drawMode;
        },
        /**
         * 更改图块模式
         */
        set: function (v) {
            if (v) {
                this.setBigTexture(null);
            }
            else {
                this.tileLayer.graphics.clear();
            }
            if (!this._drawMode && v) {
                this.resizeTileSplit(this.scene.gridWidth, this.scene.gridHeight);
            }
            this._drawMode = v;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 设置完整图片作为该层地图图像
     * @param imgURL 完整图片地址
     */
    ClientSceneLayer.prototype.setBigImage = function (imgURL) {
        var _this = this;
        if (this.drawMode)
            return;
        AssetManager.disposeImage(this.mapUrl);
        this.mapUrl = imgURL;
        this.graphics.clear();
        if (this.bigImageRoot) {
            this.removeChild(this.bigImageRoot);
            AssetManager.disposeAtlasSprite(this.bigImageRoot);
            this.bigImageRoot = null;
        }
        if (imgURL == null)
            return;
        if (this.__loadImages)
            AssetManager.disposeImages(this.__loadImages);
        this.__loadImages = [imgURL];
        AssetManager.loadImage(imgURL, Callback.New(function (tex) {
            _this.setBigTexture(tex, false);
        }, this), true);
    };
    /**
     * 根据texture设置背景
     * @param t
     * @param disposeBitImage [可选] 默认值=true 从外部设置进来的话默认是会销毁原来的大图资源
     */
    ClientSceneLayer.prototype.setBigTexture = function (t, disposeBitImage) {
        if (disposeBitImage === void 0) { disposeBitImage = true; }
        if (this.isDisposed)
            return;
        if (disposeBitImage && this.mapUrl) {
            AssetManager.disposeImage(this.mapUrl);
            this.mapUrl = null;
        }
        if (!t) {
            this.graphics.clear();
            return;
        }
        this.imgWidth = t.width;
        this.imgHeight = t.height;
        // 如果贴图大于最大贴图尺寸的话使用切割图的方式显示
        if (t.width > os.MAX_TEXTURE_SIZE || t.height > os.MAX_TEXTURE_SIZE) {
            var bitTextureBox = this.bigImageRoot = AssetManager.bigTextureToAtlasSprite(t, this.xLoop, this.yLoop, this.imgWidth, this.imgHeight);
            this.addChildAt(bitTextureBox, 0);
            return;
        }
        this.imgBigWidth = this.xLoop ? t.width * 50 : 0;
        this.imgBigHeight = this.yLoop ? t.height * 50 : 0;
        // 远景效果图：重复
        var g = new Graphics();
        var loopStr = this.xLoop && this.yLoop ? "repeat" : this.xLoop ? "repeat-x" : this.yLoop ? "repeat-y" : "no-repeat";
        // 如果图片小于
        var fillW = this.xLoop ? ClientSceneLayer.prospectSize : t.width;
        var fillH = this.yLoop ? ClientSceneLayer.prospectSize : t.height;
        g.fillTexture(t, 0, 0, fillW, fillH);
        this.graphics = g;
        Callback.CallLaterBeforeRender(this.doRepaint, this);
    };
    /**
     * 该地图层设置视口
     * @param rect
     */
    ClientSceneLayer.prototype.setViewPort = function (rect) {
        if (!this.autoUpdate)
            return;
        // 根据远景比例设置我的坐标 默认如果是100%的话则保持0,0点，保持默认即可（即与M2Map对齐）（不循环）
        // 如果远景比例不是100的话则计算在该视窗中的铺满并保证循环显示
        // 如看向100,100,100,100这个矩形区域，则非远景层的左上角图像从100,100开始，而远景层（80%）的话则从80,80开始，则远景层需要偏移20,20
        this.viewRect = rect;
        if (this.editorMode) {
            this.x = 0;
            this.y = 0;
            this.tileLayer.x = 0;
            this.tileLayer.y = 0;
            return;
        }
        if ((this.prospectsPerX != 1 || this.prospectsPerY != 1 || this.xMove != 0 || this.yMove != 0 || this.skewX != 1 || this.skewY != 1) && rect) {
            // 表示该层的坐标偏移值，如80%比例则坐标应偏移20%
            var dpx = 1 - this.prospectsPerX;
            var dpy = 1 - this.prospectsPerY;
            var globalX = Math.floor(rect.x * dpx);
            var globalY = Math.floor(rect.y * dpy);
            this.x = globalX + this.dx + this.dxMove - this.imgBigWidth;
            this.y = globalY + this.dy + this.dyMove - this.imgBigHeight;
            if (this.drawMode) {
                this.tileLayer.x = this.imgBigWidth;
                this.tileLayer.y = this.imgBigHeight;
            }
        }
        else {
            this.x = this.dx;
            this.y = this.dy;
            if (this.drawMode) {
                this.tileLayer.x = this.tileLayer.y = 0;
            }
        }
        // this.x = Math.floor(this.x);
        // this.y = Math.floor(this.y);
        this.x = this.x;
        this.y = this.y;
    };
    /**
     * 渲染
     */
    ClientSceneLayer.prototype.onRender = function (LayerMoveToZero) {
        if (LayerMoveToZero === void 0) { LayerMoveToZero = false; }
        if (!this.autoUpdate)
            return;
        if (!LayerMoveToZero) {
            this.dxMove += this.xMove;
            this.dyMove += this.yMove;
            if (this.imgWidth != 0 && this.xLoop) {
                this.dxMove %= this.imgWidth * this.scaleX;
            }
            if (this.imgHeight != 0 && this.yLoop) {
                this.dyMove %= this.imgHeight * this.scaleY;
            }
        }
        else {
            this.dxMove = 0;
            this.dyMove = 0;
        }
        this.setViewPort(this.viewRect);
        // 自动更新深度
        this.updateChildZOrder();
    };
    /**
     * 重置自动滚动
     */
    ClientSceneLayer.prototype.resetAutoMove = function () {
        this.dxMove = 0;
        this.dyMove = 0;
    };
    /**
     * 更新深度
     */
    ClientSceneLayer.prototype.updateChildZOrder = function () {
        if (this.isChangeChildZOrder) {
            var len = this.numChildren;
            var mcArray = [];
            for (var i = 0; i < len; i++) {
                mcArray.push(this.getChildAt(i));
            }
            mcArray.sort(function (a, b) {
                if (a.y == b.y && a["objectID"] && b["objectID"]) {
                    return a["objectID"] < b["objectID"] ? -1 : 1;
                }
                return a.y > b.y ? 1 : -1;
            });
            var arrLen = mcArray.length;
            for (var j = 0; j < arrLen; j++) {
                this.setChildIndex(mcArray[j], j);
            }
        }
    };
    /**
     * 释放资源
     */
    ClientSceneLayer.prototype.dispose = function () {
        if (!this.isDisposed) {
            // 清理引用
            if (this.__loadImages)
                AssetManager.disposeImages(this.__loadImages);
            if (this.mapUrl) {
                this.mapUrl = null;
            }
            if (this.bigImageRoot) {
                AssetManager.disposeAtlasSprite(this.bigImageRoot);
                this.bigImageRoot = null;
            }
            // 销毁生成的图块贴图
            this.clearTile(true);
            this.removeSelf();
        }
        _super.prototype.dispose.call(this);
    };
    //------------------------------------------------------------------------------------------------------
    // 存档读档
    //------------------------------------------------------------------------------------------------------
    ClientSceneLayer.prototype.getSaveData = function () {
        var o = {};
        o.scaleX = this.scaleX;
        o.scaleY = this.scaleY;
        o.xLoop = this.xLoop;
        o.yLoop = this.yLoop;
        o.xMove = this.xMove;
        o.yMove = this.yMove;
        o.alpha = this.alpha;
        o.blendMode = this.blendMode;
        o.mapUrl = this.mapUrl;
        return o;
    };
    ClientSceneLayer.prototype.recoverySaveData = function (o) {
        for (var i in o) {
            if (i == "mapUrl")
                continue;
            this[i] = o[i];
        }
        if (o.mapUrl) {
            this.setBigImage(o.mapUrl);
        }
    };
    ClientSceneLayer.GCAT1_keys_init = function () {
        if (ClientSceneLayer.GCAT1_keysX)
            return;
        ClientSceneLayer.GCAT1_keysX = [];
        ClientSceneLayer.GCAT1_keysX[1000] = [2, 4];
        ClientSceneLayer.GCAT1_keysX[100] = [0, 4];
        ClientSceneLayer.GCAT1_keysX[1100] = [1, 4];
        ClientSceneLayer.GCAT1_keysX[10] = [2, 2];
        ClientSceneLayer.GCAT1_keysX[1010] = [2, 3];
        ClientSceneLayer.GCAT1_keysX[1110] = [0, 0];
        ClientSceneLayer.GCAT1_keysX[1] = [0, 2];
        ClientSceneLayer.GCAT1_keysX[101] = [0, 3];
        ClientSceneLayer.GCAT1_keysX[1101] = [1, 0];
        ClientSceneLayer.GCAT1_keysX[11] = [1, 2];
        ClientSceneLayer.GCAT1_keysX[1011] = [0, 1];
        ClientSceneLayer.GCAT1_keysX[111] = [1, 1];
        ClientSceneLayer.GCAT1_keysX[1111] = [1, 3];
    };
    /**
     * 刷新自动元件-GCAT1规格
     * @param tileData 对应gridX、gridY的数据
     * @param gridX 格子坐标X
     * @param gridY 格子坐标Y
     * @param needFlushTileGrids 需要刷新的图块格子，比如当前这个格子可能导致周围8格都需要刷新
     */
    ClientSceneLayer.prototype.refreshAutoTileGrid1 = function (tileData, gridX, gridY, needFlushTileGrids, refreshGrid9) {
        if (refreshGrid9 === void 0) { refreshGrid9 = true; }
        // 刷新自身以及周围8个格子（根据模式选择自身/9格）
        var needRefreshGrids = ClientSceneLayer.gridCheckModes[refreshGrid9 ? 0 : 1];
        var len = refreshGrid9 ? needRefreshGrids.length : 1;
        for (var i = 0; i < len; i++) {
            var d = needRefreshGrids[i];
            var dx = d[0] + gridX;
            var dy = d[1] + gridY;
            var gridData = this.tileData[dx];
            if (!gridData)
                continue;
            gridData = gridData[dy];
            if (!gridData)
                continue;
            // 如果目标格子图块与当前图块不一致的话且目标是自动元件则重新刷新
            if (tileData.texID != gridData.texID && gridData.texID < 0) {
                this.needFlushAutoPos.push({ grid: new Point(dx, dy), gridData: gridData, refreshGrid9: false });
                continue;
            }
            this.doRefreshAutoTileGrid1(tileData.texID, gridData, dx, dy, needFlushTileGrids);
        }
    };
    /**
     *
     * @param tileData 数据
     * @param gridX 格子坐标X
     * @param gridY 格子坐标Y
     * @param needFlushTileGrids 需要刷新的图块格子，比如当前这个格子可能导致周围8格都需要刷新
     */
    ClientSceneLayer.prototype.doRefreshAutoTileGrid1 = function (refAtID, tileData, xGrid, yGrid, needFlushTileGrids) {
        // 如果非同类自动元件则无需刷新
        if (tileData.texID != refAtID)
            return;
        var gridInfo = this.getGridInfo(xGrid, yGrid, refAtID);
        // -- 设置图样
        // trace("-------------tileData.tex", "[", xGrid, yGrid, "]", refAtID, tileData.tex)
        var tex = ClientSceneLayer.getGCAT1Texture(refAtID, tileData.tex, gridInfo);
        // if(!this.autoTileDataCache) {
        //     this.autoTileDataCache = layerData.autoTileDataCache = [];
        // }
        var autoTileDataCacheX = this.autoTileDataCache[xGrid];
        if (!autoTileDataCacheX)
            autoTileDataCacheX = this.autoTileDataCache[xGrid] = [];
        autoTileDataCacheX[yGrid] = { autoTexID: refAtID, gridInfo: gridInfo };
        needFlushTileGrids.push({ grid: new Point(xGrid, yGrid), tex: tex, x: 0, y: 0, w: Config.SCENE_GRID_SIZE, h: Config.SCENE_GRID_SIZE });
    };
    /**
     * 获取指定格子的GCAT1计算后的显示数据
     * @param xGrid 格子x
     * @param yGrid 格子y
     * @param autoTileID
     * @param preCoverTileData [可选] 默认值=null 即将覆盖的图块数据（如果存在则使用该值计算而非this.tileData）
     * @param preCoverTileStartGrid [可选] 默认值=null 参考的起点格子坐标
     */
    ClientSceneLayer.prototype.getGridInfo = function (xGrid, yGrid, autoTileID, preCoverTileData, preCoverTileStartGrid) {
        if (preCoverTileData === void 0) { preCoverTileData = null; }
        if (preCoverTileStartGrid === void 0) { preCoverTileStartGrid = null; }
        var gridPointStatusRelyOns = ClientSceneLayer.gridPointStatusRelyOns1;
        // 确定该格子的16个点的状态，从上左到上右到下左到下右
        var gridInfo = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (var i = 0; i < 16; i++) {
            var gs = gridPointStatusRelyOns[i];
            var existGrid = true;
            var gsLen = gs.length;
            for (var s = 0; s < gsLen; s++) {
                var dPoint = gs[s];
                var dx = dPoint[0];
                var dy = dPoint[1];
                var refGridX = xGrid + dx;
                var refGridY = yGrid + dy;
                // 超越边界：当做存在
                if (refGridX < 0 || refGridY < 0 || refGridX >= this.scene.gridWidth || refGridY >= this.scene.gridHeight) {
                    continue;
                }
                // 如果存在预览的即将覆盖的区域（预览笔刷）则计算笔刷的
                var tileData = null;
                var targetTileDataX = null;
                if (preCoverTileData) {
                    refGridX -= preCoverTileStartGrid.x;
                    refGridY -= preCoverTileStartGrid.y;
                    if (refGridX >= 0 && refGridY >= 0) {
                        tileData = preCoverTileData;
                        targetTileDataX = tileData[refGridX];
                    }
                    // 如果不在光标笔刷预览中的话就还原，再次从地图中搜索
                    if (!targetTileDataX || !targetTileDataX[refGridY]) {
                        refGridX += preCoverTileStartGrid.x;
                        refGridY += preCoverTileStartGrid.y;
                        targetTileDataX = null;
                    }
                }
                if (!targetTileDataX) {
                    tileData = this.tileData;
                    targetTileDataX = tileData[refGridX];
                }
                if (!targetTileDataX) {
                    existGrid = false;
                    break;
                }
                var targetTileData = targetTileDataX[refGridY];
                if (!targetTileData || targetTileData.texID != autoTileID) {
                    existGrid = false;
                    break;
                }
            }
            // 存在格子
            if (existGrid) {
                gridInfo[i] = 1;
            }
        }
        // 转化为四个ID
        var k1 = gridInfo[0] * 1000 + gridInfo[1] * 100 + gridInfo[2] * 10 + gridInfo[3];
        var k2 = gridInfo[4] * 1000 + gridInfo[5] * 100 + gridInfo[6] * 10 + gridInfo[7];
        var k3 = gridInfo[8] * 1000 + gridInfo[9] * 100 + gridInfo[10] * 10 + gridInfo[11];
        var k4 = gridInfo[12] * 1000 + gridInfo[13] * 100 + gridInfo[14] * 10 + gridInfo[15];
        var key = k1 * 1000000000000 + k2 * 100000000 + k3 * 10000 + k4;
        return [k1, k2, k3, k4, key];
    };
    /**
     * 获取
     * @param info4
     * @return [Rectangle]
     */
    ClientSceneLayer.getGCAT1TextureSourceRect = function (info4) {
        ClientSceneLayer.GCAT1_keys_init();
        var sourcePos = ClientSceneLayer.GCAT1_keysX[info4];
        if (!sourcePos)
            return null;
        var tileSize = Math.floor(Config.SCENE_GRID_SIZE / 2);
        var dx = -sourcePos[0] * tileSize;
        var dy = -sourcePos[1] * tileSize;
        return new Rectangle(dx, dy, tileSize, tileSize);
    };
    /**
     * 获取GCAT1规格的展开的贴图
     * @param autoTileID 负数ID
     * @param gridInfo 组合标记，如果不存在则继续生成一张新的图
     */
    ClientSceneLayer.getGCAT1Texture = function (autoTileID, autoTileTex, gridInfo) {
        // var gridInfoKey = autoTileID + "_" + gridInfo.join("");
        var GCAT1_margin_textures = ClientSceneLayer.GCAT1_margin_textures[autoTileID];
        if (!GCAT1_margin_textures)
            GCAT1_margin_textures = ClientSceneLayer.GCAT1_margin_textures[autoTileID] = [];
        var gridInfoKey = gridInfo[4];
        // trace("使用KEY-",gridInfoKey,autoTileTex?autoTileTex.url:"没有贴图");
        var marginTexture = GCAT1_margin_textures[gridInfoKey];
        if (marginTexture) {
            return marginTexture;
        }
        var r1 = this.getGCAT1TextureSourceRect(gridInfo[0]);
        var r2 = this.getGCAT1TextureSourceRect(gridInfo[1]);
        var r3 = this.getGCAT1TextureSourceRect(gridInfo[2]);
        var r4 = this.getGCAT1TextureSourceRect(gridInfo[3]);
        var g = new Graphics();
        // if (!autoTileTex) {
        //     alert("error:没有图片，缓存失败！！！")
        // }
        // g.drawRect(0,0,Config.WINDOW_WIDTH,Config.WINDOW_HEIGHT,"#FF0000");
        g.fillTexture(autoTileTex, 0, 0, r1.width, r1.height, "repeat", new Point(r1.x, r1.y));
        g.fillTexture(autoTileTex, r1.width, 0, r2.width, r2.height, "repeat", new Point(r2.x, r2.y));
        g.fillTexture(autoTileTex, 0, r1.width, r1.width, r2.height, "repeat", new Point(r3.x, r3.y));
        g.fillTexture(autoTileTex, r1.width, r1.width, r2.width, r2.height, "repeat", new Point(r4.x, r4.y));
        var tex = AssetManager.drawToTexture(g, Config.SCENE_GRID_SIZE, Config.SCENE_GRID_SIZE, 0, 0);
        GCAT1_margin_textures[gridInfoKey] = tex;
        return tex;
    };
    /**
     * 清理指定的贴图
     * @param autoTileID
     */
    ClientSceneLayer.clearGCAT1Texture = function (autoTileID) {
        ClientSceneLayer.GCAT1_margin_textures[-autoTileID] = null;
    };
    /**
     * 远景图填充大小（虚拟宽高，底层做了UV重复的）
     */
    ClientSceneLayer.prospectSize = 1000000;
    /**
     * 格子检查模式-九格、当前格、周围八格
     */
    ClientSceneLayer.gridCheckModes = [
        [[0, 0], [-1, -1], [0, -1], [1, -1], [-1, 0], [1, 0], [-1, 1], [0, 1], [1, 1]],
        [[0, 0]],
        [[-1, -1], [0, -1], [1, -1], [-1, 0], [1, 0], [-1, 1], [0, 1], [1, 1]]
    ];
    //------------------------------------------------------------------------------------------------------
    // 自动元件-规格1
    //------------------------------------------------------------------------------------------------------
    ClientSceneLayer.GCAT1_margin_textures = [];
    /**
     * 自动元件1/4的位置偏移量
     */
    ClientSceneLayer.sourcePositions = [
        null,
        [2, 4],
        [0, 4],
        [1, 4],
        [2, 2],
        [2, 3],
        null,
        [0, 0],
        [0, 2],
        null,
        [0, 3],
        [1, 0],
        [1, 2],
        [0, 1],
        [1, 1],
        [1, 3] //15
    ];
    // 格子内状态点的依赖参考：按照每个1/4小块的顺序优先小块内的四个点，横向从左到右
    // 1  2  5  6
    // 3  4  7  8
    // 9 10 11 12
    ClientSceneLayer.gridPointStatusRelyOns1 = [
        // 第一个点：左边、上边、左上边
        [[-1, 0], [0, -1], [-1, -1]],
        // 第二个点：上边
        [[0, -1]],
        // 第三个点：左边
        [[-1, 0]],
        // 第四个点：一定存在
        [],
        // 第五个点：上边
        [[0, -1]],
        // 第六个点：右边、上边、右上边
        [[1, 0], [1, -1], [0, -1]],
        // 第七个点：一定存在
        [],
        // 第八个点：右边
        [[1, 0]],
        // 第九个点：左边
        [[-1, 0]],
        // 第10个点：一定存在
        [],
        // 第11个点：左边、下边、左下边
        [[-1, 0], [0, 1], [-1, 1]],
        // 第12个点：下边
        [[0, 1]],
        // 第13个点：一定存在
        [],
        // 第14个点：右边
        [[1, 0]],
        // 第15个点：下方
        [[0, 1]],
        // 第16个点：右边、下边、右下边
        [[1, 0], [0, 1], [1, 1]]
    ];
    return ClientSceneLayer;
}(GameSprite));
/**
 * AVATAR 显示对象
 * -- 确定渲染图集：动作 -> 部位 ->方向
 * -- 功能：换部件、指定某个动作-方向-帧播放或停到第几帧
 *
 * 数据结构：
 * 一个Avatar下面有若干个独享的AvatarAction
 * 一个AvatarAction下面有若干个独享的AvatarFrameImage
 *
 * 创建、更改和释放
 * var a = new Avatar();
 * a.loadData(1);
 * a.loadData(2);
 * a.dispose();
 *
 * 预加载
 * AssetManager.loadAvatar();
 *
 * 添加部件
 * var p = new Avatar();
 * p.id = 11;
 * a.addPart(p);
 *
 * 对于外部添加或更换了部件，将新建的部件主动卸载即可
 *
 *
 *
 * @author 黑暗之神KDS
 */
var Avatar = /** @class */ (function (_super) {
    __extends(Avatar, _super);
    //------------------------------------------------------------------------------------------------------
    // 构造和销毁
    //------------------------------------------------------------------------------------------------------
    /**
     * 构造函数
     */
    function Avatar() {
        var _this = _super.call(this) || this;
        /**
         * 自动ID
         */
        _this.autoID = ObjectUtils.getInstanceID();
        /**
         * 是否处于加载中标记
         */
        _this.isLoading = false;
        /**
         * 加载资源状态 0-无任何加载 1-加载了JSON 2-加载了图像资源 3-完毕
         */
        _this._loadState = 0;
        /**
         * AVATAR使用的图集
         */
        _this.picUrls = [];
        /**
         * 方向模式 1 2 3 4 5 8
         */
        _this.oriMode = 8;
        /**
         * 帧率
         */
        _this._fps = 12;
        /**
        * 当前帧
        */
        _this._currentFrame = 1;
        /**
         * 朝向
         */
        _this.ori = 2;
        /**
          * 动作Index
          */
        _this.actIndex = -1;
        /**
         * 动作ID
         */
        _this.actID = 0;
        /**
         * 动作列表 [actIndex] =
         */
        _this.actionListArr = [];
        /**
         * avatar显示对象
         */
        _this.avatarList = [];
        /**
         * 自身显示对象
         */
        _this._body = new GameSprite();
        _this._bodyGraphics = new GameSprite();
        /**
         * 1,3,5方向自动翻转
         */
        _this.autoFlip = true;
        // 动作播放完成记录轮数：每次超过最后一帧则算一次动作播放完成（类似跑步每跑完一圈则计入播放完成，派发一次播放完成动作）
        _this._actionPlayCompleteRecord = 0;
        /**
         * 参考点设置 id => AvatarRefObj
         */
        _this.refObjs = {};
        _this.syncLoadWhenAssetExist = !Config.EDIT_MODE;
        _this.addChild(_this._body);
        _this._body.addChild(_this._bodyGraphics);
        return _this;
    }
    Object.defineProperty(Avatar.prototype, "gameDataAvatarList", {
        /**
         * 获取数据库AVATAR列表
         */
        get: function () {
            return Common.avatarList;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "gameDataAvatarURL", {
        /**
         * 获取数据库AVATAR路径
         */
        get: function () {
            return "asset/json/avatar/data/avatar";
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "disposeAvatarAsset", {
        /**
         * 释放资源的方法
         */
        get: function () {
            return AssetManager.disposeAvatarAsset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "myClass", {
        /**
         * 获取我的类型
         */
        get: function () {
            return Avatar;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "id", {
        get: function () { return this._id; },
        set: function (v) {
            if (this.isDisposed)
                return;
            if (v == this.id)
                return;
            // 更换资源前卸载原资源
            this.___disposeAsset();
            this._id = v;
            this._loadIDRD = Math.random();
            this.loadData(v, this._loadIDRD);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "fps", {
        get: function () { return this._fps; },
        set: function (v) {
            v = MathUtils.int(v);
            if (this._fps == v)
                return;
            this._fps = v <= 0 ? 1 : v;
            for (var i = 0; i < this.avatarList.length; i++) {
                var avatarPart = this.avatarList[i];
                if (avatarPart == this)
                    continue;
                avatarPart.fps = v;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "currentFrame", {
        get: function () {
            return this._currentFrame;
        },
        set: function (v) {
            this.setCurrentFrame(v);
        },
        enumerable: false,
        configurable: true
    });
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 加载数据
     * @param avatarID
     */
    Avatar.prototype.loadData = function (avatarID, loadIDRD, topAvatar) {
        var _this = this;
        if (topAvatar === void 0) { topAvatar = null; }
        this.isLoading = true;
        if (!Config.EDIT_MODE && avatarID == 0) {
            this.isLoading = false;
            this.clear();
            Callback.New(this.event, this, [EventObject.LOADED]).delayRun(0);
            return;
        }
        if (Config.EDIT_MODE) {
            var avatarList = this.gameDataAvatarList;
            this.parseData(avatarList.data[avatarID], avatarList, loadIDRD, topAvatar);
        }
        else {
            this._loadState = 1;
            this.___loadJsonURL = this.gameDataAvatarURL + avatarID + ".json";
            AssetManager.loadJson(this.___loadJsonURL, Callback.New(function (avatarJson) {
                _this.parseData(avatarJson, null, loadIDRD, topAvatar);
            }, this), this.syncLoadWhenAssetExist);
        }
    };
    /**
     * 清理
     * @param clearGraphics [可选] 默认值=true 是否清理图像
     */
    Avatar.prototype.clear = function (clearGraphics) {
        if (clearGraphics === void 0) { clearGraphics = true; }
        for (var i = 0; i < this.avatarList.length; i++) {
            var avatarPart = this.avatarList[i];
            if (avatarPart == this)
                continue;
            this.removePart(avatarPart);
            i--;
        }
        if (clearGraphics)
            this._bodyGraphics.graphics = null;
        this.actionListArr = [];
    };
    /**
     * 解析数据
     * 关于死锁问题SyncTask，这里是安全的，子部件是新建立出来的不会重复加载
     * @param avatarJson
     * @param loadIDRD 在编辑器环境下为null表示强行刷新
     * @param topAvatar 根节点
     */
    Avatar.prototype.parseData = function (avatarJson, avatarListData, loadIDRD, topAvatar) {
        var _this = this;
        if (avatarListData === void 0) { avatarListData = null; }
        if (loadIDRD === void 0) { loadIDRD = null; }
        if (topAvatar === void 0) { topAvatar = null; }
        var loadRandName = "loadAvatar" + this.autoID;
        // 记录ID
        this._id = avatarJson ? avatarJson.id : null;
        // 记录根节点
        this.topAvatar = topAvatar ? topAvatar : this;
        // ---> 异步1：阻止掉过期的操作，比如设置了id=5，又设置了id=6或者已经被销毁
        if (this.isDisposed || this.topAvatar.isDisposed || (loadIDRD && this._loadIDRD != loadIDRD)) {
            this.event(Avatar.LOAD_EXPIRE);
            return;
        }
        // 不存在JSON的话则当做完成
        if (!avatarJson) {
            // 数据不存在默认使用0号行走图
            if (Config.EDIT_MODE && Common.avatarList.data[0]) {
                this.parseData(Common.avatarList.data[0], Common.avatarList, loadIDRD);
                return;
            }
            this.clear(false);
            this.event(EventObject.LOADED);
            return;
        }
        // 我的图集
        var oriArr = [1, 2, 3, 4, 6, 7, 8, 9];
        this.picUrls = avatarJson.picUrls;
        var h = Callback.New(function () {
            // ---> 异步2:阻止掉过期的操作，比如设置了id=5，又设置了id=6或者已经被销毁
            if (_this.isDisposed || _this.topAvatar.isDisposed || (loadIDRD && _this._loadIDRD != loadIDRD)) {
                _this.event(Avatar.LOAD_EXPIRE);
                return;
            }
            // clear
            _this.clear(false);
            // 基本
            _this.oriMode = avatarJson.oriMode;
            if (avatarJson.autoFlip == null)
                avatarJson.autoFlip = true;
            if (avatarJson.id == 0)
                avatarJson.autoFlip = false;
            _this.autoFlip = avatarJson.autoFlip;
            _this.name = avatarJson.name;
            // 我的动作
            for (var i = 0; i < avatarJson.actionListArr.length; i++) {
                var actData = avatarJson.actionListArr[i];
                var act = new AvatarAction();
                act.id = actData.id;
                act.oriMode = avatarJson.oriMode;
                var frameImageInfoData = actData.frameImageInfo;
                for (var s = 0; s < frameImageInfoData.length; s++) {
                    var oriActData = frameImageInfoData[s];
                    var ori = GameUtils.getOriByIndex(s, _this.oriMode);
                    act.frameImageInfo[ori] = [];
                    for (var f = 0; f < oriActData.length; f++) {
                        var frameData = oriActData[f];
                        var aImg = new AvatarFrameImage();
                        aImg.index = f;
                        aImg.picUrlIndex = frameData.picUrlIndex;
                        frameData.rect[2] = frameData.rect[2] ? frameData.rect[2] : 1;
                        frameData.rect[3] = frameData.rect[3] ? frameData.rect[3] : 1;
                        aImg.rect = new Rectangle(frameData.rect[0], frameData.rect[1], frameData.rect[2], frameData.rect[3]);
                        aImg.x = frameData.x;
                        aImg.y = frameData.y;
                        aImg.width = isNaN(frameData.width) ? frameData.rect[2] : frameData.width;
                        aImg.height = isNaN(frameData.height) ? frameData.rect[3] : frameData.height;
                        aImg.rotation = frameData.rotation ? frameData.rotation : 0;
                        if (frameData.alpha == null)
                            frameData.alpha = 1;
                        aImg.alpha = frameData.alpha;
                        aImg.hue = frameData.hue;
                        aImg.blur = frameData.blur;
                        aImg.tonal_r = frameData.tonal_r;
                        aImg.tonal_g = frameData.tonal_g;
                        aImg.tonal_b = frameData.tonal_b;
                        aImg.tonal_gray = frameData.tonal_gray;
                        aImg.tonal_mr = frameData.tonal_mr;
                        aImg.tonal_mg = frameData.tonal_mg;
                        aImg.tonal_mb = frameData.tonal_mb;
                        aImg.wait_type = frameData.wait_type;
                        aImg.wait_count = frameData.wait_count;
                        act.frameImageInfo[ori][f] = aImg;
                    }
                }
                _this.actionListArr[i] = act;
            }
            // 辅助体
            if (avatarJson.refObjs)
                _this.refObjs = avatarJson.refObjs;
            // 部位
            for (var i = 0; i < avatarJson.parts.length; i++) {
                // 此处临时修正更换changePartByAvatar中设置了partData.id导致递归溢出，而使用了深度复制
                var partData = ObjectUtils.depthClone(avatarJson.parts[i]);
                if (partData.id == 0) {
                    if (!_this.partData)
                        _this.partData = partData;
                    _this.addChild(_this._body);
                    _this.avatarList.push(_this);
                    continue;
                }
                new SyncTask(loadRandName);
                var avatarPart = new _this.myClass();
                avatarPart.prerender = _this.prerender;
                avatarPart.syncLoadWhenAssetExist = _this.syncLoadWhenAssetExist;
                avatarPart._loadIDRD = loadIDRD;
                // 加载完成或过期时都会任务推进
                avatarPart.once(EventObject.LOADED, _this, function (loadRandName, i, partData) {
                    SyncTask.taskOver(loadRandName);
                }, [loadRandName, i, partData]);
                avatarPart.once(Avatar.LOAD_EXPIRE, _this, function (loadRandName, i, partData) {
                    SyncTask.taskOver(loadRandName);
                }, [loadRandName, i, partData]);
                // 
                avatarPart.partData = partData;
                if (avatarListData) {
                    avatarPart.parseData(avatarListData.data[partData.id], avatarListData, loadIDRD);
                }
                else {
                    avatarPart.loadData(partData.id, loadIDRD, topAvatar);
                }
                _this.addPart(avatarPart);
                var avatarPartobj = {};
                ObjectUtils.clone(partData, avatarPartobj);
                delete avatarPartobj["id"];
                ObjectUtils.clone(avatarPartobj, avatarPart);
            }
            _this._loadState = 3;
            // 缓存帧图
            for (var s = 0; s < _this.actionListArr.length; s++) {
                var avatarAct = _this.actionListArr[s];
                if (!avatarAct)
                    continue;
                for (var o in oriArr) {
                    var ori = oriArr[o];
                    var frameLength = avatarAct.getFrameLength(ori);
                    for (var f = 0; f < frameLength; f++) {
                        var frame = avatarAct.getFrameImage(ori, f);
                        if (!frame)
                            continue;
                        var imgUrl = _this.picUrls[frame.picUrlIndex];
                        var g = AssetManager.getClipImage(imgUrl, 0, 0, frame.rect);
                        frame.graphics = g;
                    }
                }
            }
            // 显示当前帧
            new SyncTask(loadRandName, function (loadRandName) {
                // ---> 异步3:阻止掉过期的操作，比如设置了id=5，又设置了id=6或者已经被销毁
                if (this.isDisposed || this.topAvatar.isDisposed || (loadIDRD && this._loadIDRD != loadIDRD)) {
                    // 抛出过期事件
                    this.event(Avatar.LOAD_EXPIRE);
                    // 推进当前任务
                    SyncTask.taskOver(loadRandName);
                    return;
                }
                // 鼠标响应
                if (this._openAutoHitArea) {
                    this.openAutoHitArea(this._openAutoHitAreaForce);
                }
                if (!loadIDRD || loadIDRD == this._loadIDRD) {
                    this.isLoading = false;
                }
                // 如果通过动作index设置
                if (this.actIndex != -1) {
                    this.actionIndex = this.actIndex;
                }
                // 如果通过了动作ID设置
                else if (this.actID != 0) {
                    this.actionID = this.actID;
                }
                // 没有设置默认为1
                else {
                    this.actionID = 1;
                }
                // 渲染一帧
                this.delayOnRender(false, true, null, false);
                // 派发加载完成事件
                if (!loadIDRD || loadIDRD == this._loadIDRD) {
                    this.event(EventObject.LOADED);
                }
                // 完成时清理掉任务
                SyncTask.clear(loadRandName);
            }, [loadRandName], _this);
        }, this);
        this._loadState = 2;
        AssetManager.loadImages(this.picUrls, h, this.syncLoadWhenAssetExist, true, this.prerender);
    };
    /**
     * 销毁
     */
    Avatar.prototype.dispose = function () {
        if (!this.isDisposed) {
            // 清理同步任务
            this.___clearTask();
            // 停止播放
            this.stop(0, false);
            // 卸载资源
            this.___disposeAsset();
            this.avatarList = [];
            //卸载显示对象
            this._bodyGraphics.dispose();
            this._bodyGraphics = null;
            this._body.dispose();
            this._body = null;
            this.topAvatar = null;
        }
        _super.prototype.dispose.call(this);
    };
    /**
     * 清理任务
     */
    Avatar.prototype.___clearTask = function () {
        SyncTask.clear("loadAvatar" + this.autoID);
        for (var i = 0; i < this.avatarList.length; i++) {
            var avatarPart = this.avatarList[i];
            if (avatarPart == this)
                continue;
            avatarPart.___clearTask();
        }
    };
    /**
     * 卸载资源：根据当前的资源进行卸载
     */
    Avatar.prototype.___disposeAsset = function () {
        // 如果加载了本体资源且设置了部件的话，则按照实际部件进行卸载
        if (this._loadState == 3) {
            for (var i = 0; i < this.avatarList.length; i++) {
                var avatarPart = this.avatarList[i];
                if (avatarPart == this)
                    continue;
                avatarPart.___disposeAsset();
                avatarPart.__isDisposed = true;
            }
            // 卸载json
            AssetManager.disposeJson(this.___loadJsonURL);
            // 卸载涉及的图片资源
            AssetManager.disposeImages(this.picUrls);
        }
        // 如果加载了资源但还未设置部件的话
        else if (this._loadState == 2) {
            // 卸载json
            AssetManager.disposeJson(this.___loadJsonURL);
            // 卸载涉及的图片资源
            AssetManager.disposeImages(this.picUrls);
        }
        // 如果仅加载了JSON文件的话，则直接卸载JSON文件
        else if (this._loadState == 1) {
            AssetManager.disposeJson(this.___loadJsonURL);
        }
        this._loadState = 0;
    };
    Object.defineProperty(Avatar.prototype, "realBound", {
        //------------------------------------------------------------------------------------------------------
        // 获取
        //------------------------------------------------------------------------------------------------------
        get: function () {
            if (this.isDisposed)
                return;
            var myRect = this.getSelfBounds();
            return myRect;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "orientation", {
        get: function () {
            return this.ori;
        },
        //------------------------------------------------------------------------------------------------------
        // 朝向
        //------------------------------------------------------------------------------------------------------
        /**
         * 设置朝向，参考小键盘方向
         * 设置一个无效的朝向将忽略此次更改
         * @v 朝向
         * 7 8 9
         * 4 + 6
         * 1 2 3
         */
        set: function (v) {
            if (this.fixedOrientation)
                return;
            // 上下方向在1~2方向模式下无需切换实际朝向
            if ((v != 8 && v != 2) || this.oriMode > 2) {
                this.userChangeOrientation = true;
                for (var i in this.avatarList) {
                    if (this.avatarList[i] == this)
                        continue;
                    this.avatarList[i].orientation = v;
                }
                this.ori = v;
                this.delayOnRender(false);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "actionIndex", {
        get: function () {
            return this.actIndex;
        },
        //------------------------------------------------------------------------------------------------------
        // 动作
        //------------------------------------------------------------------------------------------------------
        /**
         * 设置动作，根据索引
         * 设置一个无效的动作将忽略此次更改
         * @param index 动作索引
         */
        set: function (index) {
            var lastActID = this.actionID;
            var oldActionIndex = this.actIndex;
            this.actIndex = index;
            var act = this.actionList[index];
            for (var i = 0; i < this.avatarList.length; i++) {
                var avatarPart = this.avatarList[i];
                if (avatarPart == this)
                    continue;
                if (act) {
                    avatarPart.actionID = act.id;
                }
                else {
                    avatarPart.actionIndex = index;
                }
            }
            if (oldActionIndex != this.actIndex) {
                this.event(Avatar.CHANGE_ACTION, [lastActID, this.actionID]);
            }
            this.delayOnRender(false);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "actionID", {
        get: function () {
            var avatarAct = this.actionListArr[this.actIndex];
            return avatarAct ? avatarAct.id : this.actID;
        },
        /**
         * 设置动作，根据动作ID
         * @param id 动作ID
         */
        set: function (id) {
            var lastActID = this.actionID;
            this.actID = id;
            var arr = ArrayUtils.matchAttributes(this.actionListArr, { id: id }, true);
            if (arr.length == 0) {
                this.actionIndex = -1;
                return;
            }
            ;
            var avatarAct = arr[0];
            var index = this.actionListArr.indexOf(avatarAct);
            var oldActionIndex = this.actIndex;
            this.actIndex = index;
            for (var i = 0; i < this.avatarList.length; i++) {
                var avatarPart = this.avatarList[i];
                if (avatarPart == this)
                    continue;
                avatarPart.actionID = id;
            }
            if (oldActionIndex != this.actIndex) {
                this.event(Avatar.CHANGE_ACTION, [lastActID, id]);
            }
            this.delayOnRender(false);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "actionList", {
        /**
         * 获取动作列表
         */
        get: function () {
            return this.actionListArr;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 是否存在动作
     * @param actionID 存在的动作ID
     * @return [boolean]
     */
    Avatar.prototype.hasActionID = function (actionID) {
        return ArrayUtils.matchAttributes(this.actionListArr, { id: actionID }, true)[0] != null;
    };
    //------------------------------------------------------------------------------------------------------
    // 部位（私有实现，不公开API，公开版是新版根据部位ID操作部位）
    //------------------------------------------------------------------------------------------------------
    /**
     * 换部位，若该部位不存在将会新增部位，层次依赖根据partIndex的顺序决定
     * @avatar 对应的AVATAR显示对象
     * @partIndex 部位Index
     */
    Avatar.prototype.changePart = function (avatar, partIndex) {
        var oldAvatar = this.avatarList[partIndex];
        var idx = this.getChildIndex(oldAvatar);
        this.removeChildAt(idx);
        this.addChildAt(avatar, idx);
        avatar.orientation = this.orientation;
        avatar.actionID = this.actionID;
        this.avatarList[partIndex] = avatar;
    };
    /**
     * 添加部位，将该部位放置当前层级最高层
     * @avatar 对应的AVATAR显示对象
     * @partIndex [可选]插入的位置，默认值-1表示自动插入至最上层
     * @return partIndex 部位索引
     */
    Avatar.prototype.addPart = function (avatar, partIndex) {
        if (partIndex === void 0) { partIndex = -1; }
        if (partIndex == -1) {
            this.avatarList.push(avatar);
            this.addChild(avatar);
        }
        else {
            this.avatarList.splice(partIndex, 0, avatar);
            this.addChildAt(avatar, partIndex);
        }
        avatar.fps = this.fps;
        avatar.orientation = this.orientation;
        avatar.actionID = this.actionID;
        return partIndex == -1 ? this.avatarList.length - 1 : partIndex;
    };
    /**
     * 移除部位，移除后，后面的部位索引会往前减少1
     * 如果该部位不再使用，请将isDispose设置为true
     * @param avatar 对应的AVATAR显示对象
     * @param isDispose [可选] 默认值=false 是否销毁
     * @return [number] 部位索引
     */
    Avatar.prototype.removePart = function (avatar, isDispose) {
        if (isDispose === void 0) { isDispose = false; }
        var partIdx = this.avatarList.indexOf(avatar);
        this.avatarList.splice(partIdx, 1);
        this.removeChild(avatar);
        if (isDispose)
            avatar.dispose();
        return partIdx;
    };
    /**
     * 移除部位,移除后，后面的部位索引会往前减少1
     * @param partIndex
     * @param isDispose [可选] 默认值=false 是否销毁
     */
    Avatar.prototype.removePartAt = function (partIndex, isDispose) {
        if (isDispose === void 0) { isDispose = false; }
        var avatar = this.avatarList.splice(partIndex, 1)[0];
        if (isDispose)
            avatar.dispose();
        this.removeChild(avatar);
    };
    //------------------------------------------------------------------------------------------------------
    // 新版本部位API
    //------------------------------------------------------------------------------------------------------
    /**
     * 添加部位，根据部件对象，如果该部位已存在则忽略
     * 添加进来的部件无需手动卸载
     * @param partID 部位ID
     * @param part 部件
     * @param partIndex [可选] 默认值=-1 插入的位置，默认值-1表示自动插入至最上层
     * @return [boolean] 是否添加成功
     */
    Avatar.prototype.addPartByAvatar = function (partID, part, partIndex) {
        if (partIndex === void 0) { partIndex = -1; }
        if (this.isLoading)
            return;
        // 不是avatar则忽略
        if (!(part instanceof Avatar))
            return;
        // 存在该部位的部件则忽略
        if (this.getPartByPartID(partID))
            return;
        // 设置部件的数据
        if (!part.partData)
            part.partData = {};
        part.partData.id = part.id;
        part.partData.partID = partID;
        // 添加到最上层或插入指定层
        if (partIndex == -1) {
            this.avatarList.push(part);
            this.addChild(part);
        }
        else {
            this.avatarList.splice(partIndex, 0, part);
            this.addChildAt(part, partIndex);
        }
        // 同步当前的状态
        part.fps = this.fps;
        part.orientation = this.orientation;
        part.actionID = this.actionID;
        part.topAvatar = this.topAvatar;
        if (this._openAutoHitArea)
            part.openAutoHitArea();
        return true;
    };
    /**
     * 添加部位：根据指定的部件对应的数据库ID，如果该部位已存在则忽略
     * 添加进来的部件无需手动卸载
     * @param partID 部位ID
     * @param avatarID 部件对应的数据库ID
     * @param partIndex [可选] 默认值=-1 插入的位置，默认值-1表示自动插入至最上层
     * @return [boolean] 是否添加成功
     */
    Avatar.prototype.addPartByID = function (partID, avatarID, partIndex) {
        if (partIndex === void 0) { partIndex = -1; }
        if (this.isLoading)
            return;
        // 存在该部位的部件则忽略
        if (this.getPartByPartID(partID))
            return;
        var newAvatar = new this.myClass();
        newAvatar.id = avatarID;
        return this.addPartByAvatar(partID, newAvatar);
    };
    /**
     * 移除部位：根据指定的部位ID
     * 可选择是否卸载的参数，如果未选择自动卸载则需要手动卸载
     * @param partID 部位ID
     * @param disposeOldPart [可选] 默认值=true 是否卸载旧部件，如果设置为false则要自行手动卸载
     * @return [Avatar] 部件
     */
    Avatar.prototype.removePartByPartID = function (partID, disposeOldPart) {
        if (disposeOldPart === void 0) { disposeOldPart = true; }
        if (this.isLoading)
            return;
        var part = this.getPartByPartID(partID);
        if (!part)
            return null;
        if (this.removePartByAvatar(part, disposeOldPart))
            return part;
        else
            return null;
    };
    /**
     * 移除部位：根据部件对象
     * 可选择是否卸载的参数，如果未选择自动卸载则需要手动卸载
     * @param part 部件
     * @param disposeOldPart [可选] 默认值=true 是否卸载旧部件（确实拥有该部件时才会成功卸载），如果设置为false则要自行手动卸载
     * @return [boolean] 是否移除成功
     */
    Avatar.prototype.removePartByAvatar = function (part, disposeOldPart) {
        if (disposeOldPart === void 0) { disposeOldPart = true; }
        if (this.isLoading)
            return;
        var partIdx = this.avatarList.indexOf(part);
        if (partIdx == -1)
            return false;
        this.avatarList.splice(partIdx, 1);
        this.removeChild(part);
        if (disposeOldPart)
            part.dispose();
        else
            part.topAvatar = part;
        return true;
    };
    /**
     * 更换部位：根据新的部件和部位ID
     * 新部件会自动继承原部件的设定（如位置、缩放、色调、透明度等设定）
     * 原部件会自动卸载
     * @param newPart 新的部件
     * @param partID 部位ID
     * @return [boolean]
     */
    Avatar.prototype.changePartByAvatar = function (newPart, partID) {
        if (this.isLoading)
            return;
        // 不是avatar则忽略
        if (!(newPart instanceof Avatar))
            return;
        var success = false;
        for (var i = 0; i < this.PartLength; i++) {
            var part = this.avatarList[i];
            if (part == this)
                continue;
            if (part.partData.partID == partID) {
                if (!newPart.partData)
                    newPart.partData = {};
                // 此处会报错，而loadData中使用了ObjectUtils.depthClone来克隆partData临时解决，需要了解详情后修正
                newPart.partData.id = newPart.id;
                newPart.partData.partID = partID;
                var oldPartIndex = this.getChildIndex(part);
                this.addChildAt(newPart, oldPartIndex);
                var oldPart = this.removeChildAt(oldPartIndex + 1);
                if (oldPart) {
                    // 继承旧的部位设定
                    var avatarPartobj = {};
                    ObjectUtils.clone(oldPart.partData, avatarPartobj);
                    delete avatarPartobj["id"];
                    // 根据最新的部件实际值为准（比如中途修改了该部件的位置）
                    ObjectUtils.cloneExcludeNonExistentAttribute(oldPart, avatarPartobj);
                    ObjectUtils.clone(avatarPartobj, newPart);
                    ObjectUtils.clone(avatarPartobj, newPart.partData);
                    oldPart.dispose();
                }
                this.avatarList[i] = newPart;
                // 同步当前的状态
                newPart.fps = this.fps;
                newPart.orientation = this.orientation;
                newPart.actionID = this.actionID;
                if (this._openAutoHitArea)
                    newPart.openAutoHitArea();
                success = true;
                break;
            }
        }
        return success;
    };
    /**
     * 更换部位：根据新的部件对应的数据库ID和部位ID
     * 新部件会自动继承原部件的设定（如位置、缩放、色调、透明度等设定）
     * 原部件会自动卸载
     * @param newAvatarID 新的部件对应的数据库ID
     * @param partID 部位ID
     * @return [boolean]
     */
    Avatar.prototype.changePartByAvatarID = function (newAvatarID, partID) {
        if (this.isLoading)
            return;
        if (!this.getPartByPartID(partID))
            return;
        var newPart = new this.myClass();
        newPart.syncLoadWhenAssetExist = true;
        newPart.id = newAvatarID;
        return this.changePartByAvatar(newPart, partID);
    };
    /**
     * 获取部位：根据部位ID
     * @param partID 部位ID
     * @return [Avatar] 部件
     */
    Avatar.prototype.getPartByPartID = function (partID) {
        return ArrayUtils.matchAttributesD2(this.avatarList, "partData", { partID: partID }, true)[0];
    };
    /**
     * 根据部件所在的位置索引获取部件
     * @param partIndex 部件所在的索引（索引范围0~PartLength-1）
     * @return [Avatar] 部件
     */
    Avatar.prototype.getPartAt = function (partIndex) {
        return this.avatarList[partIndex];
    };
    /**
     * 根据部位对应的数据库ID获取部件
     * @param avatarID 部件对应的数据库ID
     * @return [Avatar] 部件，不存在则返回null
     */
    Avatar.prototype.getPartByID = function (avatarID) {
        var m = ArrayUtils.matchAttributes(this.avatarList, { id: avatarID }, true, "==");
        return m[0];
    };
    /**
     * 根据部件获取所在的索引
     * @param avatar 部件
     * @return [number] 索引范围0~PartLength-1，不存在则返回-1
     */
    Avatar.prototype.getPartIndex = function (avatar) {
        return this.avatarList.indexOf(avatar);
    };
    Object.defineProperty(Avatar.prototype, "PartLength", {
        /**
         * 返回部位的个数（包含本体，如果只有本体则返回1）
         */
        get: function () {
            return this.avatarList.length;
        },
        enumerable: false,
        configurable: true
    });
    //------------------------------------------------------------------------------------------------------
    // 播放
    //------------------------------------------------------------------------------------------------------
    /**
     * 设置帧
     * @param v 帧数
     */
    Avatar.prototype.setCurrentFrame = function (v) {
        if (v <= 1)
            v = 1;
        this._currentFrame = v;
        this.resetFrameState();
        for (var i = 0; i < this.avatarList.length; i++) {
            var avatarPart = this.avatarList[i];
            if (avatarPart == this)
                continue;
            avatarPart.setCurrentFrame(v);
        }
        this.delayOnRender(false, true, v);
    };
    /**
    * 获取帧
    */
    Avatar.prototype.getCurrentFrame = function () {
        return this._currentFrame;
    };
    Object.defineProperty(Avatar.prototype, "frameCount", {
        /**
         * 获取当前动作方向中的总帧数（旧）
         */
        get: function () {
            var avatarAct = this.actionListArr[this.actIndex];
            return avatarAct ? avatarAct.getFrameLength(this.ori, true) : 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "totalFrame", {
        // 新API
        get: function () {
            return this.frameCount;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 跳转某帧进行播放，越界会自动取模（如帧长度10，播放13则是播放3）
     * @frame [可选]跳转AVATAR的帧数 单位：帧 默认从头开始
     */
    Avatar.prototype.gotoAndPlay = function (frame) {
        if (frame === void 0) { frame = 1; }
        if (frame <= 1)
            frame = 1;
        this.setCurrentFrame(frame);
        this.play();
    };
    /**
     * 在AVATAR的当前帧数开始播放
     */
    Avatar.prototype.play = function () {
        if (!this.isPlaying) {
            this.isPlaying = true;
            this.resetFrameState();
            os.add_ENTERFRAME(this.onRender, this);
        }
        this.delayOnRender(false);
    };
    /**
     * 停止动画
     * @param frame [可选] 默认值=0 指定停留的帧数
     * @param immediatelyRender [可选] 默认值=true 立刻刷新
     */
    Avatar.prototype.stop = function (frame, immediatelyRender) {
        if (frame === void 0) { frame = 1; }
        if (immediatelyRender === void 0) { immediatelyRender = true; }
        if (frame <= 1)
            frame = 1;
        if (this.isPlaying) {
            this.isPlaying = false;
            os.remove_ENTERFRAME(this.onRender, this);
        }
        this.setCurrentFrame(frame);
        if (immediatelyRender)
            this.delayOnRender(false);
    };
    /**
     * 延迟到下一帧渲染前调用Avatar的渲染，而非立即。比如连续改变多个参数后统一渲染，而不必要每次改变都渲染
     */
    Avatar.prototype.delayOnRender = function (autoPlay, useMapping, playFrame, sendEvent) {
        if (autoPlay === void 0) { autoPlay = true; }
        if (useMapping === void 0) { useMapping = true; }
        if (playFrame === void 0) { playFrame = null; }
        if (sendEvent === void 0) { sendEvent = true; }
        if (this.forceRender) {
            this.waitRender_waitCount = null;
            this.onRender.apply(this, [autoPlay, useMapping, playFrame, sendEvent, true]);
        }
        else {
            Callback.CallLaterBeforeRender(this.onRender, this, arguments);
        }
    };
    /**
     * 渲染
     * @param autoPlay [可选] 默认值=true 自动推进播放
     * @param useMapping 表示遇到没有的朝向和帧使用映射值
     * @param playFrame 指定播放帧
     * @param sendEvent 派发事件
     */
    Avatar.prototype.onRender = function (autoPlay, useMapping, playFrame, sendEvent, forceRender) {
        if (autoPlay === void 0) { autoPlay = true; }
        if (useMapping === void 0) { useMapping = true; }
        if (playFrame === void 0) { playFrame = null; }
        if (sendEvent === void 0) { sendEvent = true; }
        if (forceRender === void 0) { forceRender = false; }
        // if (!this.displayedInStage) return;
        // 新加载中则不渲染
        if (this.isLoading || (!Config.EDIT_MODE && this.id == 0))
            return;
        var cautoPlay = autoPlay;
        var cuseMapping = useMapping;
        var cplayFrame = playFrame;
        if (this.isDisposed)
            return;
        var now;
        if (playFrame == null) {
            if (autoPlay) {
                now = Date.now();
                // -- 上一帧有自定义等待时间的话
                if (this.waitRender_waitCount != null) {
                    if (this.waitRender_useTime) {
                        var dtime = now - this.waitRender_startCount;
                        if (dtime < this.waitRender_waitCount) {
                            return;
                        }
                    }
                    else {
                        var dFrame = __fCount - this.waitRender_startCount;
                        if (dFrame < this.waitRender_waitCount) {
                            return;
                        }
                    }
                    // -- 满足等待时间后推进1帧
                    this.waitRender_waitCount = null;
                    playFrame = this._currentFrame + 1;
                    // -- 后面应当重新播放了
                    this._startPlayTime = now;
                    this._startPlayFrame = playFrame;
                }
                // -- 否则使用帧率计算（固定间隔）
                else {
                    var timeIntervalMs = now - this._startPlayTime;
                    playFrame = Math.floor(timeIntervalMs / (1000 / this.fps)) + this._startPlayFrame;
                }
                // trace("当前playFrame=", playFrame)
                if (!forceRender && playFrame == this._currentFrame && timeIntervalMs >= 5) {
                    return;
                }
            }
            else {
                playFrame = this._currentFrame;
            }
        }
        this._currentFrame = playFrame;
        // 初始化
        this._bodyGraphics.graphics = null;
        this.currentFrameImage = null;
        // 获取当前的动作
        var avatarAct = this.actionListArr[this.actIndex];
        if (!avatarAct) {
            return;
        }
        // var frameLength = avatarAct.getFrameLength(this.ori, useMapping);
        // if (autoPlay && (playFrame == frameLength || (playFrame > frameLength && playFrame % frameLength == 0))) {
        //     this.event(Avatar.ACTION_PLAY_COMPLETED);
        // }
        // 再次获取
        // avatarAct = this.actionListArr[this.actIndex];
        // if (!avatarAct) {
        //     return;
        // }
        var renderPlayFrame = playFrame - 1;
        var frameLength = avatarAct.getFrameLength(this.ori, useMapping);
        // 获取当前的方向的当前帧
        var currentFrame = Math.max(renderPlayFrame, 0);
        var realFrame = useMapping ? currentFrame % frameLength : currentFrame;
        var frame = avatarAct.getFrameImage(this.ori, realFrame, useMapping);
        if (frame) {
            this.currentFrameImage = frame;
            this._bodyGraphics.graphics = frame.graphics;
            this._bodyGraphicsFlip = (this.oriMode % 2 == 1) && (this.ori == 3 || this.ori == 6 || this.ori == 9) && this.autoFlip;
            if (this._bodyGraphicsFlip) {
                this._bodyGraphics.scaleX = -1;
                this._bodyGraphics.x = frame.rect.width;
                //计算翻转中心线对齐
                this._body.x = -frame.width - frame.x;
            }
            else {
                this._bodyGraphics.scaleX = 1;
                this._bodyGraphics.x = 0;
                this._body.x = frame.x;
            }
            this._body.y = frame.y;
            this._body.scaleX = frame.width / frame.rect.width;
            this._body.scaleY = frame.height / frame.rect.height;
            this._body.rotation = frame.rotation;
            this._body.alpha = frame.alpha;
            this._body.hue = frame.hue;
            this._body.blur = frame.blur;
            this._body.setTonal(frame.tonal_r, frame.tonal_g, frame.tonal_b, frame.tonal_gray, frame.tonal_mr, frame.tonal_mg, frame.tonal_mb);
            // 如果开启了自动响应区域的话
            if (this._openAutoHitArea) {
                this._body.hitArea = new Rectangle(0, 0, frame.width / this._body.scaleX, frame.height / this._body.scaleY);
            }
            // 如果当前帧设置了自定义的停顿时间的话，则按照自定义停顿计算（本体才计算，部件目前是跟随本体的帧播放同步渲染的）
            // 后面考虑部件与本体的帧率播放等追加一种各自独立的模式，再追加相关参数和实现
            // -- 等待帧 frame
            if (this.topAvatar == this) {
                if (frame.wait_type == 1) {
                    this.waitRender_startCount = __fCount;
                    this.waitRender_useTime = false;
                    this.waitRender_waitCount = Math.round(frame.wait_count * os['fps'] / this.fps); // *os.fps/this.fps是为了计算实际需要等待的渲染帧数
                }
                // -- 等待时间 ms
                else if (frame.wait_type == 2) {
                    this.waitRender_startCount = Date.now();
                    this.waitRender_useTime = true;
                    this.waitRender_waitCount = frame.wait_count;
                }
            }
        }
        // 是否渲染标志，如果当前对象未渲染，但子部件渲染了，该对象也要视为渲染了
        var isRender = false;
        // 获取子对象
        for (var i = 0; i < this.avatarList.length; i++) {
            var avatarPart = this.avatarList[i];
            if (avatarPart == this)
                continue;
            if (avatarPart.onRender(autoPlay, useMapping, playFrame, sendEvent, forceRender)) {
                isRender = true;
            }
        }
        // 帧播放事件（如果子对象播放的话）
        if (frame || isRender) {
            isRender = true;
        }
        // 播放完成通知
        if (autoPlay && currentFrame >= ((this._actionPlayCompleteRecord + 1) * frameLength - 1) + 1) {
            this._actionPlayCompleteRecord++;
            if (sendEvent)
                this.event(Avatar.ACTION_PLAY_COMPLETED);
        }
        if (isRender) {
            if (sendEvent)
                this.event(Avatar.RENDER);
        }
        return isRender;
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 像素级点击碰触检测
     * 坐标系是相对于场景，比如需要鼠标检测击中的话可使用ClientScene::globalPos
     * @param x 坐标x
     * @param y 坐标y
     * @return [boolean] 是否点击中
     */
    Avatar.prototype.hitTestPoint = function (x, y) {
        if (this.isDisposed)
            return false;
        // 部件如果选中则直接算选中
        for (var i = 0; i < this.avatarList.length; i++) {
            var avatarPart = this.avatarList[i];
            if (avatarPart == this)
                continue;
            if (avatarPart.hitTestPoint(x, y)) {
                return true;
            }
        }
        // 没有图像的情况
        if (!this.currentFrameImage)
            return false;
        // 是否在范围内
        var inRect = _super.prototype.hitTestPoint.call(this, x, y);
        if (!inRect) {
            return false;
        }
        // 实际像素计算，区分Flip
        var imgUrl = this.picUrls[this.currentFrameImage.picUrlIndex];
        var tex = AssetManager.getImage(imgUrl);
        if (!tex)
            return false;
        var localP = this._bodyGraphics.globalToLocal(new Point(x, y), false);
        var tx = localP.x - this.currentFrameImage.rect.x;
        var ty = localP.y - this.currentFrameImage.rect.y;
        if (!this.currentFrameImage.positiveRect.contains(tx, ty)) {
            return false;
        }
        var c = tex.getPixels(tx, ty, 1, 1);
        return c[3] != 0;
    };
    //------------------------------------------------------------------------------------------------------
    // 响应区域：注册了事件后即根据mouseEnabled来开启区域响应（逐帧刷新点击区域）
    //------------------------------------------------------------------------------------------------------
    Avatar.prototype.on = function (type, caller, listener, args) {
        var t = _super.prototype.on.apply(this, arguments);
        if (this.hasMouseEvent)
            this.openAutoHitArea();
        return t;
    };
    ;
    Avatar.prototype.once = function (type, caller, listener, args) {
        var _this = this;
        var t = _super.prototype.once.apply(this, [type, caller, function (caller, listener, args, e) {
                listener.apply(caller, args ? args.concat([e]) : [e]);
                if (!_this.hasMouseEvent)
                    _this.closeAutoHitArea();
            }, [caller, listener, args]]);
        if (this.hasMouseEvent)
            this.openAutoHitArea();
        return t;
    };
    ;
    Avatar.prototype.off = function (type, caller, listener, onceOnly) {
        var t = _super.prototype.off.apply(this, arguments);
        if (!this.hasMouseEvent)
            this.closeAutoHitArea();
        return t;
    };
    ;
    Avatar.prototype.offAll = function (type) {
        var t = _super.prototype.offAll.apply(this, arguments);
        if (!this.hasMouseEvent)
            this.closeAutoHitArea();
        return t;
    };
    ;
    /**
     * 刷新响应区域
     */
    Avatar.prototype.openAutoHitArea = function (force) {
        if (force === void 0) { force = false; }
        if (this.isDisposed)
            return;
        this._openAutoHitArea = true;
        this._openAutoHitAreaForce = force;
        this.mouseEnabled = this._body.mouseEnabled = true;
        for (var i in this.avatarList) {
            if (this.avatarList[i] == this)
                continue;
            this.avatarList[i].openAutoHitArea(force);
        }
        if (!this.isLoading && this.topAvatar == this) {
            this.delayOnRender(false, true, null, false);
        }
    };
    Avatar.prototype.closeAutoHitArea = function (force) {
        if (force === void 0) { force = false; }
        if (this.isDisposed || Config.EDIT_MODE)
            return;
        // 如果强制开启了，非强制无法关闭
        if (this._openAutoHitAreaForce && !force)
            return;
        this._openAutoHitArea = false;
        this._openAutoHitAreaForce = false;
        this.mouseEnabled = false;
        if (this._body)
            this._body.mouseEnabled = false;
        for (var i in this.avatarList) {
            if (this.avatarList[i] == this)
                continue;
            this.avatarList[i].closeAutoHitArea(force);
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 9/10 = 0
    // 10/10 = 1
    //------------------------------------------------------------------------------------------------------
    /**
     * 重置帧状态
     */
    Avatar.prototype.resetFrameState = function () {
        this._startPlayTime = new Date().getTime();
        this._startPlayFrame = this._currentFrame;
        var frameCount = this.frameCount;
        // 当前动作总帧数为0时则视为第0轮
        if (frameCount == 0) {
            this._actionPlayCompleteRecord = 0;
        }
        else {
            // -1 目的是为了如果刚好是总帧的整数倍，不能视为下一轮，而是当前轮
            this._actionPlayCompleteRecord = Math.max(Math.floor(this._startPlayFrame / (frameCount)) - 1, 0);
        }
    };
    /**
     * 动作播放完毕事件，每当该动作播放完一次则抛出此事件
     */
    Avatar.ACTION_PLAY_COMPLETED = "EVENT_PLAY_COMPLETED";
    /**
     * 更换动作时间，每当更换动作时派发
     */
    Avatar.CHANGE_ACTION = "AvatarCHANGE_ACTION";
    /**
     * 执行 onRender 时派发
     */
    Avatar.RENDER = "AvatarRENDER";
    /**
     * 内部事件：加载过期
     */
    Avatar.LOAD_EXPIRE = "AvatarLOAD_EXPIRE";
    return Avatar;
}(GameSprite));
/**
 * 动画层
 *
 * Created by feng on 2019-02-27 14:37:26.
 */
var AnimationLayer = /** @class */ (function (_super) {
    __extends(AnimationLayer, _super);
    function AnimationLayer() {
        var _this = _super.call(this) || this;
        /**
         * 关键帧列表
         */
        _this.frames = [];
        /**
         * 是否开启关键帧插值
         */
        _this._frameinterpolationEnabled = true;
        _this._frameIndex = 0;
        _this._isOpenAutoHitArea = false;
        if (Config.EDIT_MODE) {
            _this.mouseEnabled = true;
        }
        _this.blendMode = "normal";
        return _this;
    }
    Object.defineProperty(AnimationLayer.prototype, "animation", {
        /**
         * 动画帧所属动画
         */
        get: function () {
            if (!this._animation)
                return this.parent ? this.parent.animation : null;
            return this._animation;
        },
        set: function (v) { this._animation = v; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationLayer.prototype, "isHitEffect", {
        /**
         * 是否为命中效果
         */
        get: function () { return this._isHitEffect; },
        set: function (v) {
            if (this._isHitEffect != v) {
                this._isHitEffect = v;
                this.updateFrame();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationLayer.prototype, "frameinterpolationEnabled", {
        get: function () { return this._frameinterpolationEnabled; },
        set: function (v) {
            var _this = this;
            if (this._frameinterpolationEnabled != v) {
                this._frameinterpolationEnabled = v;
                var framedata = this.frames.filter(function (v) { return v.index == _this._frameIndex; })[0];
                if (framedata)
                    framedata.frameinterpolationEnabled = v;
                this.updateFrame();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationLayer.prototype, "frameIndex", {
        /**
         * 当前显示帧
         */
        get: function () {
            return this._frameIndex;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 设置数据
     */
    AnimationLayer.prototype.setData = function (data) {
        this.name = data.name;
        this.type = data.type;
        this.frames = data.frames;
        this._isHitEffect = data.isHitEffect;
        for (var i = 0; i < data.children.length; i++) {
            var layerdata = data.children[i];
            var cls = AnimationLayer.typeClsMap[layerdata.type];
            var layer = new cls();
            layer.setData(layerdata);
            this.addChild(layer);
        }
        this.showOnEditor = !data.ishide;
        this.mouseEventEnabledInEditor = !data.islock;
    };
    /**
     * 修正动画帧材质数据
     */
    AnimationLayer.prototype.fixFramesMaterialsData = function () {
        this.frames.forEach(function (v) {
            if (!v.materialData)
                v.materialData = [{ materials: [] }];
            delete v.hue;
            delete v.blur;
            delete v.tonal_r;
            delete v.tonal_g;
            delete v.tonal_b;
            delete v.tonal_gray;
            delete v.tonal_mr;
            delete v.tonal_mg;
            delete v.tonal_mb;
        });
    };
    /**
     * 开启自动响应区域
     */
    AnimationLayer.prototype.openAutoHitArea = function (force) {
        if (force === void 0) { force = false; }
        this._openAutoHitAreaForce = force;
        this._isOpenAutoHitArea = true;
        return true;
    };
    /**
     * 关闭自动响应区域
     */
    AnimationLayer.prototype.closeAutoHitArea = function (force) {
        if (force === void 0) { force = false; }
        // 如果强制开启了，非强制无法关闭
        if (this._openAutoHitAreaForce && !force)
            return false;
        this._isOpenAutoHitArea = false;
        this._openAutoHitAreaForce = false;
        return true;
    };
    AnimationLayer.prototype.updateFrame = function () {
        this.showFrame(this._frameIndex);
    };
    /**
     * 显示指定帧
     *
     * @param frameIndex 帧索引
     */
    AnimationLayer.prototype.showFrame = function (frameIndex) {
        var _this = this;
        if (frameIndex < 0)
            return;
        //
        var preFrameIndex = this._frameIndex;
        var animationFrame = this.getFrameData(frameIndex);
        this.fromAnimationFrameData(animationFrame);
        GCAnimation.getChildrenLayers(this).forEach(function (layer) {
            layer.showFrame(frameIndex);
        });
        if (!this.animation || !this.animation.isPlaying)
            return;
        // 抛出信号
        // 计算出需要抛出的信号
        var frames = this.frames;
        var signalNames = frames.filter(function (f) { return f.signalId && ((preFrameIndex < f.index || _this._frameIndex < preFrameIndex) && f.index <= _this._frameIndex); }).map(function (v) { return v.signalId; });
        signalNames.forEach(function (signalID) {
            if (signalID > 0) {
                _this.animation.event(GCAnimation.SIGNAL, [signalID]);
            }
        });
        // 
    };
    /**
     * 设置偏移量
     */
    AnimationLayer.prototype.setOffset = function () {
        var topAnimation = this.topAnimation;
        if (topAnimation) {
            if (topAnimation.offsetX) {
                this.x += topAnimation.offsetX;
            }
            if (topAnimation.offsetY) {
                this.y += topAnimation.offsetY;
            }
        }
    };
    /**
     * 获取当前关键帧数据
     */
    AnimationLayer.prototype.getCurrentKeyFrame = function () {
        return this.getKeyFrameData(this.frameIndex);
    };
    /**
     * 获取关键帧数据
     *
     * @param frameIndex 帧索引
     */
    AnimationLayer.prototype.getKeyFrameData = function (frameIndex) {
        return this.frames.filter(function (f) { return f.index == frameIndex; })[0];
    };
    /**
     * 获取帧数据
     *
     * @param frameIndex 帧索引
     */
    AnimationLayer.prototype.getFrameData = function (frameIndex) {
        var frames = this.frames;
        var frame;
        //
        if (frames.length == 0) {
            frame = this.toAnimationFrameData();
            frame.index = frameIndex;
            return frame;
        }
        ;
        if (frameIndex < frames[0].index) {
            frame = ObjectUtils.depthClone(frames[0]);
            frame.index = frameIndex;
            return frame;
        }
        if (frameIndex > frames[frames.length - 1].index) {
            frame = ObjectUtils.depthClone(frames[frames.length - 1]);
            frame.index = frameIndex;
            return frame;
        }
        frame = frames.filter(function (v) { return v.index == frameIndex; })[0];
        if (frame)
            return frame;
        // 找到前后关键帧进行插值
        var result = frames.reduce(function (pv, cv, ci) {
            if (!pv) {
                var pf = frames[ci], nf = frames[ci + 1];
                if (pf.index < frameIndex && frameIndex < nf.index)
                    pv = { pf: pf, nf: nf };
            }
            return pv;
        }, null);
        if (!result)
            return frame;
        var interpolationEnabled = false;
        //兼容0.985
        if (result.nf.trans != null) {
            interpolationEnabled = result.nf.trans && result.nf.trans.transType != 3;
        }
        else {
            interpolationEnabled = (result.nf.frameinterpolationEnabled == null || result.nf.frameinterpolationEnabled);
        }
        //判断下一帧是否需要插值    
        if (interpolationEnabled) {
            frame = this.interpolationFrame(result.pf, result.nf, frameIndex);
        }
        else {
            //判断最后一帧
            if (frameIndex + 1 > frames[frames.length - 1].index) {
                frame = ObjectUtils.depthClone(frames[frames.length - 1]);
            }
            else {
                frame = ObjectUtils.depthClone(result.pf);
            }
            frame.index = frameIndex;
            if (result.nf.trans == null)
                frame.frameinterpolationEnabled = result.nf.frameinterpolationEnabled;
        }
        return frame;
    };
    /**
     * 移出自身
     */
    AnimationLayer.prototype.remove = function () {
        this.removeSelf();
    };
    /**
     * 是否在关键帧上
     */
    AnimationLayer.prototype.isOnKeyFrame = function () {
        var _this = this;
        var framedata = this.frames.filter(function (v) { return v.index == _this._frameIndex; })[0];
        return !!framedata;
    };
    /**
     * 保持当前帧数据
     *
     * @parame canNew 当遇到当前帧不是关键帧时是否新建关键帧；true表示会新建关键帧；默认false；
     */
    AnimationLayer.prototype.saveCurrentFrameData = function (canNew) {
        var _this = this;
        if (canNew === void 0) { canNew = false; }
        var framedata = this.frames.filter(function (v) { return v.index == _this._frameIndex; })[0];
        if (framedata) {
            this.toAnimationFrameData(framedata);
        }
        else if (canNew) {
            var newFrameData = this.toAnimationFrameData();
            this.frames.push(newFrameData);
            this.frames.sort(function (a, b) { return a.index - b.index; });
            //
            this.animation && this.animation.updateTotalFrame();
        }
    };
    /**
     * 从动画帧数据初始化
     */
    AnimationLayer.prototype.fromAnimationFrameData = function (framedata) {
        if (!framedata)
            return;
        this._frameIndex = framedata.index;
        if (framedata.trans == null) {
            if (framedata.frameinterpolationEnabled == null)
                framedata.frameinterpolationEnabled = true;
            this.frameinterpolationEnabled = framedata.frameinterpolationEnabled;
        }
    };
    /**
     * 转换动画帧数据
     */
    AnimationLayer.prototype.toAnimationFrameData = function (framedata) {
        framedata = framedata || {};
        framedata.index = this._frameIndex;
        if (framedata.trans == null) {
            framedata.frameinterpolationEnabled = this.frameinterpolationEnabled;
        }
        //有材质数据才会同步到帧数据
        if (this.materialsDataExit) {
            framedata.materialData = ObjectUtils.depthClone(this.materialData);
        }
        return framedata;
    };
    /**
     * 转换为动画层数据
     */
    AnimationLayer.prototype.toAnimationLayerData = function () {
        this.saveCurrentFrameData();
        var data = {
            type: this.type,
            name: this.name,
            children: GCAnimation.getChildrenLayers(this).map(function (v) { return v.toAnimationLayerData(); }),
            frames: this.frames,
            isHitEffect: !!this.isHitEffect,
            ishide: !this.showOnEditor,
            islock: !this.mouseEventEnabledInEditor
        };
        return data;
    };
    /**
     * 关键帧之间插值
     *
     * @param pf 上一个关键帧
     * @param nf 下一个关键帧
     * @param frameIndex 插值帧
     */
    AnimationLayer.prototype.interpolationFrame = function (pf, nf, frameIndex) {
        return { index: frameIndex, frameinterpolationEnabled: nf.frameinterpolationEnabled, trans: nf.trans, materialData: [{ materials: [] }] };
    };
    /**
     * 刷新材质插值数值
     * @param frame 当前帧
     * @param pf 上一个关键帧
     * @param nf 下一个关键帧
     * @param value 插值系数/值
     */
    AnimationLayer.prototype.refreshInterpolationFrameMaterials = function (frame, pf, nf, value) {
        //单材质组
        frame.materialData = [{ materials: [] }];
        var pfmaterials = pf.materialData[0].materials;
        var nfmaterials = nf.materialData[0].materials;
        for (var i = 0; i < pfmaterials.length; i++) {
            var pmaterial = pfmaterials[i];
            var material = {};
            var nmaterial = nfmaterials[i];
            for (var key in pmaterial) {
                if (typeof pmaterial[key] != "boolean" && typeof pmaterial[key] != "number" && typeof pmaterial[key] != "string")
                    continue;
                var pvalue = pmaterial[key];
                if (typeof pvalue != "number")
                    material[key] = pvalue;
                else
                    material[key] = (nmaterial[key] - pmaterial[key]) * value + pmaterial[key];
            }
            frame.materialData[0].materials.push(material);
        }
    };
    /**
     * 设置材质效果
     * @param materialData 当前帧材质效果数据
     */
    AnimationLayer.prototype.setFrameMaterialsEffect = function (materialData) {
        if (!this.materialData || !materialData)
            return;
        //单材质组
        var frameMaterials = materialData[0];
        if (!frameMaterials || !frameMaterials.materials)
            return;
        for (var i = 0; i < frameMaterials.materials.length; i++) {
            var frameMaterialsData = frameMaterials.materials[i];
            if (!frameMaterialsData)
                continue;
            var materialValues = {};
            for (var key in frameMaterialsData) {
                var frameMaterial = frameMaterialsData[key];
                if (typeof frameMaterial != "boolean" && typeof frameMaterial != "number" && typeof frameMaterial != "string")
                    continue;
                //材质只支持fast设置number类型的数据
                if (typeof frameMaterial == "number") {
                    materialValues["mu" + frameMaterialsData.id + "_" + key] = frameMaterial;
                }
            }
            //设置材质效果
            this.setMaterialValueFast(materialValues, i);
        }
    };
    /**
     * 刷新RGBA插值数值
     * @param frame 当前帧
     * @param pf 上一个关键帧
     * @param nf 下一个关键帧
     * @param value 插值系数/值
     * @param tween 缓动方法
     */
    AnimationLayer.prototype.refreshInterpolationFrameTonal = function (frame, pf, nf, value, tween) {
        if (!tween)
            return;
        //
        frame.hue = Math.round(tween(value, pf.hue, nf.hue - pf.hue, 1));
        frame.blur = tween(value, pf.blur, nf.blur - pf.blur, 1);
        //
        frame.tonal_r = Math.round(tween(value, pf.tonal_r, nf.tonal_r - pf.tonal_r, 1));
        frame.tonal_g = Math.round(tween(value, pf.tonal_g, nf.tonal_g - pf.tonal_g, 1));
        frame.tonal_b = Math.round(tween(value, pf.tonal_b, nf.tonal_b - pf.tonal_b, 1));
        frame.tonal_gray = Math.round(tween(value, pf.tonal_gray, nf.tonal_gray - pf.tonal_gray, 1));
        frame.tonal_mr = tween(value, pf.tonal_mr, nf.tonal_mr - pf.tonal_mr, 1);
        frame.tonal_mg = tween(value, pf.tonal_mg, nf.tonal_mg - pf.tonal_mg, 1);
        frame.tonal_mb = tween(value, pf.tonal_mb, nf.tonal_mb - pf.tonal_mb, 1);
    };
    /**
     * 检查是否需要重新绑定材质的时间过渡效果
     * @param frameData 当前帧数据
     */
    AnimationLayer.prototype.checkMaterialsTransChange = function (frameData) {
        //只有一帧关键帧不需要重新安装材质
        if (this.frames.length <= 1)
            return false;
        var currentFrameData = this.materialData;
        if (!frameData.materialData || !currentFrameData)
            return false;
        //单材质组
        var materialsA = frameData.materialData[0];
        var materialsB = currentFrameData[0];
        if (!materialsA || !materialsA.materials || !materialsB || !materialsB.materials)
            return false;
        var isChange = false;
        for (var i = 0; i < materialsA.materials.length; i++) {
            var materialA = materialsA.materials[i];
            var materialB = materialsB.materials[i];
            if (!materialA || !materialB)
                continue;
            for (var key in materialA) {
                var frameMaterial = materialA[key];
                if (typeof frameMaterial != "boolean" && typeof frameMaterial != "number" && typeof frameMaterial != "string")
                    continue;
                if (!isChange && typeof frameMaterial != "number" && frameMaterial != materialB[key]) {
                    isChange = true;
                }
                //帧参数同步到图层
                materialB[key] = frameMaterial;
            }
        }
        return isChange;
    };
    AnimationLayer.typeClsMap = {};
    return AnimationLayer;
}(GameSprite));
/**
 * Created by 黑暗之神KDS on 2018-10-12 14:31:34.
 */
var UIComponent;
(function (UIComponent) {
    var UIBase = /** @class */ (function (_super) {
        __extends(UIBase, _super);
        /**
         * 构造函数
         */
        function UIBase() {
            var _this = _super.call(this) || this;
            /**
             * 条件
             */
            _this.condition = [];
            /**
             * 是否存在事件
             */
            _this.hasCommand = [];
            /**
             * 树节点打开状态
             */
            _this.isOpen = true;
            /**
             * 材质属性
             */
            _this.materialData = [{ materials: [] }];
            /**
             * 需要加载:用于控件是否需要加载资源用
             */
            _this._needLoad = true;
            /**
             * 【编辑器专用】是否允许修改宽高
             */
            _this.modifyWidthHeightEnabled = true;
            /**
             * 【编辑器专用】对应鼠标响应
             */
            _this.mouseEventEnabledData = true;
            _this.id = ObjectUtils.getRandID();
            _this.className = "UIBase";
            _this.mouseEventEnabled = true;
            if (!Config.EDIT_MODE) {
                _this.add_DISPLAY(_this.initCondition, _this, [true]);
                _this.add_UNDISPLAY(_this.initCondition, _this, [false]);
            }
            return _this;
        }
        /**
         * 引用图像记录
         */
        UIBase.prototype.refImageRecord = function (index, imageURL) {
            // 如果存在旧的已占用的图片资源，则减少引用
            if (this.___currentRequestLoadImages && this.___currentRequestLoadImages[index]) {
                AssetManager.disposeImage(this.___currentRequestLoadImages[index]);
            }
            if (!this.___currentRequestLoadImages)
                this.___currentRequestLoadImages = [];
            this.___currentRequestLoadImages[index] = imageURL;
        };
        /**
         * 释放
         * @param disposeChild [可选] 默认值=false 释放子节点
         */
        UIBase.prototype.dispose = function () {
            if (!this.isDisposed) {
                // 获取全组件节点，然后容器仅释放自身界面
                var uiArr = this.getAllUIChildren();
                for (var s in uiArr) {
                    var ui = uiArr[s];
                    ui.dispose();
                }
                //移除条件侦听
                this.initCondition(false);
            }
            _super.prototype.dispose.call(this);
        };
        //------------------------------------------------------------------------------------------------------
        // 
        //------------------------------------------------------------------------------------------------------
        /**
         * 构造初始化（即已设置属性完毕）
         * @param uiID
         * @param syncLoadedEventWhenAssetExist [可选] 默认值=false 当资源存在时同步派发加载完成事件，否则需要等待一帧（异步派发）
         */
        UIBase.prototype.constructorInit = function (uiID, syncLoadedEventWhenAssetExist) {
            if (syncLoadedEventWhenAssetExist === void 0) { syncLoadedEventWhenAssetExist = false; }
            this._syncLoadedEventWhenAssetExist = syncLoadedEventWhenAssetExist;
            this._commondID = uiID + "_" + this.id;
            // 初始化命令
            if (!Config.EDIT_MODE) {
                if (this.guiRoot && !this.guiRoot.onlyForPreload) {
                    EventUtils.happen(UIBase, UIBase.EVENT_COMPONENT_CONSTRUCTOR_INIT, [this]);
                }
            }
            // 设置材质
            this.installMaterialData(this.materialData);
        };
        /**
         * 开始检测加载完毕的情形
         */
        UIBase.prototype.loadAssetTest = function () {
        };
        /**
         * 初始化条件
         * @param isListen 是否监听
         */
        UIBase.prototype.initCondition = function (isListen) {
            if (!Game.player) {
                return;
            }
            if (this.condition.length != 0) {
                if (!this.onConditionCheckCB)
                    this.onConditionCheckCB = new Callback(this.onConditionCheck, this);
                for (var i = 0; i < this.condition.length; i++) {
                    var condition = this.condition[i];
                    if (condition.type <= 1) {
                        var type = condition.type == 0 ? 1 : 0;
                        if (isListen) {
                            Game.player.addListenerPlayerVariable(type, condition.varID, this.onConditionCheckCB);
                        }
                        else
                            Game.player.removeListenerPlayerVariable(type, condition.varID, this.onConditionCheckCB);
                    }
                    else if (condition.type == 3) {
                        if (isListen) {
                            ClientWorld.addListenerVariable(0, condition.varID, this.onConditionCheckCB);
                        }
                        else
                            ClientWorld.removeListenerVariable(0, condition.varID, this.onConditionCheckCB);
                    }
                    else if (condition.type == 4) {
                        if (isListen) {
                            ClientWorld.addListenerVariable(1, condition.varID, this.onConditionCheckCB);
                        }
                        else
                            ClientWorld.removeListenerVariable(1, condition.varID, this.onConditionCheckCB);
                    }
                }
                // 如果需要监听且第一次条件检查用的计数为空的话
                if (isListen && this.firstConditionCheckCount == null) {
                    this.firstConditionCheckCount = this.condition.length;
                }
                this.onConditionCheck();
            }
        };
        /**
         * 当条件之一改变时触发
         */
        UIBase.prototype.onConditionCheck = function () {
            if (!Game.player)
                return;
            var lastVisible = this.visible;
            var visible = true;
            for (var i = 0; i < this.condition.length; i++) {
                var condition = this.condition[i];
                var bool = true;
                // 网络版无全局变量的条件
                if (typeof SinglePlayerGame == "undefined" && condition.type >= 3)
                    continue;
                if (condition.type == 0) {
                    bool = Game.player.variable.getSwitch(condition.varID) == condition.value;
                }
                else if (condition.type == 4) {
                    bool = ClientWorld.getWorldSwitch(condition.varID) == condition.value;
                }
                else {
                    var varValue = condition.type == 1 ? Game.player.variable.getVariable(condition.varID) : ClientWorld.getWorldVariable(condition.varID);
                    // 网络版无全局变量的条件
                    if ((condition.compare == 0 && varValue !== condition.value) ||
                        (condition.compare == 1 && varValue < condition.value) ||
                        (condition.compare == 2 && varValue <= condition.value) ||
                        (condition.compare == 3 && varValue > condition.value) ||
                        (condition.compare == 4 && varValue >= condition.value) ||
                        (condition.compare == 5 && varValue === condition.value)) {
                        bool = false;
                    }
                }
                if (!bool) {
                    visible = false;
                    break;
                }
            }
            if (this.firstConditionCheckCount > 0) {
                this.firstConditionCheckCount--;
            }
            if (this.firstConditionCheckCount == 0 || Config.SINGLE_PLAYER_CORE) {
                this.visible = visible;
            }
        };
        //------------------------------------------------------------------------------------------------------
        // 
        //------------------------------------------------------------------------------------------------------
        /**
         * 编辑器专用初始化
         */
        UIBase.prototype.inEditorInit = function () {
        };
        /**
         * 编辑器专用信息说明
         */
        UIBase.prototype.inEditorInfo = function () {
            return "";
        };
        /**
         * 编辑器专用：是否处于当前层或其子层
         * @param isInCurrentLayer
         */
        UIBase.prototype.inEditorCurrentOperactionLayer = function (isInCurrentLayer) {
            this._isInCurrentLayer = isInCurrentLayer;
        };
        UIBase.prototype.inEditorDatabase = function () {
        };
        /**
         * 获取全部子UI对象（仅限于UI组件，不含自身）
         * 筛选是UIBase且_needLoad=true
         * @return [UIComponent]
         */
        UIBase.prototype.getAllUIChildren = function () {
            var allChildren = this["_childs"];
            var uiArr = [];
            for (var i = 0; i < allChildren.length; i++) {
                var ui = allChildren[i];
                if (ui instanceof UIComponent.UIBase && ui["_needLoad"]) {
                    uiArr.push(ui);
                }
            }
            return uiArr;
        };
        /**
         * 事件：组件构造初始化事件
         */
        UIBase.EVENT_COMPONENT_CONSTRUCTOR_INIT = "UIBase_EVENT_COMPONENT_CONSTRUCTOR_INIT";
        /**
         * 事件：由于出现条件导致的出现或消失（visible变更）
         */
        UIBase.ON_VISIBLE_CHANGE = "UIBaseVisible";
        /**
         * 基础属性罗列
         */
        UIBase.BASE_ATTRS = ["x", "y", "width", "height", "rotation", "show", "opacity", "mouseEventEnabledData"];
        /**
         * 基础属性罗列-object版
         */
        UIBase.BASE_ATTRS_OBJ = { x: true, y: true, width: true, height: true, rotation: true, show: true, opacity: true, mouseEventEnabledData: true };
        /**
         * 系统保留词（部分）
         */
        UIBase.systemReservationWords = ["id", "name", "guiRoot", "onConditionCheckCB", "firstConditionCheckCount", "_isInCurrentLayer", "_syncLoadedEventWhenAssetExist", "data", "_commondID", "__forceChange",
            "isDisposed", "_tonalFilter", "_lastGameFilters", "_finalFilters", "_tips", "tips", "mouseThrough", "autoSize", "viewport", "cacheAs", "cacheAsBitmap", "graphics", "scrollRect", "mask", "parent",
            "texture", "x", "y", "_x", "_y", "left", "right", "top", "bottom"];
        return UIBase;
    }(GameSprite));
    UIComponent.UIBase = UIBase;
})(UIComponent || (UIComponent = {}));
//------------------------------------------------------------------------------------------------------
//  重写UIBase属性
//------------------------------------------------------------------------------------------------------
// visible
getset(false, UIComponent.UIBase.prototype, 'visible', function () {
    return this._style.visible;
}, function (value) {
    if (this._style && this._style.visible !== value) {
        this.getStyle().visible = value;
        this.conchModel && this.conchModel.visible(value);
        this.parentRepaint();
        this.event(UIComponent.UIBase.ON_VISIBLE_CHANGE);
    }
});
/**
 * 没有刷新addChild滚动条，在某些情况下新加入的子对象比滚动条高层
 *
 * Created by 黑暗之神KDS on 2018-10-12 16:31:59.
 */
var UIComponent;
(function (UIComponent) {
    var UIRoot = /** @class */ (function (_super) {
        __extends(UIRoot, _super);
        function UIRoot(isRoot, guiID) {
            if (isRoot === void 0) { isRoot = false; }
            if (guiID === void 0) { guiID = null; }
            var _this = _super.call(this) || this;
            _this._myScrollRect = new Rectangle(0, 0, 0, 0);
            _this._scrollShowType = 2;
            _this._scrollWidth = 16;
            //------------------------------------------------------------------------------------------------------
            // 缓动(拖动效果)
            //------------------------------------------------------------------------------------------------------
            _this._slowmotionType = 0; //缓动类型 0-开启移动端拖动效果 1-开启拖动效果 2-关闭拖动效果
            _this._rollRatio = 0.95; //滚动衰减系数
            _this.guiID = guiID;
            _this._isRoot = isRoot;
            _this.className = "UIRoot";
            _this._vScrollBar = new VScrollBar(); //纵向
            _this._hScrollBar = new HScrollBar(); //横向
            _this._vScrollBar.showButtons = false;
            _this._hScrollBar.showButtons = false;
            if (Config.EDIT_MODE) {
                _this.width = _this._contentWidth = 100;
                _this.height = _this._contentHeight = 100;
            }
            _this._vScrollBar.max = 100;
            _this._vScrollBar.min = 0;
            _this._hScrollBar.max = 100;
            _this._hScrollBar.min = 0;
            _this._vScrollValue = 0;
            _this._hScrollValue = 0;
            _this._enabledWheel = true;
            _this.on(EventObject.MOUSE_WHEEL, _this, _this.onMouseWheel);
            _this.on(EventObject.RESIZE, _this, _this.onResize);
            _this._vScrollBar.add_CHANGE(_this.onScrollBarChange, _this, [1]);
            _this._hScrollBar.add_CHANGE(_this.onScrollBarChange, _this, [2]);
            if (Config.EDIT_MODE) {
                _this._vScrollBar.mouseEnabled = _this._hScrollBar.mouseEnabled = false;
            }
            _this._mask = new Sprite();
            _this._mask.pos(0, 0);
            _this._mask.mouseEnabled = true;
            _this.onResize();
            return _this;
        }
        /**
         * 编辑器专用初始化
         */
        UIRoot.prototype.inEditorInit = function () {
            this._vScroollBarImage1 = "asset/image/picture/control/vscroll_bg.png";
            this._vScroollBarImage2 = "asset/image/picture/control/vscroll_bar.png";
            this._hScroollBarImage1 = "asset/image/picture/control/hscroll_bg.png";
            this._hScroollBarImage2 = "asset/image/picture/control/hscroll_bar.png";
        };
        /**
         * 编辑器专用：
         * @param isInCurrentLayer
         */
        UIRoot.prototype.inEditorCurrentOperactionLayer = function (isInCurrentLayer) {
            _super.prototype.inEditorCurrentOperactionLayer.call(this, isInCurrentLayer);
            this.enabledLimitView = this.enabledLimitView;
        };
        Object.defineProperty(UIRoot.prototype, "enabledLimitView", {
            get: function () {
                return this._enabledLimitView;
            },
            /**
             * 是否限制区域内显示
             */
            set: function (v) {
                if (this.destroyed)
                    return;
                this._enabledLimitView = v;
                this.scrollRect = (v && (!Config.EDIT_MODE || (Config.EDIT_MODE && !this._isInCurrentLayer))) ? this._myScrollRect : null;
                if (v) {
                    this.addChild(this._vScrollBar);
                    this.addChild(this._hScrollBar);
                    this.refresh();
                }
                else {
                    this.removeChild(this._vScrollBar);
                    this.removeChild(this._hScrollBar);
                }
                this.refreshSlowmotion();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIRoot.prototype, "enabledWheel", {
            get: function () {
                return this._enabledWheel;
            },
            set: function (v) {
                this._enabledWheel = v;
                if (this._enabledWheel) {
                    this.on(EventObject.MOUSE_WHEEL, this, this.onMouseWheel);
                }
                else {
                    this.off(EventObject.MOUSE_WHEEL, this, this.onMouseWheel);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIRoot.prototype, "scrollShowType", {
            get: function () {
                return this._scrollShowType;
            },
            /**
            * 滚动条显示模式 0-不显示 1-显示 2-自动显示 3-仅显示竖滚动条 4-仅显示横滚动条
            */
            set: function (v) {
                v = Math.floor(v);
                this._scrollShowType = v;
                this.refresh();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIRoot.prototype, "scrollWidth", {
            get: function () {
                return this._scrollWidth;
            },
            /**
             * 设置滚动条宽度
             */
            set: function (v) {
                if (this.isDisposed)
                    return;
                this._scrollWidth = v;
                this.vScrollBar = this.vScrollBar;
                this.hScrollBar = this.hScrollBar;
                this.vScrollBg = this.vScrollBg;
                this.hScrollBg = this.hScrollBg;
                this.refreshScrollPos();
                this.onResize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIRoot.prototype, "vScrollBg", {
            get: function () {
                return this._vScroollBarImage1;
            },
            /**
            * 垂直滚动条皮肤设置
            */
            set: function (v) {
                if (this.isDisposed)
                    return;
                // 如果存在旧的已占用的图片资源，则减少引用
                this.refImageRecord(0, v);
                AssetManager.loadImage(v);
                this._vScroollBarImage1 = v;
                this._vScrollBar.slider["_bg"].skin = v;
                this._vScrollBar.slider["_bg"].width = this._scrollWidth;
                this._vScrollBar.slider["setBarPoint"]();
                this._vScrollBar.slider["callLater"](this._vScrollBar.slider["changeValue"]);
                this.refreshScrollPos();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIRoot.prototype, "vScrollBar", {
            get: function () {
                return this._vScroollBarImage2;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                // 如果存在旧的已占用的图片资源，则减少引用
                this.refImageRecord(1, v);
                this._vScroollBarImage2 = v;
                AssetManager.loadImage(v, Callback.New(this.setVScrollBarSkin, this, [v]), true);
            },
            enumerable: false,
            configurable: true
        });
        UIRoot.prototype.setVScrollBarSkin = function (v) {
            if (this.isDisposed)
                return;
            if (!this._vScrollBar.slider)
                return;
            // 过期的设置则忽略掉
            if (v != this._vScroollBarImage2)
                return;
            this._vScrollBar.slider.bar.skin = v;
            this._vScrollBar.slider.bar.width = this._scrollWidth;
            this._vScrollBar.slider["setBarPoint"]();
            this._vScrollBar.slider["callLater"](this._vScrollBar.slider["changeValue"]);
            this.refreshScrollPos();
            this.onResize();
        };
        Object.defineProperty(UIRoot.prototype, "hScrollBg", {
            get: function () {
                return this._hScroollBarImage1;
            },
            /**
             * 横向滚动条皮肤设置
             */
            set: function (v) {
                if (this.isDisposed)
                    return;
                // 如果存在旧的已占用的图片资源，则减少引用
                this.refImageRecord(2, v);
                AssetManager.loadImage(v);
                this._hScroollBarImage1 = v;
                this._hScrollBar.slider["_bg"].skin = v;
                this._hScrollBar.slider["_bg"].height = this._scrollWidth;
                this._hScrollBar.slider["setBarPoint"]();
                this._hScrollBar.slider["callLater"](this._hScrollBar.slider["changeValue"]);
                this.refreshScrollPos();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIRoot.prototype, "hScrollBar", {
            get: function () {
                return this._hScroollBarImage2;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                // 如果存在旧的已占用的图片资源，则减少引用
                this.refImageRecord(3, v);
                this._hScroollBarImage2 = v;
                AssetManager.loadImage(v, Callback.New(this.setHScrollBarSkin, this, [v]), true);
            },
            enumerable: false,
            configurable: true
        });
        UIRoot.prototype.setHScrollBarSkin = function (v) {
            if (this.isDisposed)
                return;
            if (!this._hScrollBar.slider)
                return;
            // 过期的设置则忽略掉
            if (v != this._hScroollBarImage2)
                return;
            this._hScrollBar.slider.bar.skin = v;
            this._hScrollBar.slider.bar.height = this._scrollWidth;
            this._hScrollBar.slider["setBarPoint"]();
            this._hScrollBar.slider["callLater"](this._hScrollBar.slider["changeValue"]);
            this.refreshScrollPos();
            this.onResize();
        };
        /**
         * 计算宽高
         */
        UIRoot.prototype.calcTotalContentSize = function () {
            var maxH = 0, maxW = 0;
            for (var i = this.numChildren - 1; i > -1; i--) {
                var comp = this.getChildAt(i);
                if (comp == this._vScrollBar || comp == this._hScrollBar)
                    continue;
                var compRect = comp.getBounds();
                if (compRect.isEmpty()) {
                    compRect = new Rectangle(comp.x, comp.y, comp.width ? comp.width : 0, comp.height ? comp.height : 0);
                }
                if (comp.width != 0) {
                    compRect.width = comp.width;
                }
                if (comp.height != 0) {
                    compRect.height = comp.height;
                }
                maxH = Math.max(compRect.bottom, maxH, 1); //Math.max(comp.y + comp.height * comp.scaleY, maxH, 1);
                maxW = Math.max(compRect.right, maxW, 1); //Math.max(comp.x + comp.width * comp.scaleX, maxW, 1);
            }
            return { maxW: maxW, maxH: maxH };
        };
        /**
         * 刷新滚动条根据内容区域大小
         */
        UIRoot.prototype.refresh = function () {
            if (this.isDisposed || this.destroyed)
                return;
            if (this._enabledLimitView) {
                var c = this.calcTotalContentSize();
                this._mask.size(c.maxW, c.maxH);
                var maxH = c.maxH, maxW = c.maxW;
                if (this.scrollShowType == 0) {
                    this._vScrollBar.visible = this._hScrollBar.visible = false;
                }
                else if (this.scrollShowType == 1) {
                    this._vScrollBar.visible = this._hScrollBar.visible = true;
                    maxH += this._scrollWidth;
                    maxW += this._scrollWidth;
                }
                else if (this.scrollShowType == 2) {
                    this._vScrollBar.visible = (this.height / maxH) < 1;
                    this._hScrollBar.visible = (this.width / maxW) < 1;
                    if (this._vScrollBar.visible && (this.vScrollBar || this.vScrollBg))
                        maxW += this._scrollWidth;
                    if (this._hScrollBar.visible && (this.hScrollBar || this.hScrollBg))
                        maxH += this._scrollWidth;
                }
                else if (this.scrollShowType == 3) {
                    this._vScrollBar.visible = true;
                    this._hScrollBar.visible = false;
                    maxW += this._scrollWidth;
                }
                else if (this.scrollShowType == 4) {
                    this._vScrollBar.visible = false;
                    this._hScrollBar.visible = true;
                    maxH += this._scrollWidth;
                }
                this._vScrollBar.thumbPercent = maxH == 0 ? 1 : Math.min(this.height / maxH, 1);
                this._hScrollBar.thumbPercent = maxW == 0 ? 1 : Math.min(this.width / maxW, 1);
                this._hScrollBar.disabled = this.width >= maxW;
                this._vScrollBar.disabled = this.height >= maxH;
                //容器宽高
                var lastContentW = this._contentWidth;
                var lastContentH = this._contentHeight;
                this._contentWidth = maxW;
                this._contentHeight = maxH;
                if (this._vScrollBar.disabled) {
                    this._vScrollBar.value = 0;
                }
                else {
                    var perV = (lastContentH - this.height) / (this._contentHeight - this.height);
                    this._vScrollBar.value *= perV;
                }
                if (this._hScrollBar.disabled) {
                    this._hScrollBar.value = 0;
                }
                else {
                    var perH = (lastContentW - this.width) / (this._contentWidth - this.width);
                    this._hScrollBar.value *= perH;
                }
            }
            this._myScrollRect.width = this.width;
            this._myScrollRect.height = this.height;
            this._vScrollBar.height = this.height;
            this._hScrollBar.width = this.width - (this._vScrollBar.displayedInStage && this._vScrollBar.visible ? this._vScrollBar.width : 0);
            if (!this._vScrollBar.visible)
                this._myScrollRect.y = 0;
            if (!this._hScrollBar.visible)
                this._myScrollRect.x = 0;
        };
        /**
         * 刷新滚动条位置
         */
        UIRoot.prototype.refreshScrollPos = function () {
            this._vScrollBar.x = this.width - this._vScrollBar.width + this._myScrollRect.x;
            this._vScrollBar.y = this._myScrollRect.y;
            this._hScrollBar.y = this.height - this._hScrollBar.height + this._myScrollRect.y;
            this._hScrollBar.x = this._myScrollRect.x;
        };
        /**
         * 当重置尺寸时
         */
        UIRoot.prototype.onResize = function () {
            if (this.isDisposed)
                return;
            this.refresh();
            this.refreshScrollPos();
            this.enabledLimitView = this.enabledLimitView;
        };
        /**
         * 当滚轮时
         * @param e
         */
        UIRoot.prototype.onMouseWheel = function (e) {
            if (this.isDisposed)
                return;
            // 编辑器环境或没有限制时不滚动
            if (Config.EDIT_MODE || !this._enabledLimitView)
                return;
            if (!this._contentHeight || !this._contentWidth)
                return;
            var float = e.delta < 0 ? -1 : 1;
            var vScrollEnabled = this.scrollShowType != 0 && this.scrollShowType != 4 && this._vScrollBar.visible && !this._vScrollBar.disabled;
            var hScrollEnabled = this.scrollShowType != 0 && this.scrollShowType != 3 && this._hScrollBar.visible && !this._hScrollBar.disabled;
            if (!vScrollEnabled && !hScrollEnabled)
                return;
            if (vScrollEnabled) {
                if (!hScrollEnabled || !ClientMain.shiftKey) {
                    if (this._contentHeight - this.scrollWidth <= this.height)
                        return;
                    var px = Math.max(this._contentHeight * 0.01 * Math.abs(e.delta), 20);
                    var per = Math.max(px * 100 / this._contentHeight, 1);
                    this._vScrollBar.value -= per * float;
                }
            }
            if (hScrollEnabled) {
                if (!vScrollEnabled || ClientMain.shiftKey) {
                    //垂直滚动条无法滚动或者按住shift键
                    if (this._contentWidth - this.scrollWidth <= this.width)
                        return;
                    var px = Math.max(this._contentWidth * 0.01 * Math.abs(e.delta), 20);
                    var per = Math.max(px * 100 / this._contentWidth, 1);
                    this._hScrollBar.value -= per * float;
                }
            }
        };
        /**
         * 当滚轮更改时
         * @param mode
         */
        UIRoot.prototype.onScrollBarChange = function (mode) {
            // if (Config.EDIT_MODE) return;
            if (!this._vScrollBar.disabled) {
                this._myScrollRect.y = MathUtils.float(this._vScrollBar.value / 100 * (this._contentHeight - this.height));
            }
            if (!this._hScrollBar.disabled) {
                this._myScrollRect.x = MathUtils.float(this._hScrollBar.value / 100 * (this._contentWidth - this.width));
            }
            this.refreshScrollPos();
            //修正当前滚动值
            if (!Config.EDIT_MODE && this._initComplete) { //编辑器模式下不需要修正滚动值  
                if (mode == 1) {
                    this._vScrollValue = this._vScrollBar.value;
                }
                else if (mode == 2) {
                    this._hScrollValue = this._hScrollBar.value;
                }
            }
        };
        Object.defineProperty(UIRoot.prototype, "vScrollValue", {
            get: function () {
                return this._vScrollValue;
            },
            /**
             * 设置垂直方向滚动值
             * @param value 值(0~100)
             */
            set: function (value) {
                this._vScrollValue = Math.min(Math.max(this._vScrollBar.min, value), this._vScrollBar.max);
                // 编辑器环境或没有限制时不滚动
                if (!this._enabledLimitView)
                    return;
                if (!this._contentHeight || !this._contentWidth)
                    return;
                var vScrollEnabled = this.scrollShowType != 0 && this.scrollShowType != 4 && this._vScrollBar.visible && !this._vScrollBar.disabled;
                if (!vScrollEnabled)
                    return;
                this._vScrollBar.value = this._vScrollValue;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIRoot.prototype, "hScrollValue", {
            get: function () {
                return this._hScrollValue;
            },
            /**
             * 设置水平方向滚动值
             * @param value 值(0~100)
             */
            set: function (value) {
                this._hScrollValue = Math.min(Math.max(this._hScrollBar.min, value), this._hScrollBar.max);
                // 编辑器环境或没有限制时不滚动 
                if (!this._enabledLimitView)
                    return;
                if (!this._contentHeight || !this._contentWidth)
                    return;
                var hScrollEnabled = this.scrollShowType != 0 && this.scrollShowType != 3 && this._hScrollBar.visible && !this._hScrollBar.disabled;
                if (!hScrollEnabled)
                    return;
                this._hScrollBar.value = this._hScrollValue;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIRoot.prototype, "slowmotionType", {
            get: function () {
                return this._slowmotionType;
            },
            set: function (v) {
                this._slowmotionType = v;
                this.refreshSlowmotion();
            },
            enumerable: false,
            configurable: true
        });
        /**
         * 刷新缓动
         */
        UIRoot.prototype.refreshSlowmotion = function () {
            this.off(EventObject.MOUSE_DOWN, this, this.onMouseDown);
            if (this._enabledLimitView && ((this._slowmotionType == 0 && Browser.onMobile) || this._slowmotionType == 1))
                this.on(EventObject.MOUSE_DOWN, this, this.onMouseDown);
        };
        UIRoot.prototype.onMouseDown = function (e) {
            if (this.checkMouseDown(e.target))
                return;
            this._lastPoint || (this._lastPoint = new Point());
            this._lastPoint.setTo(stage.mouseX, stage.mouseY);
            this._lastValuePoint || (this._lastValuePoint = new Point());
            this._lastValuePoint.setTo(this._hScrollBar.value, this._vScrollBar.value);
            this._offsetXList = [];
            this._offsetYList = [];
            this._offsetPoint = new Point();
            timer.clear(this, this.tweenMoveX);
            timer.clear(this, this.tweenMoveY);
            stage.on(EventObject.MOUSE_UP, this, this.onStageMouseUp);
            stage.on(EventObject.MOUSE_OUT, this, this.onStageMouseUp);
            stage.on(EventObject.MOUSE_MOVE, this, this.onStageMouseMove);
        };
        UIRoot.prototype.checkMouseDown = function (disp) {
            var bool = false;
            if (disp == this._hScrollBar || disp == this._vScrollBar)
                bool = true;
            var parent = disp.parent;
            while (parent && parent != this) {
                if (parent == this._hScrollBar || parent == this._vScrollBar) {
                    bool = true;
                    break;
                }
                parent = parent.parent;
            }
            return bool;
        };
        UIRoot.prototype.onStageMouseMove = function () {
            var posX = stage.mouseX - this._lastPoint.x;
            var posY = stage.mouseY - this._lastPoint.y;
            if (posX == 0 && posY == 0)
                return;
            if (this._mask.parent == null && (Math.abs(posX) > 5 || Math.abs(posY) > 5))
                this.addChild(this._mask);
            var _x = MathUtils.float(posX * 100) / (this._contentWidth - this.width);
            var _y = MathUtils.float((posY * 100) / (this._contentHeight - this.height));
            var lastOffsetX = this._hScrollBar.value - this._lastValuePoint.x + _x;
            this._offsetXList.push(lastOffsetX);
            var lastOffsetY = this._vScrollBar.value - this._lastValuePoint.y + _y;
            this._offsetYList.push(lastOffsetY);
            (!this._hScrollBar.disabled) && (this._hScrollBar.value = this._lastValuePoint.x - _x);
            (!this._vScrollBar.disabled) && (this._vScrollBar.value = this._lastValuePoint.y - _y);
        };
        UIRoot.prototype.onStageMouseUp = function () {
            stage.off(EventObject.MOUSE_UP, this, this.onStageMouseUp);
            stage.off(EventObject.MOUSE_OUT, this, this.onStageMouseUp);
            stage.off(EventObject.MOUSE_MOVE, this, this.onStageMouseMove);
            this.removeChild(this._mask);
            //计算缓动距离
            if (!this._hScrollBar.disabled) {
                var offsetX = 0;
                var m = Math.min(this._offsetXList.length, 3);
                for (var i = 0; i < m; i++) {
                    offsetX += this._offsetXList[this._offsetXList.length - 1 - i];
                }
                this._offsetPoint.x = m > 0 ? offsetX / m : 0;
                if (Math.abs(this._offsetPoint.x) > 2) {
                    timer.frameLoop(1, this, this.tweenMoveX);
                }
            }
            if (!this._vScrollBar.disabled) {
                var offsetY = 0;
                var n = Math.min(this._offsetYList.length, 3);
                for (var i = 0; i < n; i++) {
                    offsetY += this._offsetYList[this._offsetYList.length - 1 - i];
                }
                this._offsetPoint.y = n > 0 ? offsetY / n : 0;
                if (Math.abs(this._offsetPoint.y) > 2) {
                    timer.frameLoop(1, this, this.tweenMoveY);
                }
            }
        };
        UIRoot.prototype.tweenMoveX = function () {
            this._offsetPoint.x *= this._rollRatio;
            if (Math.abs(this._offsetPoint.x) < 0.5) {
                timer.clear(this, this.tweenMoveX);
                return;
            }
            if (this._offsetPoint.x > 2)
                this._offsetPoint.x = 2;
            if (this._offsetPoint.x < -2)
                this._offsetPoint.x = -2;
            this._hScrollBar.value -= this._offsetPoint.x;
        };
        UIRoot.prototype.tweenMoveY = function () {
            this._offsetPoint.y *= this._rollRatio;
            if (Math.abs(this._offsetPoint.y) < 0.5) {
                timer.clear(this, this.tweenMoveY);
                return;
            }
            if (this._offsetPoint.y > 2)
                this._offsetPoint.y = 2;
            if (this._offsetPoint.y < -2)
                this._offsetPoint.y = -2;
            this._vScrollBar.value -= this._offsetPoint.y;
        };
        //------------------------------------------------------------------------------------------------------
        // 重写方法
        //------------------------------------------------------------------------------------------------------
        UIRoot.prototype.addChild = function (node) {
            var node = _super.prototype.addChild.call(this, node);
            if (node != this._mask)
                this.refreshAddchild();
            return node;
        };
        ;
        UIRoot.prototype.addChildren = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            _super.prototype.addChildren.apply(this, args);
            this.refreshAddchild();
        };
        ;
        UIRoot.prototype.addChildAt = function (node, index) {
            var node = _super.prototype.addChildAt.call(this, node, index);
            this.refreshAddchild();
            return node;
        };
        ;
        UIRoot.prototype.refreshAddchild = function () {
            if (this._enabledLimitView) {
                _super.prototype.addChild.call(this, this._vScrollBar);
                _super.prototype.addChild.call(this, this._hScrollBar);
            }
            Callback.CallLaterBeforeRender(this.doRefreshAddchild, this);
        };
        UIRoot.prototype.doRefreshAddchild = function () {
            this.refresh();
            if (!this._initComplete) {
                this._initComplete = true;
                // 编辑器环境或没有限制时不滚动 
                if (!this._enabledLimitView)
                    return;
                if (!this._contentHeight || !this._contentWidth)
                    return;
                var vScrollEnabled = this.scrollShowType != 0 && this.scrollShowType != 4 && this._vScrollBar.visible && !this._vScrollBar.disabled;
                if (vScrollEnabled)
                    this._vScrollBar.value = this._vScrollValue;
                var hScrollEnabled = this.scrollShowType != 0 && this.scrollShowType != 3 && this._hScrollBar.visible && !this._hScrollBar.disabled;
                if (hScrollEnabled)
                    this._hScrollBar.value = this._hScrollValue;
            }
        };
        //------------------------------------------------------------------------------------------------------
        // 
        //------------------------------------------------------------------------------------------------------
        /**
         * 构造初始化（即已设置属性完毕）
         * @param uiID
         * @param syncLoadedEventWhenAssetExist [可选] 默认值=false 当资源存在时同步派发加载完成事件，否则需要等待一帧（异步派发）
         */
        UIRoot.prototype.constructorInit = function (uiID, syncLoadedEventWhenAssetExist) {
            if (syncLoadedEventWhenAssetExist === void 0) { syncLoadedEventWhenAssetExist = false; }
            _super.prototype.constructorInit.apply(this, arguments);
            // 检测加载完毕
            // if (!Config.EDIT_MODE) 
            this.loadAssetTest();
        };
        /**
         * 开始检测加载完毕的情形:用于整个预先制作好的界面的加载完成通知 EventObject.LOADED
         * @param checkAllChildren [可选] 默认值=false 加载全部子对象
         */
        UIRoot.prototype.loadAssetTest = function (checkAllChildren) {
            if (checkAllChildren === void 0) { checkAllChildren = false; }
            // 根容器的情况：等待全部子UI加载完毕后抛出EventObject.LOADED事件
            if (this._isRoot || checkAllChildren) {
                var uiRoots = [];
                // @ts-ignore
                function onLoadedCheck(ui) {
                    count--;
                    // trace(count, "*************ui加载完毕", ui.name, ui.className);
                    if (count <= 0) { //空容器也要返回加载完成回调
                        // trace("*************all over");
                        setTimeout(function (uiRoots) {
                            // Callback.CallLater
                            for (var i in uiRoots) {
                                var ro = uiRoots[i];
                                if (ro.stage) {
                                    ro.refresh();
                                }
                            }
                        }, 0, uiRoots);
                        if (this["prerender"]) {
                            AssetManager.prerender(this);
                        }
                        this.event(EventObject.LOADED);
                    }
                }
                uiRoots.push(this);
                //子对象
                var uiArr = this.getAllUIChildren();
                //所有的加载总数(包含自身)
                var count = uiArr.length + 1;
                //自身
                this.once(GameUI.EVENT_TEST_LOAD_CHILD_UI, this, onLoadedCheck, [this]);
                this.loadSelfAssetTest();
                // trace("@@@@@@@@@总加载开始==", this._isRoot, checkAllChildren, this.guiID + "-" + this.name, this.id);
                for (var s in uiArr) {
                    var ui = uiArr[s];
                    ui.once(GameUI.EVENT_TEST_LOAD_CHILD_UI, this, onLoadedCheck, [ui]);
                    if (ui.className == "UIRoot") {
                        ui.loadSelfAssetTest();
                        uiRoots.push(ui);
                    }
                    else {
                        ui["loadAssetTest"]();
                    }
                }
            }
        };
        /**
         * 加载自身资源
         */
        UIRoot.prototype.loadSelfAssetTest = function () {
            if (this.isDisposed)
                return;
            // 记录当前请求加载的自身需要的资源图集
            var mySkins = [this._vScroollBarImage1, this._vScroollBarImage2, this._hScroollBarImage1, this._hScroollBarImage2];
            // 预加载自身的皮肤图集，不引用，仅用于加载回调
            AssetManager.loadImages(mySkins, Callback.New(function () {
                this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, false);
        };
        /**
         * 释放自身资源
         */
        UIRoot.prototype.disposeSelfAsset = function () {
            if (!this.___currentRequestLoadImages)
                return;
            AssetManager.disposeImages(this.___currentRequestLoadImages);
        };
        /**
         * 释放该界面下面所有的元件以及相应的资源
         */
        UIRoot.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (this.guiID) {
                    var uiRoot = GameUI.get(this.guiID);
                    if (uiRoot == this) {
                        var guiID = this.guiID;
                        this.guiID = null;
                        GameUI.dispose(guiID);
                        return;
                    }
                }
                //释放自身的资源
                this.disposeSelfAsset();
                this._mask.removeSelf();
                this._mask.offAll();
                this._mask = null;
                this._vScrollBar.removeSelf();
                this._vScrollBar.offAll();
                this._vScrollBar = null;
                this._hScrollBar.removeSelf();
                this._hScrollBar.offAll();
                this._hScrollBar = null;
            }
            _super.prototype.dispose.call(this);
        };
        /**
         * 自定义方法名称
         */
        UIRoot.customCompFunctionNames = ["enabledLimitView", "scrollShowType", "hScrollBar", "hScrollBg", "vScrollBar", "vScrollBg", "scrollWidth",
            "slowmotionType", "enabledWheel", "hScrollValue", "vScrollValue"];
        return UIRoot;
    }(UIComponent.UIBase));
    UIComponent.UIRoot = UIRoot;
    /**
     * UI继承类基类
     */
    var GUI_BASE = /** @class */ (function (_super) {
        __extends(GUI_BASE, _super);
        function GUI_BASE(guiID) {
            var _this = _super.call(this, true, guiID) || this;
            /**
             * 根据唯一ID进行索引
             */
            _this.compsIDInfo = {};
            var data = Game.data.uiList.data[guiID];
            if (!data)
                return _this;
            GameUI.parse(data.uiDisplayData, false, null, guiID, _this);
            return _this;
        }
        return GUI_BASE;
    }(UIRoot));
    UIComponent.GUI_BASE = GUI_BASE;
})(UIComponent || (UIComponent = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-12 14:01:57.
 */
var UIComponent;
(function (UIComponent) {
    var UIString = /** @class */ (function (_super) {
        __extends(UIString, _super);
        function UIString(inputMode) {
            if (inputMode === void 0) { inputMode = false; }
            var _this = _super.call(this) || this;
            _this._shadowColor = "#000000";
            _this._shadowDx = 1;
            _this._shadowDy = 1;
            _this._align = 0;
            _this._valign = 0;
            _this._overflow = 0;
            _this._fontSize = 16;
            _this._stroke = 0;
            _this._strokeColor = "#000000";
            _this._lastVarID = 0;
            _this.className = "UIString";
            _this._tf = inputMode ? new TextInput() : new Label();
            _this._tf.wordWrap = !inputMode;
            _this._input = inputMode;
            _this.on(EventObject.RESIZE, _this, _this.onResize);
            _this.addChild(_this._tf);
            _this._tf.font = Config.DEFAULT_FONT ? Config.DEFAULT_FONT : "宋体";
            _this._needLoad = false;
            _this.width = 200;
            _this.height = 30;
            _this.fontSize = 16;
            if (!Config.EDIT_MODE) {
                _this._onVarChange = Callback.New(_this.onVarChange, _this);
                _this.add_DISPLAY(_this.onAdded, _this);
                _this.add_UNDISPLAY(_this.onRemoved, _this);
                _this.mouseEventEnabled = false;
            }
            else {
                _this.tips = Callback.New(function () {
                    return this.inEditorInfo();
                }, _this);
            }
            return _this;
        }
        /**
         * 释放
         */
        UIString.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (!Config.EDIT_MODE) { //非编辑器模式才会添加侦听
                    var varID = this._lastVarID;
                    if (varID != 0 && this.className == "UIString") {
                        Game.player.removeListenerPlayerVariable(2, varID, this._onVarChange);
                    }
                }
                this._tf.removeSelf();
                this._tf.offAll();
                this._tf.destroy(true);
                this._tf = null;
                if (this._tf2) {
                    this._tf2.removeSelf();
                    this._tf2.offAll();
                    this._tf2.destroy(true);
                    this._tf2 = null;
                }
            }
            _super.prototype.dispose.call(this);
        };
        UIString.prototype.inEditorInit = function () {
            this.text = "字符串";
            this.mouseEventEnabledData = false;
        };
        /**
         * 当重置尺寸时
         */
        UIString.prototype.onResize = function () {
            if (this.isDisposed)
                return;
            this._tf.width = this.width;
            this._tf.height = this.height;
        };
        Object.defineProperty(UIString.prototype, "textWidth", {
            /**
             * 获取实际文本内容宽度
             * @return [number]
             */
            get: function () {
                return this._tf.textField.textWidth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "textHeight", {
            /**
             * 获取实际文本内容高度
             * @return [number]
             */
            get: function () {
                return this._tf.textField.textHeight;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "smooth", {
            /**
             * 平滑字体边缘
             */
            get: function () {
                return this._smooth;
            },
            /**
             * 平滑字体边缘
             */
            set: function (v) {
                this._smooth = v;
                this.refreshStroke();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "text", {
            get: function () {
                return this._tf.text;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                if (Config.EDIT_MODE) {
                    var varID = GameUtils.getVarID(v);
                    if (varID != 0) {
                        setText.call(this, v);
                        return;
                    }
                }
                setText.call(this, v);
                if (!Config.EDIT_MODE) {
                    var varID = GameUtils.getVarID(this.text);
                    if (varID != 0) {
                        setText.call(this, "");
                        if (this._lastVarID != 0)
                            Game.player.removeListenerPlayerVariable(2, this._lastVarID, this._onVarChange);
                        if (this.displayedInStage)
                            Game.player.addListenerPlayerVariable(2, varID, this._onVarChange);
                        this._lastVarID = varID;
                    }
                }
                function setText(v) {
                    if (this.__forceChange) {
                        this._tf.changeText(v);
                    }
                    else {
                        this._tf.text = v;
                    }
                    if (this._shadowEnabled) {
                        if (this._tf.text && !this._tf2.stage)
                            this.addChildAt(this._tf2, 0);
                        this._tf2.color = this._shadowColor;
                        if (this.__forceChange) {
                            this._tf2.changeText(this._tf.text);
                        }
                        else {
                            this._tf2.text = this._tf.text;
                        }
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        UIString.prototype.setTextForce = function (v) {
            this.__forceChange = true;
            this.text = v;
            this.__forceChange = false;
        };
        Object.defineProperty(UIString.prototype, "varID", {
            get: function () {
                return this._lastVarID;
            },
            set: function (v) {
                v = Math.floor(v);
                this.text = "$" + v;
                this._lastVarID = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "color", {
            get: function () {
                return this._tf.color;
            },
            set: function (v) {
                this._tf.color = v;
                this.width += 1;
                this.width -= 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "fontSize", {
            get: function () {
                return this._fontSize;
            },
            set: function (v) {
                this._fontSize = v;
                this.refreshStroke();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "leading", {
            get: function () {
                return this._tf.leading;
            },
            set: function (v) {
                this._tf.leading = v;
                if (this._shadowEnabled)
                    this._tf2.leading = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "letterSpacing", {
            get: function () {
                return this._tf.letterSpacing;
            },
            set: function (v) {
                this._tf.letterSpacing = v;
                if (this._shadowEnabled)
                    this._tf2.letterSpacing = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "align", {
            get: function () {
                return this._align;
            },
            set: function (v) {
                v = Math.floor(v);
                this._align = v;
                switch (v) {
                    case 0:
                        this._tf.align = "left";
                        if (this._shadowEnabled)
                            this._tf2.align = "left";
                        break;
                    case 1:
                        this._tf.align = "center";
                        if (this._shadowEnabled)
                            this._tf2.align = "center";
                        break;
                    case 2:
                        this._tf.align = "right";
                        if (this._shadowEnabled)
                            this._tf2.align = "right";
                        break;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "valign", {
            get: function () {
                return this._valign;
            },
            set: function (v) {
                v = Math.floor(v);
                this._valign = v;
                switch (v) {
                    case 0:
                        this._tf.valign = "top";
                        if (this._shadowEnabled)
                            this._tf2.valign = "top";
                        break;
                    case 1:
                        this._tf.valign = "middle";
                        if (this._shadowEnabled)
                            this._tf2.valign = "middle";
                        break;
                    case 2:
                        this._tf.valign = "bottom";
                        if (this._shadowEnabled)
                            this._tf2.valign = "bottom";
                        break;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "bold", {
            get: function () {
                return this._tf.bold;
            },
            set: function (v) {
                this._tf.bold = v;
                if (this._shadowEnabled)
                    this._tf2.bold = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "italic", {
            get: function () {
                return this._tf.italic;
            },
            set: function (v) {
                this._tf.italic = v;
                if (this._shadowEnabled)
                    this._tf2.italic = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "width", {
            // @ts-ignore
            get: function () {
                return this._tf.width;
            },
            set: function (v) {
                this._tf.width = v;
                if (this._shadowEnabled)
                    this._tf2.width = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "height", {
            // @ts-ignore
            get: function () {
                return this._tf.height;
            },
            set: function (v) {
                this._tf.height = v;
                if (this._shadowEnabled)
                    this._tf2.height = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "font", {
            get: function () {
                return this._tf.font;
            },
            set: function (v) {
                this._tf.font = v;
                if (this._shadowEnabled)
                    this._tf2.font = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "overflow", {
            get: function () {
                return this._overflow;
            },
            set: function (v) {
                v = Math.floor(v);
                this._overflow = v;
                this._tf.overflow = v == 1 ? "hidden" : "visible";
                this._tf.text = this._tf.text;
                this.width += 1;
                this.width -= 1;
                if (this._shadowEnabled) {
                    this._tf2.overflow = v == 1 ? "hidden" : "visible";
                    this._tf2.color = this._shadowColor;
                    this._tf2.text = this._tf.text;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "wordWrap", {
            get: function () {
                return this._tf.wordWrap;
            },
            set: function (v) {
                this._tf.wordWrap = v;
                if (this._shadowEnabled)
                    this._tf2.wordWrap = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "stroke", {
            get: function () {
                return this._stroke;
            },
            set: function (v) {
                if (this._stroke != v) {
                    this._stroke = v;
                    this.refreshStroke();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "strokeColor", {
            get: function () {
                return this._strokeColor;
            },
            set: function (v) {
                if (this._strokeColor != v) {
                    this._strokeColor = v;
                    this.refreshStroke();
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * 此方法在编辑器环境下被重写了：EUIRoot.init
         */
        UIString.prototype.refreshStroke = function () {
            var realStroke = this._stroke;
            if (realStroke == 0 && this._smooth)
                realStroke = 0.001;
            if (realStroke > 0) {
                this._tf.stroke = realStroke * 2;
                this._tf.strokeColor = this._strokeColor;
                this._tf.fontSize = this._fontSize * 2;
                this._tf.scale(0.5, 0.5);
                if (this.shadowEnabled) {
                    this._tf2.stroke = realStroke * 2;
                    this._tf2.strokeColor = this._strokeColor;
                    this._tf2.fontSize = this._fontSize * 2;
                    this._tf2.scale(0.5, 0.5);
                }
            }
            else {
                this._tf.stroke = 0;
                this._tf.fontSize = this._fontSize;
                this._tf.scale(1, 1);
                if (this.shadowEnabled) {
                    this._tf2.stroke = 0;
                    this._tf2.fontSize = this._fontSize;
                    this._tf2.scale(1, 1);
                }
            }
        };
        Object.defineProperty(UIString.prototype, "shadowEnabled", {
            //------------------------------------------------------------------------------------------------------
            //  阴影
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._shadowEnabled;
            },
            set: function (v) {
                this._shadowEnabled = v;
                if (this._shadowEnabled) {
                    if (!this._tf2)
                        this._tf2 = this._input ? new TextInput() : new Label();
                    this._tf2.mouseEnabled = false;
                    if (this.text)
                        this.addChildAt(this._tf2, 0);
                    this._tf2.font = this._tf.font;
                    this._tf2.bold = this._tf.bold;
                    this._tf2.italic = this._tf.italic;
                    this._tf2.valign = this._tf.valign;
                    this._tf2.align = this._tf.align;
                    this._tf2.fontSize = this._tf.fontSize;
                    this._tf2.leading = this._tf.leading;
                    this._tf2.overflow = this._tf.overflow;
                    this._tf2.wordWrap = this._tf.wordWrap;
                    this._tf2.color = this._shadowColor;
                    this._tf2.text = this._tf.text;
                    this._tf2.width = this._tf.width;
                    this._tf2.height = this._tf.height;
                    this._tf2.letterSpacing = this._tf.letterSpacing;
                    this._tf2.x = this._shadowDx;
                    this._tf2.y = this._shadowDy;
                    if (this._input) {
                        this._tf.remove_FOCUS(this.onInputFoucs, this);
                        this._tf.add_FOCUS(this.onInputFoucs, this);
                        this._tf.remove_FOCUS(this.onInputBlur, this);
                        this._tf.add_BLUR(this.onInputBlur, this);
                    }
                    //
                    this.refreshStroke();
                }
                else
                    this.removeChild(this._tf2);
            },
            enumerable: false,
            configurable: true
        });
        UIString.prototype.onInputFoucs = function () {
            if (this.shadowEnabled && this._tf2)
                this._tf2.removeSelf();
        };
        UIString.prototype.onInputBlur = function () {
            if (this.shadowEnabled && this._tf2) {
                this._tf2.color = this._shadowColor;
                this._tf2.text = this._tf.text;
                this._tf2.x = this._shadowDx;
                this._tf2.y = this._shadowDy;
                this.addChildAt(this._tf2, 0);
            }
        };
        Object.defineProperty(UIString.prototype, "shadowColor", {
            get: function () {
                return this._shadowColor;
            },
            set: function (v) {
                this._shadowColor = v;
                if (this._shadowEnabled)
                    this._tf2.color = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "shadowDx", {
            get: function () {
                return this._shadowDx;
            },
            set: function (v) {
                this._shadowDx = v;
                if (this._shadowEnabled)
                    this._tf2.x = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "shadowDy", {
            get: function () {
                return this._shadowDy;
            },
            set: function (v) {
                this._shadowDy = v;
                if (this._shadowEnabled)
                    this._tf2.y = v;
            },
            enumerable: false,
            configurable: true
        });
        //------------------------------------------------------------------------------------------------------
        // 
        //------------------------------------------------------------------------------------------------------
        /**
         * 编辑器专用信息说明
         */
        UIString.prototype.inEditorInfo = function () {
            var varID = GameUtils.getVarID(this.text);
            if (varID != 0) {
                var varName = GameListData.getName(Game.data.playerStringNameList, varID);
                return "【" + MathUtils.fixIntDigit(varID.toString()) + ":" + varName + "】";
            }
            else {
                return "";
            }
        };
        //------------------------------------------------------------------------------------------------------
        // 
        //------------------------------------------------------------------------------------------------------
        UIString.prototype.onAdded = function (e) {
            var varID = this._lastVarID;
            if (varID != 0) {
                Game.player.addListenerPlayerVariable(2, varID, this._onVarChange);
            }
        };
        UIString.prototype.onRemoved = function (e) {
            var varID = this._lastVarID;
            if (varID != 0) {
                Game.player.removeListenerPlayerVariable(2, varID, this._onVarChange);
            }
        };
        UIString.prototype.onVarChange = function (typeID, varID, value) {
            this._tf.text = value.toString();
            if (this._shadowEnabled)
                this._tf2.text = this._tf.text;
        };
        Object.defineProperty(UIString.prototype, "onChangeFragEvent", {
            //------------------------------------------------------------------------------------------------------
            // 事件
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._onChangeFragEvent;
            },
            set: function (v) {
                this._onChangeFragEvent = v;
                if (v) {
                    this.off(EventObject.CHANGE, this, this.onChange_private);
                    this.on(EventObject.CHANGE, this, this.onChange_private);
                }
                else {
                    this.off(EventObject.CHANGE, this, this.onChange_private);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIString.prototype.onChange_private = function () {
            if (Config.SINGLE_PLAYER_CORE && !(this instanceof UIComponent.UIInput)) {
                if (this._onChangeFragEvent && this.guiRoot && !this.guiRoot.onlyForPreload) {
                    CommandPage.startTriggerFragmentEvent(this._onChangeFragEvent, Game.player.sceneObject, Game.player.sceneObject);
                }
            }
        };
        /**
         * 自定义方法名称
         */
        UIString.customCompFunctionNames = ["text", "fontSize", "color", "bold", "italic", "smooth", "align", "valign", "leading", "letterSpacing",
            "font", "wordWrap", "overflow", "shadowEnabled", "shadowColor", "shadowDx", "shadowDy", "stroke", "strokeColor", "onChangeFragEvent"];
        return UIString;
    }(UIComponent.UIBase));
    UIComponent.UIString = UIString;
    ObjectUtils.redefinedEventFunc("UIComponent.UIString", [EventObject.ENTER, EventObject.INPUT, EventObject.CHANGE, EventObject.FOCUS, EventObject.BLUR], "_tf");
})(UIComponent || (UIComponent = {}));
/**
 * 动画 显示对象
 *
 * Created by feng on 2019-02-22 11:36:06.
 */
var GCAnimation = /** @class */ (function (_super) {
    __extends(GCAnimation, _super);
    /**
     * 构造函数
     */
    function GCAnimation() {
        var _this_1 = _super.call(this) || this;
        /**
         * 自动ID
         */
        _this_1.autoID = ObjectUtils.getInstanceID();
        /**
         * 频率
         */
        _this_1._fps = Config.ANIMATION_FPS ? Config.ANIMATION_FPS : 20;
        /**
         * 禁音模式
         */
        _this_1.silentMode = false;
        _this_1._showHitEffect = false;
        _this_1._currentFrame = 1;
        /**
         * 当前播放的动画是否循环
         */
        _this_1.loop = false;
        /**
         * 图源列表
         */
        _this_1.imageSources = [null];
        _this_1._totalFrame = 0;
        /**
         * 预设层
         */
        _this_1._preAnimationlayers = [];
        /**
         * 正在加载中
         */
        _this_1._isloading = false;
        /**
         * 是否加载完成
         */
        _this_1._isloaded = false;
        /**
         * 加载资源状态 0-无任何加载 1-加载了JSON 2-加载了图像资源 3-设置了动画层
         */
        _this_1._loadState = 0;
        /**
        * 是否是粒子
        */
        _this_1.isParticle = false;
        _this_1.topAnimation = _this_1;
        _this_1.syncLoadWhenAssetExist = !Config.EDIT_MODE;
        if (Config.EDIT_MODE) {
            _this_1.mouseEnabled = true;
        }
        return _this_1;
    }
    Object.defineProperty(GCAnimation.prototype, "id", {
        /**
         * ANIMATION 唯一ID
         * 更改ID后会自动加载相应的制作数据和资源，若之前的未加载完成又使用了新的话则只会抛出最新的一次加载完成事件
         */
        get: function () { return this._id; },
        set: function (v) {
            if (this.isDisposed)
                return;
            if (this._id == v)
                return;
            this.___disposeAsset();
            this._id = v;
            this._loadIDRD = Math.random();
            this.loadData(v, this._loadIDRD);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GCAnimation.prototype, "fps", {
        get: function () {
            return this._fps;
        },
        set: function (v) {
            this._fps = Math.max(Math.floor(v), 1);
            this._totalPlayTime = (this._totalFrame - 1) / this._fps * 1000;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GCAnimation.prototype, "showHitEffect", {
        /**
         * 是否显示命中效果，在播放动画前设置此项
         */
        get: function () { return this._showHitEffect; },
        set: function (v) {
            if (this.isDisposed)
                return;
            if (this._showHitEffect != v) {
                this._showHitEffect = v;
                // this.onRender();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GCAnimation.prototype, "currentFrame", {
        /**
        * 当前帧
        */
        get: function () { return this._currentFrame; },
        set: function (v) {
            if (this.isDisposed)
                return;
            if (v <= 1)
                v = 1;
            this._currentFrame = v;
            this._startTime = Date.now() - (v - 1) * 1000 / this.fps;
            this.onRender();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GCAnimation.prototype, "isPlaying", {
        /**
         * 是否正在播放中
         */
        get: function () { return this._isPlaying; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GCAnimation.prototype, "target", {
        get: function () {
            return this._target;
        },
        set: function (value) {
            if (this.isDisposed)
                return;
            // 
            if (this._target) {
                this._target.removeAnimationTargetEffect(this.animationTargetLayer);
            }
            this._target = value;
            if (this._target)
                this._target.addAnimationTargetEffect(this.animationTargetLayer);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GCAnimation.prototype, "totalFrame", {
        /**
         * 总帧数
         */
        get: function () {
            return this._totalFrame;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GCAnimation.prototype, "isLoading", {
        get: function () {
            return this._isloading;
        },
        enumerable: false,
        configurable: true
    });
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 清理
     */
    GCAnimation.prototype.clear = function () {
        for (var i = this.numChildren - 1; i >= 0; i--) {
            var layer = this.getChildAt(i);
            if (layer instanceof AnimationLayer) {
                layer.dispose();
            }
        }
        if (this.particleAni) {
            this.particleAni.emitter.stop();
            this.particleAni.stop();
            this.particleAni.offAll();
            this.particleAni.removeSelf();
            this.particleAni.destroy(true);
            this.particleAni = null;
            this.particleData = null;
        }
    };
    /**
     * 加载数据
     * @param animationID
     */
    GCAnimation.prototype.loadData = function (animationID, loadIDRD) {
        var _this_1 = this;
        if (this.isDisposed)
            return;
        this._isloading = true;
        this._isloaded = false;
        if (animationID == 0) {
            this._isloading = false;
            this._isloaded = true;
            this.clear();
            Callback.New(this.event, this, [EventObject.LOADED]).delayRun(0);
            return;
        }
        if (Config.EDIT_MODE) {
            var animationData = Common.animationList.data[animationID];
            if (!animationData) {
                Callback.New(this.event, this, [EventObject.LOADED]).delayRun(0);
                return;
            }
            this.parseData(animationData, loadIDRD);
        }
        else {
            this._loadState = 1;
            this.___loadJsonURL = "asset/json/animation/data/ani" + animationID + ".json";
            AssetManager.loadJson(this.___loadJsonURL, Callback.New(function (animationData) {
                _this_1.parseData(animationData, loadIDRD);
            }, this), this.syncLoadWhenAssetExist);
        }
    };
    /**
     * 解析数据
     * @param animationData 动画数据
     * @param loadIDRD 在编辑器环境下为null表示强行刷新
     * @param inAniEditor 是否在动画编辑器环境中
     */
    GCAnimation.prototype.parseData = function (animationData, loadIDRD, inAniEditor) {
        if (loadIDRD === void 0) { loadIDRD = null; }
        if (inAniEditor === void 0) { inAniEditor = false; }
        var loadRandName = "loadAnimation" + this.autoID;
        // ---> 异步1：阻止掉过期的操作，比如设置了id=5，又设置了id=6或者已经被销毁
        if (this.isDisposed || this.topAnimation.isDisposed || (loadIDRD && this._loadIDRD != loadIDRD)) {
            this.event(GCAnimation.LOAD_EXPIRE);
            return;
        }
        // 阻止掉过期的操作，比如设置了id=5，又设置了id=6
        if (loadIDRD && this._loadIDRD != loadIDRD)
            return;
        this._isloading = true;
        this._isloaded = false;
        if (!animationData) {
            this._isloaded = true;
            this._isloading = false;
            this.clear();
            this.event(EventObject.LOADED);
            return;
        }
        // clear
        this.clear();
        //解析数据
        if (animationData.isParticle) {
            this.particleParseData(animationData, loadIDRD, inAniEditor);
        }
        else {
            this.sFrameParseData(animationData, loadIDRD, inAniEditor);
        }
    };
    /**
     * 解析粒子动画数据
     * @param animationData 动画数据
     * @param loadIDRD 在编辑器环境下为null表示强行刷新
     * @param inAniEditor 是否在动画编辑器环境中
     */
    GCAnimation.prototype.particleParseData = function (animationData, loadIDRD, inAniEditor) {
        var _this_1 = this;
        if (inAniEditor === void 0) { inAniEditor = false; }
        this._id = animationData.id;
        this.isParticle = true;
        this.particleData = animationData.particleData;
        if (!this.particleData)
            return;
        var textureName = this.particleData.textureName;
        if (!textureName || textureName.length < 1) {
            this._isloading = false;
            this._isloaded = true;
            if (!loadIDRD || loadIDRD == _this._loadIDRD)
                _this.event(EventObject.LOADED);
            return;
        }
        var _this = this;
        this._loadState = 2;
        if (this.___loadPicUrls)
            this.___loadPicUrls = this.___loadPicUrls.concat([textureName]);
        else
            this.___loadPicUrls = [textureName];
        AssetManager.loadTexture(textureName, Callback.New(function (texture) {
            // ---> 异步2:阻止掉过期的操作，比如设置了id=5，又设置了id=6或者已经被销毁
            if (_this_1.isDisposed || _this_1.topAnimation.isDisposed || (loadIDRD && _this_1._loadIDRD != loadIDRD)) {
                _this_1.event(GCAnimation.LOAD_EXPIRE);
                return;
            }
            // 清理状态
            if (!loadIDRD || loadIDRD == _this_1._loadIDRD) {
                _this_1._isloading = false;
                _this_1._isloaded = true;
            }
            if (!texture) {
                if (!loadIDRD || loadIDRD == _this._loadIDRD)
                    _this.event(EventObject.LOADED);
                return;
            }
            var setting = new ParticleSetting();
            ObjectUtils.clone(_this.particleData, setting);
            setting.maxPartices += 1;
            //派发事件
            if (!_this.particleAni) {
                _this.particleAni = new Particle2D(setting);
            }
            else {
                _this.particleAni.setParticleSetting(setting);
            }
            _this.onRender(false);
            // -- 编辑器模式显示线框
            if (Config.EDIT_MODE) {
                // @ts-ignore
                if (_this.stage && _this_1.isInherit(EUIRoot.uiSceneMain.sceneBox)) {
                    var rect = _this_1.hitArea = new Rectangle(-Config.SCENE_GRID_SIZE / 4, -Config.SCENE_GRID_SIZE / 4, Config.SCENE_GRID_SIZE - 1, Config.SCENE_GRID_SIZE - 1);
                    _this.graphics.clear();
                    _this.graphics.drawLines(rect.x, rect.y, [rect.x, rect.y, rect.right, rect.y, rect.right, rect.bottom, rect.x, rect.bottom, rect.x, rect.y], "#FFFFFF", 2);
                }
            }
            if (!loadIDRD || loadIDRD == _this._loadIDRD) {
                _this.event(EventObject.LOADED);
            }
            if (_this._isPlaying) {
                _this._isPlaying = false;
                _this.play(true);
            }
        }, this), this.syncLoadWhenAssetExist);
    };
    /**
     * 更新粒子动画数据(编辑器专用)
     */
    GCAnimation.prototype.refreshParticleSetting = function () {
        if (!this.particleData || !this.particleData.textureName || this.particleData.textureName.length < 1) {
            if (this.particleAni) {
                this.particleAni.emitter.stop();
                this.particleAni.stop();
            }
            return;
        }
        var _this = this;
        this._loadState = 2;
        if (this.___loadPicUrls)
            this.___loadPicUrls = this.___loadPicUrls.concat([this.particleData.textureName]);
        else
            this.___loadPicUrls = [this.particleData.textureName];
        this._isloading = true;
        this._isloaded = false;
        AssetManager.loadTexture(this.particleData.textureName, Callback.New(function (texture) {
            if (!texture)
                return;
            this._isloading = false;
            this._isloaded = true;
            var setting = new ParticleSetting();
            ObjectUtils.clone(_this.particleData, setting);
            setting.maxPartices += 1;
            if (!_this.particleAni) {
                _this.particleAni = new Particle2D(setting);
            }
            else {
                _this.particleAni.setParticleSetting(setting);
            }
            if (_this._isPlaying) {
                _this._isPlaying = false;
                _this.play(true);
            }
        }, this), this.syncLoadWhenAssetExist);
    };
    /**
     * 解析序列帧动画数据
     *  --关于死锁问题SyncTask，这里是安全的，子动画是新建立出来的不会重复加载
     * @param animationData 动画数据
     * @param loadIDRD 在编辑器环境下为null表示强行刷新
     * @param inAniEditor 是否在动画编辑器环境中
     */
    GCAnimation.prototype.sFrameParseData = function (animationData, loadIDRD, inAniEditor) {
        var _this_1 = this;
        if (inAniEditor === void 0) { inAniEditor = false; }
        var loadRandName = "loadAnimation" + this.autoID;
        if (Config.EDIT_MODE)
            this.graphics.clear();
        this._id = animationData.id;
        this._totalFrame = animationData.totalFrame;
        this._totalPlayTime = (this._totalFrame - 1) / this._fps * 1000;
        this.imageSources = animationData.imageSources;
        this.isParticle = false;
        this._preAnimationlayers.length = 0;
        this.animationTargetLayer = null;
        // 加载的动画引用的图片列表
        var picUrls = animationData.imageSources.reduce(function (pv, v) { if (v && pv.indexOf(v.url) == -1)
            pv.push(v.url); return pv; }, []);
        if (this.___loadPicUrls)
            this.___loadPicUrls = this.___loadPicUrls.concat(picUrls);
        else
            this.___loadPicUrls = picUrls;
        this._loadState = 2;
        AssetManager.loadImages(picUrls, Callback.New(function () {
            // ---> 异步2:阻止掉过期的操作，比如设置了id=5，又设置了id=6或者已经被销毁
            if (_this_1.isDisposed || _this_1.topAnimation.isDisposed || (loadIDRD && _this_1._loadIDRD != loadIDRD)) {
                _this_1.event(GCAnimation.LOAD_EXPIRE);
                return;
            }
            var layers = animationData.layers;
            var isHighLayer = false;
            for (var index = 0; index < layers.length; index++) {
                var layerData = layers[index];
                var layer = GCAnimation.createAnimationLayer(layerData);
                layer.topAnimation = _this_1.topAnimation;
                layer.inAniEditor = inAniEditor;
                if (layer instanceof AnimationTargetLayer && _this_1.animationTargetLayer) {
                    isHighLayer = true;
                    continue;
                }
                else if (layer instanceof AnimationTargetLayer)
                    _this_1.animationTargetLayer = layer;
                if (layer instanceof AnimationAnimationLayer) {
                    new SyncTask(loadRandName);
                    layer.once(EventObject.LOADED, _this_1, function (loadRandName) {
                        SyncTask.taskOver(loadRandName);
                    }, [loadRandName]);
                    layer.once(GCAnimation.LOAD_EXPIRE, _this_1, function (loadRandName) {
                        SyncTask.taskOver(loadRandName);
                    }, [loadRandName]);
                }
                GCAnimation.setAnimationLayerData(layer, layerData);
                _this_1._preAnimationlayers.push(layer);
                layer.animation = _this_1;
                _this_1.addChild(layer);
                layer.showFrame(0);
            }
            _this_1._loadState = 3;
            // 显示当前帧
            new SyncTask(loadRandName, function (loadRandName) {
                // ---> 异步3:阻止掉过期的操作，比如设置了id=5，又设置了id=6或者已经被销毁
                if (_this_1.isDisposed || _this_1.topAnimation.isDisposed || (loadIDRD && _this_1._loadIDRD != loadIDRD)) {
                    // 抛出过期事件
                    _this_1.event(GCAnimation.LOAD_EXPIRE);
                    // 推进当前任务
                    SyncTask.taskOver(loadRandName);
                    return;
                }
                // 鼠标响应
                if (_this_1._openAutoHitArea || _this_1.mouseEnabled) {
                    _this_1.openAutoHitArea(_this_1._openAutoHitAreaForce);
                }
                if (!loadIDRD || loadIDRD == _this_1._loadIDRD) {
                    _this_1._isloading = false;
                    _this_1._isloaded = true;
                }
                // 刷新目标效果
                _this_1.target = _this_1.target;
                _this_1.updateParent();
                _this_1.onRender(false);
                //派发事件
                if (!loadIDRD || loadIDRD == _this_1._loadIDRD) {
                    _this_1.event(EventObject.LOADED);
                }
                if (_this_1._isPlaying) {
                    _this_1._isPlaying = false;
                    // -- 此处为了修复创建动画ID=0的动画后修改动画ID无法继续播放的问题
                    if (isNaN(_this_1._currentFrame) || isNaN(_this_1._startTime)) {
                        _this_1.gotoAndPlay();
                    }
                    else {
                        _this_1.play(true);
                    }
                }
                SyncTask.clear(loadRandName);
            }, [loadRandName], _this_1);
        }, this), this.syncLoadWhenAssetExist, true, this.prerender);
    };
    /**
     * 添加动画到指定位置
     * @param parent 父容器
     * @param target 目标对象
     * @param lowLayer 动画底层
     * @param highLayer 动画高层
     */
    GCAnimation.prototype.addToGameSprite = function (target, lowLayer, highLayer) {
        //
        if (this.isDisposed)
            return;
        this.target = target;
        this._lowLayer = lowLayer;
        this._highLayer = highLayer;
        //
        this.updateParent();
    };
    /**
     * 移除动画绑定，addToGameSprite后可使用该函数进行清理
     */
    GCAnimation.prototype.removeFromGameSprite = function () {
        this.addToGameSprite(null, null, null);
    };
    /**
     * 更新动画与父容器的关系
     */
    GCAnimation.prototype.updateParent = function () {
        var _this_1 = this;
        if (this.isDisposed || !this._isloaded)
            return;
        // 设置指定的高层和低层
        if (this._lowLayer != null || this._highLayer != null) {
            var isLowLayer = true;
            this._preAnimationlayers.forEach(function (element) {
                if (element.type == AnimationItemType.Target) {
                    isLowLayer = false;
                }
                else {
                    if (isLowLayer) {
                        if (_this_1._lowLayer)
                            _this_1._lowLayer.addChild(element);
                    }
                    else {
                        if (_this_1._highLayer)
                            _this_1._highLayer.addChild(element);
                    }
                }
            });
        }
        else {
            // 从其它层中回收子层
            this._preAnimationlayers.forEach(function (v) { return _this_1.addChild(v); });
        }
    };
    GCAnimation.prototype.dispose = function () {
        if (!this.isDisposed) {
            // 清理和停止
            os.remove_ENTERFRAME(this.onEnterFrame, this);
            this.stop(this.currentFrame);
            // 清理同步任务
            this.___clearTask();
            this.___disposeAsset();
            // 全部层移除
            this._preAnimationlayers.forEach(function (element) {
                element.dispose();
            });
            this._preAnimationlayers = [];
            //目标对象是外部的不能释放直接清空引用即可
            this.target = null;
            this.topAnimation = null;
            this._lowLayer = null;
            this._highLayer = null;
            this.animationTargetLayer = null;
            //
            if (this.particleAni) {
                this.particleAni.offAll();
                this.particleAni.removeSelf();
                this.particleAni.destroy(true);
                this.particleAni = null;
                this.particleData = null;
            }
        }
        _super.prototype.dispose.call(this);
    };
    /**
     * 清理任务
     */
    GCAnimation.prototype.___clearTask = function () {
        SyncTask.clear("loadAnimation" + this.autoID);
        GCAnimation.getChildrenLayers(this).forEach(function (layer) {
            if (layer instanceof AnimationAnimationLayer) {
                if (layer.animationInstance)
                    layer.animationInstance.___clearTask();
            }
        });
    };
    /**
     * 卸载资源：根据当前的资源进行卸载
     */
    GCAnimation.prototype.___disposeAsset = function () {
        // 如果加载了本体资源且设置了部件的话，则按照实际部件进行卸载
        if (this._loadState == 3) {
            var needDisposeAnis = [];
            GCAnimation.getChildrenLayers(this).forEach(function (layer) {
                if (layer instanceof AnimationAnimationLayer) {
                    if (layer.animationInstance)
                        needDisposeAnis.push(layer.animationInstance);
                }
            });
            for (var i = 0; i < needDisposeAnis.length; i++) {
                var aniLayer = needDisposeAnis[i];
                aniLayer.___disposeAsset();
                aniLayer.__isDisposed = true;
            }
            // 卸载json
            AssetManager.disposeJson(this.___loadJsonURL);
            // 卸载涉及的图片资源
            AssetManager.disposeImages(this.___loadPicUrls);
        }
        // 如果加载了资源但还未设置动画层的话
        else if (this._loadState == 2) {
            // 卸载json
            AssetManager.disposeJson(this.___loadJsonURL);
            // 卸载涉及的图片资源
            AssetManager.disposeImages(this.___loadPicUrls);
        }
        // 如果仅加载了JSON文件的话，则直接卸载JSON文件
        else if (this._loadState == 1) {
            AssetManager.disposeJson(this.___loadJsonURL);
        }
        this.___loadJsonURL = null;
        this.___loadPicUrls = null;
        this._loadState = 0;
    };
    //------------------------------------------------------------------------------------------------------
    // 播放
    //------------------------------------------------------------------------------------------------------
    /**
     * 跳转某帧进行播放，越界会自动取模（如帧长度10，播放13则是播放3）
     * @frame [可选]跳转AVATAR的帧数 单位：帧 默认从头开始
     * @isHit [可选]默认命中模式，动画内部的元素存在仅在命中时显示的模式，可通过设置此项为false来屏蔽掉命中时效果
     * @loop [可选]是否循环播放 默认false
     */
    GCAnimation.prototype.gotoAndPlay = function (frame) {
        if (frame === void 0) { frame = 1; }
        if (frame <= 1)
            frame = 1;
        this._currentFrame = frame;
        this._startTime = Date.now() - (frame - 1) * 1000 / this.fps;
        this.play();
    };
    /**
     * 在AVATAR的当前帧数开始播放
     */
    GCAnimation.prototype.play = function (forcePlay) {
        if (forcePlay === void 0) { forcePlay = false; }
        if (this.isDisposed)
            return;
        // 如果非顶级动画的话则忽略（因为会来自顶级动画层的update）
        if (!this.isParticle && this.layerAnimationSign) {
            return;
        }
        if (!this._isPlaying || forcePlay) {
            // 如果动画资源还在加载中的话就忽略
            if (this.isLoading) {
                this._isPlaying = true;
                return;
            }
            if (!this._isPlaying) {
                this._currentFrame = ((this._currentFrame - 1) % this._totalFrame) + 1;
                this._startTime = Date.now() - (this._currentFrame - 1) * 1000 / this.fps;
                this.event(GCAnimation.PLAY_START);
            }
            this._isPlaying = true;
            if (this.isParticle) {
                if (!this.particleData || !this.particleData.textureName || !this.particleAni)
                    return;
                if (!this.particleAni.displayedInStage)
                    this.addChild(this.particleAni);
                // 发射粒子
                this.particleAni.scaleX = 1.001;
                this.particleAni.emitter.start();
                // 播放
                this.particleAni.play();
                return;
            }
            // 刷新是否显示命中效果
            // @ts-ignore
            function refreshAnimationShowHitEffect(ani, showHitEffect) {
                ani.showHitEffect = showHitEffect;
                GCAnimation.getChildrenLayers(ani).forEach(function (layer) {
                    if (layer instanceof AnimationAnimationLayer) {
                        if (layer.animationInstance)
                            refreshAnimationShowHitEffect(layer.animationInstance, showHitEffect);
                    }
                });
            }
            refreshAnimationShowHitEffect(this, this.showHitEffect);
            // 帧刷
            os.remove_ENTERFRAME(this.onEnterFrame, this);
            os.add_ENTERFRAME(this.onEnterFrame, this);
            this.onEnterFrame();
        }
    };
    /**
     * 停止动画
     * @param frame [可选] 默认值=0 指定停留的帧数
     */
    GCAnimation.prototype.stop = function (frame) {
        if (frame === void 0) { frame = 1; }
        if (this.isDisposed)
            return;
        if (frame <= 1)
            frame = 1;
        if (this._isPlaying) {
            this._isPlaying = false;
            this.event(GCAnimation.PLAY_STOP);
            os.remove_ENTERFRAME(this.onEnterFrame, this);
            if (this.particleAni) {
                this.particleAni.emitter.stop();
                this.particleAni.stop();
            }
        }
        // if (this.__renderEnabled) {
        // if (!this.__inEditorRenderEnabled) {
        this.currentFrame = frame;
        // 停止所有音效
        var animationAudioLayers = GCAnimation.getAllLayers(this).filter(function (v) { return v instanceof AnimationAudioLayer; });
        animationAudioLayers.forEach(function (v) {
            v.stopAudio();
        });
        // 子动画停止（主要用于停止子动画的粒子层）
        var animationAnimationLayers = GCAnimation.getAllLayers(this).filter(function (v) { return v instanceof AnimationAnimationLayer; });
        animationAnimationLayers.forEach(function (v) {
            if (v.animationInstance)
                v.animationInstance.stop(frame);
        });
        // }
        // }
    };
    Object.defineProperty(GCAnimation.prototype, "__renderEnabled", {
        /**
         * 判定是否允许渲染
         */
        get: function () {
            return this.displayedInStage || (this._lowLayer && this._lowLayer.stage) || (this._highLayer && this._highLayer.stage) || (this._target && this._target.stage);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GCAnimation.prototype, "__inEditorRenderEnabled", {
        get: function () {
            return !Config.EDIT_MODE || (Config.EDIT_MODE && this.__renderEnabled);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 帧刷，更新动画时间，计算当前帧，更新动画
     */
    GCAnimation.prototype.onEnterFrame = function () {
        if (this.isDisposed)
            return;
        if (!this.__inEditorRenderEnabled)
            return;
        if (this._totalFrame <= 0)
            return;
        var now = Date.now();
        var dt = now - this._startTime;
        if (this._totalPlayTime == 0) {
            this._currentFrame = 1;
        }
        else {
            if (!this.loop) {
                this._currentFrame = ((dt) * this.fps / 1000) + 1;
            }
            else {
                this._currentFrame = ((dt % this._totalPlayTime) * this.fps / 1000) + 1;
            }
        }
        this.onRender();
        //播放完成
        if (!this.loop && dt >= this._totalPlayTime) {
            this.currentFrame = this._totalFrame;
            this.stop(this.currentFrame);
            this.event(GCAnimation.PLAY_COMPLETED);
        }
    };
    /**
     * 渲染
     */
    GCAnimation.prototype.onRender = function (sendEvent) {
        var _this_1 = this;
        if (sendEvent === void 0) { sendEvent = true; }
        if (this.isDisposed || this.topAnimation.isDisposed)
            return;
        if (this._isloading)
            return;
        if (!this.__inEditorRenderEnabled)
            return;
        GCAnimation.getChildrenLayers(this).forEach(function (layer) {
            layer.showFrame(_this_1._currentFrame - 1);
        });
        if (sendEvent)
            this.event(GCAnimation.RENDER);
    };
    /**
     * 更新动画总帧数
     *
     * 当新增或者删除帧时需主动调用
     */
    GCAnimation.prototype.updateTotalFrame = function () {
        var totalFrame = GCAnimation.getAllLayers(this).reduce(function (pv, cv) {
            var v = cv.frames.reduce(function (pv1, cv1) {
                return Math.max(pv1, cv1.index + 1);
            }, 0);
            return Math.max(v, pv);
        }, 0);
        return this._totalFrame = totalFrame;
    };
    /**
     * 添加动画层(编辑器专用添加动画层)
     * @param layer 动画层
     */
    GCAnimation.prototype.addAnimationLayer = function (layer, toIndex) {
        if (toIndex === void 0) { toIndex = -1; }
        if (!Config.EDIT_MODE)
            return;
        if (toIndex == -1 || toIndex > this.numChildren)
            this.addChild(layer);
        else
            this.addChildAt(layer, toIndex);
        //
        layer.materialData = [{ materials: [] }];
        layer.materialsDataExit = true;
        layer.installMaterialData(layer.materialData);
        layer.animation = this;
        layer.inAniEditor = true;
        layer.showFrame(this.currentFrame - 1);
    };
    /**
     * 转换为动画数据
     */
    GCAnimation.prototype.toAnimationData = function () {
        var animationData = {};
        animationData.id = this.id;
        if (this.isParticle) {
            animationData.totalFrame = 0;
            animationData.imageSources = [null];
            animationData.layers = [];
            if (this.particleData)
                this.particleData.textureName = this.particleData.textureName.replace("?texture", "");
            animationData.particleData = this.particleData;
        }
        else {
            animationData.totalFrame = this.totalFrame;
            animationData.imageSources = this.imageSources;
            animationData.layers = GCAnimation.getChildrenLayers(this).map(function (v) { return v.toAnimationLayerData(); });
            animationData.particleData = null;
        }
        animationData.isParticle = this.isParticle;
        return animationData;
    };
    /**
     * 获取该层下所有动画层
     *
     * 深度搜索
     */
    GCAnimation.getAllLayers = function (sprite) {
        var childrenLayers = GCAnimation.getChildrenLayers(sprite);
        var layers = [];
        childrenLayers.forEach(function (v) {
            layers.push(v);
            layers = layers.concat(GCAnimation.getAllLayers(v));
        });
        return layers;
    };
    /**
     * 动画层显示对象列表
     */
    GCAnimation.getChildrenLayers = function (sprite) {
        if ((!Config.EDIT_MODE || Config.BEHAVIOR_EDIT_MODE) && sprite instanceof GCAnimation) {
            if (sprite._preAnimationlayers)
                return sprite._preAnimationlayers;
        }
        var layers = [];
        for (var i = 0; i < sprite.numChildren; i++) {
            var child = sprite.getChildAt(i);
            if (child instanceof AnimationLayer) {
                layers.push(child);
            }
        }
        return layers;
    };
    /**
     * 创建动画层
     *
     * @param layerdata 动画层数据
     */
    GCAnimation.createAnimationLayer = function (layerdata) {
        var cls = AnimationLayer.typeClsMap[layerdata.type];
        var layer = new cls();
        return layer;
    };
    GCAnimation.setAnimationLayerData = function (aniLayer, layerdata) {
        aniLayer.setData(layerdata);
    };
    //------------------------------------------------------------------------------------------------------
    // 响应区域：注册了事件后即根据mouseEnabled来开启区域响应（逐帧刷新点击区域）
    //------------------------------------------------------------------------------------------------------
    GCAnimation.prototype.on = function (type, caller, listener, args) {
        var t = _super.prototype.on.apply(this, arguments);
        if (this.hasMouseEvent)
            this.openAutoHitArea();
        return t;
    };
    ;
    GCAnimation.prototype.once = function (type, caller, listener, args) {
        var _this_1 = this;
        var t = _super.prototype.once.apply(this, [type, caller, function (caller, listener, args, e) {
                listener.apply(caller, args ? args.concat([e]) : [e]);
                if (!_this_1.hasMouseEvent)
                    _this_1.closeAutoHitArea();
            }, [caller, listener, args]]);
        if (this.hasMouseEvent)
            this.openAutoHitArea();
        return t;
    };
    ;
    GCAnimation.prototype.off = function (type, caller, listener, onceOnly) {
        var t = _super.prototype.off.apply(this, arguments);
        if (!this.hasMouseEvent)
            this.closeAutoHitArea();
        return t;
    };
    ;
    GCAnimation.prototype.offAll = function (type) {
        var t = _super.prototype.offAll.apply(this, arguments);
        if (!this.hasMouseEvent)
            this.closeAutoHitArea();
        return t;
    };
    ;
    /**
     * 刷新响应区域
     */
    GCAnimation.prototype.openAutoHitArea = function (force) {
        if (force === void 0) { force = false; }
        if (this.isDisposed)
            return;
        this._openAutoHitArea = true;
        this._openAutoHitAreaForce = force;
        if (force)
            this.mouseEnabled = true;
        var len = this._preAnimationlayers.length;
        for (var i = 0; i < len; i++) {
            var aniLayer = this._preAnimationlayers[i];
            aniLayer.openAutoHitArea(force);
        }
    };
    GCAnimation.prototype.closeAutoHitArea = function (force) {
        if (force === void 0) { force = false; }
        if (this.isDisposed || Config.EDIT_MODE)
            return;
        // 如果强制开启了，非强制无法关闭
        if (this._openAutoHitAreaForce && !force)
            return;
        this._openAutoHitArea = false;
        this._openAutoHitAreaForce = false;
        var len = this._preAnimationlayers.length;
        for (var i = 0; i < len; i++) {
            var aniLayer = this._preAnimationlayers[i];
            aniLayer.closeAutoHitArea(force);
        }
    };
    /**
     * 执行 onRender 时派发
     */
    GCAnimation.RENDER = "RENDER";
    /**
     * 动画播放开始事件
     */
    GCAnimation.PLAY_START = "playStart";
    /**
    * 动画停止时事件
    */
    GCAnimation.PLAY_STOP = "playStop";
    /**
     * 动画播放完成事件
     */
    GCAnimation.PLAY_COMPLETED = "playCompleted";
    /**
     * 信号事件 on(signalID:number) 对应动画信号的ID
     */
    GCAnimation.SIGNAL = "Animation_SIGNAL";
    /**
     * 内部事件：加载过期
     */
    GCAnimation.LOAD_EXPIRE = "AvatarLOAD_EXPIRE";
    return GCAnimation;
}(GameSprite));
// @ts-ignore
window['Animation'] = GCAnimation;
/**
 * 动画显示层
 *
 * Created by feng on 2019-02-27 14:43:28.
 */
var AnimationDisplayLayer = /** @class */ (function (_super) {
    __extends(AnimationDisplayLayer, _super);
    function AnimationDisplayLayer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._horizontalReversal = false;
        return _this;
    }
    Object.defineProperty(AnimationDisplayLayer.prototype, "horizontalReversal", {
        /**
         * 水平翻转，暂未实现
         */
        get: function () {
            return this._horizontalReversal;
        },
        set: function (v) {
            this._horizontalReversal = v;
        },
        enumerable: false,
        configurable: true
    });
    /**
    * 设置数据
    */
    AnimationDisplayLayer.prototype.setData = function (data) {
        _super.prototype.setData.call(this, data);
        //兼容0.985
        if (this.frames[0] && this.frames[0].materialData) {
            this.materialData = ObjectUtils.depthClone(this.frames[0].materialData);
        }
        else if (Config.EDIT_MODE && this.inAniEditor) {
            this.fixFramesMaterialsData();
            this.materialData = [{ materials: [] }];
        }
        if (this.materialData) {
            this.materialsDataExit = true;
            this.installMaterialData(this.materialData);
        }
    };
    /**
     * 显示指定帧
     *
     * @param frameIndex 帧索引
     */
    AnimationDisplayLayer.prototype.showFrame = function (frameIndex) {
        if (!this.animation)
            return;
        _super.prototype.showFrame.call(this, frameIndex);
        var showEnable = true;
        // 在编辑器环境下的动画编辑器中时
        if (Config.EDIT_MODE && EUIWindowAnimation.InAniEditor(this.animation)) {
            if (!this.animation.isPlaying) {
                showEnable = this.showOnEditor;
            }
            else { //播放
                showEnable = this.showOnEditor && ((this.animation.showHitEffect && this.isHitEffect) || (!this.isHitEffect));
            }
        }
        // 运行时根据仅命中设定进行显示
        else {
            showEnable = (this.animation.showHitEffect && this.isHitEffect) || !this.isHitEffect;
        }
        this.visible = showEnable;
    };
    /**
     * 从动画帧数据初始化
     */
    AnimationDisplayLayer.prototype.fromAnimationFrameData = function (framedata) {
        _super.prototype.fromAnimationFrameData.call(this, framedata);
        if (!framedata)
            return;
        this.horizontalReversal = framedata.horizontalReversal;
        this.x = framedata.x;
        this.y = framedata.y;
        this.rotation = framedata.rotation;
        this.opacity = framedata.alpha;
        //兼容0.985
        if (this.materialsDataExit) {
            //检查是否需要重置
            if (this.checkMaterialsTransChange(framedata)) {
                this.clearMaterials();
                this.installMaterialData(this.materialData);
            }
            else {
                this.setFrameMaterialsEffect(framedata.materialData);
            }
        }
        else if (!Config.EDIT_MODE || !this.inAniEditor || Config.BEHAVIOR_EDIT_MODE) {
            this.hue = framedata.hue;
            this.blur = framedata.blur;
            this.setTonal(framedata.tonal_r, framedata.tonal_g, framedata.tonal_b, framedata.tonal_gray, framedata.tonal_mr, framedata.tonal_mg, framedata.tonal_mb);
        }
    };
    /**
     * 转换动画帧数据
     */
    AnimationDisplayLayer.prototype.toAnimationFrameData = function (framedata) {
        framedata = _super.prototype.toAnimationFrameData.call(this, framedata);
        framedata.horizontalReversal = this.horizontalReversal;
        framedata.x = this.x;
        framedata.y = this.y;
        framedata.rotation = this.rotation;
        framedata.alpha = this.opacity;
        return framedata;
    };
    /**
     * 关键帧之间插值
     *
     * @param pf 上一个关键帧
     * @param nf 下一个关键帧
     * @param frameIndex 插值帧
     */
    AnimationDisplayLayer.prototype.interpolationFrame = function (pf, nf, frameIndex) {
        var frame = _super.prototype.interpolationFrame.call(this, pf, nf, frameIndex);
        frame.horizontalReversal = pf.horizontalReversal;
        // 插值系数
        var t = (frameIndex - pf.index) / (nf.index - pf.index);
        //兼容(在非编辑器环境下或者编辑器环境下的动画编辑器中，并且要大于0.985版本)
        if (this.materialsDataExit) {
            var value = GameUtils.getValueByTransData(nf.trans, t);
            frame.x = (nf.x - pf.x) * value + pf.x;
            frame.y = (nf.y - pf.y) * value + pf.y;
            frame.rotation = (nf.rotation - pf.rotation) * value + pf.rotation;
            frame.alpha = (nf.alpha - pf.alpha) * value + pf.alpha;
            if (pf.materialData && nf.materialData) {
                this.refreshInterpolationFrameMaterials(frame, pf, nf, t);
            }
        }
        else {
            // 插值函数
            var tween = GameUtils.getTween(nf.tweenID)[0];
            //
            frame.tweenID = nf.tweenID;
            frame.x = tween(t, pf.x, nf.x - pf.x, 1);
            frame.y = tween(t, pf.y, nf.y - pf.y, 1);
            frame.rotation = tween(t, pf.rotation, nf.rotation - pf.rotation, 1);
            frame.alpha = tween(t, pf.alpha, nf.alpha - pf.alpha, 1);
            this.refreshInterpolationFrameTonal(frame, pf, nf, t, tween);
        }
        return frame;
    };
    return AnimationDisplayLayer;
}(AnimationLayer));
/**
 * 动画动画层
 *
 * Created by feng on 2019-02-27 14:40:39.
 */
var AnimationAnimationLayer = /** @class */ (function (_super) {
    __extends(AnimationAnimationLayer, _super);
    function AnimationAnimationLayer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * 动画元素类型
         */
        _this.type = AnimationItemType.GCAnimation;
        /**
         * 是否循环播放
         */
        _this.loop = false;
        return _this;
    }
    Object.defineProperty(AnimationAnimationLayer.prototype, "animationId", {
        /**
         * 动画编号
         */
        get: function () { return this._animationId; },
        set: function (v) {
            if (this._animationId == v)
                return;
            this._animationId = v;
            if (this._animationInstance)
                this.removeChild(this._animationInstance);
            this._animationInstance = null;
            this._animationInstance = new GCAnimation();
            this._animationInstance.topAnimation = this.topAnimation;
            if (this.topAnimation)
                this._animationInstance.syncLoadWhenAssetExist = this.topAnimation.syncLoadWhenAssetExist;
            this._animationInstance.prerender = this.topAnimation.prerender;
            this._animationInstance.layerAnimationSign = true;
            this._animationInstance.once(EventObject.LOADED, this, this.onAnimationLoaded);
            this._animationInstance.id = v;
            this.addChildAt(this._animationInstance, 0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationAnimationLayer.prototype, "animationInstance", {
        /**
         * 动画实例
         */
        get: function () { return this._animationInstance; },
        enumerable: false,
        configurable: true
    });
    AnimationAnimationLayer.prototype.onAnimationLoaded = function () {
        if (this._animationInstance.isParticle) { //设置粒子的默认包围范围
            this.setBounds(new Rectangle(-96, -133, 192, 192));
            this.hitArea = new Rectangle(-96, -133, 192, 192);
        }
        else {
            if (this._isOpenAutoHitArea) {
                this.openAutoHitArea();
            }
        }
        this.event(EventObject.LOADED);
        this.updateFrame();
    };
    /**
     * 设置数据
     */
    AnimationAnimationLayer.prototype.setData = function (data) {
        _super.prototype.setData.call(this, data);
        this.animationId = data.animationId;
        this.loop = data.loop;
    };
    /**
     * 开启自动响应区域
     */
    AnimationAnimationLayer.prototype.openAutoHitArea = function (force) {
        if (force === void 0) { force = false; }
        _super.prototype.openAutoHitArea.call(this, force);
        if (!this._animationInstance || this._animationInstance.isParticle)
            return false;
        this.mouseEnabled = true;
        if (this._animationInstance.isLoading) {
            this._animationInstance.mouseEnabled = true;
            this._animationInstance.once(EventObject.LOADED, this._animationInstance, this._animationInstance.openAutoHitArea);
        }
        else {
            this._animationInstance.mouseEnabled = true;
            this._animationInstance.openAutoHitArea(this._openAutoHitAreaForce);
        }
        return true;
    };
    /**
     * 关闭自动响应区域
     */
    AnimationAnimationLayer.prototype.closeAutoHitArea = function (force) {
        if (force === void 0) { force = false; }
        var isClosed = _super.prototype.closeAutoHitArea.call(this, force);
        // 不是真正关闭的话就忽略掉
        if (!isClosed)
            return false;
        this.mouseEnabled = false;
        if (this._animationInstance.isLoading) {
            this._animationInstance.mouseEnabled = false;
            this._animationInstance.once(EventObject.LOADED, this._animationInstance, this._animationInstance.closeAutoHitArea);
        }
        else {
            this._animationInstance.mouseEnabled = false;
            this._animationInstance.closeAutoHitArea();
        }
        return true;
    };
    /**
     * 转换为动画层数据
     */
    AnimationAnimationLayer.prototype.toAnimationLayerData = function () {
        var data = _super.prototype.toAnimationLayerData.call(this);
        data.loop = this.loop;
        data.animationId = this.animationId;
        return data;
    };
    /**
     * 从动画帧数据初始化
     */
    AnimationAnimationLayer.prototype.fromAnimationFrameData = function (framedata) {
        _super.prototype.fromAnimationFrameData.call(this, framedata);
        if (!framedata)
            return;
        //
        if (framedata.scaleX == undefined)
            framedata.scaleX = 1;
        if (framedata.scaleY == undefined)
            framedata.scaleY = 1;
        //
        this.scaleX = framedata.scaleX;
        this.scaleY = framedata.scaleY;
        // 控制子动画播放
        if (!this.animation)
            return;
        if (!this._animationInstance)
            return;
        this._animationInstance.visible = false;
        // 编辑器环境下该对象点击区域刷新
        if (!this._animationInstance.isParticle && this._isOpenAutoHitArea) {
            this.hitArea = this.getBounds();
        }
        //判断是否存在两个关键帧
        var len = this.frames ? this.frames.length : 0;
        var totalFrame = this.animation.totalFrame ? this.animation.totalFrame : 0;
        if (len == 0 || totalFrame == 0) {
            this._animationInstance.stop();
            return;
        }
        //有关键帧
        var firstFrame = this.frames[0].index;
        var lastFrame = 0;
        if (this.loop || len == 1) {
            lastFrame = totalFrame - 1;
        }
        else if (len >= 2) {
            lastFrame = this.frames[len - 1].index;
        }
        if (this._frameIndex >= firstFrame && this._frameIndex <= lastFrame) {
            this._animationInstance.visible = this._animationInstance.showOnEditor;
            if (!this._animationInstance.isParticle) {
                this._animationInstance["_isPlaying"] = this.animation["_isPlaying"];
                // 计算子动画播放帧
                // var subFrame = ((this._frameIndex - firstFrame) / this.animation.fps) * this._animationInstance.fps;
                var subFrame = this._frameIndex - firstFrame;
                if (this.loop)
                    subFrame = subFrame % this._animationInstance.totalFrame;
                GCAnimation.getChildrenLayers(this._animationInstance).forEach(function (layer) {
                    layer.showFrame(subFrame);
                });
            }
            else {
                this._animationInstance.play();
            }
        }
        else {
            this._animationInstance.stop();
        }
    };
    AnimationAnimationLayer.prototype.showFrame = function (frameIndex) {
        _super.prototype.showFrame.call(this, frameIndex);
        this.setOffset();
    };
    /**
     * 转换动画帧数据
     */
    AnimationAnimationLayer.prototype.toAnimationFrameData = function (framedata) {
        framedata = _super.prototype.toAnimationFrameData.call(this, framedata);
        framedata.scaleX = this.scaleX;
        framedata.scaleY = this.scaleY;
        return framedata;
    };
    /**
     * 关键帧之间插值
     *
     * @param pf 上一个关键帧
     * @param nf 下一个关键帧
     * @param frameIndex 插值帧
     */
    AnimationAnimationLayer.prototype.interpolationFrame = function (pf, nf, frameIndex) {
        var frame = _super.prototype.interpolationFrame.call(this, pf, nf, frameIndex);
        //
        if (pf.scaleX == undefined)
            pf.scaleX = 1;
        if (pf.scaleY == undefined)
            pf.scaleY = 1;
        // 插值系数
        var t = (frameIndex - pf.index) / (nf.index - pf.index);
        //兼容0.985
        if (nf.trans != null) {
            var value = GameUtils.getValueByTransData(nf.trans, t);
            frame.scaleX = (nf.scaleX - pf.scaleX) * value + pf.scaleX;
            frame.scaleY = (nf.scaleY - pf.scaleY) * value + pf.scaleY;
        }
        else {
            // 插值函数
            var tween = GameUtils.getTween(nf.tweenID)[0];
            //
            frame.scaleX = tween(t, pf.scaleX, nf.scaleX - pf.scaleX, 1);
            frame.scaleY = tween(t, pf.scaleY, nf.scaleY - pf.scaleY, 1);
        }
        //
        return frame;
    };
    AnimationAnimationLayer.prototype.dispose = function () {
        if (this._animationInstance)
            this._animationInstance.dispose();
        this._animationInstance = null;
        _super.prototype.dispose.call(this);
    };
    return AnimationAnimationLayer;
}(AnimationDisplayLayer));
AnimationLayer.typeClsMap[AnimationItemType.GCAnimation] = AnimationAnimationLayer;
/**
 * 动画音效层
 *
 * Created by feng on 2019-02-27 14:42:05.
 */
var AnimationAudioLayer = /** @class */ (function (_super) {
    __extends(AnimationAudioLayer, _super);
    function AnimationAudioLayer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * 动画元素类型
         */
        _this.type = AnimationItemType.Audio;
        _this._audioInfo = { url: "", volume: 1, pitch: 1 };
        _this._playAudio = false;
        return _this;
    }
    Object.defineProperty(AnimationAudioLayer.prototype, "audioInfo", {
        /**
         * 音效信息（URL按照 路径）
         */
        get: function () { return this._audioInfo; },
        set: function (v) {
            this._audioInfo = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationAudioLayer.prototype, "audioUrl", {
        /**
         * 音效路径
         */
        get: function () {
            if (!this._audioInfo.url)
                this._audioInfo.url = "";
            return this._audioInfo.url.split(",")[0];
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 设置数据
     */
    AnimationAudioLayer.prototype.setData = function (data) {
        _super.prototype.setData.call(this, data);
        this.audioInfo = data.audioInfo || { url: "", volume: 1, pitch: 1 };
    };
    /**
     * 转换为动画层数据
     */
    AnimationAudioLayer.prototype.toAnimationLayerData = function () {
        var data = _super.prototype.toAnimationLayerData.call(this);
        data.audioInfo = this.audioInfo;
        return data;
    };
    /**
     * 是否允许播放（往父系找寻是否允许播放，根据根动画的）
     */
    AnimationAudioLayer.prototype.getHitEffectVisible = function (topAnimation) {
        // 如果根动画显示命中效果的话则全部显示
        if (topAnimation.showHitEffect)
            return true;
        var p = this;
        // 往上查询必须是动画或者动画层
        while ((p instanceof GCAnimation || p instanceof AnimationLayer)) {
            // 如果该节点仅在命中时显示的话就无法出现
            if (p.isHitEffect) {
                return false;
            }
            p = p.parent;
            // 如果检测层已经是最高层的话则中断检测了
            if (p == topAnimation)
                break;
        }
        return true;
    };
    /**
     * 显示指定帧
     *
     * @param frameIndex 帧索引
     */
    AnimationAudioLayer.prototype.showFrame = function (frameIndex) {
        if (!this.animation || !this.topAnimation || this.topAnimation.isDisposed)
            return;
        if (!this._audioInfo)
            return;
        if (!this.animation.isPlaying)
            return;
        if (Config.EDIT_MODE && !this.inAniEditor)
            return;
        var topAnimation = this.topAnimation;
        if (this.animation.silentMode || (topAnimation && topAnimation.silentMode))
            return;
        // 上一帧索引
        var preFrameIndex = this._frameIndex;
        _super.prototype.showFrame.call(this, frameIndex);
        var showEnable = true;
        // 非播放时
        if (Config.EDIT_MODE && EUIWindowAnimation.InAniEditor(this.animation)) {
            if (!this.animation.isPlaying) {
                showEnable = this.showOnEditor;
            }
            else { //播放
                showEnable = this.showOnEditor && this.getHitEffectVisible(topAnimation);
            }
        }
        else {
            showEnable = this.getHitEffectVisible(topAnimation); //  (this.animation.showHitEffect && this.isHitEffect) || !this.isHitEffect;
        }
        if (!showEnable)
            this.stopAudio();
        else {
            if (this.frames.length == 0)
                return;
            //判断是否存在两个关键帧
            var len = this.frames ? this.frames.length : 0;
            var totalFrame = this.animation.totalFrame ? this.animation.totalFrame : 0;
            //有关键帧
            var firstFrame = this.frames[0].index;
            var lastFrame = 0;
            if (len == 1) {
                lastFrame = totalFrame - 1;
            }
            else if (len >= 2) {
                lastFrame = this.frames[len - 1].index;
            }
            lastFrame = lastFrame > 0 ? lastFrame : 0;
            // 动画循环
            if (this.animation.loop && preFrameIndex > firstFrame && preFrameIndex < lastFrame && frameIndex < preFrameIndex)
                this.stopAudio();
            // 是否跳帧
            var isFrameSkip = (frameIndex > preFrameIndex && frameIndex - preFrameIndex > 1);
            // 是否播放声音
            var isCanPlay = isFrameSkip ? (preFrameIndex + 1 >= firstFrame && preFrameIndex + 1 < lastFrame) : (frameIndex >= firstFrame && frameIndex < lastFrame);
            if (isCanPlay) {
                if (this._playAudio)
                    return;
                this.stopAudio();
                this._soundChannel = GameAudio.playSE(this.audioUrl, this._audioInfo.volume, this._audioInfo.pitch, this.animation.sceneObject);
                this._playAudio = true;
            }
            else {
                this._playAudio = false;
            }
        }
    };
    /**
     * 停止播放音效
     */
    AnimationAudioLayer.prototype.stopAudio = function () {
        if (this._soundChannel) {
            GameAudio.stopSE(this._soundChannel);
            this._soundChannel = null;
        }
        this._playAudio = false;
    };
    return AnimationAudioLayer;
}(AnimationLayer));
AnimationLayer.typeClsMap[AnimationItemType.Audio] = AnimationAudioLayer;
/**
 * 动画图片层
 *
 * Created by feng on 2019-02-27 14:01:41.
 */
var AnimationImageLayer = /** @class */ (function (_super) {
    __extends(AnimationImageLayer, _super);
    function AnimationImageLayer() {
        var _this_1 = _super.call(this) || this;
        /**
         * 动画元素类型
         */
        _this_1.type = AnimationItemType.Image;
        _this_1._blendModeType = 0;
        _this_1._pivotX = 0;
        _this_1._pivotY = 0;
        _this_1.img = new Sprite();
        _this_1.addChild(_this_1.img);
        //默认是空图片会使用tex宽高
        _this_1._defaultStateImage = true;
        _this_1.on(EventObject.RESIZE, _this_1, _this_1.onResize);
        _this_1.add_DISPLAY(_this_1.onDisplay, _this_1);
        _this_1.add_UNDISPLAY(_this_1.onUnDisplay, _this_1);
        return _this_1;
    }
    Object.defineProperty(AnimationImageLayer.prototype, "imageSource", {
        /**
         * 图源编号
         */
        get: function () {
            return this._imageSource;
        },
        set: function (v) {
            this._imageSource = v;
            this.updateImage();
            // timer.callLater(this, this.updateImage);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationImageLayer.prototype, "blendModeType", {
        /**
         * 混合模式类型
         *
         * 0:null
         * 1:"lighter"
         */
        get: function () { return this._blendModeType; },
        set: function (v) {
            if (this._blendModeType === v)
                return;
            this._blendModeType = v;
            this.blendMode = ["normal", "lighter"][v] || "normal";
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 设置数据
     */
    AnimationImageLayer.prototype.setData = function (data) {
        _super.prototype.setData.call(this, data);
        //通过解析动画数据创建的图片使用数据中的宽高
        this._defaultStateImage = false;
    };
    /**
     * 开启自动响应区域
     */
    AnimationImageLayer.prototype.openAutoHitArea = function (force) {
        if (force === void 0) { force = false; }
        _super.prototype.openAutoHitArea.call(this, force);
        var rect = this.img.getBounds();
        this.hitArea = rect;
        this.mouseEnabled = true;
        return true;
    };
    /**
     * 关闭自动响应区域
     */
    AnimationImageLayer.prototype.closeAutoHitArea = function (force) {
        if (force === void 0) { force = false; }
        var isClosed = _super.prototype.closeAutoHitArea.call(this, force);
        if (isClosed) {
            this.hitArea = null;
            this.mouseEnabled = false;
        }
        return isClosed;
    };
    /**
     * 添加到舞台事件
     */
    AnimationImageLayer.prototype.onDisplay = function () {
        this.updateImage();
    };
    /**
     * 从舞台移除事件
     */
    AnimationImageLayer.prototype.onUnDisplay = function () {
    };
    /**
     * 更新图片
     */
    AnimationImageLayer.prototype.updateImage = function () {
        if (!this.animation)
            return;
        var imageSource = this.animation.imageSources[this._imageSource];
        if (!imageSource) {
            this.img.graphics = null;
            return;
        }
        var _this = this;
        // AssetManager.loadImage(imageSource.url, Handler.create(this, function () {
        //     if (_this._imageSource != imageSource.index) return;
        var imagegraphics = AssetManager.getClipImage(imageSource.url, 0, 0, new Rectangle(imageSource.x, imageSource.y, imageSource.width, imageSource.height));
        _this.setSouce(imagegraphics, imageSource.width, imageSource.height);
        // }));
        // 如果已开启点击区域的话则刷新
        if (this._isOpenAutoHitArea) {
            // trace("-----updateHitArea")
            var rect = this.img.getBounds();
            this.hitArea = rect;
        }
    };
    AnimationImageLayer.prototype.showFrame = function (frameIndex) {
        _super.prototype.showFrame.call(this, frameIndex);
        this.setOffset();
    };
    /**
     * 改变宽高时重置图片尺寸
     */
    AnimationImageLayer.prototype.repaint = function () {
        _super.prototype.repaint.call(this);
        this.onResize();
    };
    /**
     * 设置图源
     * @param v
     * @param width
     * @param height
     * @param pivotX [可选] 默认值=0
     * @param pivotY [可选] 默认值=0
     */
    AnimationImageLayer.prototype.setSouce = function (v, width, height, pivotX, pivotY) {
        if (pivotX === void 0) { pivotX = 0; }
        if (pivotY === void 0) { pivotY = 0; }
        if (v == null || v instanceof Graphics) {
            this.img.graphics = v;
        }
        else if (v instanceof Avatar) {
            this.img.addChild(v);
        }
        else {
            AssetManager.loadImage(v, Callback.New(function (t) {
                var g = new Graphics();
                if (t) {
                    g.fillTexture(t, 0, 0, t.width, t.height);
                    this.setSouce(g, t.width, t.height);
                }
                else {
                    this.setSouce(g, 0, 0);
                }
            }, this));
            return;
        }
        this.img.width = width;
        this.img.height = height;
        if (this._defaultStateImage && (this.width == 0 || isNaN(this.width)))
            this.width = width;
        if (this._defaultStateImage && (this.height == 0 || isNaN(this.height)))
            this.height = height;
        this._pivotX = pivotX;
        this._pivotY = pivotY;
        this.onResize();
    };
    Object.defineProperty(AnimationImageLayer.prototype, "lockScale", {
        /**
         * 设置缩放（一般初始时设置）
         * @return [boolean]
         */
        get: function () {
            return this._lockScale;
        },
        set: function (v) {
            this._lockScale = v;
            if (!v) {
                this.img.x = 0;
                this.img.y = 0;
            }
            this.onResize();
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 重置尺寸时刷新
     */
    AnimationImageLayer.prototype.onResize = function () {
        if (!this.img || !this.img.graphics || this.img.width == 0 || this.img.height == 0)
            return;
        var scaleX = this.width / this.img.width;
        var scaleY = this.height / this.img.height;
        if (this.lockScale) {
            var scale = Math.min(scaleX, scaleY);
            this.img.scaleX = scale;
            this.img.scaleY = scale;
            var imgW = this.img.width * scale;
            var imgH = this.img.height * scale;
            this.img.x = Math.round((this.width - imgW) / 2);
            this.img.y = Math.round((this.height - imgH) / 2);
        }
        else {
            this.img.scaleX = scaleX;
            this.img.scaleY = scaleY;
        }
        if (this.width < 0 || this.height < 0) {
            this.hitArea = this.img.getBounds();
        }
        else { //存在宽高不需要设置hitarea
            this.hitArea = null;
        }
    };
    /**
     * 关键帧之间插值
     *
     * @param pf 上一个关键帧
     * @param nf 下一个关键帧
     * @param frameIndex 插值帧
     */
    AnimationImageLayer.prototype.interpolationFrame = function (pf, nf, frameIndex) {
        var frame = _super.prototype.interpolationFrame.call(this, pf, nf, frameIndex);
        frame.blendModeType = pf.blendModeType;
        // 插值系数
        var t = (frameIndex - pf.index) / (nf.index - pf.index);
        //兼容0.985
        if (nf.trans != null) {
            var value = GameUtils.getValueByTransData(nf.trans, t);
            frame.width = (nf.width - pf.width) * value + pf.width;
            frame.height = (nf.height - pf.height) * value + pf.height;
            frame.imageSource = Math.round((nf.imageSource - pf.imageSource) * value + pf.imageSource);
        }
        else {
            // 插值函数
            var tween = GameUtils.getTween(nf.tweenID)[0];
            //
            frame.width = tween(t, pf.width, nf.width - pf.width, 1);
            frame.height = tween(t, pf.height, nf.height - pf.height, 1);
            frame.imageSource = Math.round(tween(t, pf.imageSource, nf.imageSource - pf.imageSource, 1));
        }
        return frame;
    };
    /**
     * 从动画帧数据初始化
     */
    AnimationImageLayer.prototype.fromAnimationFrameData = function (framedata) {
        _super.prototype.fromAnimationFrameData.call(this, framedata);
        if (!framedata)
            return;
        this.width = framedata.width;
        this.height = framedata.height;
        this.imageSource = framedata.imageSource;
        this.blendModeType = framedata.blendModeType;
        // 控制子动画播放
        if (!this.animation)
            return;
        if (!this.img)
            return;
        this.img.visible = false;
        //判断是否存在两个关键帧
        var len = this.frames ? this.frames.length : 0;
        var totalFrame = this.animation.totalFrame ? this.animation.totalFrame : 0;
        if (len == 0 || totalFrame == 0)
            return;
        //有关键帧
        var firstFrame = this.frames[0].index;
        var lastFrame = 0;
        if (len == 1) {
            lastFrame = totalFrame - 1;
        }
        else if (len >= 2) {
            lastFrame = this.frames[len - 1].index;
        }
        if (this._frameIndex >= firstFrame && this._frameIndex <= lastFrame) {
            this.img.visible = true;
        }
        else {
            this.img.visible = false;
        }
    };
    /**
     * 转换动画帧数据
     */
    AnimationImageLayer.prototype.toAnimationFrameData = function (framedata) {
        framedata = _super.prototype.toAnimationFrameData.call(this, framedata);
        framedata.width = this.width;
        framedata.height = this.height;
        framedata.imageSource = this.imageSource;
        framedata.blendModeType = this.blendModeType;
        return framedata;
    };
    AnimationImageLayer.prototype.dispose = function () {
        if (this.img) {
            this.img.offAll();
            this.img.removeSelf();
            this.img.destroy(true);
            this.img = null;
        }
        _super.prototype.dispose.call(this);
    };
    return AnimationImageLayer;
}(AnimationDisplayLayer));
AnimationLayer.typeClsMap[AnimationItemType.Image] = AnimationImageLayer;
/**
 * 动画目标层
 *
 * Created by feng on 2019-02-27 14:43:28.
 */
var AnimationTargetLayer = /** @class */ (function (_super) {
    __extends(AnimationTargetLayer, _super);
    function AnimationTargetLayer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * 动画元素类型
         */
        _this.type = AnimationItemType.Target;
        /**
         * 是否显示
         */
        _this.showEnable = true;
        return _this;
    }
    /**
     * 更新对象状态
     */
    AnimationTargetLayer.prototype._updateView = function () {
        if (!this.animation)
            return;
        var target = this.animation.target;
        if (!target || target.isDisposed)
            return;
        if (target instanceof GameSprite) {
            target.refreshTargetEffect(false);
        }
    };
    /**
     * 重置对象材质状态
     */
    AnimationTargetLayer.prototype._installTargetEffect = function () {
        if (!this.animation)
            return;
        var target = this.animation.target;
        if (!target || target.isDisposed)
            return;
        if (target instanceof GameSprite) {
            target.refreshTargetEffect();
        }
    };
    /**
     * 设置数据
     */
    AnimationTargetLayer.prototype.setData = function (data) {
        _super.prototype.setData.call(this, data);
        //兼容0.985
        if (this.frames[0] && this.frames[0].materialData) {
            this.materialData = ObjectUtils.depthClone(this.frames[0].materialData);
        }
        else if (Config.EDIT_MODE && this.inAniEditor) {
            this.fixFramesMaterialsData();
            this.materialData = [{ materials: [] }];
        }
        if (this.materialData) {
            this.materialsDataExit = true;
            this.installMaterialData(this.materialData);
        }
    };
    /**
     * 显示指定帧
     *
     * @param frameIndex 帧索引
     */
    AnimationTargetLayer.prototype.showFrame = function (frameIndex) {
        if (!this.animation)
            return;
        // 在编辑器环境下的动画编辑器中时
        if (Config.EDIT_MODE && EUIWindowAnimation.InAniEditor(this.animation)) {
            // 非播放时
            if (!this.animation.isPlaying) {
                this.showEnable = this.showOnEditor;
            }
            else { //播放
                this.showEnable = this.showOnEditor && ((this.animation.showHitEffect && this.isHitEffect) || (!this.isHitEffect));
            }
        }
        // 运行时根据仅命中设定进行显示
        else {
            this.showEnable = (this.animation.showHitEffect && this.isHitEffect) || !this.isHitEffect;
        }
        if (!this.showEnable) {
            this._frameIndex = frameIndex;
            this.refreshTonal();
            return;
        }
        _super.prototype.showFrame.call(this, frameIndex);
    };
    /**
     * 刷新还原色调等属性
     */
    AnimationTargetLayer.prototype.refreshTonal = function () {
        this.x = this.y = this.rotation = this.hue = this.blur = 0;
        this.alpha = this.scaleX = this.scaleY = 1;
        this.setTonal(0, 0, 0, 0, 1, 1, 1);
    };
    /**
     * 从动画帧数据初始化
     */
    AnimationTargetLayer.prototype.fromAnimationFrameData = function (framedata) {
        _super.prototype.fromAnimationFrameData.call(this, framedata);
        if (this.destroyed)
            return;
        // -- 动画
        if (!framedata)
            return;
        this.x = framedata.x;
        this.y = framedata.y;
        this.rotation = framedata.rotation;
        this.opacity = framedata.alpha;
        if (framedata.scaleX == undefined)
            framedata.scaleX = 1;
        if (framedata.scaleY == undefined)
            framedata.scaleY = 1;
        this.scaleX = framedata.scaleX;
        this.scaleY = framedata.scaleY;
        //兼容0.985
        if (this.materialsDataExit) {
            //检查是否需要重置
            if (this.checkMaterialsTransChange(framedata)) {
                this.clearMaterials();
                this.installMaterialData(this.materialData);
                this._installTargetEffect();
            }
            else {
                this.setFrameMaterialsEffect(framedata.materialData);
                this._updateView();
            }
        }
        else if (!Config.EDIT_MODE || !this.inAniEditor || Config.BEHAVIOR_EDIT_MODE) {
            this.hue = framedata.hue;
            this.blur = framedata.blur;
            this.setTonal(framedata.tonal_r, framedata.tonal_g, framedata.tonal_b, framedata.tonal_gray, framedata.tonal_mr, framedata.tonal_mg, framedata.tonal_mb);
            this._updateView();
        }
    };
    /**
     * 转换动画帧数据
     */
    AnimationTargetLayer.prototype.toAnimationFrameData = function (framedata) {
        framedata = _super.prototype.toAnimationFrameData.call(this, framedata);
        if (this.showEnable) {
            framedata.x = this.x;
            framedata.y = this.y;
            framedata.rotation = this.rotation;
            framedata.alpha = this.opacity;
            framedata.scaleX = this.scaleX;
            framedata.scaleY = this.scaleY;
        }
        return framedata;
    };
    /**
     * 关键帧之间插值
     *
     * @param pf 上一个关键帧
     * @param nf 下一个关键帧
     * @param frameIndex 插值帧
     */
    AnimationTargetLayer.prototype.interpolationFrame = function (pf, nf, frameIndex) {
        var frame = _super.prototype.interpolationFrame.call(this, pf, nf, frameIndex);
        //
        if (pf.scaleX == undefined)
            pf.scaleX = 1;
        if (pf.scaleY == undefined)
            pf.scaleY = 1;
        frame.horizontalReversal = pf.horizontalReversal;
        // 插值系数
        var t = (frameIndex - pf.index) / (nf.index - pf.index);
        //兼容0.985
        if (this.materialsDataExit) {
            var value = GameUtils.getValueByTransData(nf.trans, t);
            frame.x = (nf.x - pf.x) * value + pf.x;
            frame.y = (nf.y - pf.y) * value + pf.y;
            frame.rotation = (nf.rotation - pf.rotation) * value + pf.rotation;
            frame.alpha = (nf.alpha - pf.alpha) * value + pf.alpha;
            frame.scaleX = (nf.scaleX - pf.scaleX) * value + pf.scaleX;
            frame.scaleY = (nf.scaleY - pf.scaleY) * value + pf.scaleY;
            if (pf.materialData && nf.materialData) {
                this.refreshInterpolationFrameMaterials(frame, pf, nf, t);
            }
        }
        else {
            // 插值函数
            var tween = GameUtils.getTween(nf.tweenID)[0];
            //
            frame.tweenID = nf.tweenID;
            frame.x = tween(t, pf.x, nf.x - pf.x, 1);
            frame.y = tween(t, pf.y, nf.y - pf.y, 1);
            frame.rotation = tween(t, pf.rotation, nf.rotation - pf.rotation, 1);
            frame.alpha = tween(t, pf.alpha, nf.alpha - pf.alpha, 1);
            frame.scaleX = tween(t, pf.scaleX, nf.scaleX - pf.scaleX, 1);
            frame.scaleY = tween(t, pf.scaleY, nf.scaleY - pf.scaleY, 1);
            this.refreshInterpolationFrameTonal(frame, pf, nf, t, tween);
        }
        return frame;
    };
    return AnimationTargetLayer;
}(AnimationLayer));
AnimationLayer.typeClsMap[AnimationItemType.Target] = AnimationTargetLayer;
/**
 * Created by feng on 2019-04-03 17:57:13.
 */
var UIComponent;
(function (UIComponent) {
    /**
     * 播放类型
     */
    var UIAnimationPlayType;
    (function (UIAnimationPlayType) {
        /**
         * "不播放"
         */
        UIAnimationPlayType[UIAnimationPlayType["none"] = 0] = "none";
        /**
         * "播放一次"
         */
        UIAnimationPlayType[UIAnimationPlayType["once"] = 1] = "once";
        /**
         *  "循环播放"
         */
        UIAnimationPlayType[UIAnimationPlayType["loop"] = 2] = "loop";
    })(UIAnimationPlayType || (UIAnimationPlayType = {}));
    /**
     * 动画UI
     *
     * 动画播放完成时派发事件 GCAnimation.PLAY_COMPLETED
     */
    var UIAnimation = /** @class */ (function (_super) {
        __extends(UIAnimation, _super);
        /**
         * 构造
         */
        function UIAnimation(showCircleWhenInEditor) {
            if (showCircleWhenInEditor === void 0) { showCircleWhenInEditor = true; }
            var _this = _super.call(this) || this;
            _this._playType = UIAnimationPlayType.none;
            _this._aniFrame = 1;
            _this.className = "UIAnimation";
            _this.__init();
            if (Config.EDIT_MODE) {
                _this.modifyWidthHeightEnabled = false;
                if (showCircleWhenInEditor) {
                    _this._bg = new Sprite();
                    _this.addChild(_this._bg);
                    _this.hitArea = new Rectangle(-10, -10, 20, 20);
                    _this._bg.graphics.drawCircle(0, 0, 10, "#FF0000");
                    _this._bg.alpha = 0.4;
                }
            }
            else {
                _this.on(EventObject.DISPLAY, _this, _this.refreshSize);
            }
            return _this;
        }
        Object.defineProperty(UIAnimation.prototype, "animationID", {
            /**
             * 动画编号
             */
            get: function () {
                return this._animation.id;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                if (this._animation.id == v)
                    return;
                v = Math.floor(v);
                this._animation.id = v;
                this._animation.syncLoadWhenAssetExist = this.syncLoadedEventWhenAssetExist;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "playType", {
            /**
             * 播放类型，默认不播放
             */
            get: function () { return this._playType; },
            set: function (v) { v = Math.floor(v); this._playType = v; this.updateAnimationPlayType(); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "playFps", {
            /**
             * 播放帧率
             */
            get: function () { return this.animation.fps; },
            set: function (v) { this.animation.fps = v; } // this._animation.play();
            ,
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "aniFrame", {
            get: function () {
                if (Config.EDIT_MODE)
                    return this._aniFrame;
                return this.animation.currentFrame;
            },
            set: function (v) {
                v = Math.floor(v);
                this._aniFrame = v;
                this.animation.currentFrame = v;
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "scaleNumber", {
            get: function () {
                return this._animation.scaleX;
            },
            set: function (v) {
                this._animation.scaleX = this._animation.scaleY = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "scaleNumberX", {
            get: function () {
                return this._animation.scaleX;
            },
            set: function (v) {
                this._animation.scaleX = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "scaleNumberY", {
            get: function () {
                return this._animation.scaleY;
            },
            set: function (v) {
                this._animation.scaleY = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "animation", {
            get: function () {
                return this._animation;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "silentMode", {
            /**
             * 禁音模式
             */
            get: function () { return this._animation.silentMode; },
            set: function (v) {
                this._animation.silentMode = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "showHitEffect", {
            /**
             * 是否显示命中效果，在播放动画前设置此项
             */
            get: function () { return this._animation.showHitEffect; },
            set: function (v) {
                this._animation.showHitEffect = v;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * 初始化
         */
        UIAnimation.prototype.__init = function () {
            this._animation = new GCAnimation();
            this.addChildAt(this._animation, 0);
            if (Config.EDIT_MODE) {
                this._animation.openAutoHitArea();
            }
            this._animation.showHitEffect = true;
            this._animation.on(EventObject.LOADED, this, this.onAnimationLoaded);
            this.on(EventObject.DISPLAY, this, this.updateAnimationPlayType);
        };
        Object.defineProperty(UIAnimation.prototype, "syncLoadedEventWhenAssetExist", {
            set: function (v) {
                this._syncLoadedEventWhenAssetExist = v;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * 开始检测加载完毕的情形
         */
        UIAnimation.prototype.loadAssetTest = function () {
            var aniID = this.animationID;
            AssetManager.preLoadAnimationAsset(aniID, Callback.New(function () {
                this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, true);
        };
        /**
         * 释放
         */
        UIAnimation.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (this._animation) {
                    this._animation.dispose();
                    this._animation = null;
                }
                if (this._bg) {
                    this._bg.removeSelf();
                    this._bg.offAll();
                    this._bg.destroy(true);
                    this._bg = null;
                }
            }
            _super.prototype.dispose.call(this);
        };
        /**
         * 编辑器专用初始化
         */
        UIAnimation.prototype.inEditorInit = function () {
            this.width = 192;
            this.height = 192;
            this.animationID = 1;
        };
        /**
         * 动画加载完成
         */
        UIAnimation.prototype.onAnimationLoaded = function () {
            this.refreshSize();
            // this.updateAnimationPlayType();
        };
        /**
         * 更新动画播放类型
         */
        UIAnimation.prototype.updateAnimationPlayType = function () {
            if (!this.stage)
                return;
            // 仅用于预加载的话忽略掉
            if (this.guiRoot && this.guiRoot.onlyForPreload)
                return;
            if (this.playType == UIAnimationPlayType.none)
                this._animation.stop();
            else if (this.playType == UIAnimationPlayType.once) {
                this._animation.loop = false;
                this._animation.play();
            }
            else if (this.playType == UIAnimationPlayType.loop) {
                this._animation.loop = true;
                this._animation.play(true);
            }
        };
        UIAnimation.prototype.refreshSize = function () {
            if (!this.stage)
                return;
            if (!Config.EDIT_MODE) {
                this.hitArea = this._animation.getBounds();
            }
        };
        //------------------------------------------------------------------------------------------------------
        // 响应区域：注册了事件后即根据mouseEnabled来开启区域响应（逐帧刷新点击区域）
        //------------------------------------------------------------------------------------------------------
        UIAnimation.prototype.on = function (type, caller, listener, args) {
            var t = _super.prototype.on.apply(this, arguments);
            if (this.hasMouseEvent && this.animation)
                this.animation.openAutoHitArea(true);
            return t;
        };
        ;
        UIAnimation.prototype.once = function (type, caller, listener, args) {
            var _this = this;
            var t = _super.prototype.once.apply(this, [type, caller, function (caller, listener, args, e) {
                    listener.apply(caller, args ? args.concat([e]) : [e]);
                    if (!_this.hasMouseEvent && _this.animation)
                        _this.animation.closeAutoHitArea(true);
                }, [caller, listener, args]]);
            if (this.hasMouseEvent && this.animation)
                this.animation.openAutoHitArea(true);
            return t;
        };
        ;
        UIAnimation.prototype.off = function (type, caller, listener, onceOnly) {
            var t = _super.prototype.off.apply(this, arguments);
            if (!this.hasMouseEvent && this.animation)
                this.animation.closeAutoHitArea(true);
            return t;
        };
        ;
        UIAnimation.prototype.offAll = function (type) {
            var t = _super.prototype.offAll.apply(this, arguments);
            if (!this.hasMouseEvent && this.animation)
                this.animation.closeAutoHitArea(true);
            return t;
        };
        ;
        /**
         * 自定义方法名称
         */
        UIAnimation.customCompFunctionNames = ["animationID", "scaleNumberX", "scaleNumberY", "aniFrame", "playFps", "playType", "showHitEffect", "silentMode"];
        return UIAnimation;
    }(UIComponent.UIBase));
    UIComponent.UIAnimation = UIAnimation;
    ObjectUtils.redefinedEventFunc("UIComponent.UIAnimation", [GCAnimation.RENDER, GCAnimation.PLAY_START, GCAnimation.PLAY_STOP, GCAnimation.PLAY_COMPLETED, GCAnimation.SIGNAL, EventObject.LOADED], "_animation", false);
})(UIComponent || (UIComponent = {}));
/**
 * UI组件：行走图
 * 相关事件
 *  EventObject.LOADED 加载完成时候事件
 * Created by 黑暗之神KDS on 2018-12-11 17:44:18.
 */
var UIComponent;
(function (UIComponent) {
    var UIAvatar = /** @class */ (function (_super) {
        __extends(UIAvatar, _super);
        function UIAvatar() {
            var _this = _super.call(this) || this;
            _this._oriMode = 8;
            _this._avatarFrame = 1;
            _this._orientationIndex = 0;
            _this._isPlay = true;
            _this._playOnce = false;
            _this.className = "UIAvatar";
            if (Config.EDIT_MODE) {
                _this.modifyWidthHeightEnabled = false;
            }
            _this.__init();
            return _this;
        }
        UIAvatar.prototype.__init = function () {
            var _this = this;
            this._avatar = new Avatar();
            if (Config.EDIT_MODE) {
                this._avatar.openAutoHitArea();
                this.mouseEnabled = true;
            }
            this.addChildAt(this._avatar, 0);
            this.avatar.on(Avatar.RENDER, this, this.refreshSize);
            // 第一时间捕获确认Avatar方向模式
            this.avatar.once(EventObject.LOADED, this, function () {
                _this._oriMode = _this.avatar.oriMode;
            });
        };
        Object.defineProperty(UIAvatar.prototype, "syncLoadedEventWhenAssetExist", {
            set: function (v) {
                this._syncLoadedEventWhenAssetExist = v;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * 开始检测加载完毕的情形
         */
        UIAvatar.prototype.loadAssetTest = function () {
            AssetManager.preLoadAvatarAsset(this.avatarID, Callback.New(function () {
                this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, true);
        };
        /**
         * 释放
         */
        UIAvatar.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (this._avatar) {
                    this._avatar.dispose();
                    this._avatar = null;
                }
            }
            _super.prototype.dispose.call(this);
        };
        /**
         * 编辑器专用初始化
         */
        UIAvatar.prototype.inEditorInit = function () {
            var _this = this;
            this.width = 192;
            this.height = 192;
            if (!this.stage) {
                this.once(EventObject.DISPLAY, this, function () {
                    _this.avatarID = 1;
                });
            }
            else {
                this.avatarID = 1;
            }
            this.orientationIndex = this._orientationIndex;
        };
        Object.defineProperty(UIAvatar.prototype, "avatar", {
            get: function () { return this._avatar; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "avatarID", {
            //------------------------------------------------------------------------------------------------------
            // 
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this.avatar.id;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                if (v == this.avatarID)
                    return;
                v = Math.floor(v);
                this.avatar.id = v;
                this.avatar.syncLoadWhenAssetExist = this.syncLoadedEventWhenAssetExist;
                if (Config.EDIT_MODE) {
                    var avatarData = Common.avatarList.data[v];
                    if (avatarData)
                        this._oriMode = avatarData.oriMode;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "scaleNumberX", {
            get: function () {
                return this._avatar.scaleX;
            },
            set: function (v) {
                this._avatar.scaleX = v;
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "scaleNumberY", {
            get: function () {
                return this._avatar.scaleY;
            },
            set: function (v) {
                this._avatar.scaleY = v;
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "orientationIndex", {
            get: function () {
                return this._orientationIndex;
            },
            set: function (v) {
                var _this = this;
                // 如果内部的avatar处于加载中的情况则等待加载完毕再设置（用户已经通过外部修改过朝向的则此处不再覆盖）
                // 创建UIAvatar时系统会自动设置orientationIndex，这比任何用户设置属性都要前面，而用户一旦修改了orientation或者avatar.orientation都能够正确响应
                if (this.avatar.isLoading) {
                    var oldVisible = this.avatar.visible;
                    this.avatar.visible = false;
                    this.avatar.once(EventObject.LOADED, this, function () {
                        if (_this.isDisposed || _this.avatar.isDisposed || _this.avatar.userChangeOrientation)
                            return;
                        _this.avatar.visible = oldVisible;
                        _this.orientationIndex = v;
                        _this.refreshSize();
                    });
                    return;
                }
                v = Math.floor(v);
                this._orientationIndex = v;
                var orientation = GameUtils.getFlipOriByIndex(v, this._oriMode);
                if (orientation == null)
                    orientation = GameUtils.getFlipOriByIndex(0, this._oriMode);
                this.orientation = orientation;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "orientation", {
            get: function () {
                return this.avatar.orientation;
            },
            set: function (v) {
                v = Math.floor(v);
                this._orientationIndex = GameUtils.getIndexByFlipOri(v, this._oriMode);
                this.avatar.orientation = v;
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "avatarFrame", {
            get: function () {
                return this._avatarFrame;
            },
            set: function (v) {
                v = Math.floor(v);
                this._avatarFrame = v;
                this.avatar.setCurrentFrame(v);
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "isPlay", {
            get: function () {
                return this._isPlay;
            },
            set: function (v) {
                this._isPlay = v;
                this.refreshPlayState();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "playOnce", {
            get: function () {
                return this._playOnce;
            },
            set: function (v) {
                this._playOnce = v;
                this.refreshPlayState();
            },
            enumerable: false,
            configurable: true
        });
        UIAvatar.prototype.refreshPlayState = function () {
            var _this = this;
            // 仅用于预加载的话忽略掉
            if (this.guiRoot && this.guiRoot.onlyForPreload)
                return;
            if ((this._isPlay || this._playOnce) && !this.avatar.isPlaying)
                this.avatar.play();
            if (this._playOnce) {
                this.avatar.once(Avatar.ACTION_PLAY_COMPLETED, this, function () {
                    _this.avatar.stop(_this.avatar.totalFrame);
                });
            }
            else {
                if (!this._isPlay)
                    this.avatar.stop(this.avatar.getCurrentFrame());
            }
        };
        Object.defineProperty(UIAvatar.prototype, "avatarFPS", {
            get: function () {
                return this.avatar.fps;
            },
            set: function (v) {
                v = Math.floor(v);
                this.avatar.fps = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "actionIndex", {
            get: function () {
                return this.avatar.actionIndex;
            },
            set: function (v) {
                v = Math.floor(v);
                this.avatar.actionIndex = v;
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "actionID", {
            get: function () {
                return this.avatar.actionID;
            },
            set: function (v) {
                v = Math.floor(v);
                this.avatar.actionID = v;
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "avatarHue", {
            get: function () {
                return this.avatar.hue;
            },
            set: function (v) {
                if (v == this._avatar.hue)
                    return;
                this._avatar.hue = v;
            },
            enumerable: false,
            configurable: true
        });
        //------------------------------------------------------------------------------------------------------
        // 
        //------------------------------------------------------------------------------------------------------
        UIAvatar.prototype.refreshSize = function () {
            var _this = this;
            // if (!this._avatar || !this._avatar.stage) return;
            // this.hitArea = this.avatar.getBounds();
            if (Config.EDIT_MODE) {
                Callback.CallLaterBeforeRender(function () {
                    if (_this.avatar)
                        _this.hitArea = _this.avatar.getBounds();
                }, this);
            }
            else {
                if (this.avatar)
                    this.hitArea = this.avatar.getBounds();
            }
        };
        //------------------------------------------------------------------------------------------------------
        // 响应区域：注册了事件后即根据mouseEnabled来开启区域响应（逐帧刷新点击区域）
        //------------------------------------------------------------------------------------------------------
        UIAvatar.prototype.on = function (type, caller, listener, args) {
            var t = _super.prototype.on.apply(this, arguments);
            if (this.hasMouseEvent && this.avatar)
                this.avatar.openAutoHitArea(true);
            return t;
        };
        ;
        UIAvatar.prototype.once = function (type, caller, listener, args) {
            var _this = this;
            var t = _super.prototype.once.apply(this, [type, caller, function (caller, listener, args, e) {
                    listener.apply(caller, args ? args.concat([e]) : [e]);
                    if (!_this.hasMouseEvent && _this.avatar)
                        _this.avatar.closeAutoHitArea(true);
                }, [caller, listener, args]]);
            if (this.hasMouseEvent && this.avatar)
                this.avatar.openAutoHitArea(true);
            return t;
        };
        ;
        UIAvatar.prototype.off = function (type, caller, listener, onceOnly) {
            var t = _super.prototype.off.apply(this, arguments);
            if (!this.hasMouseEvent && this.avatar)
                this.avatar.closeAutoHitArea(true);
            return t;
        };
        ;
        UIAvatar.prototype.offAll = function (type) {
            var t = _super.prototype.offAll.apply(this, arguments);
            if (!this.hasMouseEvent && this.avatar)
                this.avatar.closeAutoHitArea(true);
            return t;
        };
        ;
        /**
         * 自定义方法名称
         */
        UIAvatar.customCompFunctionNames = ["avatarID", "scaleNumberX", "scaleNumberY", "orientationIndex", "avatarFPS", "playOnce", "isPlay", "avatarFrame", "actionID", "avatarHue"];
        return UIAvatar;
    }(UIComponent.UIBase));
    UIComponent.UIAvatar = UIAvatar;
    ObjectUtils.redefinedEventFunc("UIComponent.UIAvatar", [Avatar.ACTION_PLAY_COMPLETED, Avatar.RENDER, EventObject.LOADED], "_avatar", false);
})(UIComponent || (UIComponent = {}));
/**
 *
 * Created by 黑暗之神KDS on 2018-10-12 14:02:39.
 */
var UIComponent;
(function (UIComponent) {
    var UIBitmap = /** @class */ (function (_super) {
        __extends(UIBitmap, _super);
        function UIBitmap() {
            var _this = _super.call(this) || this;
            _this._image = "";
            _this._grid9 = "0,0,0,0,0";
            /**图片组件默认地址路径 */
            _this._defaultSkins = ["asset/image/picture/control/uibitmap.png", "editorAsset/img/ui_pic.png", "editorAsset/img/ui_string.png"];
            // 0-原点 1-中心点
            _this._pivotType = 0;
            //默认是空图片会使用tex宽高
            _this._defaultStateImage = true;
            _this._uiImage = new UIImage();
            _this.addChild(_this._uiImage);
            _this.className = "UIBitmap";
            _this.on(EventObject.RESIZE, _this, _this.onResize);
            if (!Config.EDIT_MODE) {
                _this.add_DISPLAY(_this.onAdded, _this);
                _this.add_UNDISPLAY(_this.onRemoved, _this);
            }
            return _this;
        }
        /**
         * 开始检测加载完毕的情形
         */
        UIBitmap.prototype.loadAssetTest = function () {
            var _this = this;
            var varID = GameUtils.getVarID(this.image);
            // 变量的话直接返回加载完毕
            if (varID != 0) {
                // 如果网络版但未能连接服务器的话则直接返回加载成功
                if (typeof SinglePlayerGame == "undefined" && (!ClientMain.conn || !ClientMain.conn.isConnect)) {
                    this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
                    return;
                }
                // 监听变量，然后延迟关闭监听（为了优化，后续可能添加到舞台上会按照正常流程去监听，因此无需再次来回通知服务器取消监听和重新监听）
                var cb;
                Game.player.addListenerPlayerVariable(2, varID, cb = Callback.New(function (typeID, varID, value) {
                    doLoadAssetTest.apply(_this, [value]);
                    setTimeout(function () {
                        Game.player.removeListenerPlayerVariable(2, varID, cb);
                    }, 5000);
                }, this), true);
                return;
            }
            // 实际图片地址的话尝试无引用的加载，为了能够正确抛出加载完成事件
            function doLoadAssetTest(imageURL) {
                AssetManager.loadImage(imageURL, Callback.New(function () {
                    this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
                }, this), this._syncLoadedEventWhenAssetExist, false);
            }
            doLoadAssetTest.apply(this, [this.image]);
        };
        /**
         * 释放
         */
        UIBitmap.prototype.dispose = function () {
            if (!this.isDisposed) {
                var varID = GameUtils.getVarID(this.image);
                if (varID != 0 && this._onVarChange) {
                    Game.player.removeListenerPlayerVariable(2, varID, this._onVarChange);
                }
                // 释放资源
                if (this.___currentRequestLoadImages)
                    AssetManager.disposeImages(this.___currentRequestLoadImages);
                //删除引用即可
                if (this._texture) {
                    this._texture.offAll();
                    this._texture = null;
                }
                this._uiImage.removeSelf();
                this._uiImage.offAll();
                this._uiImage.destroy(true);
                this._uiImage = null;
            }
            _super.prototype.dispose.call(this);
        };
        //------------------------------------------------------------------------------------------------------
        // 编辑器模式下初始化
        //------------------------------------------------------------------------------------------------------
        UIBitmap.prototype.inEditorInit = function () {
            this.width = 100;
            this.height = 100;
            this.image = this._defaultSkins[0];
            this._grid9 = "0,0,0,0,0";
            this._emptyImage = true;
        };
        Object.defineProperty(UIBitmap.prototype, "_source", {
            get: function () {
                var varID = GameUtils.getVarID(this.image);
                if (varID != 0)
                    return null;
                return AssetManager.getImage(this.image);
            },
            enumerable: false,
            configurable: true
        });
        UIBitmap.prototype.onResize = function () {
            if (this.isDisposed)
                return;
            // 使用texture的情况
            if (this._imageByTexture) {
                this._uiImage.graphics.clear();
                this._uiImage.graphics.drawTexture(this.texture, 0, 0, this.width, this.height);
            }
            else {
                this.onImageChange(this._image, this.__imageURLAutoID);
            }
            this.refreshFlip();
        };
        /**
         * 编辑器专用信息说明
         */
        UIBitmap.prototype.inEditorInfo = function () {
            var varID = GameUtils.getVarID(this.image);
            if (this._source) {
                return "图片原始尺寸：" + this._source.width + "," + this._source.height + " " + this.mouseEnabled;
            }
            return varID != 0 ? "\u5B57\u7B26\u4E32\u53D8\u91CF\u3010" + MathUtils.fixIntDigit(varID.toString()) + "-" + GameListData.getName(Game.data.playerStringNameList, varID) + "\u3011" : "";
        };
        Object.defineProperty(UIBitmap.prototype, "defaultStateImage", {
            /**
             * 设置是图片的默认状态(是否使用tex宽高)
             */
            get: function () {
                return this._defaultStateImage;
            },
            set: function (v) {
                this._defaultStateImage = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIBitmap.prototype, "image", {
            //------------------------------------------------------------------------------------------------------
            // 
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._image;
            },
            set: function (v) {
                var _this = this;
                if (this.isDisposed)
                    return;
                this.__imageURLAutoID = ObjectUtils.getInstanceID();
                var lastImage = this.image;
                this._texture = null;
                this._imageByTexture = false;
                // 游戏运行时中如果当前是变量模式则停止掉之前的字符串变量改变的监听
                if (!Config.EDIT_MODE) {
                    var lastVarID = GameUtils.getVarID(this._image);
                    if (lastVarID != 0 && this._onVarChange)
                        Game.player.removeListenerPlayerVariable(2, lastVarID, this._onVarChange);
                }
                // 设置值
                // var lastImage = v;
                if (this._image != v) {
                    this._uiImage.skin = null;
                }
                this._image = v;
                var varID = GameUtils.getVarID(this._image);
                // 游戏运行时且显示在舞台上的话则监听字符串变量改变
                if (!Config.EDIT_MODE) {
                    if (this.displayedInStage && varID != 0) {
                        this._onVarChange = Callback.New(function (__imageURLAutoID, typeID, varID, value) {
                            _this.onImageChange(value, __imageURLAutoID);
                        }, this, [this.__imageURLAutoID]);
                        Game.player.addListenerPlayerVariable(2, varID, this._onVarChange);
                    }
                }
                // 设置图像
                if (varID == 0 || Config.EDIT_MODE)
                    this.onImageChange(v, this.__imageURLAutoID);
                // 派发事件
                if (lastImage != v && !this.__forceChange)
                    this.event(EventObject.CHANGE);
            },
            enumerable: false,
            configurable: true
        });
        UIBitmap.prototype.setImageForce = function (v) {
            this.__forceChange = true;
            this.image = v;
            this.__forceChange = false;
        };
        Object.defineProperty(UIBitmap.prototype, "pivotType", {
            get: function () {
                return this._pivotType;
            },
            set: function (v) {
                this._pivotType = v;
                this.refreshPivotType();
            },
            enumerable: false,
            configurable: true
        });
        UIBitmap.prototype.refreshPivotType = function () {
            if (this.pivotType == 1) {
                this.pivotX = this.width * 0.5;
                this.pivotY = this.height * 0.5;
            }
            else {
                this.pivotX = 0;
                this.pivotY = 0;
            }
        };
        Object.defineProperty(UIBitmap.prototype, "grid9Width", {
            //------------------------------------------------------------------------------------------------------
            // 九宫格
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._uiImage.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIBitmap.prototype, "grid9Height", {
            get: function () {
                return this._uiImage.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIBitmap.prototype, "grid9Skin", {
            get: function () {
                return this._image;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIBitmap.prototype, "grid9", {
            get: function () {
                return this._grid9;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._grid9 = this._uiImage.sizeGrid = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIBitmap.prototype, "texture", {
            // @ts-ignore
            get: function () {
                return this._texture;
            },
            set: function (v) {
                this.__imageURLAutoID = ObjectUtils.getInstanceID();
                this._texture = v;
                this._uiImage.graphics.clear();
                this._uiImage.graphics.drawTexture(v, 0, 0, this.width, this.height);
                this._imageByTexture = true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIBitmap.prototype, "flip", {
            get: function () {
                return this._flip;
            },
            set: function (v) {
                this._flip = v;
                this.refreshFlip();
            },
            enumerable: false,
            configurable: true
        });
        /**
         * 显示舞台上回调事件
         * @param e
         */
        UIBitmap.prototype.onAdded = function (e) {
            var _this = this;
            if (this.isDisposed)
                return;
            var varID = GameUtils.getVarID(this.image);
            if (varID != 0) {
                this._onVarChange = Callback.New(function (__imageURLAutoID, typeID, varID, value) {
                    _this.onImageChange(value, __imageURLAutoID);
                }, this, [this.__imageURLAutoID]);
                Game.player.addListenerPlayerVariable(2, varID, this._onVarChange);
            }
        };
        /**
         * 从舞台上移除回调事件
         * @param e
         */
        UIBitmap.prototype.onRemoved = function (e) {
            var varID = GameUtils.getVarID(this.image);
            if (varID != 0 && this._onVarChange) {
                Game.player.removeListenerPlayerVariable(2, varID, this._onVarChange);
            }
        };
        /**
         * 刷新图片显示
         * @param v
         */
        UIBitmap.prototype.onImageChange = function (v, imageURLAutoID) {
            var _this = this;
            if (imageURLAutoID === void 0) { imageURLAutoID = null; }
            if (this instanceof UIComponent.UIVideo)
                return;
            // 已卸载或直接设置texture的话以及过期的设置则忽略
            if (this.isDisposed || this._imageByTexture || (imageURLAutoID != this.__imageURLAutoID))
                return;
            var varID = GameUtils.getVarID(v);
            this._uiImage.width = this.width;
            this._uiImage.height = this.height;
            // 编辑器模式的情况
            if (Config.EDIT_MODE) {
                if (varID != 0) {
                    v = this._defaultSkins[2];
                    ;
                }
            }
            // 运行时模式：当变量模式下不显示
            else {
                if (varID != 0) {
                    this.refreshPivotType();
                    return;
                }
            }
            // 实际资源更换的情况：释放原实际图像，加载新的图像
            if (v != this._uiImage.skin) {
                this.refImageRecord(0, v);
                this._uiImage.skin = v;
                AssetManager.loadImage(v, Callback.New(function (tex) {
                    // 已释放或过期则忽略
                    if (_this.isDisposed || (imageURLAutoID != _this.__imageURLAutoID))
                        return;
                    //useDPCoord模式下如果宽高为0，重新设置图片宽高
                    if (_this.useDPCoord && (_this.width == 0 || _this.height == 0)) {
                        _this.width = _this._uiImage.width = _this.dpWidth;
                        _this.height = _this._uiImage.height = _this.dpHeight;
                    }
                    _this._texture = tex;
                    //编辑器模式下第一次设置图片地址使用tex宽高
                    var editorFirst = _this._defaultSkins.indexOf(v) == -1 && _this._emptyImage;
                    //非编辑器模式空图片并且宽高为0时使用tex宽高
                    if ((editorFirst || ((_this.width == 0 || _this.height == 0) && _this._defaultStateImage)) && tex) {
                        if (_this.useDPCoord) {
                            _this._dpTextureWidth = tex.width;
                            _this._dpTextureHeight = tex.height;
                            _this._dpDirty = true;
                            _this.dpCoordToRealCoord();
                        }
                        _this.width = _this._uiImage.width = tex.width;
                        _this.height = _this._uiImage.height = tex.height;
                        _this._defaultStateImage = false;
                        _this._emptyImage = false;
                    }
                    _this.event(EventObject.LOADED);
                }, this), true);
            }
            else {
                this._uiImage.skin = v;
            }
            this.refreshPivotType();
        };
        /**
         * 刷新水平翻转
         */
        UIBitmap.prototype.refreshFlip = function () {
            if (this.flip) {
                this._uiImage.scaleX = -1;
                this._uiImage.x = this.width;
            }
            else {
                this._uiImage.scaleX = 1;
                this._uiImage.x = 0;
            }
        };
        /**
         * 自定义方法名称
         */
        UIBitmap.customCompFunctionNames = ["image", "grid9", "flip", "pivotType"];
        return UIBitmap;
    }(UIComponent.UIBase));
    UIComponent.UIBitmap = UIBitmap;
})(UIComponent || (UIComponent = {}));
/**
 * 按钮控件
 * Created by 黑暗之神KDS on 2018-10-12 14:00:10.
 */
var UIComponent;
(function (UIComponent) {
    var UIButton = /** @class */ (function (_super) {
        __extends(UIButton, _super);
        /**
         * 构造函数
         */
        function UIButton() {
            var _this = _super.call(this) || this;
            _this._image1 = "";
            _this._image2 = "";
            _this._image3 = "";
            _this._grid9img1 = "0,0,0,0,0";
            _this._grid9img2 = "0,0,0,0,0";
            _this._grid9img3 = "0,0,0,0,0";
            _this._color = "#000000";
            /**
             * 状态
             */
            _this._state = 1;
            _this._image = new UIImage();
            _this.addChild(_this._image);
            _this._tfBox = new Sprite();
            _this._tf = new UIComponent.UIString();
            _this._tf.mouseEventEnabled = false;
            _this._tfBox.addChild(_this._tf);
            _this.addChild(_this._tfBox);
            _this.className = "UIButton";
            _this.add_MOUSEOVER(_this.onmouseover, _this);
            _this.add_MOUSEOUT(_this.onmouseout, _this);
            _this.add_MOUSEDOWN(_this.onmousedown, _this);
            _this.add_MOUSEUP(_this.onmouseup, _this);
            _this.on(EventObject.RESIZE, _this, _this.onResize);
            _this.color = "#999999";
            _this.align = 1;
            _this.valign = 1;
            _this.fontSize = 16;
            return _this;
        }
        Object.defineProperty(UIButton.prototype, "image1", {
            /**
             * 正常状态下图片
             */
            get: function () {
                return this._image1;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                // 设置
                this._image1 = v;
                // 如果存在旧的已占用的图片资源，则减少引用
                this.refImageRecord(0, v);
                AssetManager.loadImage(v);
                this.onImageChange(v, 1);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "image2", {
            /**
             * 鼠标移入时图片
             */
            get: function () {
                return this._image2;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                this._image2 = v;
                // 如果存在旧的已占用的图片资源，则减少引用
                this.refImageRecord(1, v);
                AssetManager.loadImage(v);
                this.onImageChange(v, 2);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "image3", {
            /**
             * 鼠标点击时图片
             */
            get: function () {
                return this._image3;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                this._image3 = v;
                // 如果存在旧的已占用的图片资源，则减少引用
                this.refImageRecord(2, v);
                AssetManager.loadImage(v);
                this.onImageChange(v, 3);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "smooth", {
            /**
             * 平滑字体边缘
             */
            get: function () {
                return this._smooth;
            },
            /**
             * 平滑字体边缘
             */
            set: function (v) {
                this._smooth = v;
                this._tf.smooth = v;
            },
            enumerable: false,
            configurable: true
        });
        UIButton.prototype.inEditorInit = function () {
            this.label = "Button";
            this.width = 216;
            this.height = 54;
            this.image1 = "asset/image/picture/control/btn_normal.png";
            this.image2 = "asset/image/picture/control/btn_over.png";
            this.image3 = "asset/image/picture/control/btn_click.png";
        };
        /**
         * 当图片改变时
         * @param v
         */
        UIButton.prototype.onImageChange = function (v, index) {
            // 忽略掉过期的状态
            this.setState(this._state);
        };
        /**
         * 清理鼠标事件
         */
        UIButton.prototype.clearMouseEvent = function () {
            this.remove_MOUSEOVER(this.onmouseover, this);
            this.remove_MOUSEOUT(this.onmouseout, this);
            this.remove_MOUSEDOWN(this.onmousedown, this);
            this.remove_MOUSEUP(this.onmouseup, this);
        };
        /**
         * 开始检测加载完毕的情形
         */
        UIButton.prototype.loadAssetTest = function () {
            var _this = this;
            // 预加载自身的皮肤图集，不引用，仅用于加载回调
            AssetManager.loadImages([this.image1, this.image2, this.image3], Callback.New(function () {
                _this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, false);
        };
        /**
         * 释放
         */
        UIButton.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (this.___currentRequestLoadImages)
                    AssetManager.disposeImages(this.___currentRequestLoadImages);
                this._tf.dispose();
                this._tf = null;
                this._tfBox.removeSelf();
                this._tfBox = null;
                this._image.removeSelf();
                this._image = null;
            }
            _super.prototype.dispose.call(this);
        };
        Object.defineProperty(UIButton.prototype, "grid9img1Width", {
            //------------------------------------------------------------------------------------------------------
            // 九宫格
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img1Height", {
            get: function () {
                return this.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img1Skin", {
            get: function () {
                return this._image1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img1", {
            get: function () {
                return this._grid9img1;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._grid9img1 = v;
                this.refresImage(1);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img2Width", {
            get: function () {
                return this.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img2Height", {
            get: function () {
                return this.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img2Skin", {
            get: function () {
                return this._image2;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img2", {
            get: function () {
                return this._grid9img2;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._grid9img2 = v;
                this.refresImage(2);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img3Width", {
            get: function () {
                return this.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img3Height", {
            get: function () {
                return this.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img3Skin", {
            get: function () {
                return this._image3;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img3", {
            get: function () {
                return this._grid9img3;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._grid9img3 = v;
                this.refresImage(3);
            },
            enumerable: false,
            configurable: true
        });
        UIButton.prototype.refresImage = function (state) {
            var url = this["image" + this._state];
            if (url != this._image.skin)
                return;
            this._image.sizeGrid = this["grid9img" + this._state];
        };
        Object.defineProperty(UIButton.prototype, "label", {
            //------------------------------------------------------------------------------------------------------
            // 文本
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._tf.text;
            },
            set: function (v) {
                this._tf.text = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "align", {
            get: function () {
                return this._tf.align;
            },
            set: function (v) {
                this._tf.align = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "valign", {
            get: function () {
                return this._tf.valign;
            },
            set: function (v) {
                this._tf.valign = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "bold", {
            get: function () {
                return this._tf.bold;
            },
            set: function (v) {
                this._tf.bold = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "italic", {
            get: function () {
                return this._tf.italic;
            },
            set: function (v) {
                this._tf.italic = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "font", {
            get: function () {
                return this._tf.font;
            },
            set: function (v) {
                this._tf.font = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (v) {
                this._color = v;
                this.setFontColorState(this._state);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "overColor", {
            get: function () {
                return this._overColor ? this._overColor : this._color;
            },
            set: function (v) {
                this._overColor = v;
                this.setFontColorState(this._state);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "clickColor", {
            get: function () {
                return this._clickColor ? this._clickColor : this._color;
            },
            set: function (v) {
                this._clickColor = v;
                this.setFontColorState(this._state);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "fontSize", {
            get: function () {
                return this._tf.fontSize;
            },
            set: function (v) {
                this._tf.fontSize = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "letterSpacing", {
            get: function () {
                return this._tf.letterSpacing;
            },
            set: function (v) {
                this._tf.letterSpacing = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "textDx", {
            get: function () {
                return this._tf.x;
            },
            set: function (v) {
                this._tf.x = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "textDy", {
            get: function () {
                return this._tf.y;
            },
            set: function (v) {
                this._tf.y = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "textStroke", {
            get: function () {
                return this._tf.stroke;
            },
            set: function (v) {
                this._tf.stroke = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "textStrokeColor", {
            get: function () {
                return this._tf.strokeColor;
            },
            set: function (v) {
                this._tf.strokeColor = v;
            },
            enumerable: false,
            configurable: true
        });
        //------------------------------------------------------------------------------------------------------
        // 事件
        //------------------------------------------------------------------------------------------------------
        UIButton.prototype.onmouseover = function (e) {
            if (e.target == this)
                this.setState(2);
        };
        UIButton.prototype.onmouseout = function (e) {
            if (e.target == this)
                this.setState(1);
        };
        UIButton.prototype.onmousedown = function (e) {
            if (e.target == this)
                this.setState(3);
        };
        UIButton.prototype.onmouseup = function (e) {
            if (e.target == this)
                this.setState(2);
        };
        /**
         * 当重置大小时
         */
        UIButton.prototype.onResize = function () {
            if (this.isDisposed)
                return;
            this.setState(this._state);
            this._tf.width = this.width;
            this._tf.height = this.height;
        };
        //------------------------------------------------------------------------------------------------------
        // 效果
        //------------------------------------------------------------------------------------------------------
        UIButton.prototype.setState = function (state) {
            if (this.isDisposed)
                return;
            this._state = state;
            this.graphics.clear();
            var url = this["image" + this._state];
            if (url) {
                this._image.skin = url;
                this._image.width = this.width;
                this._image.height = this.height;
                this._image.sizeGrid = this["grid9img" + this._state];
                // this.loadImage(url, 0, 0, Math.abs(this.width), Math.abs(this.height));
            }
            else {
                this._image.skin = null;
            }
            this.setFontColorState(state);
        };
        UIButton.prototype.setFontColorState = function (state) {
            switch (state) {
                case 1:
                    this._tf.color = this._color;
                    break;
                case 2:
                    this._tf.color = this._overColor ? this._overColor : this._color;
                    break;
                case 3:
                    this._tf.color = this._clickColor ? this._clickColor : this._color;
                    break;
            }
        };
        /**
        * 自定义方法名称
        */
        UIButton.customCompFunctionNames = ["label", "image1", "grid9img1", "image2", "grid9img2", "image3", "grid9img3", "fontSize", "color", "overColor",
            "clickColor", "bold", "italic", "smooth", "align", "valign", "letterSpacing", "font", "textDx", "textDy", "textStroke", "textStrokeColor"];
        return UIButton;
    }(UIComponent.UIBase));
    UIComponent.UIButton = UIButton;
})(UIComponent || (UIComponent = {}));
/**
 * Created by 黑暗之神KDS on 2019-04-14 21:41:10.
 */
var UIComponent;
(function (UIComponent) {
    var UICheckBox = /** @class */ (function (_super) {
        __extends(UICheckBox, _super);
        function UICheckBox() {
            var _this = _super.call(this) || this;
            _this._grid9img1 = "0,0,0,0,0";
            _this._grid9img2 = "0,0,0,0,0";
            _this._image = new UIImage();
            _this.addChild(_this._image);
            _this.className = "UICheckBox";
            _this.on(EventObject.RESIZE, _this, _this.refresh);
            if (!Config.EDIT_MODE) {
                _this.add_CLICK(function () {
                    this.selected = !this.selected;
                }, _this);
            }
            return _this;
        }
        UICheckBox.prototype.inEditorInit = function () {
            this.width = 14;
            this.height = 14;
            this.image1 = "asset/image/picture/control/check_unselected.png";
            this.image2 = "asset/image/picture/control/check_selected.png";
        };
        /**
         * 开始检测加载完毕的情形
         */
        UICheckBox.prototype.loadAssetTest = function () {
            AssetManager.loadImages([this.image1, this.image2], Callback.New(function () {
                this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, false);
        };
        /**
         * 释放
         */
        UICheckBox.prototype.dispose = function () {
            if (!this.isDisposed) {
                // 释放资源
                if (this.___currentRequestLoadImages)
                    AssetManager.disposeImages(this.___currentRequestLoadImages);
                //释放子对象
                this._image.removeSelf();
                this._image.offAll();
                this._image = null;
            }
            _super.prototype.dispose.call(this);
        };
        Object.defineProperty(UICheckBox.prototype, "image1", {
            //------------------------------------------------------------------------------------------------------
            // 
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._image1;
            },
            set: function (v) {
                this._image1 = v;
                this.refImageRecord(0, v);
                AssetManager.loadImage(v); //增加引用
                this.refresh();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UICheckBox.prototype, "image2", {
            get: function () {
                return this._image2;
            },
            set: function (v) {
                this._image2 = v;
                this.refImageRecord(1, v);
                AssetManager.loadImage(v);
                ; //增加引用
                this.refresh();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UICheckBox.prototype, "selected", {
            get: function () {
                return this._selected;
            },
            set: function (v) {
                if (v != this._selected) {
                    this._selected = v;
                    this.refresh();
                    if (!this.__forceChange) {
                        this.event(EventObject.CHANGE);
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        UICheckBox.prototype.setSelectedForce = function (v) {
            this.__forceChange = true;
            this.selected = v;
            this.__forceChange = false;
        };
        Object.defineProperty(UICheckBox.prototype, "grid9img1Width", {
            //------------------------------------------------------------------------------------------------------
            // 九宫格
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._image.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UICheckBox.prototype, "grid9img1Height", {
            get: function () {
                return this._image.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UICheckBox.prototype, "grid9img1Skin", {
            get: function () {
                return this._image1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UICheckBox.prototype, "grid9img1", {
            get: function () {
                return this._grid9img1;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._grid9img1 = v;
                this.refresh();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UICheckBox.prototype, "grid9img2Width", {
            get: function () {
                return this._image.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UICheckBox.prototype, "grid9img2Height", {
            get: function () {
                return this._image.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UICheckBox.prototype, "grid9img2Skin", {
            get: function () {
                return this._image2;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UICheckBox.prototype, "grid9img2", {
            get: function () {
                return this._grid9img2;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._grid9img2 = v;
                this.refresh();
            },
            enumerable: false,
            configurable: true
        });
        //------------------------------------------------------------------------------------------------------
        // 刷新显示
        //------------------------------------------------------------------------------------------------------
        UICheckBox.prototype.refresh = function () {
            var _this = this;
            if (this.isDisposed)
                return;
            this.graphics.clear();
            var url = this._selected ? this.image2 : this.image1;
            var gridText = this._selected ? this._grid9img2 : this._grid9img1;
            if (url) {
                AssetManager.loadImage(url, Callback.New(function (url, tex) {
                    if (_this.isDisposed)
                        return;
                    var thisUrl = _this._selected ? _this.image2 : _this.image1;
                    if (thisUrl != url)
                        return;
                    _this._image.skin = url;
                    _this._image.width = _this.width;
                    _this._image.height = _this.height;
                    _this._image.sizeGrid = gridText;
                }, this, [url]), true, false);
            }
        };
        Object.defineProperty(UICheckBox.prototype, "onChangeFragEvent", {
            //------------------------------------------------------------------------------------------------------
            // 事件
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._onChangeFragEvent;
            },
            set: function (v) {
                this._onChangeFragEvent = v;
                if (v) {
                    this.off(EventObject.CHANGE, this, this.onChange_private);
                    this.on(EventObject.CHANGE, this, this.onChange_private);
                }
                else {
                    this.off(EventObject.CHANGE, this, this.onChange_private);
                }
            },
            enumerable: false,
            configurable: true
        });
        UICheckBox.prototype.onChange_private = function () {
            if (Config.SINGLE_PLAYER_CORE) {
                if (this._onChangeFragEvent && this.guiRoot && !this.guiRoot.onlyForPreload) {
                    CommandPage.startTriggerFragmentEvent(this._onChangeFragEvent, Game.player.sceneObject, Game.player.sceneObject);
                }
            }
        };
        /**
         * 自定义方法名称
         */
        UICheckBox.customCompFunctionNames = ["selected", "image1", "grid9img1", "image2", "grid9img2"];
        return UICheckBox;
    }(UIComponent.UIBase));
    UIComponent.UICheckBox = UICheckBox;
})(UIComponent || (UIComponent = {}));
/**
 * 下拉框控件 UIComboBox
 *
 * Created by 黑暗之神KDS on 2019-11-11 01:13:31.
 */
var UIComponent;
(function (UIComponent) {
    var UIComboBox = /** @class */ (function (_super) {
        __extends(UIComboBox, _super);
        function UIComboBox() {
            var _this = _super.call(this) || this;
            _this._displayItemSize = 5;
            _this._selectedIndex = 0;
            _this._itemAlign = 0;
            _this._itemValign = 1;
            _this._itemBold = false;
            _this._itemItalic = false;
            _this._itemOverColor = "#FFFFFF";
            _this._itemOverBgColor = "#000000";
            _this._itemFontSize = 12;
            _this._itemLetterSpacing = 0;
            _this._itemTextDx = 2;
            _this._itemTextDy = 0;
            _this._itemTextStroke = 0;
            _this._itemTextStrokeColor = "#000000";
            _this._listScrollBg = "asset/image/picture/control/uicomboboxbg.png";
            _this._listScrollBar = "asset/image/picture/control/uicomboboxslider.png";
            _this._isOpen = false;
            _this._root = new Sprite();
            _this.addChild(_this._root);
            _this.className = "UIComboBox";
            _this._bgImg = new UIComponent.UIBitmap();
            _this._tf = new UIComponent.UIString();
            _this._root.addChild(_this._bgImg);
            _this._root.addChild(_this._tf);
            _this._tf.valign = 1;
            _this._tf.align = 1;
            if (!Config.EDIT_MODE) {
                _this.on(EventObject.MOUSE_DOWN, _this, _this.onMouseDown);
                _this._list = new UIComponent.UIList();
                _this._list.alpha = _this._listAlpha;
                _this._list.spaceY = 0;
                _this._list.overImageOnTop = false;
                _this._list.overImageAlpha = 1;
                _this._list.onCreateItem = Callback.New(function (ui, data, index) {
                    ui.on(EventObject.MOUSE_DOWN, _this, _this.closeList, [index]);
                    ui.hitArea = new Rectangle(0, 0, _this.width, _this.itemHeight);
                    if (_this.itemFont)
                        ui.label.font = _this.itemFont;
                    ui.label.color = _this.itemColor;
                    ui.label.smooth = _this.smooth;
                    ui.label.align = _this.itemAlign;
                    ui.label.valign = _this.itemValign;
                    ui.label.fontSize = _this.itemFontSize;
                    ui.label.letterSpacing = _this.itemLetterSpacing;
                    ui.label.bold = _this.itemBold;
                    ui.label.italic = _this.itemItalic;
                    ui.label.x = _this.itemTextDx;
                    ui.label.y = _this.itemTextDy;
                    ui.label.stroke = _this.itemTextStroke;
                    ui.label.strokeColor = _this.itemTextStrokeColor;
                    ui.label.height = _this.itemHeight;
                    ui.label.width = _this.width;
                    ui.on(EventObject.MOUSE_OVER, _this, _this.onItemOver, [ui]);
                    ui.on(EventObject.MOUSE_OUT, _this, _this.onItemOut, [ui]);
                }, _this);
                _this._list.on(EventObject.MOUSE_DOWN, _this, function (e) {
                    e.stopPropagation();
                });
                _this._list.scrollShowType = 2;
            }
            _this.on(EventObject.RESIZE, _this, _this.onResize);
            _this.width = 200;
            _this.height = 30;
            _this.itemHeight = 20;
            _this.listBgColor = "#FFFFFF";
            _this.listAlpha = 1;
            _this.color = "#FFFFFF";
            _this.itemColor = "#000000";
            _this.fontSize = 16;
            if (Config.EDIT_MODE) {
                _this._tf.text = "选项文字";
                _this.itemLabels = "选项1,选项2,选项3";
            }
            return _this;
        }
        UIComboBox.prototype.dispose = function () {
            if (!this.isDisposed) {
                //舞台侦听事件需要清理
                os.remove_ENTERFRAME(this.refreshListPosition, this);
                this._bgImg.dispose();
                this._bgImg = null;
                this._tf.dispose();
                this._tf = null;
                if (this._list)
                    this._list.dispose();
                this._list = null;
                this._root.removeSelf();
                this._root.offAll();
                this._root = null;
            }
            _super.prototype.dispose.call(this);
        };
        UIComboBox.prototype.inEditorInit = function () {
            this._bgImg.image = "asset/image/picture/control/uicombobox.png";
        };
        UIComboBox.prototype.loadAssetTest = function () {
            AssetManager.loadImages([this._bgImg.image, this._listScrollBg, this._listScrollBar], Callback.New(function () {
                this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, false);
        };
        UIComboBox.prototype.onResize = function (e) {
            if (this.isDisposed)
                return;
            this._bgImg.width = this.width;
            this._bgImg.height = this.height;
            this._tf.width = this.width;
            this._tf.height = this.height;
            if (this._list) {
                this._list.width = this.width;
                this._list.height = 200;
            }
        };
        Object.defineProperty(UIComboBox.prototype, "bgSkin", {
            //------------------------------------------------------------------------------------------------------
            // 控件本体
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._bgImg.image;
            },
            set: function (v) {
                this._bgImg.image = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "align", {
            get: function () {
                return this._tf.align;
            },
            set: function (v) {
                v = Math.floor(v);
                this._tf.align = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "valign", {
            get: function () {
                return this._tf.valign;
            },
            set: function (v) {
                v = Math.floor(v);
                this._tf.valign = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "bold", {
            get: function () {
                return this._tf.bold;
            },
            set: function (v) {
                this._tf.bold = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "italic", {
            get: function () {
                return this._tf.italic;
            },
            set: function (v) {
                this._tf.italic = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "font", {
            get: function () {
                return this._tf.font;
            },
            set: function (v) {
                this._tf.font = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "color", {
            get: function () {
                return this._tf.color;
            },
            set: function (v) {
                this._tf.color = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "fontSize", {
            get: function () {
                return this._tf.fontSize;
            },
            set: function (v) {
                this._tf.fontSize = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "letterSpacing", {
            get: function () {
                return this._tf.letterSpacing;
            },
            set: function (v) {
                this._tf.letterSpacing = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "textDx", {
            get: function () {
                return this._tf.x;
            },
            set: function (v) {
                this._tf.x = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "textDy", {
            get: function () {
                return this._tf.y;
            },
            set: function (v) {
                this._tf.y = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "textStroke", {
            get: function () {
                return this._tf.stroke;
            },
            set: function (v) {
                this._tf.stroke = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "textStrokeColor", {
            get: function () {
                return this._tf.strokeColor;
            },
            set: function (v) {
                this._tf.strokeColor = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "bgGrid9Width", {
            //-----
            //------------------------------------------------------------------------------------------------------
            // 九宫格
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._bgImg.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "bgGrid9Height", {
            get: function () {
                return this._bgImg.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "bgGrid9Skin", {
            get: function () {
                return this._bgImg.image;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "bgGrid9", {
            get: function () {
                var gridText = this._bgImg.grid9;
                if (!gridText || gridText == "")
                    gridText = "0,0,0,0,0";
                return gridText;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._bgImg.grid9 = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "smooth", {
            /**
             * 平滑字体边缘
             */
            get: function () {
                return this._smooth;
            },
            /**
             * 平滑字体边缘
             */
            set: function (v) {
                this._smooth = v;
                this._tf.smooth = v;
            },
            enumerable: false,
            configurable: true
        });
        //------------------------------------------------------------------------------------------------------
        // LIST
        //------------------------------------------------------------------------------------------------------
        UIComboBox.prototype.onMouseDown = function (e) {
            var _this = this;
            if (!this._itemLabelArr || this._list.stage)
                return;
            this._overItem = null;
            this._list.itemModelClass = ComboboxListRender;
            var arr = [];
            var itemLabels = this._itemLabelArr;
            for (var i = 0; i < itemLabels.length; i++) {
                var item = new UIListItemData();
                item.label = itemLabels[i];
                arr.push(item);
            }
            this._list.items = arr;
            stage.addChild(this._list);
            this.refreshListPosition();
            this._list.height = this.itemHeight * Math.min(this.displayItemSize, itemLabels.length);
            this._list.graphics.clear();
            this._list.graphics.drawRect(0, 0, this._list.width, this.itemHeight * itemLabels.length, this.listBgColor);
            this._list.overImage.image = "";
            this._list.overImage.graphics.clear();
            this._list.overImage.graphics.drawRect(0, 0, this.width, this.itemHeight, this.itemOverBgColor);
            if (this.selectedIndex >= 0 && this.selectedIndex < itemLabels.length) {
                this._list["_overImageBox"].y = this.selectedIndex * this.itemHeight;
                this._overItem = this._list.getItemUI(this.selectedIndex);
                this._overItem.label.color = this.itemOverColor;
            }
            this._isOpen = true;
            this.event(UIComboBox.OPEN);
            Callback.CallLater(function () {
                stage.once(EventObject.MOUSE_DOWN, _this, _this.closeList, [null]);
                os.add_ENTERFRAME(_this.refreshListPosition, _this);
            }, this);
        };
        UIComboBox.prototype.refreshListPosition = function () {
            if (!this._list || !this._list.stage)
                return;
            var p = new Point(0, this.height);
            var gp = this.localToGlobal(p);
            this._list.x = gp.x;
            this._list.y = gp.y;
        };
        UIComboBox.prototype.onItemOver = function (ui) {
            if (this._overItem)
                this._overItem.label.color = this.itemColor;
            this._overItem = ui;
            ui.label.color = this.itemOverColor;
        };
        UIComboBox.prototype.onItemOut = function (ui) {
            if (this._overItem)
                this._overItem.label.color = this.itemColor;
            this._overItem = ui;
            ui.label.color = this.itemColor;
        };
        UIComboBox.prototype.closeList = function (selIndex, e) {
            if (selIndex != null)
                this.selectedIndex = selIndex;
            stage.off(EventObject.MOUSE_DOWN, this, this.closeList);
            os.remove_ENTERFRAME(this.refreshListPosition, this);
            this._list.removeSelf();
            this._isOpen = false;
            this.event(UIComboBox.CLOSE);
        };
        Object.defineProperty(UIComboBox.prototype, "selectedIndex", {
            get: function () {
                return this._selectedIndex;
            },
            set: function (v) {
                this._selectedIndex = v;
                if (Config.EDIT_MODE)
                    return;
                if (v >= 0 && v < this._itemLabelArr.length) {
                    this._tf.text = this._itemLabelArr[v];
                }
                else {
                    this._tf.text = "";
                }
                if (!this.__forceChange)
                    this.event(EventObject.CHANGE);
            },
            enumerable: false,
            configurable: true
        });
        UIComboBox.prototype.setSelectedForce = function (v) {
            this.__forceChange = true;
            this.selectedIndex = v;
            this.__forceChange = false;
        };
        Object.defineProperty(UIComboBox.prototype, "itemLabels", {
            get: function () {
                return this._itemLabels;
            },
            set: function (v) {
                if (v == null)
                    return;
                this._itemLabels = v;
                this._itemLabelArr = v.split(",");
                this.selectedIndex = this.selectedIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemHeight", {
            get: function () {
                return this._itemHeight;
            },
            set: function (v) {
                this._itemHeight = v;
                if (this._list)
                    this._list.itemHeight = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "displayItemSize", {
            get: function () {
                return this._displayItemSize;
            },
            set: function (v) {
                this._displayItemSize = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "listScrollBg", {
            get: function () {
                return this._listScrollBg;
            },
            set: function (v) {
                this._listScrollBg = v;
                if (this._list)
                    this._list.vScrollBg = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "listScrollBar", {
            get: function () {
                return this._listScrollBar;
            },
            set: function (v) {
                this._listScrollBar = v;
                if (this._list)
                    this._list.vScrollBar = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "listBgColor", {
            get: function () {
                return this._listBgColor;
            },
            set: function (v) {
                this._listBgColor = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "listAlpha", {
            get: function () {
                return this._listAlpha;
            },
            set: function (v) {
                this._listAlpha = v;
                if (this._list)
                    this._list.alpha = this._listAlpha;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemAlign", {
            get: function () {
                return this._itemAlign;
            },
            set: function (v) {
                v = Math.floor(v);
                this._itemAlign = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemValign", {
            get: function () {
                return this._itemValign;
            },
            set: function (v) {
                v = Math.floor(v);
                this._itemValign = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemBold", {
            get: function () {
                return this._itemBold;
            },
            set: function (v) {
                this._itemBold = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemItalic", {
            get: function () {
                return this._itemItalic;
            },
            set: function (v) {
                this._itemItalic = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemFont", {
            get: function () {
                return this._itemFont;
            },
            set: function (v) {
                this._itemFont = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemColor", {
            get: function () {
                return this._itemColor;
            },
            set: function (v) {
                this._itemColor = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemOverColor", {
            get: function () {
                return this._itemOverColor;
            },
            set: function (v) {
                this._itemOverColor = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemOverBgColor", {
            get: function () {
                return this._itemOverBgColor;
            },
            set: function (v) {
                this._itemOverBgColor = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemFontSize", {
            get: function () {
                return this._itemFontSize;
            },
            set: function (v) {
                this._itemFontSize = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemLetterSpacing", {
            get: function () {
                return this._itemLetterSpacing;
            },
            set: function (v) {
                this._itemLetterSpacing = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemTextDx", {
            get: function () {
                return this._itemTextDx;
            },
            set: function (v) {
                this._itemTextDx = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemTextDy", {
            get: function () {
                return this._itemTextDy;
            },
            set: function (v) {
                this._itemTextDy = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemTextStroke", {
            get: function () {
                return this._itemTextStroke;
            },
            set: function (v) {
                this._itemTextStroke = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemTextStrokeColor", {
            get: function () {
                return this._itemTextStrokeColor;
            },
            set: function (v) {
                this._itemTextStrokeColor = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "isComboBoxOpen", {
            get: function () {
                return this._isOpen;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "onChangeFragEvent", {
            //------------------------------------------------------------------------------------------------------
            // 事件
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._onChangeFragEvent;
            },
            set: function (v) {
                this._onChangeFragEvent = v;
                if (v) {
                    this.off(EventObject.CHANGE, this, this.onChange_private);
                    this.on(EventObject.CHANGE, this, this.onChange_private);
                }
                else {
                    this.off(EventObject.CHANGE, this, this.onChange_private);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIComboBox.prototype.onChange_private = function () {
            if (Config.SINGLE_PLAYER_CORE) {
                if (this._onChangeFragEvent && this.guiRoot && !this.guiRoot.onlyForPreload) {
                    CommandPage.startTriggerFragmentEvent(this._onChangeFragEvent, Game.player.sceneObject, Game.player.sceneObject);
                }
            }
        };
        /**
         * 下拉框打开事件
         */
        UIComboBox.OPEN = "UIComboBox_OPEN";
        /**
         * 下拉框关闭事件
         */
        UIComboBox.CLOSE = "UIComboBox_CLOSE";
        /**
         * 自定义方法名称
         */
        UIComboBox.customCompFunctionNames = ["itemLabels", "selectedIndex", "bgSkin", "bgGrid9", "fontSize", "color", "bold", "italic", "smooth", "align", "valign", "letterSpacing", "font", "textDx", "textStroke", "textStrokeColor", "displayItemSize", "listScrollBg", "listScrollBar", "listAlpha", "listBgColor", "itemHeight", "itemFontSize", "itemColor", "itemBold", "itemItalic", "itemAlign", "itemValign", "itemLetterSpacing", "itemFont", "itemOverColor", "itemOverBgColor", "itemTextDx", "itemTextDy", "itemTextStroke", "itemTextStrokeColor", "onChangeFragEvent"];
        return UIComboBox;
    }(UIComponent.UIBase));
    UIComponent.UIComboBox = UIComboBox;
    var ComboboxListRender = /** @class */ (function (_super) {
        __extends(ComboboxListRender, _super);
        function ComboboxListRender() {
            var _this = _super.call(this) || this;
            _this.label = new UIComponent.UIString();
            _this.label.wordWrap = false;
            _this.addChild(_this.label);
            return _this;
        }
        ComboboxListRender.prototype.dispose = function () {
            if (this.label)
                this.label.dispose();
            this.label = null;
            _super.prototype.destroy.call(this, true);
        };
        return ComboboxListRender;
    }(Sprite));
})(UIComponent || (UIComponent = {}));
/**
 * 自定义数值组件
 * Created by 黑暗之神KDS on 2020-06-20 12:04:06.
 */
var UIComponent;
(function (UIComponent) {
    var UICustomGameNumber = /** @class */ (function (_super) {
        __extends(UICustomGameNumber, _super);
        /**
         * 构造函数
         */
        function UICustomGameNumber() {
            var _this = _super.call(this) || this;
            _this._customData = [1, {}, {}];
            /**
             * 编辑器预览
             */
            _this._previewNum = 2;
            /**
             * 小数点设置
             */
            _this._previewFixed = 0;
            _this.className = "UICustomGameNumber";
            _this._tf.text = "";
            if (!Config.EDIT_MODE) {
                _this.on(EventObject.DISPLAY, _this, _this.onDisplay);
                _this.on(EventObject.UNDISPLAY, _this, _this.onUnDisplay);
            }
            return _this;
        }
        /**
         * 编辑器初始化
         */
        UICustomGameNumber.prototype.inEditorInit = function () {
            _super.prototype.inEditorInit.call(this);
            this.customData = this.customData;
        };
        /**
         * 当显示时
         */
        UICustomGameNumber.prototype.onDisplay = function () {
            os.add_ENTERFRAME(this.refreshDataDisplay, this);
            this.refreshDataDisplay();
        };
        /**
         * 当不再显示时
         */
        UICustomGameNumber.prototype.onUnDisplay = function () {
            os.remove_ENTERFRAME(this.refreshDataDisplay, this);
        };
        Object.defineProperty(UICustomGameNumber.prototype, "customData", {
            /**
             * 获取自定义数据
             */
            get: function () {
                return this._customData;
            },
            /**
             * 设置自定义数据
             * @param v [自定义游戏数据显示ID,objValue,idValue]
             */
            set: function (v) {
                this._customData = v;
                if (v == null) {
                    this._tf.text = "0";
                    if (this._shadowEnabled) {
                        this._tf2.color = this._shadowColor;
                        this._tf2.text = this._tf.text;
                    }
                    return;
                }
                if (Config.EDIT_MODE) {
                    this.refreshEditorDataDisplay();
                }
                else if (typeof CustomGameNumber != "undefined") {
                    var customDataDisplayID = v[0];
                    this._customDataDisplayFunc = CustomGameNumber["f" + customDataDisplayID];
                    this.refreshDataDisplay();
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * 刷新数据显示
         */
        UICustomGameNumber.prototype.refreshDataDisplay = function () {
            if (this._customData == null || !this._customDataDisplayFunc) {
                this._tf.text = "";
                if (this._shadowEnabled) {
                    this._tf2.color = this._shadowColor;
                    this._tf2.text = "";
                }
                return;
            }
            var value = this._customDataDisplayFunc(null, this.customData[1]);
            if (value == null || isNaN(value)) {
                this._tf.text = "";
                if (this._shadowEnabled) {
                    this._tf2.color = this._shadowColor;
                    this._tf2.text = "";
                }
                return;
            }
            this._tf.text = value.toFixed(this._previewFixed);
            if (this._shadowEnabled) {
                this._tf2.color = this._shadowColor;
                this._tf2.text = this._tf.text;
            }
        };
        Object.defineProperty(UICustomGameNumber.prototype, "previewNum", {
            //------------------------------------------------------------------------------------------------------
            // 编辑器预览属性[0-游戏数值标题 1-游戏数值描述 2-一位数预览 3-二位数预览 4-三位数预览 5-四位数预览 6-五位数预览]
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._previewNum;
            },
            set: function (v) {
                if (v != this._previewNum) {
                    this._previewNum = v;
                    this.refreshEditorDataDisplay();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UICustomGameNumber.prototype, "previewFixed", {
            //------------------------------------------------------------------------------------------------------
            // 小数点设置 【0-整数 1-保留1位小数点 2-保留2位小数点 3-保留3位小数点 4-保留4位小数点 5-保留5位小数点 6-保留6位小数点】
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._previewFixed;
            },
            set: function (v) {
                if (v != this._previewFixed) {
                    this._previewFixed = v;
                    this.refreshEditorDataDisplay();
                }
            },
            enumerable: false,
            configurable: true
        });
        //------------------------------------------------------------------------------------------------------
        // 编辑器显示
        //------------------------------------------------------------------------------------------------------
        /**
         * 编辑器专用信息说明(tips信息)
         */
        UICustomGameNumber.prototype.inEditorInfo = function () {
            if (!this._customData || !this._customData[2])
                return "";
            var idValue = this._customData[2][0];
            var customDataDisplayID = this._customData[0];
            var dataName = CommandExecute.customMessage(idValue, Game.data.customDataDisplayList, customDataDisplayID);
            if (!dataName)
                return "";
            var str = StringUtils.clearHtmlTag1(dataName.title + dataName.content);
            if (str[str.length - 1] == " ")
                str = str.substr(0, str.length - 1);
            return str;
        };
        /**
         * 获取自定义游戏数值信息说明
         */
        UICustomGameNumber.prototype.getCustomGameNumberInfo = function () {
            if (!this._customData || !this._customData[2])
                return "";
            var idValue = this._customData[2][0];
            var customDataDisplayID = this._customData[0];
            var dataName = CommandExecute.customMessage(idValue, Game.data.customDataDisplayList, customDataDisplayID);
            if (!dataName)
                return "";
            var info = StringUtils.paraseCustomMessage(dataName);
            var str = info.title;
            if (this._previewNum == 1) {
                str = info.content;
                if (str[str.length - 1] == " ")
                    str = str.substr(0, str.length - 1);
            }
            return str;
        };
        /**
         * 刷新编辑器显示效果
         */
        UICustomGameNumber.prototype.refreshEditorDataDisplay = function () {
            if (!Config.EDIT_MODE)
                return;
            if (this._previewNum == 0 || this._previewNum == 1) {
                var str = this.getCustomGameNumberInfo();
                if (str)
                    this._tf.text = str;
            }
            else if (this._previewNum == 2) {
                this._tf.text = Number(0).toFixed(this._previewFixed);
            }
            else if (this._previewNum == 3) {
                this._tf.text = Number(10).toFixed(this._previewFixed);
            }
            else if (this._previewNum == 4) {
                this._tf.text = Number(100).toFixed(this._previewFixed);
            }
            else if (this._previewNum == 5) {
                this._tf.text = Number(1000).toFixed(this._previewFixed);
            }
            else if (this._previewNum == 6) {
                this._tf.text = Number(10000).toFixed(this._previewFixed);
            }
            if (this._shadowEnabled) {
                this._tf2.color = this._shadowColor;
                this._tf2.text = this._tf.text;
            }
        };
        /**
         * 释放
         */
        UICustomGameNumber.prototype.dispose = function () {
            if (!this.isDisposed)
                os.remove_ENTERFRAME(this.refreshDataDisplay, this);
            _super.prototype.dispose.call(this);
        };
        /**
         * 自定义方法名称
         */
        UICustomGameNumber.customCompFunctionNames = ["customData", "previewNum", "previewFixed", "fontSize", "color", "bold", "italic", "smooth", "align", "valign", "leading",
            "letterSpacing", "font", "wordWrap", "overflow", "shadowEnabled", "shadowColor", "shadowDx", "shadowDy", "stroke", "strokeColor"];
        return UICustomGameNumber;
    }(UIComponent.UIString));
    UIComponent.UICustomGameNumber = UICustomGameNumber;
})(UIComponent || (UIComponent = {}));
/**
 * 自定义数值组件
 * Created by 黑暗之神KDS on 2020-06-20 12:04:06.
 */
var UIComponent;
(function (UIComponent) {
    var UICustomGameString = /** @class */ (function (_super) {
        __extends(UICustomGameString, _super);
        /**
         * 构造函数
         */
        function UICustomGameString() {
            var _this = _super.call(this) || this;
            _this._customData = [1, {}, {}];
            /**
             * 编辑器模拟显示字符串
             */
            _this._inEditorText = "[STR]";
            _this.className = "UICustomGameString";
            _this._tf.text = "";
            if (!Config.EDIT_MODE) {
                _this.on(EventObject.DISPLAY, _this, _this.onDisplay);
                _this.on(EventObject.UNDISPLAY, _this, _this.onUnDisplay);
            }
            return _this;
        }
        /**
         * 编辑器初始化
         */
        UICustomGameString.prototype.inEditorInit = function () {
            _super.prototype.inEditorInit.call(this);
            this.customData = this.customData;
        };
        /**
         * 当显示时
         */
        UICustomGameString.prototype.onDisplay = function () {
            os.add_ENTERFRAME(this.refreshDataDisplay, this);
            this.refreshDataDisplay();
        };
        /**
         * 当不再显示时
         */
        UICustomGameString.prototype.onUnDisplay = function () {
            os.remove_ENTERFRAME(this.refreshDataDisplay, this);
        };
        Object.defineProperty(UICustomGameString.prototype, "customData", {
            /**
             * 获取自定义数据
             */
            get: function () {
                return this._customData;
            },
            /**
             * 设置自定义数据
             * @param v [自定义游戏数据显示ID,objValue,idValue]
             */
            set: function (v) {
                this._customData = v;
                if (v == null) {
                    this._tf.text = "0";
                    if (this._shadowEnabled) {
                        this._tf2.color = this._shadowColor;
                        this._tf2.text = this._tf.text;
                    }
                    return;
                }
                if (Config.EDIT_MODE) {
                    this.refreshEditorDataDisplay();
                }
                else if (typeof CustomGameString != "undefined") {
                    var customDataDisplayID = v[0];
                    this._customDataDisplayFunc = CustomGameString["f" + customDataDisplayID];
                    this.refreshDataDisplay();
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * 刷新数据显示
         */
        UICustomGameString.prototype.refreshDataDisplay = function () {
            if (this._customData == null || !this._customDataDisplayFunc) {
                this._tf.text = "";
                if (this._shadowEnabled) {
                    this._tf2.color = this._shadowColor;
                    this._tf2.text = this._tf.text;
                }
                return;
            }
            var value = this._customDataDisplayFunc(null, this.customData[1]);
            if (value == null) {
                this._tf.text = "";
                if (this._shadowEnabled) {
                    this._tf2.color = this._shadowColor;
                    this._tf2.text = this._tf.text;
                }
                return;
            }
            this._tf.text = value;
            if (this._shadowEnabled) {
                this._tf2.color = this._shadowColor;
                this._tf2.text = this._tf.text;
            }
        };
        Object.defineProperty(UICustomGameString.prototype, "inEditorText", {
            /**
             * 获取自定义数据
             */
            get: function () {
                return this._inEditorText;
            },
            //------------------------------------------------------------------------------------------------------
            // 编辑器显示
            //------------------------------------------------------------------------------------------------------
            /**
             * 设置自定义数据
             * @param v [自定义游戏数据显示ID,objValue,idValue]
             */
            set: function (v) {
                this._inEditorText = v;
                this.refreshEditorDataDisplay();
            },
            enumerable: false,
            configurable: true
        });
        /**
         * 编辑器专用信息说明(tips信息)
         */
        UICustomGameString.prototype.inEditorInfo = function () {
            if (this._customData && this._customData[2]) {
                var idValue = this._customData[2][0];
                var customDataDisplayID = this._customData[0];
                var dataName = CommandExecute.customMessage(idValue, Game.data.customGameStringList, customDataDisplayID);
                if (dataName) {
                    var str = StringUtils.clearHtmlTag1(dataName.title);
                    str += StringUtils.clearHtmlTag1(dataName.content);
                    if (str[str.length - 1] == " ")
                        str = str.substr(0, str.length - 1);
                    return str;
                }
            }
            return "";
        };
        UICustomGameString.prototype.refreshEditorDataDisplay = function () {
            if (!Config.EDIT_MODE)
                return;
            this._tf.text = this._inEditorText;
            if (this._shadowEnabled) {
                this._tf2.color = this._shadowColor;
                this._tf2.text = this._tf.text;
            }
        };
        /**
         * 释放
         */
        UICustomGameString.prototype.dispose = function () {
            if (!this.isDisposed)
                os.remove_ENTERFRAME(this.refreshDataDisplay, this);
            _super.prototype.dispose.call(this);
        };
        /**
         * 自定义方法名称
         */
        UICustomGameString.customCompFunctionNames = ["customData", "inEditorText", "fontSize", "color", "bold", "italic", "smooth", "align", "valign", "leading",
            "letterSpacing", "font", "wordWrap", "overflow", "shadowEnabled", "shadowColor", "shadowDx", "shadowDy", "stroke", "strokeColor"];
        return UICustomGameString;
    }(UIComponent.UIString));
    UIComponent.UICustomGameString = UICustomGameString;
})(UIComponent || (UIComponent = {}));
/**
 * Created by 黑暗之神KDS on 2019-04-24 20:40:13.
 */
var UIComponent;
(function (UIComponent) {
    var UIGUI = /** @class */ (function (_super) {
        __extends(UIGUI, _super);
        function UIGUI() {
            var _this = _super.call(this) || this;
            _this._guiID = 0;
            _this._root = new Sprite();
            _this._instanceClassName = "";
            _this.addChild(_this._root);
            _this.className = "UIGUI";
            _this.modifyWidthHeightEnabled = false;
            _this._lastRect = _this.getSelfBounds().clone();
            return _this;
        }
        /**
         * 编辑器专用初始化
         */
        UIGUI.prototype.inEditorInit = function () {
            this.clear(0);
        };
        /**
         * 开始检测加载完毕的情形
         */
        UIGUI.prototype.loadAssetTest = function () {
            if (Config.EDIT_MODE) {
                Callback.New(checkUIRoot, this).delayRun(0);
            }
            else {
                checkUIRoot.call(this);
            }
            function checkUIRoot() {
                if (this._ui) {
                    this._ui.once(EventObject.LOADED, this, this.event, [EventObject.LOADED]);
                    this._ui["loadAssetTest"](true);
                }
                else {
                    this.event(EventObject.LOADED);
                }
            }
        };
        Object.defineProperty(UIGUI.prototype, "guiID", {
            get: function () {
                return this._guiID;
            },
            set: function (v) {
                if (this._guiID != v) {
                    this.loadGUI(v);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIGUI.prototype, "instanceClassName", {
            /**
             * 游戏运行时的实现类
             */
            get: function () {
                return this._instanceClassName;
            },
            set: function (v) {
                this._instanceClassName = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIGUI.prototype, "root", {
            /**
             * 获取容器
             */
            get: function () {
                return this._ui;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * 加载GUI
         * @param guiID
         */
        UIGUI.prototype.loadGUI = function (guiID) {
            var _this = this;
            this._guiID = guiID;
            this.clear(guiID);
            if (guiID == 0)
                return;
            if (Config.EDIT_MODE) {
                Callback.New(function () {
                    if (_this.isDeepLoop(_this._guiID)) {
                        gcide_canvasbuilder.AlertUtils.alert("不允许循环嵌套!");
                        var p = _this.parent;
                        while (p) {
                            if (p instanceof UIGUI) {
                                p.guiID = 0;
                            }
                            if (p instanceof UIComponent.UIList) {
                                p.itemModelGUI = 0;
                            }
                            p = p.parent;
                        }
                        _this.loadGUI(0);
                        return;
                    }
                    var uiData = Common.uiList.data[guiID];
                    if (!uiData) {
                        return;
                    }
                    _this._ui = GameUI.parse(uiData.uiDisplayData);
                    _this._ui.once(EventObject.LOADED, _this, function () {
                        // var rect = this.getSelfBounds();
                        // trace("GUI--rect=",rect);
                        // this.hitArea = rect;
                        _this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
                    });
                    os.add_ENTERFRAME(_this.onEditorCheckLoaded, _this);
                    if (_this._root)
                        _this._root.addChild(_this._ui);
                    // @ts-ignore
                    EUIRoot.dataBaseWindow.win7.off(EUIWindowUI.EVENT_GUI_DATA_SYNC_COMPLETE, _this, _this.onGUIDataChange);
                    // @ts-ignore
                    EUIRoot.dataBaseWindow.win7.on(EUIWindowUI.EVENT_GUI_DATA_SYNC_COMPLETE, _this, _this.onGUIDataChange);
                }, this).delayRun(0);
            }
            else {
                var ui = GameUI.load(guiID, true);
                if (this._root)
                    this._root.addChild(ui);
                this._ui = ui;
                this.event(EventObject.LOADED);
            }
        };
        /**
         * 当界面数据更改时：重新载入该界面
         */
        UIGUI.prototype.onGUIDataChange = function (syncGUIID) {
            if (syncGUIID == this.guiID) {
                // @ts-ignore
                EUIRoot.dataBaseWindow.win7.off(EUIWindowUI.EVENT_GUI_DATA_SYNC_COMPLETE, this, this.onGUIDataChange);
                this.loadGUI(this.guiID);
            }
        };
        /**
         * 检测循环嵌套
         */
        UIGUI.prototype.isDeepLoop = function (guiID) {
            var p = this.parent;
            while (p) {
                if (p instanceof UIGUI) {
                    if (p.guiID == guiID)
                        return true;
                }
                if (p instanceof UIComponent.UIList) {
                    if (p.itemModelGUI == guiID)
                        return true;
                }
                if (p instanceof UIComponent.UIRoot) {
                    if (p.guiID == guiID)
                        return true;
                }
                p = p.parent;
            }
            return false;
        };
        UIGUI.prototype.clear = function (guiID) {
            this.graphics.clear();
            if (this._root)
                this._root.removeChildren();
            if (!guiID) {
                this._lastRect = new Rectangle;
                this.graphics.drawRect(0, 0, 100, 100, "#000000");
                this.width = 100;
                this.height = 100;
                this.event(EventObject.LOADED);
            }
            else {
                this.width = 0;
                this.height = 0;
            }
        };
        /**
         * 释放该界面下面所有的元件以及相应的资源
         */
        UIGUI.prototype.dispose = function () {
            if (!this.isDisposed) {
                //dispose时需要清除侦听
                os.remove_ENTERFRAME(this.onEditorCheckLoaded, this);
                if (Config.EDIT_MODE) {
                    // @ts-ignore
                    EUIRoot.dataBaseWindow.win7.off(EUIWindowUI.EVENT_GUI_DATA_SYNC_COMPLETE, this, this.onGUIDataChange);
                }
                if (this._ui)
                    this._ui.dispose();
                this._ui = null;
                this._root.removeSelf();
                this._root.offAll();
                this._root.destroy(true);
                this._root = null;
            }
            _super.prototype.dispose.call(this);
        };
        //------------------------------------------------------------------------------------------------------
        // 编辑器专区
        //------------------------------------------------------------------------------------------------------
        UIGUI.prototype.onEditorCheckLoaded = function () {
            if (this.isDisposed)
                return;
            var rect = this.getSelfBounds();
            if (!rect.equals(this._lastRect)) {
                this._lastRect = rect.clone();
                this.hitArea = rect;
                os.remove_ENTERFRAME(this.onEditorCheckLoaded, this);
                this.event(EventObject.LOADED);
            }
        };
        /**
         * 自定义方法名称
         */
        UIGUI.customCompFunctionNames = ["guiID", "instanceClassName"];
        return UIGUI;
    }(UIComponent.UIBase));
    UIComponent.UIGUI = UIGUI;
})(UIComponent || (UIComponent = {}));
/**
 * Created by 黑暗之神KDS on 2019-04-14 17:43:32.
 */
var UIComponent;
(function (UIComponent) {
    var UIInput = /** @class */ (function (_super) {
        __extends(UIInput, _super);
        function UIInput() {
            var _this = _super.call(this, !Config.EDIT_MODE) || this;
            _this._color = "#000000";
            _this._promptColor = "#606060";
            _this.className = "UIInput";
            _this.valign = 1;
            _this.width = 200;
            _this.height = 30;
            _this.fontSize = 16;
            _this.align = 0;
            _this.inputMode = 0;
            _this.maxChars = 99999;
            _this.mouseEventEnabled = true;
            return _this;
        }
        UIInput.prototype.select = function () {
            this.setSelection(0, 999999999);
        };
        UIInput.prototype.setSelection = function (startIndex, endIndex) {
            if (this._inputMode == 3)
                return;
            if (this._tf instanceof TextInput) {
                this._tf.setSelection(startIndex, endIndex);
            }
        };
        ;
        UIInput.prototype.inEditorInit = function () {
            this.mouseEventEnabledData = true;
            this.text = "默认文本";
        };
        UIInput.prototype.setTextForce = function (v) {
            this.__forceChange = true;
            this.text = v;
            this.__forceChange = false;
            this.color = this.color;
        };
        Object.defineProperty(UIInput.prototype, "focus", {
            get: function () {
                return this._tf.focus;
            },
            set: function (v) {
                this._tf.focus = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIInput.prototype, "restrict", {
            get: function () {
                return this._restrict ? this._restrict : "";
            },
            set: function (v) {
                this._restrict = this._tf.restrict = v ? v : "";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIInput.prototype, "maxChars", {
            get: function () {
                return this._tf.maxChars;
            },
            set: function (v) {
                this._tf.maxChars = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIInput.prototype, "inputMode", {
            get: function () {
                return this._inputMode;
            },
            set: function (v) {
                v = Math.floor(v);
                var lastInputMode = this._inputMode;
                this._inputMode = v;
                switch (v) {
                    case 0:
                        this._tf.type = "text";
                        break;
                    case 1:
                        this._tf.type = "password";
                        break;
                    case 2:
                        this._tf.type = "number";
                        break;
                    case 3:
                        break;
                }
                if ((lastInputMode <= 2 && v == 3) || (lastInputMode == 3 && v < 3)) {
                    this.changeTextInputType();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIInput.prototype, "text", {
            get: function () {
                if (!Config.EDIT_MODE) { //编辑器是Label
                    return this._tf.text;
                }
                else {
                    return this._text;
                }
            },
            set: function (v) {
                this._text = v;
                if (this.__forceChange) {
                    this._tf.changeText(v);
                }
                else {
                    this._tf.text = v;
                }
                this._tf.color = this._color;
                if (this._shadowEnabled) {
                    if (this._text && !this._tf2.stage)
                        this.addChildAt(this._tf2, 0);
                    this._tf2.color = this._shadowColor;
                    if (this.__forceChange) {
                        this._tf2.changeText(this._tf.text);
                    }
                    else {
                        this._tf2.text = this._tf.text;
                    }
                }
                //编辑器显示提示文本(提示文本不显示阴影)
                if (Config.EDIT_MODE && !this._text && this._prompt) {
                    this._tf.changeText(this._prompt);
                    this._tf.color = this._promptColor;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIInput.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (v) {
                this._color = v;
                if (!Config.EDIT_MODE) { //编辑器是Label
                    this._tf.color = v ? v : "#000000";
                }
                else {
                    if (this._text) {
                        this._tf.color = v;
                        this.width += 1;
                        this.width -= 1;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIInput.prototype, "prompt", {
            get: function () {
                return this._prompt;
            },
            set: function (v) {
                this._prompt = v;
                if (!Config.EDIT_MODE) { //编辑器是Label
                    this._tf.prompt = v ? v : "";
                }
                else {
                    if (!this._text && this._prompt) {
                        this._tf.changeText(this._prompt);
                        this._tf.color = this._promptColor;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIInput.prototype, "promptColor", {
            get: function () {
                return this._promptColor;
            },
            set: function (v) {
                this._promptColor = v;
                if (!Config.EDIT_MODE) { //编辑器是Label
                    this._tf.promptColor = v ? v : "#606060";
                }
                else {
                    if (!this._text && this._prompt) {
                        this._tf.color = this._promptColor;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * 更改文本输入类别
         */
        UIInput.prototype.changeTextInputType = function () {
            var oldTf = this._tf;
            if (this._tf.parent)
                this._tf.parent.removeChild(this._tf);
            if (this._inputMode == 3) {
                this._tf = new TextArea();
            }
            else {
                this._tf = new TextInput();
            }
            this.addChild(this._tf);
            var recoveryAttrs = ["text", "color", "fontSize", "leading", "align", "valign",
                "bold", "width", "height", "font", "overflow", "wordWrap", "restrict"];
            for (var i in recoveryAttrs) {
                var attr = recoveryAttrs[i];
                this._tf[attr] = oldTf[attr];
            }
            if (this._inputMode == 3) {
                this._tf.valign = "top";
            }
            if (Config.EDIT_MODE) {
                this._tf.mouseEnabled = false;
            }
        };
        Object.defineProperty(UIInput.prototype, "onInputFragEvent", {
            //------------------------------------------------------------------------------------------------------
            // 片段事件 INPUT/ENTER
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._onInputFragEvent;
            },
            set: function (v) {
                this._onInputFragEvent = v;
                if (v) {
                    this.off(EventObject.INPUT, this, this.onInput_private);
                    this.on(EventObject.INPUT, this, this.onInput_private);
                }
                else {
                    this.off(EventObject.INPUT, this, this.onInput_private);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIInput.prototype, "onEnterFragEvent", {
            get: function () {
                return this._onEnterFragEvent;
            },
            set: function (v) {
                this._onEnterFragEvent = v;
                if (v) {
                    this.off(EventObject.ENTER, this, this.onEnter_private);
                    this.on(EventObject.ENTER, this, this.onEnter_private);
                }
                else {
                    this.off(EventObject.ENTER, this, this.onEnter_private);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIInput.prototype.onInput_private = function () {
            if (Config.SINGLE_PLAYER_CORE) {
                if (this._onInputFragEvent && this.guiRoot && !this.guiRoot.onlyForPreload) {
                    CommandPage.startTriggerFragmentEvent(this._onInputFragEvent, Game.player.sceneObject, Game.player.sceneObject);
                }
            }
        };
        UIInput.prototype.onEnter_private = function () {
            if (Config.SINGLE_PLAYER_CORE) {
                if (this._onEnterFragEvent && this.guiRoot && !this.guiRoot.onlyForPreload) {
                    CommandPage.startTriggerFragmentEvent(this._onEnterFragEvent, Game.player.sceneObject, Game.player.sceneObject);
                }
            }
        };
        /**
         * 自定义方法名称
         */
        UIInput.customCompFunctionNames = ["text", "fontSize", "color", "prompt", "promptColor", "bold", "italic", "smooth", "align", "leading",
            "font", "wordWrap", "restrict", "inputMode", "maxChars", "shadowEnabled", "shadowColor", "shadowDx", "shadowDy", "onInputFragEvent", "onEnterFragEvent"];
        return UIInput;
    }(UIComponent.UIString));
    UIComponent.UIInput = UIInput;
})(UIComponent || (UIComponent = {}));
/**
 * 列表控件
 *  -- 项数据基类：UIListItemData （此外系统会自动创建每个界面作为项数据类-ListItem_?，请查阅system/UIRuntime.ts）
 *     项数据类会自动根据控件创建相应的属性，以便填充后自动呈现出该数值或字符串（以及图片地址等）
 *     项数据映射值参考：
 *     UIBitmap -> string-图片地址
 *     UIString -> string-文本
 *     UIVariable -> number-数值变量ID
 *     UIAvatar -> number-行走图ID
 *     UIStandAvatar -> number-立绘ID
 *     UIAnimation -> number-动画ID
 *     UIInput -> string-默认文本
 *     UICheckBox -> boolean-选中状态
 *     UISwitch -> number-开关ID
 *     UITabBox -> string-项（如aa,bb,cc）
 *     UISlider -> number-值
 *     UIGUI -> number-界面ID
 *     UIList -> UIListItemData[]-项数据
 *
 * 相关事件：
 *  EventObject.CHANGE 当改变状态时派发  onChange(state:number) state=0 表示selectedIndex改变，否则是overIndex
 *  EventObject.LOADED 加载完成时候事件
 *
 *
 * 使用方法：
 *  var a = new UIList();
 *  a.itemModelGUI = 8; // 使用指定的界面ID来创建项，如果需要指定类，请使用 itemModelClass
 *  stage.addChild(a);
 *  var dArr = [];
 *  for(var i=0;i<10;i++){
 *     var d:ListItem_8 = new ListItem_8();
 *     d.pic = "asset/image/a.jpg"; // 假设8号界面存在名为pic的控件
 *     d.txt = "kds"; // 假设8号界面存在名为txt的文本
 *     d.战斗力 = 5; // 假设8号界面存在名为战斗力的数值变量控件，这里绑定5号变量
 *     dArr.push(d);
 *  }
 *  a.items = dArr;
 *
 * Created by 黑暗之神KDS on 2019-07-09 15:04:27.
 */
var UIComponent;
(function (UIComponent) {
    var UIList = /** @class */ (function (_super) {
        __extends(UIList, _super);
        /**
         * 构造函数
         */
        function UIList() {
            var _this = _super.call(this) || this;
            //------------------------------------------------------------------------------------------------------
            // 
            //------------------------------------------------------------------------------------------------------
            /**
             * 鼠标悬停则作为选中效果（默认是悬停效果）
             */
            _this.overSelectMode = true;
            /**指定是否可以选择，若值为true则可以选择，否则不可以选择。*/
            _this._selectEnable = true;
            /**
             * 水平方向显示的单元格数量。
             */
            _this._repeatX = 1;
            /**
             * 水平方向显示的单元格之间的间距（以像素为单位）。
             */
            _this._spaceX = 2;
            /**
             * 垂直方向显示的单元格之间的间距（以像素为单位）。
             */
            _this._spaceY = 20;
            /**
             * 项的宽度
             */
            _this._itemWidth = 200;
            /**
             * 项的高度
             */
            _this._itemHeight = 50;
            /**
             * 选中项索引
             */
            _this._selectedIndex = -1;
            /**
             * 悬停项缩影
             */
            _this._overIndex = -1;
            /**
             * 设置数据源
             */
            _this._items = [];
            /**
             * 光标效果九宫格
             */
            _this._overImageGrid9 = "0,0,0,0,0";
            /**
             * 选中效果九宫格
             */
            _this._selectImageGrid9 = "0,0,0,0,0";
            /**
             * 选中效果是否位于上层
             */
            _this._selectedImageOnTop = true;
            /**
            * 光标效果是否位于上层
            */
            _this._overImageOnTop = true;
            /**
             * 实际列表中显示的ITEM
             */
            _this._itemSize = 0;
            /**
             * 子项缩进
             */
            _this.subitemIndentation = 20;
            /**
             * 预览项个数
             */
            _this._previewSize = 5;
            /**
             * 快捷键取消索引
             */
            _this.cancelSelectedIndex = -1;
            _this.className = "UIList";
            _this._contentArea = new GameSprite();
            _this._overImageBox = new GameSprite();
            _this._overImage = new UIComponent.UIBitmap();
            _this._overImageBox.addChild(_this._overImage);
            _this._selectedImageBox = new GameSprite();
            _this._selectedImage = new UIComponent.UIBitmap();
            _this._selectedImageBox.addChild(_this._selectedImage);
            _this._overImageBox.mouseEnabled = false;
            _this._selectedImageBox.mouseEnabled = false;
            _this._overImageBox.visible = false;
            _this.refreshLayer();
            // @ts-ignore
            _this.enabledLimitView = true;
            // @ts-ignore
            _this.scrollShowType = 2;
            _this.selectedImageAlpha = 0.5;
            _this.overImageAlpha = 0.5;
            // @ts-ignore
            _this.width = 200;
            // @ts-ignore
            _this.height = 200;
            return _this;
            // if (Config.EDIT_MODE) {
            //     Callback.CallLater(this.itemsPreview, this);
            // }
        }
        Object.defineProperty(UIList, "KEY_BOARD_ENABLED", {
            get: function () {
                return UIList._KEY_BOARD_ENABLED;
            },
            set: function (v) {
                UIList._KEY_BOARD_ENABLED = v;
                if (v) {
                    if (typeof stage != "undefined")
                        UIList.listKeyboardHandle();
                    else
                        EventUtils.addEventListener(ClientWorld, ClientWorld.EVENT_INITED, Callback.New(UIList.listKeyboardHandle, UIList), true);
                }
                else {
                    // 重置，以免在关闭时再弹起按键已经无法关闭该状态了（SRPG模板准备阶段的是否准备完毕选项触发过该BUG）
                    UIList.keyDownEnter = false;
                    UIList.keyDownEsc = false;
                    stage.off(EventObject.KEY_UP, this, UIList.onListKeyUp);
                    stage.off(EventObject.KEY_DOWN, this, UIList.onListKeyDown);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIList.listKeyboardHandle = function () {
            stage.on(EventObject.KEY_DOWN, this, UIList.onListKeyDown);
            stage.on(EventObject.KEY_UP, this, UIList.onListKeyUp);
        };
        UIList.onListKeyDown = function (e) {
            this.setKeyDown(e.keyCode);
        };
        UIList.onListKeyUp = function (e) {
            if (UIList.KEY_ENTER.indexOf(e.keyCode) != -1) {
                UIList.keyDownEnter = false;
            }
            else if (UIList.KEY_ESC.indexOf(e.keyCode) != -1) {
                UIList.keyDownEsc = false;
            }
        };
        /**
         * 模拟按键按下：仅能操作当前焦点的UIList
         * @param keyCode 对应键位 KEY_UP/KEY_DOWN/KEY_LEFT/KEY_RIGHT/KEY_ENTER
         */
        UIList.setKeyDown = function (keyCode) {
            if (!this._focus || !this._focus.stage)
                return;
            var dx = this._focus.selectedIndex % this._focus.repeatX;
            var dy = Math.floor(this._focus.selectedIndex / this._focus.repeatX);
            if (UIList.KEY_LEFT.indexOf(keyCode) != -1) {
                dx -= 1;
                if (dx < 0)
                    dx = 0;
            }
            else if (UIList.KEY_RIGHT.indexOf(keyCode) != -1) {
                dx += 1;
                if (dx >= this._focus.repeatX)
                    dx = this._focus.repeatX - 1;
            }
            else if (UIList.KEY_UP.indexOf(keyCode) != -1) {
                dy -= 1;
                if (dy < 0)
                    dy = 0;
            }
            else if (UIList.KEY_DOWN.indexOf(keyCode) != -1) {
                dy += 1;
                var rowCount = Math.ceil(this._focus.length / this._focus.repeatX);
                if (dy >= rowCount)
                    dy = rowCount - 1;
            }
            else if (UIList.KEY_ENTER.indexOf(keyCode) != -1) {
                // 避免连续按下ENTER
                if (UIList.keyDownEnter)
                    return;
                UIList.keyDownEnter = true;
                // 打开或关闭节点
                var data = this._focus.selectedItem;
                if (!data)
                    return;
                if (data.numChildren == 0) {
                    data.isOpen = !data.isOpen;
                    this._focus.refreshOrder();
                    this._focus.event(UIList.OPEN_STATE_CHANGE, [this._focus.getItemUI(this._focus.selectedIndex), data, this._focus.selectedIndex]);
                }
                // 点击ITEM
                Callback.CallLaterBeforeRender(this._focus.event, this._focus, [UIList.ITEM_CLICK]);
                return;
            }
            else if (UIList.KEY_ESC.indexOf(keyCode) != -1) {
                // 避免连续按下ESC
                if (UIList.keyDownEsc)
                    return;
                UIList.keyDownEsc = true;
                if (this._focus.cancelSelectedIndex >= 0 && this._focus.cancelSelectedIndex < this._focus.items.length) {
                    this._focus.selectedIndex = this._focus.cancelSelectedIndex;
                    // 点击ITEM
                    Callback.CallLaterBeforeRender(this._focus.event, this._focus, [UIList.ITEM_CLICK]);
                    return;
                }
            }
            var selectedIndex = dy * this._focus.repeatX + dx;
            if (selectedIndex < 0)
                selectedIndex = 0;
            if (selectedIndex >= this._focus.length)
                selectedIndex = this._focus.length - 1;
            this._focus.selectedIndex = selectedIndex;
        };
        Object.defineProperty(UIList, "focus", {
            get: function () {
                return this._focus;
            },
            set: function (list) {
                // 如果传过来的列表已销毁则视为null
                if (list && list.isDisposed)
                    list = null;
                if (this._focus == list)
                    return;
                var lastFocus = this._focus;
                if (UIList.SINGLE_FOCUS_MODE) {
                    if (this._focus)
                        this._focus.mouseEnabled = false;
                }
                this._focus = list;
                if (list) {
                    if (list.selectedIndex == -1)
                        list.selectedIndex = 0;
                    if (UIList.SINGLE_FOCUS_MODE) {
                        list.mouseEnabled = true;
                    }
                }
                EventUtils.happen(UIList, UIList.EVENT_FOCUS_CHANGE, [lastFocus, this._focus]);
            },
            enumerable: false,
            configurable: true
        });
        UIList.prototype.dispose = function () {
            // @ts-ignore
            if (!this.isDisposed) {
                if (Config.EDIT_MODE) {
                    // @ts-ignore
                    EUIRoot.dataBaseWindow.win7.off(EUIWindowUI.EVENT_GUI_DATA_SYNC_COMPLETE, this, this.onItemUIChange);
                }
                this.clearItems();
                this._overImage.dispose();
                this._overImage = null;
                this._overImageBox.dispose();
                this._overImageBox = null;
                this._selectedImage.dispose();
                this._selectedImage = null;
                this._selectedImageBox.dispose();
                this._selectedImageBox = null;
                this._contentArea.dispose();
                this._contentArea = null;
            }
            _super.prototype.dispose.call(this);
        };
        UIList.prototype.inEditorInit = function () {
            this.overImageURL = "asset/image/picture/control/uilistover.png";
            this.selectImageURL = "asset/image/picture/control/uilistselect.png";
            _super.prototype.inEditorInit.call(this);
        };
        /**
         * 开始检测加载完毕的情形
         */
        UIList.prototype.loadAssetTest = function () {
            if (this.itemModelClass) {
                this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
                return;
            }
            var id = MathUtils.int(this.itemModelGUI);
            // 加载父类的资源:记录当前请求加载的容器需要的资源图集,预加载容器的皮肤图集，不引用，仅用于加载回调
            var mySkins = [this._vScroollBarImage1, this._vScroollBarImage2, this._hScroollBarImage1, this._hScroollBarImage2];
            AssetManager.loadImages(mySkins, Callback.New(function () {
                AssetManager.preLoadUIAsset(id, Callback.New(function () {
                    this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
                }, this), this._syncLoadedEventWhenAssetExist, true);
            }, this), this._syncLoadedEventWhenAssetExist, false);
        };
        /**
         * 构造初始化（即已设置属性完毕）
         * @param uiID
         * @param syncLoadedEventWhenAssetExist [可选] 默认值=false 当资源存在时同步派发加载完成事件，否则需要等待一帧（异步派发）
         */
        UIList.prototype.constructorInit = function (uiID, syncLoadedEventWhenAssetExist) {
            if (syncLoadedEventWhenAssetExist === void 0) { syncLoadedEventWhenAssetExist = false; }
            _super.prototype.constructorInit.apply(this, arguments);
            if (!Config.EDIT_MODE && UIList.SINGLE_FOCUS_MODE) {
                this.mouseEnabled = false;
            }
        };
        /**
         * 项预览：用于编辑器中预览用
         */
        UIList.prototype.itemsPreview = function () {
            if (!Config.EDIT_MODE || !this.stage)
                return;
            if (this.checkDeepLoopAndReset(this._itemModelGUI))
                return;
            var arr = [];
            for (var i = 0; i < this._previewSize; i++) {
                var d = new UIListItemData();
                arr.push(d);
            }
            this.items = arr;
            this.selectedIndex = 0;
        };
        Object.defineProperty(UIList.prototype, "itemSprites", {
            /**
             * 获取全部项对应的显示对象
             * 如果更新了项数据则显示对象也会被替换成新的，若需要记录该显示对象请谨慎使用
             */
            get: function () {
                return this._contentArea["_childs"];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "previewSize", {
            get: function () {
                return this._previewSize;
            },
            set: function (v) {
                if (!Config.EDIT_MODE)
                    return;
                if (this._previewSize != v) {
                    this._previewSize = Math.min(v, 100);
                    Callback.CallLater(this.itemsPreview, this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectEnable", {
            //------------------------------------------------------------------------------------------------------
            // 常规操作
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._selectEnable;
            },
            set: function (v) {
                if (this._selectEnable != v) {
                    this._selectEnable = v;
                    this._overImageBox.visible = v;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "repeatX", {
            get: function () {
                return this._repeatX;
            },
            set: function (v) {
                if (this._repeatX != v) {
                    this._repeatX = v;
                    if (this._repeatX < 1)
                        this._repeatX = 1;
                    this.refreshOrder();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "spaceX", {
            get: function () {
                return this._spaceX;
            },
            set: function (v) {
                if (this._spaceX != v) {
                    this._spaceX = v;
                    this.refreshOrder();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "spaceY", {
            get: function () {
                return this._spaceY;
            },
            set: function (v) {
                if (this._spaceY != v) {
                    this._spaceY = v;
                    this.refreshOrder();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "itemWidth", {
            get: function () {
                return this._itemWidth;
            },
            set: function (v) {
                if (this._itemWidth != v) {
                    this._itemWidth = v;
                    if (this._itemWidth < 1)
                        this._itemWidth = 1;
                    this.refreshOrder();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "itemHeight", {
            get: function () {
                return this._itemHeight;
            },
            set: function (v) {
                if (this._itemHeight != v) {
                    this._itemHeight = v;
                    if (this._itemHeight < 1)
                        this._itemHeight = 1;
                    this.refreshOrder();
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * 滚动到指定行：如果该项显示对象在完全显示中时则忽略滚动
         * @param index 指定的索引
         * @param ignoreAlreadyInVisible [可选] 默认值=true 忽略已
         * @param tween [可选] 默认值=false 是否缓动
         * @param duration [可选] 默认值=0 持续时间
         * @param ease [可选] 默认值=null 缓动方法
         * @param complete [可选] 默认值=null 当缓动完毕时回调
         */
        UIList.prototype.scrollTo = function (index, ignoreAlreadyInVisible, tween, duration, ease, complete) {
            if (ignoreAlreadyInVisible === void 0) { ignoreAlreadyInVisible = true; }
            if (tween === void 0) { tween = false; }
            if (duration === void 0) { duration = 0; }
            if (ease === void 0) { ease = null; }
            if (complete === void 0) { complete = null; }
            var column = index % this.repeatX;
            var row = Math.floor(index / this.repeatX);
            // 计算项显示对象所在的位置
            var px = column * (this.itemWidth + this.spaceX);
            var py = row * (this.itemHeight + this.spaceY);
            var rect = new Rectangle(px, py, this.itemWidth, this.itemHeight);
            var points = [[rect.x, rect.y], [rect.right, rect.y], [rect.right, rect.bottom], [rect.x, rect.bottom]];
            var needScrollTo = false;
            var myScrollRect = this._myScrollRect.clone();
            if (this._vScrollBar.visible)
                myScrollRect.width -= this.scrollWidth;
            if (this._hScrollBar.visible)
                myScrollRect.height -= this.scrollWidth;
            // 总宽度高度
            var totalWidth = this._contentWidth - this._myScrollRect.width;
            var totalHeight = this._contentHeight - this._myScrollRect.height;
            // 该项所在的位置
            var perX, perY;
            if (myScrollRect.y >= py || !ignoreAlreadyInVisible) {
                perY = py * 100 / totalHeight;
            }
            else if (rect.bottom > myScrollRect.bottom) {
                perY = (py - myScrollRect.height + rect.height) * 100 / totalHeight;
            }
            if (myScrollRect.x > px || !ignoreAlreadyInVisible) {
                perX = px * 100 / totalWidth;
            }
            else if (rect.right > myScrollRect.right) {
                perX = (px - myScrollRect.width + rect.width) * 100 / totalWidth;
            }
            if (tween) {
                if (perX != null) {
                    Tween.clearAll(this._hScrollBar);
                    Tween.to(this._hScrollBar, { value: perX }, duration, ease, complete);
                }
                if (perY != null) {
                    Tween.clearAll(this._vScrollBar);
                    Tween.to(this._vScrollBar, { value: perY }, duration, ease, complete);
                }
            }
            else {
                if (perX != null)
                    this._hScrollBar.value = perX;
                if (perY != null)
                    this._vScrollBar.value = perY;
            }
        };
        /**
         * 计算宽高
         */
        UIList.prototype.calcTotalContentSize = function () {
            var itemLen = this._itemSize;
            var itemColumnNum = Math.min(itemLen, this.repeatX);
            var itemRowNum = Math.ceil(itemLen / this.repeatX);
            var maxW = (itemColumnNum * this.itemWidth) + Math.max(itemColumnNum - 1, 0) * this.spaceX;
            var maxH = (itemRowNum * this.itemHeight) + Math.max(itemRowNum - 1, 0) * this.spaceY;
            return { maxW: maxW, maxH: maxH };
        };
        Object.defineProperty(UIList.prototype, "selectedImage", {
            /**
             * 获取选中的对象
             */
            get: function () {
                return this._selectedImage;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "overImageURL", {
            get: function () {
                return this._overImageURL;
            },
            //------------------------------------------------------------------------------------------------------
            // 效果
            //------------------------------------------------------------------------------------------------------
            set: function (v) {
                if (this.isDisposed)
                    return;
                if (this._overImageURL != v) {
                    this._overImageURL = v;
                    this._overImage.image = v;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "overImage", {
            get: function () {
                return this._overImage;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectImageURL", {
            get: function () {
                return this._selectImageURL;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                if (this._selectImageURL != v) {
                    this._selectImageURL = v;
                    this._selectedImage.image = v;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectImage", {
            get: function () {
                return this._selectedImage;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectedImageAlpha", {
            get: function () {
                return this._selectedImageAlpha;
            },
            set: function (v) {
                if (this._selectedImageAlpha != v) {
                    this._selectedImageAlpha = v;
                    this._selectedImageBox.alpha = v;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "overImageAlpha", {
            get: function () {
                return this._overImageAlpha;
            },
            set: function (v) {
                if (this._overImageAlpha != v) {
                    this._overImageAlpha = v;
                    this._overImageBox.alpha = v;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectedImageOnTop", {
            get: function () {
                return this._selectedImageOnTop;
            },
            set: function (v) {
                if (this._selectedImageOnTop != v) {
                    this._selectedImageOnTop = v;
                    this.refreshLayer();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "overImageOnTop", {
            get: function () {
                return this._overImageOnTop;
            },
            set: function (v) {
                if (this._overImageOnTop != v) {
                    this._overImageOnTop = v;
                    this.refreshLayer();
                }
            },
            enumerable: false,
            configurable: true
        });
        UIList.prototype.refreshLayer = function () {
            if (!this._selectedImageOnTop) {
                this.addChild(this._selectedImageBox);
            }
            if (!this._overImageOnTop) {
                this.addChild(this._overImageBox);
            }
            this.addChild(this._contentArea);
            if (this._selectedImageOnTop) {
                this.addChild(this._selectedImageBox);
            }
            if (this._overImageOnTop) {
                this.addChild(this._overImageBox);
            }
        };
        Object.defineProperty(UIList.prototype, "overImageGrid9Width", {
            //------------------------------------------------------------------------------------------------------
            // 九宫格
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._overImage.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "overImageGrid9Height", {
            get: function () {
                return this._overImage.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "overImageGrid9Skin", {
            get: function () {
                return this._overImage.image;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "overImageGrid9", {
            get: function () {
                return this._overImageGrid9;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                if (this._overImageGrid9 != v) {
                    this._overImageGrid9 = v;
                    this._overImage.grid9 = v;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectImageGrid9Width", {
            get: function () {
                return this._selectedImage.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectImageGrid9Height", {
            get: function () {
                return this._selectedImage.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectImageGrid9Skin", {
            get: function () {
                return this._selectedImage.image;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectImageGrid9", {
            get: function () {
                return this._selectImageGrid9;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                if (this._selectImageGrid9 != v) {
                    this._selectImageGrid9 = v;
                    this._selectedImage.grid9 = v;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "itemModelClass", {
            //------------------------------------------------------------------------------------------------------
            // 源模型设置
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._itemModelClass;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                if (this._itemModelClass != v) {
                    this._itemModelClass = v;
                    this._itemModelGUI = 0;
                    this.event(EventObject.LOADED);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "itemModelGUI", {
            get: function () {
                return this._itemModelGUI;
            },
            set: function (v) {
                var _this = this;
                if (this.isDisposed)
                    return;
                this._itemModelGUI = v;
                if (v == 0) {
                    this._itemModelClass = null;
                    this.itemsPreview();
                    this.event(EventObject.LOADED);
                    return;
                }
                if (Config.EDIT_MODE) {
                    Callback.CallLater(function () {
                        if (_this.isDisposed)
                            return;
                        if (_this.checkDeepLoopAndReset(_this._itemModelGUI))
                            return;
                        var uiData = Common.uiList.data[v];
                        if (!uiData) {
                            _this._itemModelClass = null;
                            _this.itemsPreview();
                            _this.event(EventObject.LOADED);
                            return;
                        }
                        var instanceClassName = uiData.uiDisplayData.instanceClassName;
                        var classObj = window[instanceClassName];
                        if (!classObj)
                            classObj = window["GUI_" + v];
                        _this._itemModelClass = classObj;
                        _this.itemsPreview();
                    }, this);
                }
                else {
                    var uiData = Common.uiList.data[v];
                    if (!uiData) {
                        this._itemModelClass = null;
                        this.itemsPreview();
                        this.event(EventObject.LOADED);
                        return;
                    }
                    var instanceClassName = uiData.uiDisplayData.instanceClassName;
                    var classObj = window[instanceClassName];
                    if (!classObj)
                        classObj = window["GUI_" + v];
                    this._itemModelClass = classObj;
                    AssetManager.preLoadUIAsset(v, Callback.New(function () {
                        _this.event(EventObject.LOADED);
                    }, this), true, true);
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * 检查循环嵌套并重置
         * @return [boolean]
         */
        UIList.prototype.checkDeepLoopAndReset = function (guiID) {
            if (!guiID)
                return false;
            if (Config.EDIT_MODE && this.isDeepLoop(guiID)) {
                gcide_canvasbuilder.AlertUtils.alert("不允许循环嵌套!");
                var p = this.parent;
                while (p) {
                    if (p instanceof UIComponent.UIGUI) {
                        p.guiID = 0;
                    }
                    if (p instanceof UIList) {
                        p.itemModelGUI = 0;
                    }
                    p = p.parent;
                }
                this.itemModelGUI = 0;
                return true;
            }
            return false;
        };
        /**
         * 检测循环嵌套
         */
        UIList.prototype.isDeepLoop = function (guiID) {
            if (!guiID)
                return false;
            var p = this.parent;
            while (p) {
                if (p instanceof UIComponent.UIGUI) {
                    if (p.guiID == guiID)
                        return true;
                }
                if (p instanceof UIList) {
                    if (p.itemModelGUI == guiID)
                        return true;
                }
                if (p instanceof UIComponent.UIRoot) {
                    if (p.guiID == guiID)
                        return true;
                }
                p = p.parent;
            }
            return false;
        };
        //------------------------------------------------------------------------------------------------------
        // ITEM 数据操作
        //------------------------------------------------------------------------------------------------------
        UIList.prototype.clearItems = function () {
            for (var i = 0; i < this._contentArea.numChildren; i++) {
                var item = this._contentArea.getChildAt(i);
                item.dispose();
                i--;
            }
        };
        Object.defineProperty(UIList.prototype, "items", {
            /**
             * 设置数据集
             * 根据数据集生成对应的ITEM容器
             * @return [UIListItemData]
             */
            get: function () {
                return this._items;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                var lastSelectedIndex = this.selectedIndex;
                // clear all
                this.clearItems();
                this._items = [];
                // create all
                if (Config.EDIT_MODE || this._itemModelClass) {
                    this.checkDeepLoopAndReset(this._itemModelGUI);
                    var len = v.length;
                    for (var i = 0, itemIndex = 0; i < len; i++) {
                        var node = v[i];
                        if (!node)
                            continue;
                        var nodeChildren = node.getList();
                        var childrenlen = nodeChildren.length;
                        for (var s = 0; s < childrenlen; s++) {
                            var data = nodeChildren[s];
                            this._items.push(data);
                            var ui;
                            if (Config.EDIT_MODE) {
                                ui = this._itemModelClass ? new this._itemModelClass(false, this._itemModelGUI) : GameUI.load(this.itemModelGUI, true);
                            }
                            else {
                                ui = new this._itemModelClass(false, this._itemModelGUI);
                            }
                            this._contentArea.addChild(ui);
                            this.itemInit(ui, data, itemIndex);
                            itemIndex++;
                        }
                    }
                    this.refreshOrder();
                }
                // 选中上次选中项
                // 重新选中
                if (lastSelectedIndex >= this.length)
                    lastSelectedIndex = this.length - 1;
                this.selectedIndex = lastSelectedIndex;
                // this.selectedItem = this.selectedItem;
                if (Config.EDIT_MODE) {
                    // @ts-ignore
                    EUIRoot.dataBaseWindow.win7.off(EUIWindowUI.EVENT_GUI_DATA_SYNC_COMPLETE, this, this.onItemUIChange);
                    // @ts-ignore
                    EUIRoot.dataBaseWindow.win7.on(EUIWindowUI.EVENT_GUI_DATA_SYNC_COMPLETE, this, this.onItemUIChange);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIList.prototype.onItemUIChange = function (syncGUIID) {
            if (syncGUIID == this.itemModelGUI) {
                // @ts-ignore
                EUIRoot.dataBaseWindow.win7.off(EUIWindowUI.EVENT_GUI_DATA_SYNC_COMPLETE, this, this.onItemUIChange);
                this.items = this.items;
            }
        };
        /**
         * 替换数据刷新显示，同时会触发 onCreateItem 函数
         * @param itemData 新数据
         * @param index 需要替换的items索引
         */
        UIList.prototype.replaceItem = function (itemData, index) {
            // @ts-ignore
            if (this.isDisposed)
                return;
            if (index < 0)
                return;
            var ui = this._contentArea.getChildAt(index);
            if (!ui)
                return;
            this._items[index] = itemData;
            ui.offAll();
            this.itemInit(ui, itemData, index);
        };
        /**
         * 添加数据
         * @param itemData 新数据
         * @param index [可选] 默认值=-1 插入的位置，-1表示向后插入
         * @return [UIRoot] 数据对应的显示对象
         */
        UIList.prototype.addItem = function (itemData, index) {
            if (index === void 0) { index = -1; }
            var data = itemData;
            var itemIndex = index == -1 ? this._items.length : Math.max(0, Math.min(index, this._items.length));
            this._items.splice(itemIndex, 0, data);
            var ui = new this._itemModelClass(false, this._itemModelGUI);
            this._contentArea.addChildAt(ui, itemIndex);
            this.itemInit(ui, data, itemIndex);
            this.refreshOrder();
            return ui;
        };
        /**
         * 移除数据
         * @param itemData 数据，如果该数据不在列表内则忽略
         * @return [number] 数据所在的位置
         */
        UIList.prototype.removeItem = function (itemData) {
            var itemIndex = this.items.indexOf(itemData);
            this.removeItemByIndex(itemIndex);
            return itemIndex;
        };
        /**
         * 移除数据，根据指定的位置
         * @param index 指定的位置
         * @return [UIListItemData] 数据
         */
        UIList.prototype.removeItemByIndex = function (index) {
            if (index < 0 || index >= this.items.length)
                return;
            var d = this._items[index];
            this._contentArea.removeChildAt(index);
            this._items.splice(index, 1);
            this.refreshOrder();
            return d;
        };
        /**
         * 更换位置
         * @param itemData 数据
         * @param toIndex 需要更换至的位置
         * @return [boolean] 是否更换成功
         */
        UIList.prototype.setItemIndex = function (itemData, toIndex) {
            var itemIndex = this.items.indexOf(itemData);
            return this.setItemIndexByIndex(itemIndex, toIndex);
        };
        /**
         * 更换位置-根据数据所在的位置
         * @param itemIndex 数据所在的位置
         * @param toIndex 需要更换至的位置
         * @return [boolean] 是否更换成功
         */
        UIList.prototype.setItemIndexByIndex = function (itemIndex, toIndex) {
            if (itemIndex < 0 || itemIndex >= this.items.length)
                return;
            var ui = this.getItemUI(itemIndex);
            var data = this.items[itemIndex];
            this._contentArea.setChildIndex(ui, toIndex);
            ArrayUtils.setIndex(this.items, data, toIndex);
            this.refreshOrder();
            return true;
        };
        /**
         * 获取显示对象
         * @param index 索引
         * @return [UIRoot]
         */
        UIList.prototype.getItemUI = function (index) {
            if (index < 0 || index >= this._contentArea.numChildren)
                return null;
            return this._contentArea.getChildAt(index);
        };
        /**
         * 项初始化
         */
        UIList.prototype.itemInit = function (ui, data, index) {
            var _this = this;
            if (!ui)
                return;
            // 装载的数据设置
            ui.data = data;
            ui.hitArea = new Rectangle(0, 0, this.itemWidth, this.itemHeight);
            // over 效果
            ui.on(EventObject.MOUSE_OVER, this, function (index, ui, data) {
                // -- 实时获取，因为可能中途插入、更换位置等
                index = _this.items.indexOf(data);
                if (_this.overSelectMode) {
                    _this.selectedIndex = index;
                }
                //
                _this._overItem = ui;
                _this.overIndex = index;
            }, [index, ui, data]);
            ui.on(EventObject.MOUSE_OUT, this, function (ui) {
                _this._overItem = null;
                _this.overIndex = -1;
            }, [ui]);
            // 选中 效果
            ui.on(EventObject.MOUSE_DOWN, this, function (ui, data, index) {
                if (_this.selectedItem == data) {
                    _this.event(UIList.ITEM_CLICK);
                    return;
                }
                _this.selectedItem = data;
                if (!UIList.SINGLE_FOCUS_MODE)
                    UIList.focus = _this;
            }, [ui, data, index]);
            // 双击 切换开启效果
            ui.on(EventObject.DOUBLE_CLICK, this, function (ui, data, index) {
                if (!data || data.numChildren == 0)
                    return;
                // -- 实时获取，因为可能中途插入、更换位置等
                index = _this.items.indexOf(data);
                data.isOpen = !data.isOpen;
                _this.refreshOrder();
                _this.event(UIList.OPEN_STATE_CHANGE, [ui, data, index]);
            }, [ui, data, index]);
            // 设置数据
            this.refreshItem(data);
            // 自定义回调
            this.event(UIList.ITEM_CREATE, [ui, data, index]);
            this.onCreateItem && this.onCreateItem.runWith([ui, data, index]);
        };
        /**
         * 刷新数据
         * @param item
         */
        UIList.prototype.refreshItem = function (item) {
            var idx = this.items.indexOf(item);
            if (idx == -1)
                return;
            var ui = this._contentArea.getChildAt(idx);
            var uiNames = item.uiNames;
            for (var i = 0; i < uiNames.length; i++) {
                var attrName = uiNames[i];
                var comp = ui[attrName];
                var value = item[attrName];
                if (comp && comp instanceof UIComponent.UIBase && value != null) {
                    switch (comp.className) {
                        case "UIBitmap":
                            comp.image = value;
                            break;
                        case "UIString":
                            comp.text = value;
                            break;
                        case "UIVariable":
                            comp.varID = value;
                            break;
                        case "UIAvatar":
                            comp.avatarID = value;
                            break;
                        case "UIStandAvatar":
                            comp.avatarID = value;
                            break;
                        case "UIAnimation":
                            comp.animationID = value;
                            break;
                        case "UIInput":
                            comp.text = value;
                            break;
                        case "UICheckBox":
                            comp.selected = value;
                            break;
                        case "UISwitch":
                            comp.switchID = value;
                            break;
                        case "UITabBox":
                            comp.items = value;
                            break;
                        case "UISlider":
                            comp.value = value;
                            break;
                        case "UIGUI":
                            comp.guiID = value;
                            break;
                        case "UIList":
                            comp.items = value;
                            break;
                    }
                }
            }
        };
        Object.defineProperty(UIList.prototype, "length", {
            /**
             * 列表的数据总个数。
             */
            get: function () { return this._items.length; },
            enumerable: false,
            configurable: true
        });
        ;
        Object.defineProperty(UIList.prototype, "selectedItem", {
            //------------------------------------------------------------------------------------------------------
            // ITEM 单体对象操作
            // 左右键单击:选中，CTRL、SHIFT多选
            // mouseover:选中效果
            // 
            //------------------------------------------------------------------------------------------------------
            /**
             * 选中项，根据指定的数据
             * @return [UIListItemData]
             */
            get: function () {
                return this._selectedItem;
            },
            set: function (v) {
                var idx = this._items.indexOf(v);
                this._selectedItem = idx != -1 ? v : null;
                this.selectedIndex = idx;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectedIndex", {
            /**
             * 选中项，根据索引（即所在数据组的位置，数据组包括未打开的隐藏树节点）
             * @return [number]
             */
            get: function () {
                return this._selectedIndex;
            },
            set: function (v) {
                // 表示可能已经替换了新的数据而索引未变
                var newSelectedItem = v < 0 ? null : this._items[v];
                if (this._selectedIndex != v || this._selectedItem != newSelectedItem) {
                    this._selectedIndex = v;
                    this._selectedItem = newSelectedItem;
                    this.refreshSelectedImagePos();
                    if (!this.__forceChange)
                        this.event(EventObject.CHANGE, [0]);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIList.prototype.setSelectedIndexForce = function (v) {
            this.__forceChange = true;
            this.selectedIndex = v;
            this.__forceChange = false;
        };
        Object.defineProperty(UIList.prototype, "overIndex", {
            /**
             * 悬停项，根据索引（即所在数据组的位置，数据组包括未打开的隐藏树节点）
             * @return [number]
             */
            get: function () {
                return this._overIndex;
            },
            set: function (v) {
                if (this._overIndex != v) {
                    this._overIndex = v;
                    if (this._overIndex < 0 || this._overIndex >= this.items.length) {
                        this._overItem = null;
                    }
                    else {
                        this._overItem = this.getItemUI(this._overIndex);
                    }
                    this.refreshOverImagePos();
                    if (!this.__forceChange)
                        this.event(EventObject.CHANGE, [1]);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIList.prototype.setOverIndexForce = function (v) {
            this.__forceChange = true;
            this.overIndex = v;
            this.__forceChange = false;
        };
        /**
         * 刷新选中图片位置根据选中项
         */
        UIList.prototype.refreshSelectedImagePos = function () {
            if (this.selectedIndex < 0 || this.selectedIndex >= this._contentArea.numChildren) {
                this._selectedImageBox.visible = false;
                return;
            }
            var ui = this._contentArea.getChildAt(this.selectedIndex);
            if (!ui) {
                this._selectedImageBox.visible = false;
                return;
            }
            this._selectedImageBox.visible = ui.visible;
            this._selectedImageBox.x = ui.x;
            this._selectedImageBox.y = ui.y;
        };
        /**
         * 刷新悬停图片位置根据悬停项
         */
        UIList.prototype.refreshOverImagePos = function () {
            if (this.overIndex < 0 || this.overIndex >= this._contentArea.numChildren) {
                this._overImageBox.visible = false;
                return;
            }
            var ui = this._contentArea.getChildAt(this.overIndex);
            if (!ui) {
                this._overImageBox.visible = false;
                return;
            }
            this._overImageBox.visible = ui.visible;
            this._overImageBox.x = ui.x;
            this._overImageBox.y = ui.y;
        };
        //------------------------------------------------------------------------------------------------------
        // 私有实现
        //------------------------------------------------------------------------------------------------------
        /**
         * 刷新排列
         */
        UIList.prototype.refreshOrder = function () {
            var len = this._contentArea.numChildren;
            this._itemSize = 0;
            for (var i = 0, s = 0; i < len; i++) {
                var ui = this._contentArea.getChildAt(i);
                var data = ui.data;
                if (data.isHideNode) {
                    ui.visible = false;
                    continue;
                }
                this._itemSize++;
                ui.visible = true;
                ui.x = (s % this.repeatX) * (this._itemWidth + this._spaceX) + data.depth * this.subitemIndentation;
                ui.y = Math.floor(s / this.repeatX) * (this._itemHeight + this._spaceY);
                s++;
            }
            this._overImageBox.visible = s > 0 && this.selectEnable;
            this._contentArea.width = (this._itemWidth * this.repeatX) + (this._spaceX * this.repeatX - 1);
            this._contentArea.height = Math.ceil(len / this.repeatX) * this._itemHeight + Math.max(0, Math.ceil(len / this.repeatX) - 1) * this._spaceY;
            this._overImage.width = this._itemWidth;
            this._overImage.height = this._itemHeight;
            if (this._overItem) {
                this._overImageBox.x = this._overItem.x;
                this._overImageBox.y = this._overItem.y;
            }
            this._selectedImage.width = this._itemWidth;
            this._selectedImage.height = this._itemHeight;
            this.refreshSelectedImagePos();
            this.refresh();
        };
        /**
         * 自定义方法名称
         */
        UIList.customCompFunctionNames = ["itemModelGUI", "previewSize", "selectEnable", "repeatX", "itemWidth", "itemHeight", "spaceX", "spaceY", "scrollShowType",
            "hScrollBar", "hScrollBg", "vScrollBar", "vScrollBg", "scrollWidth", "selectImageURL", "selectImageGrid9", "selectedImageAlpha", "selectedImageOnTop",
            "overImageURL", "overImageGrid9", "overImageAlpha", "overImageOnTop", "overSelectMode", "slowmotionType"];
        /**
         * 事件：当焦点更改时派发的事件 onFocusChange(lastFocus:UIList,currentFocus:UIList);
         */
        UIList.EVENT_FOCUS_CHANGE = "UIListEVENT_FOCUS_CHANGE";
        /**
         * 事件：打开状态发生改变时 onChange(ui,data,index)
         */
        UIList.OPEN_STATE_CHANGE = "UIList_EVENT_OPEN_STATE_CHANGE";
        /**
         * 事件：点击确认项（已选中该项时再点击则派发事件/或ENTER键）
         */
        UIList.ITEM_CLICK = "UIListITEM_CLICK";
        /**
         * 事件：创建项时
         */
        UIList.ITEM_CREATE = "UIListITEM_CREATE";
        /**
         * 按键-向上移动 开启键盘支持后的默认快捷键，支持修改
         */
        UIList.KEY_UP = [Keyboard.UP];
        /**
         * 按键-向下移动 开启键盘支持后的默认快捷键，支持修改
         */
        UIList.KEY_DOWN = [Keyboard.DOWN];
        /**
         * 按键-向左移动 开启键盘支持后的默认快捷键，支持修改
         */
        UIList.KEY_LEFT = [Keyboard.LEFT];
        /**
         * 按键-向右移动 开启键盘支持后的默认快捷键，支持修改
         */
        UIList.KEY_RIGHT = [Keyboard.RIGHT];
        /**
         * 按键-确定 开启键盘支持后的默认快捷键，支持修改
         */
        UIList.KEY_ENTER = [Keyboard.ENTER, Keyboard.SPACE];
        /**
         * 按键-取消 开启键盘支持后的默认快捷键，支持修改
         */
        UIList.KEY_ESC = [Keyboard.ESCAPE];
        /**
         * 避免连续按下ENTER/ESC
         */
        UIList.keyDownEnter = false;
        UIList.keyDownEsc = false;
        return UIList;
    }(UIComponent.UIRoot));
    UIComponent.UIList = UIList;
})(UIComponent || (UIComponent = {}));
/**
 * 属性格式：默认路径、是否锁定该路径、支持的格式
 * Created by 黑暗之神KDS on 2018-10-12 14:00:10.
 */
var UIComponent;
(function (UIComponent) {
    var UISlider = /** @class */ (function (_super) {
        __extends(UISlider, _super);
        /**
         * 构造函数
         */
        function UISlider() {
            var _this = _super.call(this) || this;
            //背景
            _this._image1 = "";
            //滑块
            _this._image2 = "";
            //填充
            _this._image3 = "";
            //遮罩
            _this._blockFillMask = new UIImage();
            // 0=块模式 1-填充模式 2-块与填充同时显示
            _this._blockFillMode = 2;
            //
            _this._bgImg = new UIImage();
            _this._blockImg = new UIImage();
            _this._blockFillImg = new UIImage();
            _this._blockGrid9 = "0,0,0,0,0";
            _this._bgGrid9 = "0,0,0,0,0";
            _this._blockFillGrid9 = "0,0,0,0,0";
            _this.addChild(_this._bgImg);
            _this._bgImg.addChild(_this._blockImg);
            _this.className = "UISlider";
            // this.add_MOUSEOVER(this.onmouseover, this);
            // this.add_MOUSEOUT(this.onmouseout, this);
            _this.on(EventObject.RESIZE, _this, _this.refreshSize);
            if (!Config.EDIT_MODE) {
                _this.on(EventObject.DISPLAY, _this, _this.onDisplay);
                _this.on(EventObject.UNDISPLAY, _this, _this.unDisplay);
                _this._onVarChange = Callback.New(_this.onVarChange, _this);
                _this._blockImg.add_MOUSEDOWN(_this.onMouseDown, _this);
                _this._bgImg.add_MOUSEDOWN(function (e) {
                    if (e.target != _this._bgImg)
                        return;
                    if (_this.step == 0)
                        return;
                    var blockTex = AssetManager.getImage(_this.image2);
                    if (!blockTex)
                        return;
                    //
                    if (_this._blockFillMode == 1 || _this._blockFillMode == 2) {
                        if (!_this._blockFillImg.stage)
                            _this._bgImg.addChildAt(_this._blockFillImg, 0);
                    }
                    //
                    var lastValue = _this._value;
                    var per = 0;
                    if (_this.transverseMode) {
                        _this._blockImg.x = _this._bgImg.mouseX - blockTex.width * 0.5;
                        if (_this._blockPosMode == 0) {
                            _this._blockImg.x = Math.max(Math.min(_this._blockImg.x, _this.width - blockTex.width), 0);
                            per = _this._blockImg.x / (_this.width - blockTex.width);
                        }
                        else if (_this._blockPosMode == 1) {
                            _this._blockImg.x = Math.max(Math.min(_this._blockImg.x, _this.width - blockTex.width * 0.5), -blockTex.width * 0.5);
                            per = (_this._blockImg.x + blockTex.width * 0.5) / _this.width;
                        }
                        else if (_this._blockPosMode == 2) {
                            _this._blockImg.x = Math.max(Math.min(_this._blockImg.x, _this.width), -blockTex.width);
                            per = (_this._blockImg.x + blockTex.width) / (_this.width + blockTex.width);
                        }
                        if (_this._blockFillImg.stage) {
                            if (_this._fillStrething) {
                                _this._blockFillImg.width = _this.width;
                                _this._blockFillMask.x = -_this.width + _this._blockImg.x + blockTex.width * 0.5;
                            }
                            else {
                                _this._blockFillImg.width = _this._blockImg.x + blockTex.width * 0.5;
                            }
                        }
                    }
                    else {
                        _this._blockImg.y = _this._bgImg.mouseY - blockTex.height * 0.5;
                        if (_this._blockPosMode == 0) {
                            _this._blockImg.y = Math.max(Math.min(_this._blockImg.y, _this.height - blockTex.height), 0);
                            per = _this._blockImg.y / (_this.height - blockTex.height);
                        }
                        else if (_this._blockPosMode == 1) {
                            _this._blockImg.y = Math.max(Math.min(_this._blockImg.y, _this.height - blockTex.height * 0.5), -blockTex.height * 0.5);
                            per = (_this._blockImg.y + blockTex.height * 0.5) / _this.height;
                        }
                        else if (_this._blockPosMode == 2) {
                            _this._blockImg.y = Math.max(Math.min(_this._blockImg.y, _this.height), -blockTex.height);
                            per = (_this._blockImg.y + blockTex.height) / (_this.height + blockTex.height);
                        }
                        if (_this._blockFillImg.stage) {
                            if (_this._fillStrething) {
                                _this._blockFillImg.height = _this.height;
                                _this._blockFillMask.y = -_this.height + _this._blockImg.y + blockTex.height * 0.5;
                            }
                            else {
                                _this._blockFillImg.height = _this._blockImg.y + blockTex.height * 0.5;
                            }
                        }
                    }
                    per = Math.max(Math.min(per, 1), 0);
                    var value = (_this.max - _this.min == 0) ? 0 : (per * (_this.max - _this.min) + _this.min);
                    var pow = Math.pow(10, (_this._step + "").length - 1);
                    value = Math.round(Math.round(value / _this._step) * _this._step * pow) / pow;
                    value = Math.max(Math.min(value, _this.max), _this.min);
                    if (value != lastValue) {
                        _this.setValue(value, false, true);
                    }
                    _this.onMouseDown(e);
                }, _this);
            }
            _this.min = 0;
            _this.max = 100;
            _this.width = 191;
            _this.height = 6;
            _this.step = 1;
            _this.value = 50;
            _this.transverseMode = true;
            _this.blockPosMode = 0;
            _this.fillStrething = false;
            return _this;
            // this._blockImg.alpha = 0.5;
        }
        /**
         * 初始状态
         */
        UISlider.prototype.inEditorInit = function () {
            this.image1 = "asset/image/picture/control/slider_bg.png";
            this.image2 = "asset/image/picture/control/slider_block.png";
            this.image3 = "asset/image/picture/control/slider_bgfill.png";
        };
        /**
         * 开始检测加载完毕的情形
         */
        UISlider.prototype.loadAssetTest = function () {
            AssetManager.loadImages([this.image1, this.image2, this.image3], Callback.New(function () {
                this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, false);
        };
        /**
         * 释放
         */
        UISlider.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (this.___currentRequestLoadImages)
                    AssetManager.disposeImages(this.___currentRequestLoadImages);
                this._bgImg.removeSelf();
                this._bgImg.offAll();
                this._bgImg = null;
                this._blockImg.removeSelf();
                this._blockImg.offAll();
                this._blockImg = null;
                this._blockFillImg.removeSelf();
                this._blockFillImg.offAll();
                this._blockFillImg = null;
                this._blockFillMask.removeSelf();
                this._blockFillMask.offAll();
                this._blockFillMask = null;
                if (!Config.EDIT_MODE) { //非编辑器模式才会添加侦听
                    var varID = this._bindingVarID;
                    if (varID != 0 && this.className == "UISlider" && Game.player) {
                        Game.player.removeListenerPlayerVariable(0, varID, this._onVarChange);
                    }
                }
            }
            _super.prototype.dispose.call(this);
        };
        UISlider.prototype.onDisplay = function () {
            this.refreshBindingVarID();
        };
        UISlider.prototype.unDisplay = function () {
            var varID = this._bindingVarID;
            if (varID != 0) {
                Game.player.removeListenerPlayerVariable(0, varID, this._onVarChange);
            }
        };
        Object.defineProperty(UISlider.prototype, "image1", {
            //------------------------------------------------------------------------------------------------------
            // 设置显示
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._image1;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                this._image1 = v;
                this.refImageRecord(0, v);
                AssetManager.loadImage(v); //增加引用
                this.refresh();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "image2", {
            get: function () {
                return this._image2;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                this._image2 = v;
                this.refImageRecord(1, v);
                AssetManager.loadImage(v); //增加引用
                this.refresh();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "image3", {
            get: function () {
                return this._image3;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                this._image3 = v;
                this.refImageRecord(2, v);
                AssetManager.loadImage(v); //增加引用
                this.refresh();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "blockFillMode", {
            // 0=块模式 1-填充模式 2-块与填充同时显示
            get: function () {
                return this._blockFillMode;
            },
            set: function (v) {
                v = Math.floor(v);
                this._blockFillMode = v;
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "blockPosMode", {
            //------------------------------------------------------------------------------------------------------
            // 追加模式
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._blockPosMode;
            },
            set: function (v) {
                this._blockPosMode = v;
                v = Math.floor(v);
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "fillStrething", {
            get: function () {
                return this._fillStrething;
            },
            set: function (v) {
                this._fillStrething = v;
                if (this._fillStrething) {
                    this._blockFillMask.skin = this.image3;
                    this._blockFillImg.mask = this._blockFillMask;
                }
                else {
                    this._blockFillImg.mask = null;
                }
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "transverseMode", {
            //------------------------------------------------------------------------------------------------------
            // 是否横向
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._transverseMode;
            },
            set: function (v) {
                this._transverseMode = v;
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "min", {
            get: function () {
                return this._min;
            },
            set: function (v) {
                this._min = v;
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "max", {
            get: function () {
                return this._max;
            },
            set: function (v) {
                this._max = v;
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (v) {
                v = Math.max(Math.min(v, this.max), this.min);
                this.setValue(v, true, false);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * 设置当前值，不派发事件
         * @param v
         */
        UISlider.prototype.setValueForce = function (v) {
            this.__forceChange = true;
            this.value = v;
            this.__forceChange = false;
        };
        /**
         * 内部：设置值
         * @param v 值
         * @param isRefreshSize 是否刷新尺寸
         * @param force 是否强制设置，强制设置则无需检查是否改变
         */
        UISlider.prototype.setValue = function (v, isRefreshSize, force) {
            // 如果是绑定了变量的情况下，且单机版本将会影响变量（由于绑定了变量，直接修改变量会自动同步value）
            if (this._isBindingVarID && this._bindingVarID && Config.SINGLE_PLAYER_CORE) {
                Game.player.variable.setVariable(this._bindingVarID, v);
                return;
            }
            if (force) {
                this._value = v;
                if (isRefreshSize)
                    this.refreshSize();
                this.event(EventObject.CHANGE);
            }
            else if (v != this._value) {
                var lastValue = this._value;
                this._value = v;
                if (isRefreshSize)
                    this.refreshSize();
                if (this._value != lastValue) {
                    if (!this.__forceChange)
                        this.event(EventObject.CHANGE);
                }
            }
        };
        Object.defineProperty(UISlider.prototype, "isBindingVarID", {
            get: function () {
                return this._isBindingVarID;
            },
            //------------------------------------------------------------------------------------------------------
            //  变量
            //------------------------------------------------------------------------------------------------------
            set: function (v) {
                this._isBindingVarID = v;
                this.refreshBindingVarID();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "bindingVarID", {
            get: function () {
                return this._bindingVarID;
            },
            set: function (v) {
                this._bindingVarID = v;
                this.refreshBindingVarID();
            },
            enumerable: false,
            configurable: true
        });
        UISlider.prototype.refreshBindingVarID = function () {
            if (!Config.EDIT_MODE) {
                if (this._isBindingVarID && this._isBindingVarID) {
                    if (this.displayedInStage) {
                        Game.player.removeListenerPlayerVariable(0, this._bindingVarID, this._onVarChange);
                        Game.player.addListenerPlayerVariable(0, this._bindingVarID, this._onVarChange);
                    }
                }
            }
        };
        UISlider.prototype.onVarChange = function (typeID, varID, value) {
            if (value != this._value) {
                var lastValue = this._value;
                this._value = value;
                this.refreshSize();
                if (this._value != lastValue) {
                    if (!this.__forceChange)
                        this.event(EventObject.CHANGE);
                }
            }
        };
        Object.defineProperty(UISlider.prototype, "step", {
            //------------------------------------------------------------------------------------------------------
            // 
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._step;
            },
            set: function (v) {
                this._step = v;
            },
            enumerable: false,
            configurable: true
        });
        //------------------------------------------------------------------------------------------------------
        // 事件
        //------------------------------------------------------------------------------------------------------
        UISlider.prototype.onmouseover = function (e) {
        };
        UISlider.prototype.onmouseout = function (e) {
        };
        UISlider.prototype.onMouseDown = function (e) {
            if (this._blockFillMode == 1)
                return;
            var rect = new Rectangle();
            var blockTex = AssetManager.getImage(this.image2);
            if (!blockTex)
                return;
            if (this.transverseMode) {
                var posX = 0;
                if (this._blockPosMode == 1)
                    posX = -blockTex.width * 0.5;
                else if (this._blockPosMode == 2)
                    posX = -blockTex.width;
                var posW = this.width - blockTex.width;
                if (this._blockPosMode == 1)
                    posW = this.width;
                else if (this._blockPosMode == 2)
                    posW = this.width + blockTex.width;
                rect.x = posX;
                rect.y = (this.height - blockTex.height) / 2;
                rect.width = posW;
                rect.height = 0;
            }
            else {
                var posY = 0;
                if (this._blockPosMode == 1)
                    posY = -blockTex.height * 0.5;
                else if (this._blockPosMode == 2)
                    posY = -blockTex.height;
                var posH = this.height - blockTex.height;
                if (this._blockPosMode == 1)
                    posH = this.height;
                else if (this._blockPosMode == 2)
                    posH = this.height + blockTex.height;
                rect.x = (this.width - blockTex.width) / 2;
                rect.y = posY;
                rect.width = 0;
                rect.height = posH;
            }
            this._blockImg.startDrag(rect);
            this._blockImg.on(EventObject.DRAG_MOVE, this, this.onMouseDrag);
            stage.once(EventObject.MOUSE_UP, this, this.onMouseUp);
        };
        UISlider.prototype.onMouseDrag = function () {
            if (this.step == 0)
                return;
            //
            if (this._blockFillMode == 1 || this._blockFillMode == 2) {
                if (!this._blockFillImg.stage)
                    this._bgImg.addChildAt(this._blockFillImg, 0);
            }
            var lastValue = this._value;
            var blockTex = AssetManager.getImage(this.image2);
            var per = 0;
            if (this.transverseMode) {
                if (this._blockFillImg.stage) {
                    if (this._fillStrething) {
                        this._blockFillImg.width = this.width;
                        this._blockFillMask.x = -this.width + this._blockImg.x + blockTex.width * 0.5;
                    }
                    else {
                        this._blockFillImg.width = this._blockImg.x + blockTex.width * 0.5;
                    }
                }
                if (this._blockPosMode == 0)
                    per = this._blockImg.x / (this.width - blockTex.width);
                else if (this._blockPosMode == 1)
                    per = (this._blockImg.x + blockTex.width * 0.5) / this.width;
                else if (this._blockPosMode == 2)
                    per = (this._blockImg.x + blockTex.width) / (this.width + blockTex.width);
            }
            else {
                if (this._blockFillImg.stage) {
                    if (this._fillStrething) {
                        this._blockFillImg.height = this.height;
                        this._blockFillMask.y = -this.height + this._blockImg.y + blockTex.height * 0.5;
                    }
                    else {
                        this._blockFillImg.height = this._blockImg.y + blockTex.height * 0.5;
                    }
                }
                if (this._blockPosMode == 0)
                    per = this._blockImg.y / (this.height - blockTex.height);
                else if (this._blockPosMode == 1)
                    per = (this._blockImg.y + blockTex.height * 0.5) / this.height;
                else if (this._blockPosMode == 2)
                    per = (this._blockImg.y + blockTex.height) / (this.height + blockTex.height);
            }
            per = Math.max(Math.min(per, 1), 0);
            var value = (this.max - this.min == 0) ? 0 : (per * (this.max - this.min) + this.min);
            var pow = Math.pow(10, (this._step + "").length - 1);
            value = Math.round(Math.round(value / this._step) * this._step * pow) / pow;
            value = Math.max(Math.min(value, this.max), this.min);
            if (value != lastValue) {
                this.setValue(value, false, true);
            }
        };
        UISlider.prototype.onMouseUp = function () {
            this._blockImg.stopDrag();
            this._blockImg.off(EventObject.DRAG_MOVE, this, this.onMouseDrag);
        };
        Object.defineProperty(UISlider.prototype, "blockGrid9Width", {
            //------------------------------------------------------------------------------------------------------
            // 九宫格
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._blockImg.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "blockGrid9Height", {
            get: function () {
                return this._blockImg.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "blockGrid9Skin", {
            get: function () {
                return this._blockImg.skin;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "blockGrid9", {
            get: function () {
                return this._blockGrid9;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._blockGrid9 = this._blockImg.sizeGrid = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "bgGrid9Width", {
            get: function () {
                return this._bgImg.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "bgGrid9Height", {
            get: function () {
                return this._bgImg.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "bgGrid9Skin", {
            get: function () {
                return this._bgImg.skin;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "bgGrid9", {
            get: function () {
                return this._bgGrid9;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._bgGrid9 = this._bgImg.sizeGrid = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "blockFillGrid9Width", {
            get: function () {
                return this._blockFillImg.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "blockFillGrid9Height", {
            get: function () {
                return this._blockFillImg.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "blockFillGrid9Skin", {
            get: function () {
                return this._blockFillImg.skin;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "blockFillGrid9", {
            get: function () {
                return this._blockFillGrid9;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._blockFillGrid9 = this._blockFillImg.sizeGrid = v;
            },
            enumerable: false,
            configurable: true
        });
        //------------------------------------------------------------------------------------------------------
        // 刷新
        //------------------------------------------------------------------------------------------------------
        UISlider.prototype.refresh = function () {
            var _this = this;
            if (this.isDisposed)
                return;
            AssetManager.loadImages([this.image1, this.image2, this.image3], Callback.New(function (image1, image2, image3) {
                if (_this.isDisposed)
                    return;
                if (_this.image1 != image1 || _this.image2 != image2 || _this.image3 != image3)
                    return;
                _this._bgImg.skin = _this.image1;
                _this._blockImg.skin = _this.image2;
                _this._blockFillImg.skin = _this.image3;
                if (_this._fillStrething)
                    _this._blockFillMask.skin = _this.image3;
                _this.refreshSize();
            }, this, [this.image1, this.image2, this.image3]), true, false);
        };
        UISlider.prototype.refreshSize = function () {
            if (this.isDisposed)
                return;
            // if (this.step == 0) return;
            // var pow = Math.pow(10, (this._step + "").length - 1);
            // this._value = Math.round(Math.round(this._value / this._step) * this._step * pow) / pow;
            this._bgImg.width = this.width;
            this._bgImg.height = this.height;
            var blockTex = AssetManager.getImage(this.image2);
            this._value = Math.max(Math.min(this._value, this.max), this.min);
            var per = (this.max - this.min == 0) ? 0 : ((this._value - this.min) / (this.max - this.min));
            if (this.transverseMode) {
                // 填充模式/带块的填充模式
                if (this._blockFillMode == 1 || this._blockFillMode == 2) {
                    if (!this._blockFillImg.stage)
                        this._bgImg.addChildAt(this._blockFillImg, 0);
                    this._blockFillImg.x = 0;
                    this._blockFillImg.y = 0;
                    this._blockFillImg.height = this.height;
                    if (this._fillStrething) {
                        this._blockFillImg.width = this.width;
                        this._blockFillMask.width = this.width;
                        this._blockFillMask.height = this.height;
                        this._blockFillMask.x = -this.width + per * this.width;
                    }
                    else {
                        this._blockFillImg.width = per * this.width;
                    }
                }
                // 块模式/带块的填充模式
                if (this._blockFillMode == 0 || this._blockFillMode == 2) {
                    if (!this._blockImg.stage)
                        this._bgImg.addChild(this._blockImg);
                    if (blockTex) {
                        var pos = per * (this.width - blockTex.width);
                        if (this._blockPosMode == 1)
                            pos = per * this.width - blockTex.width * 0.5;
                        else if (this._blockPosMode == 2)
                            pos = per * (this.width + blockTex.width) - blockTex.width;
                        this._blockImg.x = pos;
                        this._blockImg.y = (this.height - blockTex.height) / 2;
                        this._blockImg.width = blockTex.width;
                        this._blockImg.height = blockTex.height;
                    }
                }
            }
            else {
                if (this._blockFillMode == 1 || this._blockFillMode == 2) {
                    if (!this._blockFillImg.stage)
                        this._bgImg.addChildAt(this._blockFillImg, 0);
                    this._blockFillImg.x = 0;
                    this._blockFillImg.y = 0;
                    this._blockFillImg.width = this.width;
                    if (this._fillStrething) {
                        this._blockFillImg.height = this.height;
                        this._blockFillMask.height = this.height;
                        this._blockFillMask.width = this.width;
                        this._blockFillMask.y = -this.height + per * this.height;
                    }
                    else {
                        this._blockFillImg.height = per * this.height;
                    }
                }
                if (this._blockFillMode == 0 || this._blockFillMode == 2) {
                    if (!this._blockImg.stage)
                        this._bgImg.addChild(this._blockImg);
                    if (blockTex) {
                        var pos = per * (this.height - blockTex.height);
                        if (this._blockPosMode == 1)
                            pos = per * this.height - blockTex.height * 0.5;
                        else if (this._blockPosMode == 2)
                            pos = per * (this.height + blockTex.height) - blockTex.height;
                        this._blockImg.y = pos;
                        this._blockImg.x = (this.width - blockTex.width) / 2;
                        this._blockImg.width = blockTex.width;
                        this._blockImg.height = blockTex.height;
                    }
                }
            }
            if (this._blockFillMode != 1) {
                if (!this._blockImg.stage)
                    this._bgImg.addChild(this._blockImg);
            }
            else {
                this._blockImg.removeSelf();
            }
            if (this._blockFillMode == 0 || this.value == this.min) {
                this._blockFillImg.removeSelf();
            }
        };
        Object.defineProperty(UISlider.prototype, "onChangeFragEvent", {
            //------------------------------------------------------------------------------------------------------
            // 事件
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._onChangeFragEvent;
            },
            set: function (v) {
                this._onChangeFragEvent = v;
                if (v) {
                    this.off(EventObject.CHANGE, this, this.onChange_private);
                    this.on(EventObject.CHANGE, this, this.onChange_private);
                }
                else {
                    this.off(EventObject.CHANGE, this, this.onChange_private);
                }
            },
            enumerable: false,
            configurable: true
        });
        UISlider.prototype.onChange_private = function () {
            if (Config.SINGLE_PLAYER_CORE) {
                if (this._onChangeFragEvent && this.guiRoot && !this.guiRoot.onlyForPreload) {
                    CommandPage.startTriggerFragmentEvent(this._onChangeFragEvent, Game.player.sceneObject, Game.player.sceneObject);
                }
            }
        };
        /**
         * 自定义方法名称
         */
        UISlider.customCompFunctionNames = ["image1", "bgGrid9", "image2", "blockGrid9", "image3", "blockFillGrid9", "step", "min", "max", "value",
            "transverseMode", "blockFillMode", "blockPosMode", "fillStrething", "isBindingVarID", "bindingVarID"];
        return UISlider;
    }(UIComponent.UIBase));
    UIComponent.UISlider = UISlider;
})(UIComponent || (UIComponent = {}));
/**
 * Created by 黑暗之神KDS on 2020-01-26 23:19:30.
 */
var UIComponent;
(function (UIComponent) {
    var UIStandAvatar = /** @class */ (function (_super) {
        __extends(UIStandAvatar, _super);
        function UIStandAvatar() {
            var _this = _super.call(this) || this;
            _this.className = "UIStandAvatar";
            return _this;
        }
        /**
         * 开始检测加载完毕的情形
         */
        UIStandAvatar.prototype.loadAssetTest = function () {
            AssetManager.preLoadStandAvatarAsset(this.avatarID, Callback.New(function () {
                this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, true);
        };
        UIStandAvatar.prototype.__init = function () {
            var _this = this;
            this._avatar = new StandAvatar();
            if (Config.EDIT_MODE) {
                this._avatar.openAutoHitArea();
                this.mouseEnabled = true;
            }
            this.addChildAt(this._avatar, 0);
            this.avatar.on(Avatar.RENDER, this, this.refreshSize);
            this.avatar.on(EventObject.LOADED, this, function () {
                _this._oriMode = _this.avatar.oriMode;
                _this.refreshSize();
                // this.event(EventObject.LOADED);
            });
        };
        Object.defineProperty(UIStandAvatar.prototype, "flip", {
            get: function () {
                return this.avatar.flip;
            },
            set: function (v) {
                if (v == this.flip)
                    return;
                this.avatar.flip = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIStandAvatar.prototype, "avatarID", {
            get: function () {
                return this.avatar.id;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                if (v == this.avatarID)
                    return;
                v = Math.floor(v);
                this.avatar.id = v;
                this.avatar.syncLoadWhenAssetExist = this.syncLoadedEventWhenAssetExist;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * 自定义方法名称
         */
        UIStandAvatar.customCompFunctionNames = ["avatarID", "actionID", "scaleNumberX", "scaleNumberY", "flip", "playOnce", "isPlay", "avatarFrame", "avatarFPS", "avatarHue"];
        return UIStandAvatar;
    }(UIComponent.UIAvatar));
    UIComponent.UIStandAvatar = UIStandAvatar;
})(UIComponent || (UIComponent = {}));
/**
 * Created by 黑暗之神KDS on 2019-04-14 22:31:21.
 */
var UIComponent;
(function (UIComponent) {
    var UISwitch = /** @class */ (function (_super) {
        __extends(UISwitch, _super);
        function UISwitch() {
            var _this = _super.call(this) || this;
            _this.className = "UISwitch";
            _this._selected = 1;
            if (!Config.EDIT_MODE) {
                _this._selected = 0;
                _this._onVarChange = Callback.New(_this.onVarChange, _this);
                _this.add_DISPLAY(_this.onAdded, _this);
                _this.add_UNDISPLAY(_this.onRemoved, _this);
                _this.offAll(EventObject.CLICK);
            }
            else {
                _this._previewselected = true;
            }
            return _this;
        }
        Object.defineProperty(UISwitch.prototype, "switchID", {
            get: function () {
                return this.getVarID();
            },
            set: function (v) {
                v = Math.floor(v);
                var lastVarID = this.getVarID();
                if (lastVarID != 0)
                    Game.player.removeListenerPlayerVariable(1, lastVarID, this._onVarChange);
                this._selected = v;
                var varID = this.getVarID();
                if (this.displayedInStage && varID != 0)
                    Game.player.addListenerPlayerVariable(1, varID, this._onVarChange);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISwitch.prototype, "selected", {
            get: function () {
                return this._selected;
            },
            set: function (v) {
                this._selected = v;
                if (!Config.EDIT_MODE) {
                    this.switchID = v;
                }
            },
            enumerable: false,
            configurable: true
        });
        UISwitch.prototype.onVarChange = function (typeID, varID, value) {
            this.onChange_private();
            this.refresh();
        };
        Object.defineProperty(UISwitch.prototype, "previewselected", {
            get: function () {
                return this._previewselected;
            },
            /**
             * 编辑器预览选中效果
             * @param v
             */
            set: function (v) {
                if (!Config.EDIT_MODE)
                    return;
                this._previewselected = v;
                var url = this._previewselected ? this.image2 : this.image1;
                var gridText = this._previewselected ? this._grid9img2 : this._grid9img1;
                if (url) {
                    this._image.skin = url;
                    this._image.width = this.width;
                    this._image.height = this.height;
                    this._image.sizeGrid = gridText;
                }
            },
            enumerable: false,
            configurable: true
        });
        UISwitch.prototype.getVarID = function () {
            return this._selected;
        };
        UISwitch.prototype.onAdded = function (e) {
            var varID = this.getVarID();
            if (varID != 0) {
                Game.player.addListenerPlayerVariable(1, varID, this._onVarChange);
            }
        };
        UISwitch.prototype.onRemoved = function (e) {
            var varID = this.getVarID();
            if (varID != 0) {
                Game.player.removeListenerPlayerVariable(1, varID, this._onVarChange);
            }
        };
        UISwitch.prototype.refresh = function () {
            var _this = this;
            if (this.isDisposed)
                return;
            this.graphics.clear();
            if (!Config.EDIT_MODE) {
                var varID = this.getVarID();
                if (varID) {
                    var switchBool = Game.player.variable.getSwitch(varID);
                    if (switchBool) {
                        var url = this.image2;
                        var gridText = this._grid9img2;
                    }
                    else {
                        url = this.image1;
                        gridText = this._grid9img1;
                    }
                    if (url) {
                        AssetManager.loadImage(url, Callback.New(function (url, tex) {
                            if (_this.isDisposed)
                                return;
                            var varID = _this.getVarID();
                            var thisUrl = Game.player.variable.getSwitch(varID) ? _this.image2 : _this.image1;
                            if (thisUrl != url)
                                return;
                            _this._image.skin = url;
                            _this._image.width = _this.width;
                            _this._image.height = _this.height;
                            _this._image.sizeGrid = gridText;
                        }, this, [url]), true, false);
                    }
                }
            }
            else {
                var url = this._previewselected ? this.image2 : this.image1;
                var gridText = this._previewselected ? this._grid9img2 : this._grid9img1;
                if (url) {
                    AssetManager.loadImage(url, Callback.New(function (url, tex) {
                        if (_this.isDisposed)
                            return;
                        var thisUrl = _this._previewselected ? _this.image2 : _this.image1;
                        if (thisUrl != url)
                            return;
                        _this._image.skin = url;
                        _this._image.width = _this.width;
                        _this._image.height = _this.height;
                        _this._image.sizeGrid = gridText;
                    }, this, [url]), true, false);
                }
            }
        };
        /**
        * 释放
        */
        UISwitch.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (!Config.EDIT_MODE) { //非编辑器模式才会添加侦听
                    var varID = this.getVarID();
                    if (varID != 0 && this.className == "UISwitch") {
                        Game.player.removeListenerPlayerVariable(1, varID, this._onVarChange);
                    }
                }
                _super.prototype.dispose.call(this);
            }
        };
        /**
        * 自定义方法名称
        */
        UISwitch.customCompFunctionNames = ["selected", "image1", "grid9img1", "image2", "grid9img2", "previewselected"];
        return UISwitch;
    }(UIComponent.UICheckBox));
    UIComponent.UISwitch = UISwitch;
})(UIComponent || (UIComponent = {}));
/**
 * Created by 黑暗之神KDS on 2019-04-14 22:31:21.
 */
var UIComponent;
(function (UIComponent) {
    var UITabBox = /** @class */ (function (_super) {
        __extends(UITabBox, _super);
        function UITabBox() {
            var _this = _super.call(this) || this;
            _this._selectedIndex = -1;
            _this._rowMode = false;
            _this._grid9img1 = "0,0,0,0,0";
            _this._grid9img2 = "0,0,0,0,0";
            _this._spacing = 0;
            _this._labelSelectedColor = "#FFFFFF";
            _this._labelColor = "#666666";
            _this._labelSize = 16;
            _this._labelLetterSpacing = 0;
            _this._labelAlign = 1;
            _this._labelValign = 1;
            _this._tabRoot = new Sprite();
            _this._itemButtons = [];
            _this._itemLabels = [];
            _this._labelDx = 0;
            _this._labelDy = 0;
            _this._labelStroke = 0;
            _this._labelStrokeColor = "#000000";
            _this.addChild(_this._tabRoot);
            _this.className = "UITabBox";
            if (Config.EDIT_MODE) {
                _this.modifyWidthHeightEnabled = false;
            }
            _this.rowMode = false;
            _this.spacing = 5;
            _this.selectedIndex = 0;
            _this._labelFont = Config.DEFAULT_FONT;
            return _this;
        }
        /**
         * 编辑器专用初始化
         */
        UITabBox.prototype.inEditorInit = function () {
            this.itemWidth = 141;
            this.itemHeight = 41;
            this.width = 433;
            this.height = 41;
            this._labelDx = 0;
            this._labelDy = 0;
            this.itemImage1 = "asset/image/picture/control/tab_unselected.png";
            this.itemImage2 = "asset/image/picture/control/tab_selected.png";
            this.items = "标签项1,标签项2,标签项3";
        };
        /**
         * 开始检测加载完毕的情形
         */
        UITabBox.prototype.loadAssetTest = function () {
            var _this = this;
            AssetManager.loadImages([this.itemImage1, this.itemImage2], Callback.New(function () {
                _this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, false);
        };
        /**
         * 释放
         */
        UITabBox.prototype.dispose = function () {
            if (!this.isDisposed) {
                this.clearItems();
                this._tabRoot.removeSelf();
                this._tabRoot.offAll();
                this._tabRoot = null;
            }
            _super.prototype.dispose.call(this);
        };
        Object.defineProperty(UITabBox.prototype, "selectedIndex", {
            get: function () {
                return this._selectedIndex;
            },
            //------------------------------------------------------------------------------------------------------
            // 
            //------------------------------------------------------------------------------------------------------
            /**
             * 选中
             */
            set: function (v) {
                v = Math.floor(v);
                if (this._selectedIndex != v) {
                    this._selectedIndex = v;
                    this.refreshSelected();
                    this.onSelected();
                    if (!this.__forceChange)
                        this.event(EventObject.CHANGE);
                }
            },
            enumerable: false,
            configurable: true
        });
        UITabBox.prototype.setSelectedForce = function (v) {
            this.__forceChange = true;
            this.selectedIndex = v;
            this.__forceChange = false;
        };
        Object.defineProperty(UITabBox.prototype, "items", {
            get: function () {
                return this._items;
            },
            //------------------------------------------------------------------------------------------------------
            // 
            //------------------------------------------------------------------------------------------------------
            /**
             * 设置标签项
             */
            set: function (v) {
                this._items = v;
                this.refreshItems();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "length", {
            get: function () {
                return this._itemButtons.length;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "itemImage1", {
            get: function () {
                return this._itemImage1;
            },
            //------------------------------------------------------------------------------------------------------
            // 
            //------------------------------------------------------------------------------------------------------
            /**
             * 标签项选中时的图片样式
             */
            set: function (v) {
                this._itemImage1 = v;
                this.refreshButtonImage();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "itemImage2", {
            get: function () {
                return this._itemImage2;
            },
            /**
             * 标签项移入时的图片样式
             */
            set: function (v) {
                this._itemImage2 = v;
                this.refreshButtonImage();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "grid9img1Width", {
            //------------------------------------------------------------------------------------------------------
            // 九宫格设置
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this.itemWidth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "grid9img1Height", {
            get: function () {
                return this.itemHeight;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "grid9img1Skin", {
            get: function () {
                return this._itemImage1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "grid9img1", {
            get: function () {
                return this._grid9img1;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._grid9img1 = v;
                this.refreshButtonImage(false);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "grid9img2Width", {
            get: function () {
                return this.itemWidth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "grid9img2Height", {
            get: function () {
                return this.itemHeight;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "grid9img2Skin", {
            get: function () {
                return this._itemImage2;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "grid9img2", {
            get: function () {
                return this._grid9img2;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._grid9img2 = v;
                this.refreshButtonImage(false);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "smooth", {
            /**
             * 平滑字体边缘
             */
            get: function () {
                return this._smooth;
            },
            /**
             * 平滑字体边缘
             */
            set: function (v) {
                this._smooth = v;
                this.refreshItems();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "rowMode", {
            get: function () {
                return this._rowMode;
            },
            //------------------------------------------------------------------------------------------------------
            // 
            //------------------------------------------------------------------------------------------------------
            /**
             * 排列为行的模式
             */
            set: function (v) {
                this._rowMode = v;
                this.refreshItemSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "itemWidth", {
            get: function () {
                return this._itemWidth;
            },
            /**
             * 标签项长度
             */
            set: function (v) {
                this._itemWidth = v;
                this.refreshItemSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "itemHeight", {
            get: function () {
                return this._itemHeight;
            },
            /**
             * 标签项高度
             */
            set: function (v) {
                this._itemHeight = v;
                this.refreshItemSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "spacing", {
            get: function () {
                return this._spacing;
            },
            /**
             * 标签项间距
             */
            set: function (v) {
                this._spacing = v;
                this.refreshItemSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelFont", {
            get: function () {
                return this._labelFont;
            },
            //------------------------------------------------------------------------------------------------------
            // 
            //------------------------------------------------------------------------------------------------------
            /**
             * 文本字体
             * @param v
             */
            set: function (v) {
                this._labelFont = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelSelectedColor", {
            get: function () {
                return this._labelSelectedColor;
            },
            /**
             * 文本颜色 标签项选中时
             */
            set: function (v) {
                this._labelSelectedColor = v;
                this.refreshSelected();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelColor", {
            get: function () {
                return this._labelColor;
            },
            /**
             * 文本颜色 标签项未选中时
             */
            set: function (v) {
                this._labelColor = v;
                this.refreshSelected();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelSize", {
            get: function () {
                return this._labelSize;
            },
            /**
             * 文本字体大小
             */
            set: function (v) {
                this._labelSize = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelLetterSpacing", {
            get: function () {
                return this._labelLetterSpacing;
            },
            set: function (v) {
                this._labelLetterSpacing = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelAlign", {
            get: function () {
                return this._labelAlign;
            },
            /**
             * 文本字体对齐模式
             */
            set: function (v) {
                v = Math.floor(v);
                this._labelAlign = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelValign", {
            get: function () {
                return this._labelValign;
            },
            set: function (v) {
                v = Math.floor(v);
                this._labelValign = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelBold", {
            get: function () {
                return this._labelBold;
            },
            /**
             * 文本字体粗体模式
             */
            set: function (v) {
                this._labelBold = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelItalic", {
            get: function () {
                return this._labelItalic;
            },
            /**
             * 文本字体斜体
             * @param v
             */
            set: function (v) {
                this._labelItalic = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelDx", {
            get: function () {
                return this._labelDx;
            },
            /**
             * 文本字体偏移
             * @param v
             */
            set: function (v) {
                this._labelDx = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelDy", {
            get: function () {
                return this._labelDy;
            },
            /**
             * 文本字体偏移
             * @param v
             */
            set: function (v) {
                this._labelDy = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelStroke", {
            /**
             * 字体描边
             * @return [number]
             */
            get: function () {
                return this._labelStroke;
            },
            set: function (v) {
                this._labelStroke = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelStrokeColor", {
            get: function () {
                return this._labelStrokeColor;
            },
            set: function (v) {
                this._labelStrokeColor = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        //------------------------------------------------------------------------------------------------------
        // 
        //------------------------------------------------------------------------------------------------------
        UITabBox.prototype.clearItems = function () {
            for (var i = 0; i < this._itemButtons.length; i++) {
                var button = this._itemButtons[i];
                button.dispose();
                var label = this._itemLabels[i];
                label.dispose();
            }
            this._itemButtons = [];
            this._itemLabels = [];
        };
        /**
         * 刷新标签项目：根据项生成对应的按钮、文本
         */
        UITabBox.prototype.refreshItems = function () {
            this.clearItems();
            if (!this.items)
                return;
            var itemArr = this.items.split(",");
            for (var i = 0; i < itemArr.length; i++) {
                var button = new UIComponent.UIButton;
                button["_needLoad"] = false;
                button.clearMouseEvent();
                var label = new UIComponent.UIString;
                label.text = itemArr[i];
                label.valign = 1;
                label.smooth = this.smooth;
                label.overflow = 1;
                button.addChild(label);
                //
                this._tabRoot.addChild(button);
                this._itemLabels.push(label);
                this._itemButtons.push(button);
                if (!Config.EDIT_MODE) {
                    button.add_CLICK(this.setSelectedIndex, this, [i]);
                }
                else {
                    button.mouseEnabled = false;
                    label.mouseEnabled = false;
                }
            }
            this.refreshButtonImage();
            this.refreshItemSize();
            this.refreshLabels();
            this.refreshSelected();
            this.onSelected();
        };
        /**
         * 刷新标签项的排列、尺寸
         */
        UITabBox.prototype.refreshItemSize = function () {
            var _width = 433;
            var _height = 41;
            for (var i = 0; i < this._itemButtons.length; i++) {
                var button = this._itemButtons[i];
                var label = this._itemLabels[i];
                label.width = this.itemWidth;
                label.height = this.itemHeight;
                button.width = this.itemWidth;
                button.height = this.itemHeight;
                if (this.rowMode) {
                    button.x = 0;
                    button.y = (this.itemHeight + this.spacing) * i;
                    if (i == this._itemButtons.length - 1) {
                        _width = this.itemWidth;
                        _height = button.y + this.itemHeight;
                    }
                }
                else {
                    button.x = (this.itemWidth + this.spacing) * i;
                    button.y = 0;
                    if (i == this._itemButtons.length - 1) {
                        _width = button.x + this.itemWidth;
                        _height = this.itemHeight;
                    }
                }
            }
            this.width = _width;
            this.height = _height;
        };
        /**
         * 刷新按钮图片样式
         */
        UITabBox.prototype.refreshButtonImage = function (refreshImage) {
            if (refreshImage === void 0) { refreshImage = true; }
            if (this.isDisposed)
                return;
            for (var i = 0; i < this._itemButtons.length; i++) {
                var button = this._itemButtons[i];
                if (refreshImage) {
                    button.image1 = this.itemImage1;
                    button.image2 = this.itemImage2;
                }
                button.grid9img1 = this.grid9img1;
                button.grid9img2 = this.grid9img2;
            }
        };
        /**
         * 刷新按钮内文本样式
         */
        UITabBox.prototype.refreshLabels = function () {
            for (var i = 0; i < this._itemButtons.length; i++) {
                var label = this._itemLabels[i];
                label.font = this.labelFont;
                label.fontSize = this.labelSize;
                label.letterSpacing = this.labelLetterSpacing;
                label.bold = this.labelBold;
                label.italic = this.labelItalic;
                label.align = this.labelAlign;
                label.valign = this.labelValign;
                label.stroke = this.labelStroke;
                label.strokeColor = this.labelStrokeColor;
                label.x = this._labelDx;
                label.y = this._labelDy;
            }
        };
        /**
         * 刷新选中状态
         */
        UITabBox.prototype.refreshSelected = function () {
            for (var i = 0; i < this._itemButtons.length; i++) {
                var button = this._itemButtons[i];
                var label = this._itemLabels[i];
                label.color = this.labelColor;
                button.setState(1);
            }
            if (this.selectedIndex < 0 || this.selectedIndex >= this._itemButtons.length)
                return;
            this._itemButtons[this.selectedIndex].setState(2);
            this._itemLabels[this.selectedIndex].color = this.labelSelectedColor;
        };
        /**
         * 选中
         */
        UITabBox.prototype.setSelectedIndex = function (v) {
            this.selectedIndex = v;
        };
        /**
         * 当选中的情况
         */
        UITabBox.prototype.onSelected = function () {
            if (Config.EDIT_MODE)
                return;
            var len = Math.min(this._itemButtons.length, this.numChildren - 1);
            for (var i = 1; i <= len; i++) {
                var btn = this.getChildAt(i);
                btn.visible = false;
            }
            if (this.selectedIndex < 0 || this.selectedIndex >= len)
                return;
            this.getChildAt(this.selectedIndex + 1).visible = true;
        };
        //------------------------------------------------------------------------------------------------------
        //  重写addChild 根据子对象的名称快速设置我的属性
        //  根据选中状态刷新是否显示
        //------------------------------------------------------------------------------------------------------
        UITabBox.prototype.addChild = function (node) {
            var n = _super.prototype.addChild.call(this, node);
            this.onSelected();
            return n;
        };
        UITabBox.prototype.addChildAt = function (node, index) {
            var n = _super.prototype.addChildAt.call(this, node, index);
            this.onSelected();
            return n;
        };
        UITabBox.prototype.addChildren = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var n = _super.prototype.addChildren.apply(this, args);
            this.onSelected();
        };
        Object.defineProperty(UITabBox.prototype, "onChangeFragEvent", {
            //------------------------------------------------------------------------------------------------------
            // 事件
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._onChangeFragEvent;
            },
            set: function (v) {
                this._onChangeFragEvent = v;
                if (v) {
                    this.off(EventObject.CHANGE, this, this.onChange_private);
                    this.on(EventObject.CHANGE, this, this.onChange_private);
                }
                else {
                    this.off(EventObject.CHANGE, this, this.onChange_private);
                }
            },
            enumerable: false,
            configurable: true
        });
        UITabBox.prototype.onChange_private = function () {
            if (Config.SINGLE_PLAYER_CORE) {
                if (this._onChangeFragEvent && this.guiRoot && !this.guiRoot.onlyForPreload) {
                    CommandPage.startTriggerFragmentEvent(this._onChangeFragEvent, Game.player.sceneObject, Game.player.sceneObject);
                }
            }
        };
        /**
         * 自定义方法名称
         */
        UITabBox.customCompFunctionNames = ["selectedIndex", "itemImage1", "grid9img1", "itemImage2", "grid9img2", "itemWidth", "itemHeight", "items", "rowMode", "spacing",
            "labelSize", "labelColor", "labelFont", "labelBold", "labelItalic", "smooth", "labelAlign", "labelValign", "labelLetterSpacing", "labelSelectedColor", "labelDx", "labelDy",
            "labelStroke", "labelStrokeColor", "onChangeFragEvent"];
        return UITabBox;
    }(UIComponent.UIBase));
    UIComponent.UITabBox = UITabBox;
})(UIComponent || (UIComponent = {}));
/**
 * Created by 黑暗之神KDS on 2018-10-12 14:02:26.
 */
var UIComponent;
(function (UIComponent) {
    var UIVariable = /** @class */ (function (_super) {
        __extends(UIVariable, _super);
        function UIVariable() {
            var _this = _super.call(this) || this;
            _this.className = "UIVariable";
            _this._tf.text = "";
            return _this;
        }
        /**
         * 释放
         */
        UIVariable.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (!Config.EDIT_MODE) { //非编辑器模式才会添加侦听
                    var varID = this._lastVarID;
                    if (varID != 0 && this.className == "UIVariable" && Game.player) {
                        Game.player.removeListenerPlayerVariable(0, varID, this._onVarChange);
                    }
                }
            }
            _super.prototype.dispose.call(this);
        };
        //------------------------------------------------------------------------------------------------------
        // 
        //------------------------------------------------------------------------------------------------------
        UIVariable.prototype.inEditorInit = function () {
            _super.prototype.inEditorInit.call(this);
            this.varID = 1;
        };
        Object.defineProperty(UIVariable.prototype, "text", {
            get: function () {
                return this._tf.text;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                if (Config.EDIT_MODE) {
                    var varID = GameUtils.getVarID(v);
                    if (varID != 0) {
                        setText.call(this, v);
                        // this._tf.text = "{字符串" + varID + ":" + GameListData.getName(Game.data.playerStringNameList, varID) + "}";
                        return;
                    }
                }
                if (!Config.EDIT_MODE) {
                    var varID = GameUtils.getVarID(v);
                    if (varID != 0) {
                        this._tf.changeText("");
                        if (this._shadowEnabled) {
                            this._tf2.color = this._shadowColor;
                            this._tf2.changeText("");
                        }
                        if (this._lastVarID != 0)
                            Game.player.removeListenerPlayerVariable(0, this._lastVarID, this._onVarChange);
                        if (this.displayedInStage)
                            Game.player.addListenerPlayerVariable(0, varID, this._onVarChange);
                        this._lastVarID = varID;
                    }
                    else {
                        setText.call(this, v);
                    }
                }
                else {
                    setText.call(this, v);
                }
                function setText(v) {
                    if (this.__forceChange) {
                        this._tf.changeText(v);
                    }
                    else {
                        this._tf.text = v;
                    }
                    if (this._shadowEnabled) {
                        this._tf2.color = this._shadowColor;
                        if (this.__forceChange) {
                            this._tf2.changeText(this._tf.text);
                        }
                        else {
                            this._tf2.text = this._tf.text;
                        }
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * 编辑器专用信息说明
         */
        UIVariable.prototype.inEditorInfo = function () {
            var varName = GameListData.getName(Game.data.playerVariableNameList, this.varID);
            return "【" + MathUtils.fixIntDigit(this.varID) + ":" + varName + "】";
        };
        //------------------------------------------------------------------------------------------------------
        // 游戏运动时绑定玩家变量以便实时显示
        //------------------------------------------------------------------------------------------------------
        UIVariable.prototype.onAdded = function (e) {
            if (this.varID == 0)
                return;
            Game.player.addListenerPlayerVariable(0, this.varID, this._onVarChange);
        };
        UIVariable.prototype.onRemoved = function (e) {
            if (this.varID == 0)
                return;
            Game.player.removeListenerPlayerVariable(0, this.varID, this._onVarChange);
        };
        UIVariable.prototype.onVarChange = function (typeID, varID, value) {
            this._tf.text = value.toString();
            if (this._shadowEnabled) {
                this._tf2.color = this._shadowColor;
                this._tf2.text = this._tf.text;
            }
        };
        /**
         * 自定义方法名称
         */
        UIVariable.customCompFunctionNames = ["varID", "fontSize", "color", "bold", "italic", "smooth", "align", "valign", "leading", "letterSpacing",
            "font", "wordWrap", "overflow", "shadowEnabled", "shadowColor", "shadowDx", "shadowDy", "stroke", "strokeColor", "onChangeFragEvent"];
        return UIVariable;
    }(UIComponent.UIString));
    UIComponent.UIVariable = UIVariable;
})(UIComponent || (UIComponent = {}));
/**
 * 视频贴图
 * -- 不支持移动端使用
 *
 * 事件：
 * EventObject.LOADED 已加载元数据时触发。
 * EventObject.ERROR 当遇到错误时派发
 * EventObject.COMPLETE 当播放完毕时派发
 *
 * Created by 黑暗之神KDS on 2020-12-24 13:24:59.
 */
var UIComponent;
(function (UIComponent) {
    var UIVideo = /** @class */ (function (_super) {
        __extends(UIVideo, _super);
        /**
         * 组件模式
         * @param editorCompMode [可选] 默认值=true 编辑器模式下显示专门的组件样式而非实际的视频
         */
        function UIVideo(editorCompMode) {
            if (editorCompMode === void 0) { editorCompMode = true; }
            var _this = _super.call(this) || this;
            _this._videoURL = "";
            // 倍率
            _this._playbackRate = 1;
            // 音量
            _this._volume = 1;
            // 当前时间（秒）
            _this._currentTime = 0;
            // 播放模式
            _this._playType = 0;
            _this.className = "UIVideo";
            // 移动端无法使用
            // if (Browser.onMobile) {
            //     this.image = "";
            //     this.width = 0;
            //     this.height = 0;
            //     this.visible = false;
            //     return;
            // }
            // 编辑器组件模式
            if (Config.EDIT_MODE && editorCompMode) {
                _this.editorCompMode = true;
            }
            // 
            _this._dpTextureWidth = 1000;
            _this._dpTextureHeight = 1000;
            _this.width = 1000;
            _this.height = 1000;
            _this._uiImage.width = _this.width;
            _this._uiImage.height = _this.height;
            _this._dpDirty = true;
            _this.onResize();
            // 编辑器组件模式
            if (_this.editorCompMode) {
                return _this;
            }
            if (Config.EDIT_MODE) {
                _this.add_DISPLAY(_this.onAdded, _this);
                _this.add_UNDISPLAY(_this.onRemoved, _this);
            }
            var video = _this.videoElement = document.createElement("video");
            // 非PC端强制静音
            if (os.platform != 2) {
                video.muted = true;
                os.canvas.addEventListener("click", function () {
                    if (!_this.muted)
                        video.muted = false;
                    _this.canSetMuted = true;
                    // @ts-ignore
                    os.canvas.removeEventListener("click", arguments.callee);
                });
            }
            video.style.position = "absolute";
            video.style.zIndex = "9999999999";
            video.width = 1;
            video.height = 1;
            video.style.opacity = "0.1";
            // 加载完成
            video.addEventListener("loadedmetadata", function () {
                _this.event(EventObject.LOADED);
                if (_this.stage && _this.videoElement && _this._playType == 0 && !_this._metaDataLoaded)
                    _this.videoElement.play();
                _this._metaDataLoaded = true;
                _this.webGLCanvas.recreateResource();
                stage.on(EventObject.RENDER, _this, _this.onVideoRender);
            });
            video.addEventListener("error", function () {
                _this.event(EventObject.ERROR);
            });
            video.addEventListener("ended", function () {
                _this.event(EventObject.COMPLETE);
            });
            var canvas = _this.webGLCanvas = HTMLCanvas.create("2D", video); // WebGLCanvas
            _this.webGLCanvas.size(1, 1);
            var tex = _this.videoTex = new Texture(canvas);
            _this.texture = tex;
            return _this;
        }
        /**
         * 清理
         */
        UIVideo.prototype.clear = function () {
            this.webGLCanvas.disposeResource();
            this._playType = 0;
            this._metaDataLoaded = false;
            stage.off(EventObject.RENDER, this, this.onVideoRender);
        };
        /**
         * 释放
         */
        UIVideo.prototype.dispose = function () {
            if (!this.isDisposed) {
                stage.off(EventObject.RENDER, this, this.onVideoRender);
                if (this.videoTex) {
                    this.videoTex.destroy(true);
                    this.videoTex = null;
                }
                if (this.videoElement) {
                    this.pause();
                    this.videoElement.src = null;
                    this.videoElement["srcObject"] = null;
                    if (this.videoElement.parentNode)
                        document.body.removeChild(this.videoElement);
                    this.videoElement = null;
                }
                if (this.webGLCanvas) {
                    this.webGLCanvas.disposeResource();
                    this.webGLCanvas = null;
                }
            }
            _super.prototype.dispose.call(this);
        };
        /**
         * 编辑器环境
         */
        UIVideo.prototype.inEditorInit = function () {
            this.width = 100;
            this.height = 100;
        };
        UIVideo.prototype.loadAssetTest = function () {
            this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
        };
        Object.defineProperty(UIVideo.prototype, "duration", {
            //------------------------------------------------------------------------------------------------------
            // 只读属性
            //------------------------------------------------------------------------------------------------------
            /**
             * 时间：秒 如果不存在时则返回NaN
             */
            get: function () {
                if (!this.videoElement)
                    return NaN;
                return this.videoElement.duration;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIVideo.prototype, "networkState", {
            /**
             * 网络状态
             * 0 = NETWORK_EMPTY - 音频/视频尚未初始化
             * 1 = NETWORK_IDLE - 音频/视频是活动的且已选取资源，但并未使用网络
             * 2 = NETWORK_LOADING - 浏览器正在下载数据
             * 3 = NETWORK_NO_SOURCE - 未找到音频/视频来源
             */
            get: function () {
                if (!this.videoElement)
                    return 0;
                return this.videoElement.networkState;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIVideo.prototype, "videoURL", {
            //------------------------------------------------------------------------------------------------------
            // 属性
            //------------------------------------------------------------------------------------------------------
            /**
             * 视频
             */
            get: function () {
                return this._videoURL;
            },
            set: function (v) {
                this._videoURL = v;
                if (!this.videoElement)
                    return;
                this._metaDataLoaded = false;
                this.videoElement.src = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIVideo.prototype, "playbackRate", {
            /**
             * 播放速率 1表示100%
             */
            get: function () {
                return this._playbackRate;
            },
            set: function (v) {
                this._playbackRate = v;
                if (!this.videoElement)
                    return;
                this.videoElement.playbackRate = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIVideo.prototype, "volume", {
            /**
             * 音量
             */
            get: function () {
                return this._volume;
            },
            set: function (v) {
                this._volume = v;
                if (!this.videoElement)
                    return;
                this.videoElement.volume = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIVideo.prototype, "currentTime", {
            /**
             * 当前时间
             */
            get: function () {
                if (!this.videoElement)
                    return this._currentTime;
                return this.videoElement.currentTime;
            },
            set: function (v) {
                this._currentTime = v;
                if (!this.videoElement)
                    return;
                this.videoElement.currentTime = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIVideo.prototype, "playType", {
            /**
             * 自动播放 0-播放 1-停止播放 2-暂停
             */
            get: function () {
                return this._playType;
            },
            set: function (v) {
                this._playType = v;
                if (v == 0) {
                    this.play();
                }
                else if (v == 1) {
                    this.stop();
                }
                else {
                    this.pause();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIVideo.prototype, "muted", {
            /**
             * 静音
             */
            get: function () {
                return this._muted;
            },
            set: function (v) {
                this._muted = v;
                if (!this.videoElement)
                    return;
                if (this._muted) {
                    this.videoElement.muted = true;
                }
                else {
                    if (os.platform == 2 || this.canSetMuted)
                        this.videoElement.muted = false;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIVideo.prototype, "loop", {
            /**
             * 循环
             */
            get: function () {
                return this._loop;
            },
            set: function (v) {
                this._loop = v;
                if (!this.videoElement)
                    return;
                this.videoElement.loop = v;
            },
            enumerable: false,
            configurable: true
        });
        //------------------------------------------------------------------------------------------------------
        // 方法
        //------------------------------------------------------------------------------------------------------
        /**
         * 播放
         */
        UIVideo.prototype.play = function () {
            this._playType = 0;
            if (!this.videoElement)
                return;
            if (this.stage && this._metaDataLoaded)
                this.videoElement.play();
        };
        /**
         * 停止播放
         */
        UIVideo.prototype.stop = function () {
            this._playType = 1;
            if (!this.videoElement)
                return;
            this.videoElement.load();
        };
        /**
         * 暂停播放
         */
        UIVideo.prototype.pause = function (changePlayState) {
            if (changePlayState === void 0) { changePlayState = true; }
            if (changePlayState)
                this._playType = 2;
            if (!this.videoElement)
                return;
            this.videoElement.pause();
        };
        //------------------------------------------------------------------------------------------------------
        // 内部实现
        //------------------------------------------------------------------------------------------------------
        UIVideo.prototype.onResize = function () {
            Callback.CallLaterBeforeRender(this.doResize, this);
            _super.prototype.onResize.call(this);
        };
        UIVideo.prototype.doResize = function () {
            if (this.editorCompMode) {
                this.graphics.clear();
                if (this.useDPCoord) {
                    var scale = Math.max(this.scaleX, this.scaleY);
                    if (scale != 0) {
                        this.graphics.drawRect(0, 0, this.width, this.height, "#000000", "#EEEEEE", Math.ceil(5 / scale));
                    }
                }
                else {
                    this.graphics.drawRect(0, 0, this.width, this.height, "#000000", "#EEEEEE", 2);
                }
            }
            if (this.videoElement) {
                this.webGLCanvas.size(this.width, this.height);
            }
        };
        UIVideo.prototype.onVideoRender = function () {
            if (!this.videoElement)
                return;
            this.webGLCanvas.reloadCanvasData();
        };
        UIVideo.prototype.onAdded = function (e) {
            if (!this.videoElement)
                return;
            // -- 刷新播放状态
            this.playType = this.playType;
            if (!this.videoElement.parentNode)
                document.body.appendChild(this.videoElement);
        };
        UIVideo.prototype.onRemoved = function (e) {
            if (!this.videoElement)
                return;
            this.pause(false);
            if (this.videoElement.parentNode)
                document.body.removeChild(this.videoElement);
        };
        Object.defineProperty(UIVideo.prototype, "onLoadedFragEvent", {
            //------------------------------------------------------------------------------------------------------
            // 事件
            //------------------------------------------------------------------------------------------------------
            get: function () {
                return this._onLoadedFragEvent;
            },
            set: function (v) {
                this._onLoadedFragEvent = v;
                if (v) {
                    this.off(EventObject.LOADED, this, this.onLoaded_private);
                    this.on(EventObject.LOADED, this, this.onLoaded_private);
                }
                else {
                    this.off(EventObject.LOADED, this, this.onLoaded_private);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIVideo.prototype.onLoaded_private = function () {
            if (Config.SINGLE_PLAYER_CORE && this._onLoadedFragEvent && this.guiRoot && !this.guiRoot.onlyForPreload) {
                CommandPage.startTriggerFragmentEvent(this._onLoadedFragEvent, Game.player.sceneObject, Game.player.sceneObject);
            }
        };
        Object.defineProperty(UIVideo.prototype, "onErrorFragEvent", {
            get: function () {
                return this._onErrorFragEvent;
            },
            set: function (v) {
                this._onErrorFragEvent = v;
                if (v) {
                    this.off(EventObject.ERROR, this, this.onError_private);
                    this.on(EventObject.ERROR, this, this.onError_private);
                }
                else {
                    this.off(EventObject.ERROR, this, this.onError_private);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIVideo.prototype.onError_private = function () {
            if (Config.SINGLE_PLAYER_CORE && this._onErrorFragEvent && this.guiRoot && !this.guiRoot.onlyForPreload) {
                CommandPage.startTriggerFragmentEvent(this._onErrorFragEvent, Game.player.sceneObject, Game.player.sceneObject);
            }
        };
        Object.defineProperty(UIVideo.prototype, "onCompleteFragEvent", {
            get: function () {
                return this._onCompleteFragEvent;
            },
            set: function (v) {
                this._onCompleteFragEvent = v;
                if (v) {
                    this.off(EventObject.COMPLETE, this, this.onComplete_private);
                    this.on(EventObject.COMPLETE, this, this.onComplete_private);
                }
                else {
                    this.off(EventObject.COMPLETE, this, this.onComplete_private);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIVideo.prototype.onComplete_private = function () {
            if (Config.SINGLE_PLAYER_CORE && this._onCompleteFragEvent && this.guiRoot && !this.guiRoot.onlyForPreload) {
                CommandPage.startTriggerFragmentEvent(this._onCompleteFragEvent, Game.player.sceneObject, Game.player.sceneObject);
            }
        };
        /**
         * 自定义方法名称
         */
        UIVideo.customCompFunctionNames = ["videoURL", "playType", "volume", "playbackRate", "currentTime", "muted", "loop", "pivotType", "flip", "onLoadedFragEvent", "onErrorFragEvent", "onCompleteFragEvent"];
        return UIVideo;
    }(UIComponent.UIBitmap));
    UIComponent.UIVideo = UIVideo;
})(UIComponent || (UIComponent = {}));
/**
 * 资源管理器
 * 采用引用计数方式缓存资源，一旦引用计数为0时则会自动释放实际的资源
 * 基础资源包含：Image资源、Audio资源、JSON资源、Text资源、ArrayBuffer资源
 *
 *【系统规则】
 * -- 高级显示对象包含多种基础资源，在创建这些高级显示对象会根据内部关联到基础资源自动增加引用，而释放对象时会减少引用，高级显示对象包含：
 *    -- Avatar/StandAvatar 行走图/立绘
 *    -- GCAnimation 动画
 *    -- ClientScene 客户端场景
 *    -- ClientSceneObject 客户端场景对象
 *    -- UIxxx 各种界面组件（包括整体界面 GUI_XXX）
 *    -- 由项目层自行增加的高级显示对象等等
 *
 * -- 预加载高级资源，如果未设置自动释放的话，需要手动释放，否则会一直引用这些资源导致无法被自动释放。
 *    根据编辑器预设的配置进行载入相关的基础资源，而卸载也是根据编辑器预设的配置进行卸载相关的基础资源（与实际用到的场景动态更换了内部的资源无关）。
 *    主要用于预占用资源，以便在此期间不会被系统自动释放掉，比如设计在进入游戏场景前预载入一些资源，到进入下一个场景前再释放，以便在该场景内不会被系统自动释放掉
 *    预加载接口包含--预加载高级资源（每个高级资源包含若干的基础资源）：自行加载的需要自行卸载
 *    -- 预加载场景 preLoadSceneAsset                 ==> 卸载场景 disposeScene
 *    -- 预加载场景对象 preLoadSceneObjectAsset       ==> 卸载场景对象 disposeSceneObject
 *    -- 预加载行走图资源 preLoadAvatarAsset          ==> 卸载行走图资源 disposeAvatarAsset
 *    -- 预加载立绘资源 preLoadStandAvatarAsset       ==> 卸载立绘资源 disposeStandAvatarAsset
 *    -- 预加载动画资源 preLoadAnimationAsset         ==> 卸载动画资源 disposeAnimationAsset
 *    -- 预加载界面资源 preLoadUIAsset                ==> 卸载界面资源 disposeUIAsset
 *    -- 预加载对话框资源 preLoadDialog               ==> 卸载对话框资源 disposeDialog
 *    -- 预加载事件页中涉及的资源 preLoadCommandPage   ==> 卸载事件页中涉及的资源 disposeCommandPage
 *
 * -- 预加载接口包含--预加载基础资源：自行加载的需要自行卸载
 *    -- 加载图片（解析为Object） loadImage                     ==> 释放图片 disposeImage
 *    -- 加载Json文件（解析为Object） loadJson                  ==> 释放Json文件 disposeJson
 *    -- 加载文本文件（解析为字符串） loadText                   ==> 释放文本文件 disposeText
 *    -- 加载原始文件（解析为ArrayBuffer） loadFileArrayBuffer  ==> 释放原始文件 disposeFileArrayBuffer
 *    -- 加载音频 loadAudio                                   ==> 卸载音频 disposeAudio
 *
 * -- 图像系统中使用到的资源
 *    -- 「显示图片/动画/立绘」：通道被覆盖时上一个占用通道的资源会被释放（减少引用），新资源会增加引用，如显示3号动画在1号通道里，然后再显示2号立绘在1号通道里，此前的3号动画就会被释放
 *       为了防止常用的图片显示等效果被中途系统自动将图片卸载了，可以预加载这些图片先占用引用。
 *       比如场景相关事件可勾选场景的“预加载事件页中涉及的资源”，以保证在该场景中执行这些图片效果中途不会被系统卸载，同时切换场景后会自动释放掉这些资源
 *      （如果新场景仍然用到了这些资源又会再次被引用到而导致不会被系统卸载）。
 *    -- 「消除」：将当前指定通道的资源释放掉，比如当前使用了3号动画，则3号动画引用减1，如果全局没有任何用到了3号动画时（此时引用为0）则会被系统实际回收，
 *                下次未预加载就直接使用时可能会由于动态加载该资源导致一小段时间未能显示出来（因为处于加载中，需要一点时间）。
 *
 * -- 对话框中使用到的头像资源
 *    -- 在每次对话启动时会创建头像资源（引用+1），然后停止对话时会释放掉头像资源（引用-1），此时如果全局未有任何引用的话会被系统实际回收，
 *       若不想在某段期间内被系统实际回收，可以提前预加载这些头像资源。
 *
 * 【总结】
 *    -- 自行创建的对象需要自行销毁（gameObject.dispose）
 *    -- 自行预加载的资源需要自行销毁（AssetManager.disposeXXX）
 *
 * 【示例1：自行创建的高级对象，自行销毁】
 *    // 创建一个3号行走图实例，系统识别为引用了3号行走图相关的一些基础资源（引用+1）
 *    var a = new Avatar;
 *    a.id = 3;
 *    // 释放掉这个实例，只有调用释放后这些被增加引用的基础资源才会减少引用，以便让系统自动回收资源（引用-1）
 *    a.dispose();
 *
 *    // 创建2号界面
 *    var b = new GUI_2;
 *    // 卸载2号界面
 *    b.dispose();
 *
 * 【示例2：预加载资源，在一定期间内不会被系统释放，当使用完毕后再手动卸载】
 *    // 预加载3号行走图（引用+1） 此时3号行走图的引用=1
 *    AssetManager.preLoadAvatarAsset(3, Callback.New(()=>{
 *       // 使用行走图（引用+1） 此时3号行走图的引用=2
 *       var a = new Avatar;
 *       a.id = 3;
 *       // 60秒后
 *       setTimeout(()=>{
 *          // 卸载行走图（引用-1） 此时3号行走图的引用=1
 *          a.dispose();
 *          // 卸载掉预加载的3号行走图占用（引用-1） 此时3号行走图的引用=0 系统会自动回收
 *          AssetManager.disposeAvatarAsset(3);
 *       },60*1000);
 *    }));
 *
 *
 *
 * Created by 黑暗之神KDS on 2018-08-08 16:28:46.
 */
var AssetManager = /** @class */ (function () {
    function AssetManager() {
    }
    //------------------------------------------------------------------------------------------------------
    // 游戏资源预加载
    //------------------------------------------------------------------------------------------------------
    /**
     * 预加载加载场景资源，如果autoDispose为false的话则需要手动卸载：AssetManager::disposeScene
     * -- 场景的相关JSON文件
     * -- 如勾选预载地图资源：预载入地图资源：图层的图片、图块的图片、BGM、BGS
     * -- 如勾选预载全部的场景对象资源：预载入全场景对象资源（仅单机版可用）
     * -- 如勾选预载场景事件涉及的资源：预载入场景触发的事件页中的资源 参考 preLoadCommandPage 方法（仅单机版可用）
     * -- 预设的自定义预加载资源列表
     * @param id 场景ID
     * @param complete [可选] 默认值=null
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     * @param autoDispose [可选] 默认值=false 是否自动释放资源（加载后会在延迟一段时间后自动释放，用于减少引用计数）
     * @param prerender [可选] 默认值=false 是否预渲染图片资源，保证完成回调后使用时不会因为渲染而卡顿，一般资源较大时可以尝试开启此项，开启此项会有额外的性能和内存开销
     */
    AssetManager.preLoadSceneAsset = function (id, complete, syncCallbackWhenAssetExist, autoDispose, prerender) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = false; }
        if (prerender === void 0) { prerender = false; }
        if (id == 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            return;
        }
        AssetManager.loadJson("asset/json/scene/data/scene" + id + ".json", Callback.New(function (jsonObj) {
            if (!jsonObj) {
                complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                return;
            }
            // 全加载完成回调
            var loadCount = 1;
            function onLoadOne() {
                loadCount--;
                if (loadCount == 0) {
                    if (autoDispose)
                        AssetManager.disposeScene(id);
                    complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                }
            }
            var onLoadOneCB = Callback.New(onLoadOne, this);
            // 全图层用到的图片加载
            if (jsonObj.preloadMapAsset) {
                var imgUrls = [];
                for (var i = 0; i < jsonObj.LayerDatas.length; i++) {
                    var layerData = jsonObj.LayerDatas[i];
                    if (!layerData.drawMode && layerData.img) {
                        imgUrls.push(layerData.img);
                    }
                    if (layerData.drawMode && layerData.tileTexIDs) {
                        for (var tileID in layerData.tileTexIDs) {
                            var tileIDInt = MathUtils.int(tileID);
                            if (tileIDInt < 0) {
                                var autoTileData = Game.data.autoTileList.data[-tileIDInt];
                                if (autoTileData && autoTileData.url)
                                    imgUrls.push(autoTileData.url);
                            }
                            else {
                                var tileData = Game.data.tileList.data[tileIDInt];
                                if (tileData && tileData.url)
                                    imgUrls.push(tileData.url);
                            }
                        }
                    }
                }
                loadCount += 1;
                AssetManager.loadImages(imgUrls, onLoadOneCB, syncCallbackWhenAssetExist, true, prerender);
                // BGM/BGS
                if (jsonObj.bgm) {
                    loadCount++;
                    AssetManager.loadAudio(jsonObj.bgm, onLoadOneCB, syncCallbackWhenAssetExist);
                }
                if (jsonObj.bgs) {
                    loadCount++;
                    AssetManager.loadAudio(jsonObj.bgs, onLoadOneCB, syncCallbackWhenAssetExist);
                }
            }
            // 扩展
            if (AssetManager.preLoadSceneAssetExt) {
                loadCount++;
                AssetManager.preLoadSceneAssetExt.runWith([id, onLoadOne]);
            }
            // 自定义资源列表
            for (var s in jsonObj.preLoadAssets) {
                var preLoadAssetInfo = jsonObj.preLoadAssets[s];
                var valueStr = preLoadAssetInfo.value;
                var valueInt = preLoadAssetInfo.value;
                loadCount++;
                switch (preLoadAssetInfo.type) {
                    case 0:
                        AssetManager.loadImage(valueStr, onLoadOneCB, syncCallbackWhenAssetExist, true, prerender);
                        break;
                    case 1:
                        AssetManager.loadAudio(valueStr, onLoadOneCB, syncCallbackWhenAssetExist);
                        break;
                    case 2:
                        AssetManager.loadText(valueStr, onLoadOneCB, syncCallbackWhenAssetExist);
                        break;
                    case 3:
                        AssetManager.loadJson(valueStr, onLoadOneCB, syncCallbackWhenAssetExist);
                        break;
                    case 4:
                        AssetManager.preLoadAvatarAsset(valueInt, onLoadOneCB, syncCallbackWhenAssetExist, false, prerender);
                        break;
                    case 5:
                        AssetManager.preLoadUIAsset(valueInt, onLoadOneCB, syncCallbackWhenAssetExist, false, prerender);
                        break;
                    case 6:
                        AssetManager.preLoadAnimationAsset(valueInt, onLoadOneCB, syncCallbackWhenAssetExist, false, prerender);
                        break;
                    case 7:
                        AssetManager.preLoadStandAvatarAsset(valueInt, onLoadOneCB, syncCallbackWhenAssetExist, false, prerender);
                        break;
                    case 8:
                        AssetManager.preLoadDialog(valueInt, onLoadOneCB, syncCallbackWhenAssetExist);
                        break;
                }
            }
            onLoadOneCB.run();
        }, this));
    };
    /**
     * 预加载场景对象资源，如果autoDispose为false的话则需要手动卸载：AssetManager::disposeSceneObject
     * -- 根据自定义显示对象层（行走图、界面、动画）来加载其下所有资源
     * @param so 场景对象数据
     * @param complete [可选] 默认值=null
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     * @param autoDispose [可选] 默认值=false 是否自动释放资源（加载后会在延迟一段时间后自动释放，用于减少引用计数）
     * @param prerender [可选] 默认值=false 是否预渲染图片资源，保证完成回调后使用时不会因为渲染而卡顿，一般资源较大时可以尝试开启此项，开启此项会有额外的性能和内存开销
     */
    AssetManager.preLoadSceneObjectAsset = function (so, complete, syncCallbackWhenAssetExist, autoDispose, prerender) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = false; }
        if (prerender === void 0) { prerender = false; }
        var modelData = Common.sceneObjectModelList.data[so.modelID];
        var fixModuleData = Config.useNewSceneObjectModel ? Common.sceneObjectModelList.data[0] : modelData;
        if (!modelData) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            return;
        }
        var loadCount = 0;
        function onLoadOne() {
            loadCount--;
            if (loadCount == 0) {
                // 小加载都释放了，这里不应该多释放一次 if (autoDispose) setTimeout((so: SceneObject) => { AssetManager.disposeSceneObject(so); }, AssetManager.disposeInterval, so);
                loadCount = -1;
                complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            }
        }
        var onLoadOneCB = Callback.New(onLoadOne, this);
        var loads = [];
        if (so.avatarID != 0) {
            loadCount++;
            loads.push(Callback.New(this.preLoadAvatarAsset, this, [so.avatarID, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose, prerender]));
        }
        // 旧原型/新公共模块
        for (var i in fixModuleData.preLayer) {
            var preLayer = fixModuleData.preLayer[i];
            var displayInfo = so.displayList[preLayer.varName];
            if (!displayInfo)
                continue;
            addPreloadByLoad.call(this, displayInfo);
        }
        // 模块集
        if (so.moduleDisplayList) {
            for (var s = 0; s < so.moduleDisplayList.length; s++) {
                var moduleDisplayList = so.moduleDisplayList[s];
                for (var i in moduleDisplayList) {
                    var displayInfo = moduleDisplayList[i];
                    if (!displayInfo)
                        continue;
                    addPreloadByLoad.call(this, displayInfo);
                }
            }
        }
        for (var i in loads) {
            loads[i].run();
        }
        if (loadCount == 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
        }
        function addPreloadByLoad(displayInfo) {
            if (displayInfo.type == SceneObjectModelData.TYPE_UI_DESIGNATION || displayInfo.type == SceneObjectModelData.TYPE_UI_DESIGNATION) {
                loadCount++;
                loads.push(Callback.New(this.preLoadUIAsset, this, [displayInfo.id, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose, prerender]));
            }
            else if (displayInfo.type == SceneObjectModelData.TYPE_ANIMATION_DESIGNATION || displayInfo.type == SceneObjectModelData.TYPE_ANIMATION_TYPE) {
                loadCount++;
                loads.push(Callback.New(this.preLoadAnimationAsset, this, [displayInfo.id, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose, prerender]));
            }
        }
    };
    /**
     * 预加载行走图数据，如果autoDispose为false的话则需要手动卸载： AssetManager::disposeAvatarAsset
     * @param id 行走图ID
     * @param complete [可选] 默认值=null
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     * @param autoDispose [可选] 默认值=false 是否自动释放资源（加载后会在延迟一段时间后自动释放，用于减少引用计数）
     * @param prerender [可选] 默认值=false 是否预渲染图片资源，保证完成回调后使用时不会因为渲染而卡顿，一般资源较大时可以尝试开启此项，开启此项会有额外的性能和内存开销
     */
    AssetManager.preLoadAvatarAsset = function (id, complete, syncCallbackWhenAssetExist, autoDispose, prerender) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = false; }
        if (prerender === void 0) { prerender = false; }
        AssetManager.preLoadAvatarBaseAsset(id, complete, syncCallbackWhenAssetExist, autoDispose, false, prerender);
    };
    /**
     * 预加载立绘数据，如果autoDispose为false的话则需要手动卸载： AssetManager::disposeStandAvatarAsset
     * @param id 立绘资源ID
     * @param complete [可选] 默认值=null
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     * @param autoDispose [可选] 默认值=false 是否自动释放资源（加载后会在延迟一段时间后自动释放，用于减少引用计数）
     * @param prerender [可选] 默认值=false 是否预渲染图片资源，保证完成回调后使用时不会因为渲染而卡顿，一般资源较大时可以尝试开启此项，开启此项会有额外的性能和内存开销
     */
    AssetManager.preLoadStandAvatarAsset = function (id, complete, syncCallbackWhenAssetExist, autoDispose, prerender) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = false; }
        if (prerender === void 0) { prerender = false; }
        if (id <= 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
        }
        else {
            AssetManager.preLoadAvatarBaseAsset(id, complete, syncCallbackWhenAssetExist, autoDispose, true, prerender);
        }
    };
    AssetManager.preLoadAvatarBaseAsset = function (id, complete, syncCallbackWhenAssetExist, autoDispose, isStandAvatar, prerender) {
        var _this = this;
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = false; }
        if (isStandAvatar === void 0) { isStandAvatar = false; }
        if (prerender === void 0) { prerender = false; }
        var assetURLHead = isStandAvatar ? "asset/json/standAvatar/data/standAvatar" : "asset/json/avatar/data/avatar";
        if (id < 0 || (id == 0 && !Config.EDIT_MODE)) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            return;
        }
        AssetManager.loadJson(assetURLHead + id + ".json", Callback.New(function (id, complete, syncCallbackWhenAssetExist, autoDispose, isStandAvatar, prerender, avatarData) {
            if (complete === void 0) { complete = null; }
            if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
            if (autoDispose === void 0) { autoDispose = false; }
            if (isStandAvatar === void 0) { isStandAvatar = false; }
            if (prerender === void 0) { prerender = false; }
            if (avatarData === void 0) { avatarData = null; }
            if (!avatarData) {
                complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                return;
            }
            var loadCount = avatarData.parts.length;
            var onLoaded = Callback.New(function (id, complete, syncCallbackWhenAssetExist, autoDispose, isStandAvatar, avatarData) {
                if (complete === void 0) { complete = null; }
                if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
                if (autoDispose === void 0) { autoDispose = false; }
                if (isStandAvatar === void 0) { isStandAvatar = false; }
                if (avatarData === void 0) { avatarData = null; }
                loadCount--;
                if (loadCount == 0) {
                    if (autoDispose)
                        isStandAvatar ? AssetManager.disposeStandAvatarAsset(id) : AssetManager.disposeAvatarAsset(id);
                    complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                }
            }, _this, [id, complete, syncCallbackWhenAssetExist, autoDispose, isStandAvatar, prerender, avatarData]);
            // 加载自身图集（需要预渲染）
            AssetManager.loadImages(avatarData.picUrls, onLoaded, syncCallbackWhenAssetExist, true, prerender);
            // 加载部件
            for (var i = 0; i < avatarData.parts.length; i++) {
                var avatarPartID = avatarData.parts[i].id;
                if (avatarPartID == 0)
                    continue;
                AssetManager.preLoadAvatarBaseAsset(avatarPartID, onLoaded, syncCallbackWhenAssetExist, false, isStandAvatar, prerender);
            }
        }, this, [id, complete, syncCallbackWhenAssetExist, autoDispose, isStandAvatar, prerender]), syncCallbackWhenAssetExist);
    };
    /**
     * 预加载界面，如果autoDispose为false的话则需要手动卸载：AssetManager::disposeUIAsset
     * @param id 界面ID
     * @param complete [可选] 默认值=null
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     * @param autoDispose [可选] 默认值=false 是否自动释放资源（加载后会在延迟一段时间后自动释放，用于减少引用计数）
     * @param prerender [可选] 默认值=false 是否预渲染图片资源，保证完成回调后使用时不会因为渲染而卡顿，一般资源较大时可以尝试开启此项，开启此项会有额外的性能和内存开销
     */
    AssetManager.preLoadUIAsset = function (id, complete, syncCallbackWhenAssetExist, autoDispose, prerender) {
        var _this = this;
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = false; }
        if (prerender === void 0) { prerender = false; }
        if (id == 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            return;
        }
        AssetManager.loadJson("asset/json/ui/data/ui" + id + ".json", Callback.New(function (uiDisData) {
            if (!uiDisData || !uiDisData.root) {
                complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                return;
            }
            // 此处新建无运行时的纯界面并监听其资源加载以及增加引用。并且添加到舞台上为了预加载后预渲染，以便回调时不卡帧
            var root = new UIComponent.UIRoot(true, id);
            root.onlyForPreload = true;
            var uiArr = AssetManager.preUIs[id];
            if (!uiArr)
                uiArr = AssetManager.preUIs[id] = [];
            uiArr.push(root);
            root.once(EventObject.LOADED, complete.caller, function (prerender, root) {
                if (prerender)
                    AssetManager.prerender(root);
                complete.run();
                if (autoDispose)
                    AssetManager.disposeUIAsset(id);
            }, [prerender, root]);
            // 修正第二次预渲染导致报错的问题
            Callback.CallLaterBeforeRender(function () {
                var ui = GameUI.parse(uiDisData, false, null, id, root, syncCallbackWhenAssetExist);
            }, _this);
        }, this), syncCallbackWhenAssetExist, false);
    };
    /**
     * 预加载动画，如果autoDispose设置为false的话则需要手动卸载：AssetManager::disposeAnimationAsset
     * @param id 动画ID
     * @param complete [可选] 默认值=null
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     * @param autoDispose [可选] 默认值=false 是否自动释放资源（加载后会在延迟一段时间后自动释放，用于减少引用计数）
     * @param prerender [可选] 默认值=false 是否预渲染图片资源，保证完成回调后使用时不会因为渲染而卡顿，一般资源较大时可以尝试开启此项，开启此项会有额外的性能和内存开销
     */
    AssetManager.preLoadAnimationAsset = function (id, complete, syncCallbackWhenAssetExist, autoDispose, prerender) {
        var _this = this;
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = false; }
        if (prerender === void 0) { prerender = false; }
        if (id == 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            return;
        }
        AssetManager.loadJson("asset/json/animation/data/ani" + id + ".json", Callback.New(function (id, complete, syncCallbackWhenAssetExist, autoDispose, prerender, aniData) {
            if (complete === void 0) { complete = null; }
            if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
            if (autoDispose === void 0) { autoDispose = false; }
            if (prerender === void 0) { prerender = false; }
            if (aniData === void 0) { aniData = null; }
            if (!aniData) {
                complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                return;
            }
            // 加载完成统计
            var loadCount = 1;
            var onLoaded = Callback.New(function () {
                loadCount--;
                if (loadCount == 0) {
                    if (autoDispose)
                        AssetManager.disposeAnimationAsset(id);
                    complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                }
            }, _this);
            if (aniData.isParticle && aniData.particleData) {
                AssetManager.loadTexture(aniData.particleData.textureName, onLoaded, syncCallbackWhenAssetExist);
            }
            else {
                // 加载其中可能存在的动画层，列出该动画下面的所有动画层（含子节点的子节点等）
                for (var index = 0; index < aniData.layers.length; index++) {
                    var layerInfo = aniData.layers[index];
                    if (layerInfo.type == AnimationItemType.GCAnimation) {
                        var nodes = ArrayUtils.getTreeNodeArray(layerInfo);
                        for (var s in nodes) {
                            var childLayerInfo = nodes[s];
                            if (childLayerInfo.type == AnimationItemType.GCAnimation) {
                                loadCount++;
                                AssetManager.preLoadAnimationAsset(childLayerInfo.animationId, onLoaded, syncCallbackWhenAssetExist, false, prerender);
                            }
                        }
                    }
                }
                // 加载自身资源
                var picUrls = aniData.imageSources ? aniData.imageSources.reduce(function (pv, v) { if (v && pv.indexOf(v.url) == -1)
                    pv.push(v.url); return pv; }, []) : [];
                AssetManager.loadImages(picUrls, onLoaded, syncCallbackWhenAssetExist, true, prerender);
            }
        }, this, [id, complete, syncCallbackWhenAssetExist, autoDispose, prerender]), syncCallbackWhenAssetExist);
    };
    /**
    * 预加载事件页中包含的资源（仅支持系统内核的事件，如果有需要加载到自定义命令中的资源支持重写来扩展该方法）
    * -- 对话/选项事件：对话框
    * -- 设置对象行为：行走图
    * -- 图像系统的图片、动画、界面、立绘、音效、对话框
    * -- 显示雾的雾图片
    * -- BGM、BGS、SE
    * -- 游戏界面
    * @param commandPage 事件页
    * @param complete [可选] 默认值=null 完成时回调
    * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
    * @param autoDispose [可选] 默认值=false 是否自动释放资源（加载后会在延迟一段时间后自动释放，用于减少引用计数）
    */
    AssetManager.preLoadCommandPage = function (commandPage, complete, syncCallbackWhenAssetExist, autoDispose) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = false; }
        // 已存在则忽略掉
        if (AssetManager.commandPerloadCache[commandPage.id]) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            return;
        }
        var loadCount = 0;
        function onLoadOne() {
            loadCount--;
            if (loadCount == 0) {
                loadCount = -1;
                complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            }
        }
        var onLoadOneCB = Callback.New(onLoadOne, this);
        var loads = [];
        var commandsLength = commandPage.commands.length;
        var dialogCache = [], avatarCache = [], imageCache = [], audioCache = [], uiCache = [], animationCache = [], standAvatarCache = [], cmdPageCache = [];
        var perlaodCommandPageAssetCache = [dialogCache, avatarCache, imageCache, audioCache, uiCache, animationCache, standAvatarCache, cmdPageCache];
        if (!AssetManager.commandPerloadCache[commandPage.id])
            AssetManager.commandPerloadCache[commandPage.id] = perlaodCommandPageAssetCache;
        for (var i = 0; i < commandsLength; i++) {
            var cmd = commandPage.commands[i];
            // 对话框 + 选项
            if (cmd.type == 11 || cmd.type == 3) {
                loadCount++;
                var dialogID = cmd.params[0];
                loads.push(Callback.New(this.preLoadDialog, this, [dialogID, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                dialogCache.push(dialogID);
                if (cmd.type == 11) {
                    var dialogData = Common.dialogList.data[dialogID];
                    if (!dialogData)
                        continue;
                    var mode = dialogData.headBox.perviewMode;
                    if (!mode) {
                        loads.push(Callback.New(this.loadImage, this, [cmd.params[1], onLoadOneCB, syncCallbackWhenAssetExist, true]));
                        imageCache.push(cmd.params[1]);
                    }
                    else if (mode == 1) {
                        var standID = MathUtils.int(cmd.params[1]);
                        if (standID > 0) {
                            loads.push(Callback.New(this.preLoadStandAvatarAsset, this, [standID, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                            standAvatarCache.push(standID);
                        }
                    }
                    else if (mode == 2) {
                        var aniID = MathUtils.int(cmd.params[1]);
                        if (aniID > 0) {
                            loads.push(Callback.New(this.preLoadAnimationAsset, this, [aniID, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                            animationCache.push(aniID);
                        }
                    }
                    else if (mode == 3) {
                        var viewID = MathUtils.int(cmd.params[1]);
                        if (viewID > 0) {
                            loads.push(Callback.New(this.preLoadUIAsset, this, [viewID, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                            uiCache.push(viewID);
                        }
                    }
                    //语音
                    if (cmd.params[6]) {
                        var audioURLInfo = GameAudio.getAudioURL(cmd.params[6]);
                        var audioURL = audioURLInfo ? audioURLInfo.url : null;
                        if (audioURL) {
                            loads.push(Callback.New(this.loadAudio, this, [audioURL, onLoadOneCB, syncCallbackWhenAssetExist, true]));
                            audioCache.push(audioURL);
                        }
                    }
                }
            }
            // 行为
            else if (cmd.type == 22) {
                var m = ArrayUtils.matchAttributes(cmd.params[2], { 0: 0 }, false);
                loadCount += m.length;
                for (var s = 0; s < m.length; s++) {
                    var avatarID = m[s][1];
                    loads.push(Callback.New(this.preLoadAvatarAsset, this, [avatarID, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                    avatarCache.push(avatarID);
                }
            }
            // 雾
            else if (cmd.type == 36) {
                loadCount++;
                var img = cmd.params[0];
                imageCache.push(img);
                loads.push(Callback.New(this.loadImage, this, [img, onLoadOneCB, syncCallbackWhenAssetExist, true]));
            }
            // 音频
            else if (cmd.type == 63 || cmd.type == 65 || cmd.type == 67 || cmd.type == 69) {
                loadCount++;
                var audioUrl = cmd.params[0];
                audioCache.push(audioUrl);
                loads.push(Callback.New(this.loadAudio, this, [audioUrl, onLoadOneCB, syncCallbackWhenAssetExist, true]));
            }
            // 界面
            else if (cmd.type == 72) {
                loadCount++;
                var uiID = cmd.params[0];
                uiCache.push(uiID);
                loads.push(Callback.New(this.preLoadUIAsset, this, [uiID, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
            }
            // 图像系统
            else if (cmd.type == 37) {
                var imageInfos = cmd.params[0];
                var mPics = ArrayUtils.matchAttributes(imageInfos, { 0: 0 }, false);
                var mAnis = ArrayUtils.matchAttributes(imageInfos, { 0: 5 }, false);
                var mDialogs = ArrayUtils.matchAttributes(imageInfos, { 0: 9 }, false);
                var mSes = ArrayUtils.matchAttributes(imageInfos, { 0: 10 }, false);
                var mStandAvatars = ArrayUtils.matchAttributes(imageInfos, { 0: 11 }, false);
                var mUis = ArrayUtils.matchAttributes(imageInfos, { 0: 13 }, false);
                loadCount += mPics.length + mAnis.length + mDialogs.length + mSes.length + mStandAvatars.length + mUis.length;
                for (var s = 0; s < mPics.length; s++) {
                    imageCache.push(mPics[s][2]);
                    loads.push(Callback.New(this.loadImage, this, [mPics[s][2], onLoadOneCB, syncCallbackWhenAssetExist, true]));
                }
                for (var s = 0; s < mAnis.length; s++) {
                    animationCache.push(mAnis[s][2]);
                    loads.push(Callback.New(this.preLoadAnimationAsset, this, [mAnis[s][2], onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                }
                for (var s = 0; s < mDialogs.length; s++) {
                    dialogCache.push(mDialogs[s][1]);
                    loads.push(Callback.New(this.preLoadDialog, this, [mDialogs[s][1], onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                }
                for (var s = 0; s < mSes.length; s++) {
                    audioCache.push(mSes[s][1]);
                    loads.push(Callback.New(this.loadAudio, this, [mSes[s][1], onLoadOneCB, syncCallbackWhenAssetExist, true]));
                }
                for (var s = 0; s < mStandAvatars.length; s++) {
                    standAvatarCache.push(mStandAvatars[s][8]);
                    loads.push(Callback.New(this.preLoadStandAvatarAsset, this, [mStandAvatars[s][8], onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                }
                for (var s = 0; s < mUis.length; s++) {
                    uiCache.push(mUis[s][8]);
                    loads.push(Callback.New(this.preLoadUIAsset, this, [mUis[s][8], onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                }
            }
            // 公共事件
            else if (cmd.type == 16) {
                var cmdPage = Command.gameWorld.commonEventPages[cmd.params[0]];
                if (cmdPage) {
                    loadCount++;
                    cmdPageCache.push(cmdPage);
                    AssetManager.preLoadCommandPage(cmdPage, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose);
                }
            }
            // 事件页片段
            else if (cmd.type == 15) {
                var realSID = commandPage.id + "_" + commandPage.commands.indexOf(cmd);
                var fragmentPage = CommandExecute.fragmentEvents[realSID];
                if (!fragmentPage)
                    fragmentPage = CommandExecute.fragmentEvents[realSID] = new CommandPage(cmd.params[2]);
                if (fragmentPage) {
                    loadCount++;
                    cmdPageCache.push(fragmentPage);
                    AssetManager.preLoadCommandPage(fragmentPage, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose);
                }
            }
        }
        for (var f in loads) {
            loads[f].run();
        }
        if (loadCount == 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
        }
    };
    /**
    * 预加载对话框的相关资源
    * @param id 对话框ID
    * @param complete [可选] 默认值=null 完成时回调
    * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
    * @param autoDispose [可选] 默认值=false 是否自动释放资源（加载后会在延迟一段时间后自动释放，用于减少引用计数）
    */
    AssetManager.preLoadDialog = function (id, complete, syncCallbackWhenAssetExist, autoDispose) {
        var _this = this;
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = false; }
        if (id == 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            return;
        }
        AssetManager.loadJson("asset/json/dialog/data/dialog" + id + ".json", Callback.New(function (id, complete, syncCallbackWhenAssetExist, autoDispose, dialogData) {
            if (complete === void 0) { complete = null; }
            if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
            if (autoDispose === void 0) { autoDispose = false; }
            if (!dialogData) {
                complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                return;
            }
            // 加载图片、音频、动画
            var d = dialogData;
            var imageUrls = [d.dialogBox.image, d.optionBox.image1, d.optionBox.image2, d.optionBox.image3, d.optionBox.selectImageURL];
            var seUrls = [d.optionBox.clickSe, d.optionBox.overSe];
            var aniID = d.skipBox.animationID;
            // 加载
            var loadCount = 0;
            function onLoadOne(id, complete, syncCallbackWhenAssetExist, autoDispose) {
                if (complete === void 0) { complete = null; }
                if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
                if (autoDispose === void 0) { autoDispose = false; }
                loadCount--;
                if (loadCount == 0) {
                    loadCount = -1;
                    if (autoDispose)
                        AssetManager.disposeDialog(id);
                    complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                }
            }
            var onLoadOneCB = Callback.New(onLoadOne, _this, [id, complete, syncCallbackWhenAssetExist, autoDispose]);
            var loads = [];
            loadCount += imageUrls.length + seUrls.length + 1;
            for (var s = 0; s < imageUrls.length; s++)
                loads.push(Callback.New(AssetManager.loadImage, _this, [imageUrls[s], onLoadOneCB, syncCallbackWhenAssetExist, true]));
            for (var s = 0; s < seUrls.length; s++)
                loads.push(Callback.New(AssetManager.loadAudio, _this, [seUrls[s], onLoadOneCB, syncCallbackWhenAssetExist, true]));
            _this.preLoadAnimationAsset(aniID, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose);
            for (var f in loads) {
                loads[f].run();
            }
        }, this, [id, complete, syncCallbackWhenAssetExist, autoDispose]), syncCallbackWhenAssetExist);
    };
    /**
     * 批量加载高级资源
     * @param onFin 当加载完成时回调 onFin();
     * @param onProgress [可选] 默认值=null 加载进度回调 onProgress(current:number,count:number); 当前加载数,加载总数
     * @param images [可选] 默认值=[] 需要加载的图片路径集
     * @param scenes [可选] 默认值=[] 需要加载的场景ID集
     * @param avatars [可选] 默认值=[] 需要加载的行走图ID集
     * @param standAvatars [可选] 默认值=[] 需要加载的立绘ID集
     * @param animations [可选] 默认值=[] 需要加载的动画ID集
     * @param uis  [可选] 默认值=[] 需要加载的UI集
     * @param jsons [可选] 默认值=[] 需要加载的JSON集
     * @param audios [可选] 默认值=[] 需要加载的音频集
     * @param dialogs [可选] 默认值=[] 需要加载的对话框
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     * @param autoDispose [可选] 默认值=false 是否自动释放资源（加载后会在延迟一段时间后自动释放，用于减少引用计数）
     * @param prerender [可选] 默认值=false 是否预渲染图片资源，保证完成回调后使用时不会因为渲染而卡顿，一般资源较大时可以尝试开启此项，开启此项会有额外的性能和内存开销
     */
    AssetManager.batchPreLoadAsset = function (onFin, onProgress, images, scenes, avatars, standAvatars, animations, uis, jsons, audios, dialogs, syncCallbackWhenAssetExist, autoDispose, prerender) {
        if (onProgress === void 0) { onProgress = null; }
        if (images === void 0) { images = []; }
        if (scenes === void 0) { scenes = []; }
        if (avatars === void 0) { avatars = []; }
        if (animations === void 0) { animations = []; }
        if (uis === void 0) { uis = []; }
        if (jsons === void 0) { jsons = []; }
        if (audios === void 0) { audios = []; }
        if (dialogs === void 0) { dialogs = []; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = false; }
        if (prerender === void 0) { prerender = false; }
        var loadCount = images.length + scenes.length + avatars.length + standAvatars.length + animations.length + uis.length + jsons.length + (Array.isArray(audios) ? audios.length : 0) + (Array.isArray(dialogs) ? dialogs.length : 0);
        if (loadCount == 0) {
            onFin && (syncCallbackWhenAssetExist ? onFin.run() : onFin.delayRun(0));
            return;
        }
        var loadCountR = loadCount;
        function onLoaded() {
            loadCount--;
            onProgress && onProgress.runWith([loadCountR - loadCount, loadCountR]);
            if (loadCount == 0) {
                onFin && (syncCallbackWhenAssetExist ? onFin.run() : onFin.delayRun(0));
            }
        }
        var onLoadedCB = Callback.New(onLoaded, this);
        for (var i = 0; i < images.length; i++) {
            var url = images[i];
            this.loadImage(url, onLoadedCB, syncCallbackWhenAssetExist, true, prerender);
            if (autoDispose)
                AssetManager.disposeImage(url);
        }
        for (var i = 0; i < scenes.length; i++) {
            this.preLoadSceneAsset(scenes[i], onLoadedCB, syncCallbackWhenAssetExist, autoDispose, prerender);
        }
        for (var i = 0; i < avatars.length; i++) {
            this.preLoadAvatarAsset(avatars[i], onLoadedCB, syncCallbackWhenAssetExist, autoDispose, prerender);
        }
        for (var i = 0; i < standAvatars.length; i++) {
            this.preLoadStandAvatarAsset(standAvatars[i], onLoadedCB, syncCallbackWhenAssetExist, autoDispose, prerender);
        }
        for (var i = 0; i < animations.length; i++) {
            this.preLoadAnimationAsset(animations[i], onLoadedCB, syncCallbackWhenAssetExist, autoDispose, prerender);
        }
        for (var i = 0; i < uis.length; i++) {
            this.preLoadUIAsset(uis[i], onLoadedCB, syncCallbackWhenAssetExist, autoDispose, prerender);
        }
        for (var i = 0; i < jsons.length; i++) {
            var url = jsons[i];
            this.loadJson(url, onLoadedCB, syncCallbackWhenAssetExist, true);
            if (autoDispose)
                AssetManager.disposeJson(url);
        }
        if (Array.isArray(audios)) {
            for (var i = 0; i < audios.length; i++) {
                this.loadAudio(audios[i], onLoadedCB, syncCallbackWhenAssetExist, true);
                if (autoDispose)
                    AssetManager.disposeAudio(url);
            }
        }
        if (Array.isArray(dialogs)) {
            for (var i = 0; i < dialogs.length; i++) {
                // @ts-ignore
                this.preLoadDialog(dialogs[i], onLoadedCB, syncCallbackWhenAssetExist, autoDispose);
            }
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 卸载游戏资源
    //------------------------------------------------------------------------------------------------------
    /**
     * 释放场景资源
     * @param id
     */
    AssetManager.disposeScene = function (id) {
        if (!id || id <= 0 || Config.EDIT_MODE)
            return;
        var dataURL = "asset/json/scene/data/scene" + id + ".json";
        // 无需引用的方式加载，只是为了获取内容以便卸载
        AssetManager.loadJson(dataURL, Callback.New(function (jsonObj) {
            if (!jsonObj)
                return;
            // 卸载场景扩展
            if (AssetManager.disposeSceneAssetExt) {
                AssetManager.disposeSceneAssetExt.runWith([id]);
            }
            // 卸载制作数据
            AssetManager.disposeJson(dataURL);
            // 全图层用到的图片卸载
            var imgUrls = [];
            for (var i = 0; i < jsonObj.LayerDatas.length; i++) {
                var layerData = jsonObj.LayerDatas[i];
                if (!layerData.drawMode && layerData.img) {
                    imgUrls.push(layerData.img);
                }
                if (layerData.drawMode && layerData.tileTexIDs) {
                    for (var tileID in layerData.tileTexIDs) {
                        var tileIDInt = MathUtils.int(tileID);
                        if (tileIDInt < 0) {
                            var autoTileData = Game.data.autoTileList.data[-tileIDInt];
                            if (autoTileData && autoTileData.url)
                                imgUrls.push(autoTileData.url);
                        }
                        else {
                            var tileData = Game.data.tileList.data[tileIDInt];
                            if (tileData && tileData.url)
                                imgUrls.push(tileData.url);
                        }
                    }
                }
            }
            AssetManager.disposeImages(imgUrls);
            // BGM/BGS
            if (jsonObj.bgm) {
                AssetManager.disposeAudio(jsonObj.bgm);
            }
            if (jsonObj.bgs) {
                AssetManager.disposeAudio(jsonObj.bgs);
            }
            // 自定义资源列表
            for (var s in jsonObj.preLoadAssets) {
                var preLoadAssetInfo = jsonObj.preLoadAssets[s];
                var valueStr = preLoadAssetInfo.value;
                var valueInt = preLoadAssetInfo.value;
                switch (preLoadAssetInfo.type) {
                    case 0:
                        AssetManager.disposeImage(valueStr);
                        break;
                    case 1:
                        AssetManager.disposeAudio(valueStr);
                        break;
                    case 2:
                        AssetManager.disposeText(valueStr);
                        break;
                    case 3:
                        AssetManager.disposeJson(valueStr);
                        break;
                    case 4:
                        AssetManager.disposeAvatarAsset(valueInt);
                        break;
                    case 5:
                        AssetManager.disposeUIAsset(valueInt);
                        break;
                    case 6:
                        AssetManager.disposeAnimationAsset(valueInt);
                        break;
                    case 7:
                        AssetManager.disposeStandAvatarAsset(valueInt);
                        break;
                    case 8:
                        AssetManager.disposeDialog(valueInt);
                        break;
                }
            }
        }, this), true, false);
    };
    /**
     * 释放场景对象资源
     */
    AssetManager.disposeSceneObject = function (so) {
        if (Config.EDIT_MODE)
            return;
        var modelData = Common.sceneObjectModelList.data[so.modelID];
        if (!modelData) {
            return;
        }
        var loads = [];
        for (var i in modelData.preLayer) {
            var preLayer = modelData.preLayer[i];
            var displayInfo = so.displayList[preLayer.varName];
            if (!displayInfo) {
                continue;
            }
            ;
            switch (preLayer.type) {
                case 1:
                    this.disposeAvatarAsset(displayInfo.id);
                    break;
                case 2:
                    this.disposeUIAsset(preLayer.id);
                    break;
                case 3:
                    if (displayInfo) {
                        this.disposeUIAsset(displayInfo.id);
                    }
                    break;
                case 4:
                    this.disposeAnimationAsset(preLayer.id);
                    break;
                case 5:
                    if (displayInfo) {
                        this.disposeAnimationAsset(displayInfo.id);
                    }
                    break;
            }
        }
    };
    /**
     * 释放行走图资源
     * @param id
     */
    AssetManager.disposeAvatarAsset = function (id, isStandAvatar) {
        if (isStandAvatar === void 0) { isStandAvatar = false; }
        if (!id || id < 0 || Config.EDIT_MODE)
            return;
        var assetURLHead = isStandAvatar ? "asset/json/standAvatar/data/standAvatar" : "asset/json/avatar/data/avatar";
        var dataURL = assetURLHead + id + ".json";
        AssetManager.loadJson(dataURL, Callback.New(function (isStandAvatar, dataURL, avatarData) {
            if (!avatarData) {
                return;
            }
            // 卸载制作数据
            AssetManager.disposeJson(dataURL);
            // 卸载自身的资源
            AssetManager.disposeImages(avatarData.picUrls);
            // 卸载部位的资源
            for (var i = 0; i < avatarData.parts.length; i++) {
                var avatarPartID = avatarData.parts[i].id;
                if (avatarPartID == 0)
                    continue;
                AssetManager.disposeAvatarAsset(avatarPartID, isStandAvatar);
            }
        }, this, [isStandAvatar, dataURL]), true, false);
    };
    /**
     * 释放立绘资源
     * @param id
     */
    AssetManager.disposeStandAvatarAsset = function (id) {
        return AssetManager.disposeAvatarAsset(id, true);
    };
    /**
     * 释放UI
     */
    AssetManager.disposeUIAsset = function (id) {
        if (!id || id <= 0 || Config.EDIT_MODE)
            return;
        var uiArr = AssetManager.preUIs[id];
        if (!uiArr || uiArr.length == 0)
            return;
        var ui = uiArr.shift();
        ui.dispose();
    };
    /**
     * 释放动画
     * @param id
     */
    AssetManager.disposeAnimationAsset = function (id) {
        if (!id || id <= 0 || Config.EDIT_MODE)
            return;
        var dataURL = "asset/json/animation/data/ani" + id + ".json";
        AssetManager.loadJson(dataURL, Callback.New(function (aniData) {
            if (!aniData || !aniData.imageSources) {
                return;
            }
            // 卸载制作数据
            AssetManager.disposeJson(dataURL);
            if (aniData.isParticle && aniData.particleData) {
                AssetManager.disposeImage(aniData.particleData.textureName);
            }
            else {
                // 加载其中可能存在的动画层，列出该动画下面的所有动画层（含子节点的子节点等）
                for (var index = 0; index < aniData.layers.length; index++) {
                    var layerInfo = aniData.layers[index];
                    if (layerInfo.type == AnimationItemType.GCAnimation) {
                        var nodes = ArrayUtils.getTreeNodeArray(layerInfo);
                        for (var s in nodes) {
                            var childLayerInfo = nodes[s];
                            if (childLayerInfo.type == AnimationItemType.GCAnimation) {
                                AssetManager.disposeAnimationAsset(childLayerInfo.animationId);
                            }
                        }
                    }
                }
                // 加载自身资源
                var picUrls = aniData.imageSources.reduce(function (pv, v) { if (v && pv.indexOf(v.url) == -1)
                    pv.push(v.url); return pv; }, []);
                AssetManager.disposeImages(picUrls);
            }
        }, this), true, false);
    };
    /**
     * 释放由于预加载事件页加载的资源
     * @param commandPage 事件页
     */
    AssetManager.disposeCommandPage = function (commandPage) {
        var cache = AssetManager.commandPerloadCache[commandPage.id];
        if (cache) {
            var dialogCache = cache[0], avatarCache = cache[1], imageCache = cache[2], audioCache = cache[3], uiCache = cache[4], animationCache = cache[5], standAvatarCache = cache[6], cmdPageCache = cache[7];
            for (var s = 0; s < dialogCache.length; s++)
                AssetManager.disposeDialog(dialogCache[s]);
            for (var s = 0; s < avatarCache.length; s++)
                AssetManager.disposeAvatarAsset(avatarCache[s]);
            for (var s = 0; s < imageCache.length; s++)
                AssetManager.disposeImage(imageCache[s]);
            for (var s = 0; s < audioCache.length; s++) {
                AssetManager.disposeAudio(audioCache[s]);
            }
            for (var s = 0; s < uiCache.length; s++)
                AssetManager.disposeUIAsset(uiCache[s]);
            for (var s = 0; s < animationCache.length; s++)
                AssetManager.disposeAnimationAsset(animationCache[s]);
            for (var s = 0; s < standAvatarCache.length; s++)
                AssetManager.disposeStandAvatarAsset(standAvatarCache[s]);
            for (var s = 0; s < cmdPageCache.length; s++)
                AssetManager.disposeCommandPage(cmdPageCache[s]);
            delete AssetManager.commandPerloadCache[commandPage.id];
        }
    };
    /**
     * 预加载对话框的相关资源
     * @param id 对话框ID
     */
    AssetManager.disposeDialog = function (id) {
        if (id == 0)
            return;
        var jsonURL = "asset/json/dialog/data/dialog" + id + ".json";
        AssetManager.loadJson(jsonURL, Callback.New(function (jsonURL, dialogData) {
            if (!dialogData) {
                return;
            }
            // 卸载json文件
            AssetManager.disposeJson(jsonURL);
            // 卸载图片、音频、动画
            var d = dialogData;
            var imageUrls = [d.dialogBox.image, d.optionBox.image1, d.optionBox.image2, d.optionBox.image3];
            var seUrls = [d.optionBox.clickSe, d.optionBox.overSe];
            var aniID = d.skipBox.animationID;
            for (var s = 0; s < imageUrls.length; s++)
                AssetManager.disposeImage(imageUrls[s]);
            for (var s = 0; s < seUrls.length; s++)
                AssetManager.disposeAudio(seUrls[s]);
            AssetManager.disposeAnimationAsset(aniID);
        }, this, [jsonURL]), true, false);
    };
    //------------------------------------------------------------------------------------------------------
    // 加载基础资源 
    //------------------------------------------------------------------------------------------------------
    /**
     * 加载图片
     * @param url 图片地址
     * @param complete [可选] 默认值=null 当完成时回调 complete(tex:Texture)
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     * @param useRef 使用引用计数
     * @param prerender [可选] 默认值=false 是否预渲染图片资源，保证完成回调后使用时不会因为渲染而卡顿，一般资源较大时可以尝试开启此项
     */
    AssetManager.loadImage = function (url, complete, syncCallbackWhenAssetExist, useRef, prerender) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        if (prerender === void 0) { prerender = false; }
        this.loadAsset(url, Loader.IMAGE, complete, syncCallbackWhenAssetExist, useRef, false, prerender);
    };
    /**
     * 加载Texture粒子图片
     * @param url 图片地址
     * @param complete [可选] 默认值=null 当完成时回调 complete(tex:Texture)
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     * @param useRef 使用引用计数
     * @param isTexture 是否是粒子贴图
     */
    AssetManager.loadTexture = function (url, complete, syncCallbackWhenAssetExist, useRef) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        this.loadAsset(url, Loader.IMAGE, complete, syncCallbackWhenAssetExist, useRef, true);
    };
    /**
     * 加载图片集，忽略空地址，始终会返回加载完毕回调
     * @param urls 图片地址集
     * @param complete [可选] 默认值=null
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     * @param useRef [可选] 默认值=true 使用引用计数
     * @param prerender [可选] 默认值=false 是否预渲染图片资源，保证完成回调后使用时不会因为渲染而卡顿，一般资源较大时可以尝试开启此项
     */
    AssetManager.loadImages = function (urls, complete, syncCallbackWhenAssetExist, useRef, prerender) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        if (prerender === void 0) { prerender = false; }
        this.batchLoadAsset(urls, Loader.IMAGE, complete, syncCallbackWhenAssetExist, useRef, false, prerender);
    };
    /**
     * 加载Texture粒子图片集，忽略空地址，始终会返回加载完毕回调
     * @param urls 图片地址集
     * @param complete [可选] 默认值=null
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     * @param useRef 使用引用计数
     */
    AssetManager.loadTextures = function (urls, complete, syncCallbackWhenAssetExist, useRef) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        this.batchLoadAsset(urls, Loader.IMAGE, complete, syncCallbackWhenAssetExist, useRef, true);
    };
    /**
     * 加载音频文件支持格式 .mp3 .ogg
     * @param url 音频文件地址
     * @param complete [可选] 默认值=null 加载完成时回调
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     * @param useRef 使用引用计数
     */
    AssetManager.loadAudio = function (url, complete, syncCallbackWhenAssetExist, useRef) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        var newURL = url.split(",")[0];
        this.loadAsset(newURL, Loader.SOUND, complete, syncCallbackWhenAssetExist, useRef);
    };
    /**
     * 加载音频文件集，忽略空地址，始终会返回加载完毕回调
     * @param urls 音频文件集
     * @param complete [可选] 默认值=null
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     * @param useRef 使用引用计数
     */
    AssetManager.loadAudios = function (urls, complete, syncCallbackWhenAssetExist, useRef) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        // 包含音量音调的取得地址
        var newURLs = [];
        for (var i in urls) {
            var url = urls[i].split(",")[0];
            if (url)
                newURLs.push(url);
        }
        this.batchLoadAsset(newURLs, Loader.SOUND, complete, syncCallbackWhenAssetExist, useRef);
    };
    /**
     * 加载并解析JSON文件
     * @param url json文件地址
     * @param complete complete(jsonObj:any)
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     * @param useRef [可选] 默认值=true 使用引用计数
     * @param onErrorTips [可选] 默认值=true 当错误时提示
     */
    AssetManager.loadJson = function (url, complete, syncCallbackWhenAssetExist, useRef, onErrorTips) {
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        if (onErrorTips === void 0) { onErrorTips = true; }
        if (!url) {
            complete && (syncCallbackWhenAssetExist ? complete.runWith([]) : complete.delayRun(1, null, []));
            return;
        }
        if (useRef)
            AssetManager.addRef(url);
        var asset = loader.getRes(url);
        if (asset) {
            complete && (syncCallbackWhenAssetExist ? complete.runWith([asset]) : complete.delayRun(1, null, [asset]));
            return;
        }
        FileUtils.loadJsonFile(url, complete, onErrorTips);
    };
    /**
     * 加载并解析JSON文件集，忽略空地址，始终会返回加载完毕回调
     * @param urls json文件地址集
     * @param complete [可选] 默认值=null
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     * @param useRef 使用引用计数
     */
    AssetManager.loadJsons = function (urls, complete, syncCallbackWhenAssetExist, useRef) {
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        this.batchLoadAsset(urls, Loader.JSON, complete, syncCallbackWhenAssetExist, useRef);
    };
    /**
     * 加载Text文件
     * @param url 文件路径
     * @param complete
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     * @param useRef 使用引用计数
     */
    AssetManager.loadText = function (url, complete, syncCallbackWhenAssetExist, useRef) {
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        this.loadAsset(url, Loader.TEXT, complete, syncCallbackWhenAssetExist, useRef);
    };
    /**
     * 加载Text文件集
     * @param urls 文件路径集
     * @param complete
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     * @param useRef 使用引用计数
     */
    AssetManager.loadTexts = function (urls, complete, syncCallbackWhenAssetExist, useRef) {
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        this.batchLoadAsset(urls, Loader.TEXT, complete, syncCallbackWhenAssetExist, useRef);
    };
    /**
     * 加载文件资源（二进制）
     * @param url 文件路径集
     * @param complete 加载完成时回调函数 complete(arrayBuffer:ArrayBuffer)
     * @param useRef [可选] 默认值=true 使用引用计数
     */
    AssetManager.loadFileArrayBuffer = function (url, complete, useRef) {
        if (useRef === void 0) { useRef = true; }
        this.loadAsset(url, Loader.BUFFER, complete, true, useRef);
    };
    /**
     * 加载资源
     * @param url
     * @param type
     * @param complete [可选] 默认值=null
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     * @param useRef 使用引用计数
     * @param isTexture 是否是粒子贴图
     * @param prerender [可选] 默认值=false 是否预渲染图片资源，保证完成回调后使用时不会因为渲染而卡顿，一般资源较大时可以尝试开启此项
     */
    AssetManager.loadAsset = function (url, type, complete, syncCallbackWhenAssetExist, useRef, isTexture, prerender) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        if (isTexture === void 0) { isTexture = false; }
        if (prerender === void 0) { prerender = false; }
        if (!url || typeof url !== "string") {
            complete && (syncCallbackWhenAssetExist ? complete.runWith([]) : complete.delayRun(1));
            return;
        }
        if (useRef)
            AssetManager.addRef(url);
        var asset = loader.getRes(url);
        if (asset) {
            if (asset.bitmap && type == Loader.IMAGE) {
                if (isTexture) {
                    // if (Config.EDIT_MODE) (asset as Texture).isLinearSampling = false;
                    (asset.bitmap).enableMerageInAtlas = false;
                }
                else
                    (asset.bitmap).enableMerageInAtlas = true;
            }
            // 预渲染
            if (prerender && type == Loader.IMAGE && asset && asset instanceof Texture) {
                var sp = new Sprite;
                sp.texture = asset;
                sp.texture["__rendered"] = true;
                AssetManager.prerender(sp);
                sp.texture = null;
                sp.destroy(true);
            }
            complete && (syncCallbackWhenAssetExist ? complete.runWith([asset]) : complete.delayRun(1, null, [asset]));
            return;
        }
        loader.load(url, Handler.create(this, function (type, asset) {
            if (asset && asset.bitmap && type == Loader.IMAGE && isTexture) {
                (asset.bitmap).enableMerageInAtlas = false;
            }
            // 预渲染
            if (prerender && type == Loader.IMAGE && asset && asset instanceof Texture) {
                var sp = new Sprite;
                sp.texture = asset;
                sp.texture["__rendered"] = true;
                AssetManager.prerender(sp);
                sp.texture = null;
                sp.destroy(true);
            }
            AssetManager.onDisplayTexture(asset, complete);
        }, [type]), null, type);
    };
    /**
     * 加载资源后还要用于显示，当显示完成后回调
     * @param asset
     * @param complete
     */
    AssetManager.onDisplayTexture = function (asset, complete) {
        complete && complete.runWith([asset]);
        // return;
        // if (Config.EDIT_MODE) {
        //     complete && complete.runWith([asset]);
        //     return;
        // }
        // if (asset && asset instanceof Texture) {
        //     var sp = new UIComponent.UIBitmap();
        //     sp.x = Config.WINDOW_WIDTH;
        //     sp.once(EventObject.LOADED, this, (sp: UIComponent.UIBitmap, complete: Callback) => {
        //         Callback.New((sp: UIComponent.UIBitmap, complete: Callback) => {
        //             sp.dispose();
        //             complete && complete.runWith([asset]);
        //         }, this, [sp, complete]).delayRun(20);
        //     }, [sp, complete]);
        //     sp.image = (asset as Texture).url;
        //     stage.addChild(sp);
        // }
        // else {
        //     complete && complete.runWith([asset]);
        // }
    };
    /**
     * 批量加载资源
     * @param urls 资源集
     * @param type 类别
     * @param complete [可选] 默认值=null 回调
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     * @param useRef 使用引用计数
     * @param isTexture 是否是粒子贴图
     * @param prerender [可选] 默认值=false 是否预渲染图片资源，保证完成回调后使用时不会因为渲染而卡顿，一般资源较大时可以尝试开启此项
     */
    AssetManager.batchLoadAsset = function (urls, type, complete, syncCallbackWhenAssetExist, useRef, isTexture, prerender) {
        var _this = this;
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        if (isTexture === void 0) { isTexture = false; }
        if (prerender === void 0) { prerender = false; }
        var loadUrls = [];
        for (var i in urls) {
            if (urls[i] && typeof urls[i] === "string")
                loadUrls.push(urls[i]);
        }
        if (loadUrls.length == 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(1));
            return;
        }
        var allExist = true;
        for (var i in loadUrls) {
            var url = loadUrls[i];
            var asset = loader.getRes(url);
            if (!asset)
                allExist = false;
            if (asset && asset.bitmap && type == Loader.IMAGE) {
                if (isTexture)
                    (asset.bitmap).enableMerageInAtlas = false;
                else
                    (asset.bitmap).enableMerageInAtlas = true;
            }
            if (useRef)
                AssetManager.addRef(url);
        }
        if (allExist) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(1));
        }
        else {
            loader.load(loadUrls, Handler.create(this, function (type, loadUrls, prerender) {
                if (type == Loader.IMAGE && isTexture) {
                    for (var i in loadUrls) {
                        var url = loadUrls[i];
                        var asset = loader.getRes(url);
                        if (!asset || !asset.bitmap)
                            continue;
                        (asset.bitmap).enableMerageInAtlas = false;
                    }
                }
                // 预渲染
                if (type == Loader.IMAGE && prerender) {
                    for (var i in loadUrls) {
                        var url = loadUrls[i];
                        var asset = loader.getRes(url);
                        if (!asset || !(asset instanceof Texture))
                            continue;
                        var sp = new Sprite;
                        sp.texture = asset;
                        sp.texture["__rendered"] = true;
                        AssetManager.prerender(sp);
                        sp.texture = null;
                        sp.destroy(true);
                    }
                }
                var displayCount = loadUrls.length;
                var onDisplay = Callback.New(function () {
                    displayCount--;
                    if (displayCount == 0)
                        complete && complete.run();
                }, _this);
                for (var i in loadUrls) {
                    var url = loadUrls[i];
                    var asset = loader.getRes(url);
                    AssetManager.onDisplayTexture(asset, onDisplay);
                }
            }, [type, loadUrls, prerender]), null, type);
        }
    };
    /**
     * 批量卸载高级资源
     * @param images [可选] 默认值=[] 需要加载的图片路径集
     * @param scenes [可选] 默认值=[] 需要加载的场景ID集
     * @param avatars [可选] 默认值=[] 需要加载的行走图ID集
     * @param standAvatars [可选] 默认值=[] 需要加载的立绘ID集
     * @param animations [可选] 默认值=[] 需要加载的动画ID集
     * @param uis  [可选] 默认值=[] 需要加载的UI集
     * @param jsons [可选] 默认值=[] 需要加载的JSON集
     * @param audios [可选] 默认值=[] 需要加载的音频集
     * @param dialogs [可选] 默认值=[] 需要加载的对话框
     */
    AssetManager.batchDisposeAsset = function (images, scenes, avatars, standAvatars, animations, uis, jsons, audios, dialogs) {
        if (images === void 0) { images = []; }
        if (scenes === void 0) { scenes = []; }
        if (avatars === void 0) { avatars = []; }
        if (animations === void 0) { animations = []; }
        if (uis === void 0) { uis = []; }
        if (jsons === void 0) { jsons = []; }
        if (audios === void 0) { audios = []; }
        if (dialogs === void 0) { dialogs = []; }
        for (var i = 0; i < images.length; i++) {
            var url = images[i];
            AssetManager.disposeImage(url);
        }
        for (var i = 0; i < scenes.length; i++) {
            this.disposeScene(scenes[i]);
        }
        for (var i = 0; i < avatars.length; i++) {
            this.disposeAvatarAsset(avatars[i]);
        }
        for (var i = 0; i < standAvatars.length; i++) {
            this.disposeStandAvatarAsset(standAvatars[i]);
        }
        for (var i = 0; i < animations.length; i++) {
            this.disposeAnimationAsset(animations[i]);
        }
        for (var i = 0; i < uis.length; i++) {
            this.disposeUIAsset(uis[i]);
        }
        for (var i = 0; i < jsons.length; i++) {
            var url = jsons[i];
            AssetManager.disposeJson(url);
        }
        for (var i = 0; i < audios.length; i++) {
            this.disposeAudio(audios[i]);
        }
        for (var i = 0; i < dialogs.length; i++) {
            AssetManager.disposeDialog(dialogs[i]);
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 获取基础资源
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取贴图资源
     * @param url 图片地址
     * @return [Texture]
     */
    AssetManager.getImage = function (url) {
        var tex = loader.getRes(url);
        return tex;
    };
    /**
     * 获取JSON资源
     */
    AssetManager.getJson = function (url) {
        return loader.getRes(url);
    };
    /**
     * 获取文本资源
     */
    AssetManager.getText = function (url) {
        return loader.getRes(url);
    };
    /**
     * 获取文件资源（二进制）
     */
    AssetManager.getFileArrayBuffer = function (url) {
        return loader.getRes(url);
    };
    //------------------------------------------------------------------------------------------------------
    // 卸载基础资源
    //------------------------------------------------------------------------------------------------------
    /**
     * 卸载图片资源：当引用计数为0时会延迟后清理掉实际的所有资源以及其所有的切图资源（需保证切图资源Graphics外部已没有引用）
     * @param url 图片文件地址
     */
    AssetManager.disposeImage = function (url, force) {
        if (force === void 0) { force = false; }
        if (Config.EDIT_MODE)
            return;
        if (!url)
            return;
        function doDisposeImage(url) {
            AssetManager.imageAssets[url] = null;
            delete AssetManager.assetCountMap[url];
            var t = loader.getRes(url);
            loader.clearRes(url, true);
            if (t && t.destroy) {
                t.destroy(true);
            }
        }
        if (force) {
            doDisposeImage(url);
            return;
        }
        Callback.New(function (url) {
            var ref = AssetManager.subRef(url);
            if (ref == 0)
                doDisposeImage(url);
        }, this, [url]).delayRun(AssetManager.disposeInterval);
    };
    /**
     * 卸载图片资源：当引用计数为0时会延迟后清理掉实际的所有资源以及其所有的切图资源（需保证切图资源Graphics外部已没有引用）
     * @param url 图片文件地址
     */
    AssetManager.disposeImages = function (urls, force) {
        if (force === void 0) { force = false; }
        if (Config.EDIT_MODE)
            return;
        if (!urls || urls.length == 0)
            return;
        for (var i in urls) {
            AssetManager.disposeImage(urls[i], force);
        }
    };
    /**
     * 卸载音频资源，当引用计数为0时会延迟后清理掉实际的所有资源
     * @param url 音频文件地址
     */
    AssetManager.disposeAudio = function (url, force) {
        if (force === void 0) { force = false; }
        if (Config.EDIT_MODE)
            return;
        if (!url)
            return;
        function doDisposeAudio(url) {
            delete AssetManager.assetCountMap[url];
            var s = loader.getRes(url);
            loader.clearRes(url, true);
            if (s && s.dispose)
                s.dispose();
        }
        if (force) {
            doDisposeAudio(url);
            return;
        }
        Callback.New(function (url) {
            var ref = AssetManager.subRef(url);
            if (ref == 0)
                doDisposeAudio(url);
        }, this, [url]).delayRun(AssetManager.disposeInterval);
    };
    /**
     * 卸载JSON资源，当引用计数为0时会延迟后清理掉实际的所有资源
     * @param url json文件地址
     */
    AssetManager.disposeJson = function (url, force) {
        if (force === void 0) { force = false; }
        if (Config.EDIT_MODE || !url)
            return;
        function doDisposeJson(url) {
            delete AssetManager.assetCountMap[url];
            loader.clearRes(url, true);
        }
        if (force) {
            doDisposeJson(url);
            return;
        }
        Callback.New(function (url) {
            var ref = AssetManager.subRef(url);
            if (ref == 0)
                doDisposeJson(url);
        }, this, [url]).delayRun(force ? 0 : AssetManager.disposeInterval);
    };
    /**
     * 卸载文本资源，当引用计数为0时会延迟后清理掉实际的所有资源
     * @param url 文本文件地址
     */
    AssetManager.disposeText = function (url, force) {
        if (force === void 0) { force = false; }
        if (Config.EDIT_MODE || !url)
            return;
        function doDisposeText(url) {
            delete AssetManager.assetCountMap[url];
            loader.clearRes(url, true);
        }
        if (force) {
            doDisposeText(url);
            return;
        }
        Callback.New(function (url) {
            var ref = AssetManager.subRef(url);
            if (ref == 0)
                doDisposeText(url);
        }, this, [url]).delayRun(force ? 0 : AssetManager.disposeInterval);
    };
    /**
     * 卸载文件资源（二进制）
     * @param url 文件路径集
     * @param complete
     * @param useRef [可选] 默认值=true 使用引用计数
     */
    AssetManager.disposeFileArrayBuffer = function (url, force) {
        if (force === void 0) { force = false; }
        if (Config.EDIT_MODE || !url)
            return;
        function doDisposeFileArrayBuffer(url) {
            delete AssetManager.assetCountMap[url];
            loader.clearRes(url, true);
        }
        if (force) {
            doDisposeFileArrayBuffer(url);
            return;
        }
        Callback.New(function (url) {
            var ref = AssetManager.subRef(url);
            if (ref == 0)
                doDisposeFileArrayBuffer(url);
        }, this, [url]).delayRun(force ? 0 : AssetManager.disposeInterval);
    };
    //------------------------------------------------------------------------------------------------------
    // 切图、截图
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取切片的贴图资源：整图资源必须已载入，当没有对应的切图时会临时切一次
     * @param url
     * @param x 显示的偏移值x
     * @param y 显示的偏移值y
     * @param rect 对纹理的取样 偏移和宽高
     */
    AssetManager.getClipImage = function (url, x, y, rect) {
        var tex = AssetManager.getImage(url);
        if (!tex)
            return null;
        // if (Config.EDIT_MODE) tex.isLinearSampling = false;
        var imageAssetClips = AssetManager.imageAssets[url];
        if (!imageAssetClips)
            imageAssetClips = AssetManager.imageAssets[url] = {};
        var key = x + "_" + y + "_" + rect.width + "_" + rect.height + "_" + rect.x + "_" + rect.y;
        var g = imageAssetClips[key];
        if (!g || (g && g["___useTexture"] != tex)) {
            g = imageAssetClips[key] = new Graphics();
            g.fillTexture(tex, x, y, rect.width, rect.height, null, new Point(rect.x, rect.y));
            g["___useTexture"] = tex;
        }
        return g;
    };
    /**
     * 转为贴图（显存）
     * @param source 源，Sprite或Graphics均可
     * @param textureWidth
     * @param textureHeight
     * @param offsetX source相对于画布的偏移X
     * @param offsetY source相对于画布的偏移Y
     * @param mipmap [可选] 默认值=false 是否使用mipmap
     * @param minFifter [可选] 默认值=-1 缩小时的采样方式
     * @param magFifter [可选] 默认值=-1 放大时的采样方式
     * @return [Texture]
     */
    AssetManager.drawToTexture = function (source, textureWidth, textureHeight, offsetX, offsetY, mipmap, minFifter, magFifter) {
        if (offsetX === void 0) { offsetX = 0; }
        if (offsetY === void 0) { offsetY = 0; }
        if (mipmap === void 0) { mipmap = false; }
        if (minFifter === void 0) { minFifter = 0x2600; }
        if (magFifter === void 0) { magFifter = 0x2600; }
        var helpSprite;
        if (source instanceof Graphics) {
            helpSprite = new Sprite();
            helpSprite.graphics = source;
            helpSprite.blendMode = null; //"light"
        }
        else {
            helpSprite = source;
        }
        // var d1 = new Date().getTime();
        var oldRect = helpSprite.scrollRect;
        helpSprite.scrollRect = new Rectangle(-offsetX, -offsetY, textureWidth, textureHeight);
        var t = _drawToTexture(helpSprite, textureWidth, textureHeight, 0, 0, mipmap, minFifter, magFifter);
        // var d2 = new Date().getTime();
        helpSprite.scrollRect = oldRect;
        // trace(d2 - d1, "ms 花费A", source instanceof Graphics, textureWidth, textureHeight, offsetX, offsetY)
        var texture = new Texture(t.bitmap);
        return texture;
        function _drawToTexture(sprite, textureWidth, textureHeight, offsetX, offsetY, mipmap, minFifter, magFifter) {
            var _renderType = 640;
            offsetX -= sprite.x;
            offsetY -= sprite.y;
            sprite.scaleY *= -1;
            // 修正canvas比较小的时候截图存在的问题
            var oldSpriteScaleX = sprite.scaleX;
            var oldSpriteScaleY = sprite.scaleY;
            var sx = stage.width / os.canvas.width;
            var sy = stage.height / os.canvas.height;
            var specialHandle = (sx > 1 || sy > 1) && textureWidth >= os.canvas.width && textureHeight >= os.canvas.height;
            if (specialHandle) {
                sprite.scaleY /= sy;
                sprite.scaleX /= sx;
                var texSx = textureWidth / stage.width;
                var texSy = textureHeight / stage.height;
                sprite.scaleX *= texSx;
                sprite.scaleY *= texSy;
            }
            var renderTarget = RenderTarget2D.create(textureWidth, textureHeight, 0x1908, 0x1401, 0, mipmap, false, minFifter, magFifter);
            if (specialHandle) {
                renderTarget.bitmap["_w"] = Math.ceil(sx * stage.width);
                renderTarget.bitmap["_h"] = Math.ceil(sy * stage.height);
                renderTarget["_w"] = os.canvas.width * texSx;
                renderTarget["_h"] = os.canvas.height * texSy;
            }
            renderTarget.start();
            renderTarget.clear(0.0, 0.0, 0.0, 0.0);
            Render.context.clear();
            RenderSprite.renders[_renderType]._fun(sprite, Render.context, offsetX, RenderState2D.height + offsetY);
            if (specialHandle) {
                os.context.viewport(0, 0, os.canvas.width * texSx, os.canvas.height * texSy);
            }
            Render.context.flush();
            renderTarget.end();
            if (specialHandle) {
                sprite.scaleX = oldSpriteScaleX;
                sprite.scaleY = oldSpriteScaleY;
            }
            sprite.scaleY *= -1;
            return renderTarget;
        }
    };
    /**
     * 【内部使用】预渲染
     * 如果显示对象包含的资源较多，首次渲染可能造成卡顿，为了让渲染前不至于卡顿，可以在加载之类的地方去预渲染一下。
     */
    AssetManager.prerender = function (source) {
        var oldChilds = stage._childs;
        var oldScaleX = source.scaleX;
        source.scaleX = 0;
        stage._childs = [source];
        stage._loop();
        stage._childs = oldChilds;
        source.scaleX = oldScaleX;
    };
    /**
     * 以拼合图的形式绘制到容器中（由于设备限制贴图大小而需要拼合）
     * 需要调用disposeAtlasSprite来主动释放这些显存上的贴图
     * @param source
     * @param width
     * @param height
     * @return [Sprite]
     */
    AssetManager.drawToAtlasSprite = function (source, width, height, mipmap, minFifter, magFifter, offsetX, offsetY) {
        if (mipmap === void 0) { mipmap = false; }
        if (minFifter === void 0) { minFifter = -1; }
        if (magFifter === void 0) { magFifter = -1; }
        if (offsetX === void 0) { offsetX = 0; }
        if (offsetY === void 0) { offsetY = 0; }
        var root = new Sprite();
        var splitW = Math.ceil(width / Config.TILE_SPLIT_SIZE);
        var splitH = Math.ceil(height / Config.TILE_SPLIT_SIZE);
        for (var xGrid = 0; xGrid < splitW; xGrid++) {
            for (var yGrid = 0; yGrid < splitH; yGrid++) {
                var dx = -Config.TILE_SPLIT_SIZE * xGrid;
                var dy = -Config.TILE_SPLIT_SIZE * yGrid;
                var tex = AssetManager.drawToTexture(source, Config.TILE_SPLIT_SIZE, Config.TILE_SPLIT_SIZE, dx + offsetX, dy + offsetY, mipmap, minFifter, magFifter);
                var splitSp = new Sprite();
                splitSp.texture = tex;
                splitSp.x = -dx;
                splitSp.y = -dy;
                root.addChild(splitSp);
            }
        }
        return root;
    };
    /**
     * 大贴图转化为拼图
     * @param texture 贴图
     * @param xLoop x循环
     * @param yLoop y循环
     * @return [Sprite]
     */
    AssetManager.bigTextureToAtlasSprite = function (texture, xLoop, yLoop, mapWidth, mapHeight) {
        if (xLoop === void 0) { xLoop = false; }
        if (yLoop === void 0) { yLoop = false; }
        if (mapWidth === void 0) { mapWidth = 0; }
        if (mapHeight === void 0) { mapHeight = 0; }
        var drawArea = [];
        if (xLoop) {
            drawArea.push([1, 0], [-1, 0]);
        }
        if (yLoop) {
            drawArea.push([0, 1], [0, -1]);
        }
        if (xLoop && yLoop) {
            drawArea.push([-1, -1], [1, -1], [1, 1], [-1, 1]);
        }
        var img = texture.bitmap["_image"];
        if (!img) {
            return new Sprite();
        }
        var maxW = Config.TILE_SPLIT_SIZE;
        var maxH = Config.TILE_SPLIT_SIZE;
        var root = new Sprite();
        var splitW = Math.ceil(img.width / maxW);
        var splitH = Math.ceil(img.height / maxW);
        for (var xGrid = 0; xGrid < splitW; xGrid++) {
            for (var yGrid = 0; yGrid < splitH; yGrid++) {
                var dx = maxW * xGrid;
                var dy = maxW * yGrid;
                var canvas = document.createElement("canvas");
                canvas.width = maxW;
                canvas.height = maxW;
                var canvas2d = document.createElement("canvas");
                canvas2d.width = maxW;
                canvas2d.height = maxW;
                var ctx = canvas2d.getContext("2d");
                ctx.drawImage(img, dx, dy, maxW, maxW, 0, 0, maxW, maxH);
                var wgImage = new WebGLImage(canvas2d, new Date().getTime() + Math.random().toString());
                var newTexture = new Texture(wgImage);
                var splitSp = new Sprite();
                splitSp.texture = newTexture;
                splitSp.x = dx;
                splitSp.y = dy;
                for (var s in drawArea) {
                    var loopSp = new Sprite();
                    loopSp.name = "loop";
                    loopSp.texture = newTexture;
                    root.addChild(loopSp);
                    loopSp.x = drawArea[s][0] * mapWidth + splitSp.x;
                    loopSp.y = drawArea[s][1] * mapHeight + splitSp.y;
                }
                root.addChild(splitSp);
            }
        }
        return root;
    };
    /**
     * 释放拼合的贴图
     * @param root
     */
    AssetManager.disposeAtlasSprite = function (root) {
        if (!root)
            return;
        for (var i = 0; i < root.numChildren; i++) {
            var sp = root.getChildAt(i);
            sp.texture.destroy(true);
            sp.texture = null;
        }
        root.removeChildren();
    };
    //------------------------------------------------------------------------------------------------------
    // private
    //------------------------------------------------------------------------------------------------------
    /**
     * 减少资源引用
     * @param url
     */
    AssetManager.subRef = function (url) {
        var ref = AssetManager.assetCountMap[url];
        if (ref == null) {
            return 0;
        }
        ref--;
        if (ref == 0) {
            delete AssetManager.assetCountMap[url];
        }
        else {
            AssetManager.assetCountMap[url] = ref;
        }
        return ref;
    };
    /**
     * 增加资源引用
     * @param url
     */
    AssetManager.addRef = function (url) {
        var ref = AssetManager.assetCountMap[url];
        if (ref == null) {
            AssetManager.assetCountMap[url] = ref = 0;
        }
        AssetManager.assetCountMap[url] = ++ref;
    };
    //------------------------------------------------------------------------------------------------------
    // 图片使用格式转化
    //------------------------------------------------------------------------------------------------------
    /**
     * 贴图转为base64格式
     * @param texture 贴图
     * @return [string] base64字符串
     */
    AssetManager.textureToBase64 = function (texture) {
        var sp = new Sprite();
        sp.texture = texture;
        var htmlCanvas = sp.drawToCanvas(texture.width, texture.height, 0, 0);
        var canvas = htmlCanvas.getCanvas();
        var base64 = canvas.toDataURL("image/png");
        htmlCanvas.dispose();
        return base64;
    };
    /**
     * 贴图转为ArrayBuffer格式
     * @param texture 贴图
     * @return [ArrayBuffer] ArrayBuffer字节数组
     */
    AssetManager.textureToArrayBuffer = function (texture) {
        var base64 = AssetManager.textureToBase64(texture);
        var arr = base64.split(',');
        var mime = arr[0].match(/:(.*?);/)[1];
        var bstr = atob(arr[1]);
        var n = bstr.length;
        var u8arr = new Uint8Array(n);
        while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
        }
        return u8arr.buffer;
    };
    /**
     * ArrayBuffer格式转为Base64格式
     * @param arrayBuffer ArrayBuffer字节数组
     * @return [string] base64字符串
     */
    AssetManager.arrayBufferToBase64 = function (arrayBuffer) {
        var binary = "";
        var bytes = new Uint8Array(arrayBuffer);
        var len = bytes.byteLength;
        for (var i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        var base64 = "data:image/jpeg;base64," + window.btoa(binary);
        return base64;
    };
    /**
     * Base64格式转ArrayBuffer格式
     * @param base64 base64字符串
     * @return [ArrayBuffer] ArrayBuffer字节数组
     */
    AssetManager.base64ToArrayBuffer = function (base64) {
        var arr = base64.split(',');
        var mime = arr[0].match(/:(.*?);/)[1];
        var bstr = atob(arr[1]);
        var n = bstr.length;
        var u8arr = new Uint8Array(n);
        while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
        }
        return u8arr.buffer;
    };
    /**
     * Base64格式转为贴图
     * @param base64 base64字符串
     * @param callback 回调(tex:贴图)
     */
    AssetManager.base64ToTexture = function (base64, callback) {
        var buffer = AssetManager.base64ToArrayBuffer(base64);
        AssetManager.arrayBufferToTexture(buffer, callback);
    };
    /**
     * ArrayBuffer格式转为贴图
     * @param arrayBuffer 字节数组
     * @param callback 回调(tex:贴图)
     */
    AssetManager.arrayBufferToTexture = function (arrayBuffer, callback) {
        var blob = new Blob([arrayBuffer], { type: "image/png" });
        var url = URL.createObjectURL(blob);
        loader.load(url, Handler.create(this, function () {
            var tex = loader.getRes(url);
            callback && callback.runWith([tex]);
        }), null, Loader.IMAGE);
    };
    //------------------------------------------------------------------------------------------------------
    // 预加载字体
    //------------------------------------------------------------------------------------------------------
    /**
     * 预加载所有预设的字体
     * @param complete [可选] 默认值=null 加载完成回调
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     */
    AssetManager.preloadFonts = function (complete, syncCallbackWhenAssetExist) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        var list = Config.FONTS ? Config.FONTS : [];
        var allExist = true;
        for (var i = 0; i < list.length; i++) {
            var name = list[i].name;
            var fontFace = FontLoadManager.getFontByName(name);
            if (!fontFace)
                allExist = false;
        }
        if (allExist) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(1));
        }
        else {
            FontLoadManager.loadFontFile(list, complete);
        }
    };
    /**
     * 预加载指定的字体文件
     * @param fontUrl
     * @param complete [可选] 默认值=null 加载完成回调
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     */
    AssetManager.preloadFont = function (fontUrl, complete, syncCallbackWhenAssetExist) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (!fontUrl) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(1));
            return;
        }
        var arr = fontUrl.split("/");
        var fullname = arr.pop();
        var arr2 = fullname.split(".");
        var ext = arr2.pop();
        var name = arr2.join(".");
        var fontFace = FontLoadManager.getFontByName(name);
        if (fontFace) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(1));
        }
        else {
            var font = { name: name, path: fontUrl, fonttype: ext, size: 0 };
            FontLoadManager.loadFontFile([font], complete);
        }
    };
    /**
     * 资源引用计数 url:引用计数
     */
    AssetManager.assetCountMap = {};
    /**
     * Graphics 切片图片资源集
     */
    AssetManager.imageAssets = {};
    /**
     * 释放资源的间隔ms（当引用计数为0时会延迟清理资源，因为最近可能还会频繁用到）
     */
    AssetManager.disposeInterval = 60000; // 60000
    /**
     * 预加载缓存的UI
     */
    AssetManager.preUIs = [];
    /**
     * 缓存事件页 [commandPage.id] = [dialogCache, avatarCache, imageCache, audioCache, uiCache, animationCache, standAvatar]
     */
    AssetManager.commandPerloadCache = [];
    return AssetManager;
}());
/**
 * // --
 * 动画层可以添加到底层/高层或指定层
 * UI只能当做sceneObject加入场上或者添加到默认最高层（以及指定层）
 *
 * 【层次】
 * -- 场景 sceneLayer
 *     - 自定义层
 *         -- 1~N 预设层
 *         -- 影子层
 *         -- 动画底层
 *         -- 对象底层
 *         -- 对象层
 *         -- M~K 预设层
 *     - 最高层角色
 *     - 最高层动画层
 *     - 雾层
 *     - 天气层
 * -- 图片 imageLayer
 * -- UI uiLayer
 *
 * Created by 黑暗之神KDS on 2018-07-22 17:29:13.
 */
var ClientScene = /** @class */ (function (_super) {
    __extends(ClientScene, _super);
    /**
     * 构造函数
     */
    function ClientScene() {
        var _this = _super.call(this) || this;
        /**
         * 玩家集
         */
        _this.players = [];
        /**
         * 游戏对象列表
         */
        _this.sceneObjects = [];
        /**
         * 预先设定层组(地图编辑器中预设的)
         */
        _this.settingLayers = [];
        /**
         * 层次显示对象
         */
        _this.layers = [];
        /**
         * 镜头
         */
        _this.camera = new Camera();
        if (typeof GameSprite == "undefined")
            return _this;
        _this.displayObject = new GameSprite();
        _this.displayObjectView = new GameSprite();
        _this.displayObject.addChild(_this.displayObjectView);
        _this.camera.viewPort.setTo(0, 0, Config.WINDOW_WIDTH, Config.WINDOW_HEIGHT);
        if (typeof Game == "undefined")
            return _this;
        EventUtils.addEventListener(Game, Game.EVENT_PAUSE_CHANGE, Callback.New(_this.onPauseChange, _this));
        return _this;
    }
    //------------------------------------------------------------------------------------------------------
    // 基本
    //------------------------------------------------------------------------------------------------------
    /**
     * 创建场景，会根据预设的实现类来创建对应的实例场景
     * @param sceneID 场景ID
     * @param onBaseDataLoaded [可选] 默认值=null 当基础数据加载完毕时 onBaseDataLoaded(scene)
     * @param onLoaded [可选] 默认值=null onLoaded(scene)
     * @param syncCallbackWhenAssetExist [可选] 默认值=false 当资源存在时同步回调，否则需要等待一帧（异步回调）
     * @return [ClientScene]
     */
    ClientScene.createScene = function (sceneID, onBaseDataLoaded, onLoaded, syncCallbackWhenAssetExist) {
        var _this = this;
        if (onBaseDataLoaded === void 0) { onBaseDataLoaded = null; }
        if (onLoaded === void 0) { onLoaded = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        AssetManager.loadJson("asset/json/scene/data/scene" + sceneID + ".json", Callback.New(function (mapData) {
            if (!mapData) {
                throw ("error:场景不存在");
            }
            var cls = mapData.clientInstanceClassName;
            var classImpl = globalThis[cls];
            var scene = (classImpl && classImpl.prototype instanceof ClientScene) ? new classImpl : new ClientScene();
            scene.isSetScene = true;
            scene.id = sceneID;
            scene.parse(mapData, Common.gameData);
            // Scene.parse(mapData, scene, Common.gameData);
            if (scene.createSceneLoadExt) {
                scene.createSceneLoadExt(onBaseDataLoadedFunction);
            }
            else {
                onBaseDataLoadedFunction.apply(_this);
            }
            function onBaseDataLoadedFunction() {
                scene.event(ClientScene.BASE_DATA_LOADED, [scene]);
                onBaseDataLoaded && onBaseDataLoaded.runWith([scene]);
                scene.install(Callback.New(function () {
                    scene.event(EventObject.LOADED, [scene]);
                    onLoaded && onLoaded.runWith([scene]);
                }, scene));
            }
        }, this), syncCallbackWhenAssetExist);
    };
    /**
     * 清理当前的场景
     */
    ClientScene.prototype.dispose = function () {
        if (!this.isDisposed) {
            // 派发释放事件
            this.event(GameSprite.ON_DISPOSE);
            this.isDisposed = true;
            // 卸载JSON
            AssetManager.disposeJson("asset/json/scene/data/scene" + this.id + ".json");
            // 停止渲染
            this.stopRender();
            // 移除自身
            this.displayObject.removeSelf();
            // 销毁所有当前的图层
            for (var i in this.layers) {
                this.layers[i].dispose();
            }
            // 销毁所有场景对象
            for (var i in this.sceneObjects) {
                var so = this.sceneObjects[i];
                if (so)
                    so.dispose();
            }
            // 销毁自身
            this.displayObject.dispose();
            // sceneobject列表数据置空
            this.sceneObjects.length = 0;
        }
    };
    /**
     * 安装：根据配置数据安装起场景来
     */
    ClientScene.prototype.install = function (onFin) {
        // clear
        this.settingLayers.length = 0;
        var oldLayers = this.layers.concat();
        for (var i = 0; i < oldLayers.length; i++) {
            oldLayers[i].dispose();
        }
        this.layers.length = this.settingLayers.length = 0;
        // 设置触摸区域
        if (!Config.EDIT_MODE)
            this.displayObject.hitArea = new Rectangle(-this.width, -this.height, this.width * 2, this.height * 2);
        // 安装层次：画面层次与场景对象层
        for (var i = 0; i < this.LayerDatas.length; i++) {
            var layerData = this.LayerDatas[i];
            var layer = new ClientSceneLayer(this);
            // 非对象层才安装图层属性
            if (!layerData.p) {
                new SyncTask(ClientScene.TASK_INSTALL, function () { });
                layer.install(layerData, Callback.New(SyncTask.taskOver, SyncTask, [ClientScene.TASK_INSTALL]));
            }
            this.addLayer(layer);
            this.settingLayers.push(layer);
            if (layerData.p)
                this.sceneObjectLayer = layer;
        }
        var sceneObjectLayerIndex = this.layers.indexOf(this.sceneObjectLayer);
        // 添加层：对象底层
        this.sceneObjectLowLayer = new ClientSceneLayer(this);
        this.addLayerAt(this.sceneObjectLowLayer, sceneObjectLayerIndex);
        // 添加层：动画底层
        this.animationLowLayer = new ClientSceneLayer(this);
        this.addLayerAt(this.animationLowLayer, sceneObjectLayerIndex);
        // 添加层：影子层
        this.shadowLayer = new ClientSceneLayer(this);
        this.addLayerAt(this.shadowLayer, sceneObjectLayerIndex);
        // 追加的层次：角色高层、动画高层、雾层、天气层
        var layerArr = ["sceneObjectHighLayer", "animationHighLayer", "fogLayer", "weaterLayer"];
        for (var s in layerArr) {
            layer = this[layerArr[s]] = new ClientSceneLayer(this);
            this.addLayer(layer);
        }
        // 深度自动更新
        this.sceneObjectLowLayer.isChangeChildZOrder = true;
        this.sceneObjectLayer.isChangeChildZOrder = true;
        this.sceneObjectHighLayer.isChangeChildZOrder = true;
        // 刷新相机
        if (this.camera.viewPort.width > this.width) {
            this.camera.viewPort.width = this.width;
        }
        if (this.camera.viewPort.height > this.height) {
            this.camera.viewPort.height = this.height;
        }
        // 任务结束
        new SyncTask(ClientScene.TASK_INSTALL, function () {
            onFin.run();
            SyncTask.taskOver(ClientScene.TASK_INSTALL);
        });
    };
    //------------------------------------------------------------------------------------------------------
    // 图层
    //------------------------------------------------------------------------------------------------------
    /**
     * 刷新场景系统层
     */
    ClientScene.prototype.refreshSceneSystemLayers = function () {
        // clear
        this.layers.length = 0;
        this.displayObjectView.removeChildren();
        // 安装层次：画面层次与场景对象层
        for (var i = 0; i < this.settingLayers.length; i++) {
            var layer = this.settingLayers[i];
            this.addLayer(layer);
        }
        var sceneObjectLayerIndex = this.layers.indexOf(this.sceneObjectLayer);
        // 添加层：对象底层
        this.addLayerAt(this.sceneObjectLowLayer, sceneObjectLayerIndex);
        // 添加层：动画底层
        this.addLayerAt(this.animationLowLayer, sceneObjectLayerIndex);
        // 添加层：影子层
        this.addLayerAt(this.shadowLayer, sceneObjectLayerIndex);
        // 追加的层次：场景对象高层、动画高层、雾层、天气层
        var layerArr = ["sceneObjectHighLayer", "animationHighLayer", "fogLayer", "weaterLayer"];
        for (var s in layerArr) {
            layer = this[layerArr[s]];
            this.addLayer(layer);
        }
    };
    /**
     * 添加显示层
     * @param layer
     */
    ClientScene.prototype.addLayer = function (layer) {
        this.displayObjectView.addChild(layer);
        this.layers.push(layer);
    };
    /**
     * 添加显示层到指定层
     * @param layer
     * @param index
     */
    ClientScene.prototype.addLayerAt = function (layer, index) {
        this.displayObjectView.addChildAt(layer, index);
        this.layers.splice(index, 0, layer);
    };
    /**
     * 移除显示层
     * @param layer
     */
    ClientScene.prototype.removeLayer = function (layer) {
        this.displayObjectView.removeChild(layer);
        this.layers.splice(this.layers.indexOf(layer), 1);
    };
    /**
     * 指定移除某一层
     * @param index
     */
    ClientScene.prototype.removeLayerAt = function (index) {
        this.displayObjectView.removeChildAt(index);
        this.layers.splice(index, 1);
    };
    /**
     * 设置层
     */
    ClientScene.prototype.setLayerIndex = function (layer, index) {
        this.displayObjectView.setChildIndex(layer, index);
        ArrayUtils.setIndex(this.layers, layer, index);
    };
    /**
     * 获取当前的图层总数
     * @return [number]
     */
    ClientScene.prototype.getLayerLength = function () {
        return this.layers.length;
    };
    /**
     * 获取层，根据实际层次
     */
    ClientScene.prototype.getLayer = function (index) {
        return this.layers[index];
    };
    /**
     * 获取层，根据预设层次
     * @param id 对应地图层预览中的序号
     */
    ClientScene.prototype.getLayerByPreset = function (id) {
        return ArrayUtils.get(this.settingLayers, id - 1);
    };
    /**
     * 获取层根据名称
     * @param name 图层的名称
     * @return [ClientSceneLayer]
     */
    ClientScene.prototype.getLayerByName = function (name) {
        return ArrayUtils.matchAttributes(this.settingLayers, { name: name }, true)[0];
    };
    //------------------------------------------------------------------------------------------------------
    // 场景对象
    //------------------------------------------------------------------------------------------------------
    /**
     * 有场景对象加入至场景上
     * @param soData 场景对象数据
     * @param isEntity 是否是实体对象而非数据，如果是数据则会根据数据重新创建一个实体对象
     * @param useModelClass 是否使用场景对象模型的实现类
     * @return [ClientSceneObject] 添加的场景对象实例
     */
    ClientScene.prototype.addSceneObject = function (soData, isEntity, useModelClass) {
        if (isEntity === void 0) { isEntity = false; }
        if (useModelClass === void 0) { useModelClass = false; }
        // 存在则忽略
        var lastSo = this.sceneObjects[soData.index];
        if (lastSo && lastSo != soData) {
            return null;
        }
        // 生成客户端的游戏对象
        var soc;
        if (isEntity) {
            soc = soData;
        }
        else {
            if (useModelClass) {
                if (Config.useNewSceneObjectModel) {
                    var fixModelData = Common.sceneObjectModelList.data[0];
                }
                else {
                    var fixModelData = Common.sceneObjectModelList.data[soData.modelID];
                }
                if (fixModelData) {
                    var cls;
                    if (fixModelData.clientInstanceClassName && window[fixModelData.clientInstanceClassName]) {
                        cls = window[fixModelData.clientInstanceClassName];
                    }
                    else {
                        cls = SceneObjectModelData.sceneObjectClass[soData.modelID];
                    }
                    if (!cls)
                        cls = ClientSceneObject;
                    soc = new cls(soData, this);
                }
                else {
                    soc = new ClientSceneObject(soData, this);
                }
            }
            else {
                soc = new ClientSceneObject(soData, this);
            }
        }
        // 是否需要真正添加到场景显示列表上
        //（如果存在soData.persetData的话根据其状态页刷新后的状态，如不能出现在场景上则不添加）
        var needInScene = soData.persetData ? soc.inScene : true;
        // 添加到场景对象记录列表中
        this.sceneObjects[soData.index] = soc;
        soc.inScene = needInScene;
        soc.scene = this;
        if (needInScene) {
            // 显示对象添加
            if (soc.layerLevel == 0) {
                this.sceneObjectLowLayer.addChild(soc.root);
                this.sceneObjectLowLayer.updateChildZOrder();
            }
            else if (soc.layerLevel == 1) {
                this.sceneObjectLayer.addChild(soc.root);
                this.sceneObjectLayer.updateChildZOrder();
            }
            else {
                this.sceneObjectHighLayer.addChild(soc.root);
                this.sceneObjectHighLayer.updateChildZOrder();
            }
            this.shadowLayer.addChild(soc.shadow);
            // 刷新显示对象处于新的格子状态
            Callback.CallLaterBeforeRender(soc.refreshCoordinate, soc);
        }
        if (Game.pause)
            soc.stopRender(true);
        return soc;
    };
    /**
     * 有场景对象从场景上移除
     * @param so 场景对象数据
     * @param removeFromList 是否从列表中移除
     * @return [ClientSceneObject] 移除的场景对象实例
     */
    ClientScene.prototype.removeSceneObject = function (so, removeFromList) {
        if (removeFromList === void 0) { removeFromList = true; }
        // 清空数据
        var soc = this.sceneObjects[so.index];
        if (removeFromList)
            this.sceneObjects[so.index] = null;
        // 从舞台上移除
        if (soc) {
            // 清理所有其他场景对象与他关联的触发器
            if (removeFromList && !Config.EDIT_MODE && !Config.BEHAVIOR_EDIT_MODE && Config.SINGLE_PLAYER_CORE) {
                for (var i = 0; i < Game.currentScene.sceneObjects.length; i++) {
                    var tSo = Game.currentScene.sceneObjects[i];
                    if (!tSo || tSo == soc)
                        continue;
                    for (var s1 in tSo.triggerLines) {
                        var tSoTrigger = tSo.triggerLines[s1];
                        if (tSoTrigger.executor == soc || tSoTrigger.trigger == soc) {
                            tSoTrigger.dispose();
                        }
                    }
                    for (var s2 in tSo.triggerSingleLines) {
                        var tSoTrigger = tSo.triggerSingleLines[s2];
                        if (tSoTrigger && (tSoTrigger.executor == soc || tSoTrigger.trigger == soc)) {
                            tSoTrigger.dispose();
                            delete tSo.triggerSingleLines[s2];
                        }
                    }
                }
            }
            // 显示对象处理
            soc.root.removeSelf();
            soc.shadow.removeSelf();
            soc.inScene = false;
        }
        return soc;
    };
    //------------------------------------------------------------------------------------------------------
    // 单机专用
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取场景预设的场景对象数据（不包含出生点）
     * @return [SceneObject]
     */
    ClientScene.prototype.getPresetSceneObjectDatas = function () {
        var sceneData = Game.data.sceneList.data[this.id];
        var sceneObjDatas = sceneData.sceneObjectData;
        var sceneObjects = sceneObjDatas.sceneObjects;
        return sceneObjects;
    };
    /**
     * 添加新对象，以默认值
     * @param modelID 模型ID
     * @param presetSceneObjectData [可选] 默认值=null 预设数据，以便生成时使用该数据作为参考，如 {x:500,y:500}
     * @param soSwitchs 场景对象的开关
     * @param recordData 恢复的数据，如来自存档，会先切换至当前应显示的状态页然后恢复对应的数据。（追加模块数据 ___gcModules[moduleIndex] = {}; // 包含模块id）
     * @return [ClientSceneObject]
     */
    ClientScene.prototype.addNewSceneObject = function (modelID, presetSceneObjectData, soSwitchs, recordData) {
        if (presetSceneObjectData === void 0) { presetSceneObjectData = null; }
        if (soSwitchs === void 0) { soSwitchs = null; }
        if (recordData === void 0) { recordData = null; }
        if (!Game.currentScene)
            return;
        var modelData = Game.data.sceneObjectModelList.data[modelID];
        if (modelData) {
            var fixModelData = Config.useNewSceneObjectModel ? Game.data.sceneObjectModelList.data[0] : modelData;
            // 序列化自定义属性，默认值
            var presetCustomAttrs = CustomAttributeSetting.formatCustomData(null, fixModelData.varAttributes);
            // 安装
            var so = new SceneObject();
            if (presetSceneObjectData)
                ObjectUtils.clone(presetSceneObjectData, so);
            SceneObject.installCustomData(so, presetCustomAttrs);
            // 索引
            so.index = ArrayUtils.getNullPosition(Game.currentScene.sceneObjects);
            // 预设数据
            var eventData = {
                condition: [],
                customCommands: []
            };
            var sceneData = Game.data.sceneList.data[Game.currentScene.id];
            // 根据原型预设给到默认的模块数据安装
            if (Config.useNewSceneObjectModel) {
                so.moduleIDs = modelData.presetModules.concat();
                var modulesCustomAttribute = [];
                for (var i = 0; i < so.moduleIDs.length; i++) {
                    var moduleID = so.moduleIDs[i];
                    var moduleData = Game.data.sceneObjectModuleList.data[moduleID];
                    if (moduleData) {
                        // -- 自定义属性typeValue格式
                        modulesCustomAttribute.push(CustomAttributeSetting.formatCustomData(null, moduleData.varAttributes));
                    }
                    else {
                        so.moduleIDs.splice(i, 1);
                    }
                }
            }
            so.persetData = {
                sceneObjectData: sceneData.sceneObjectData,
                fromSceneObjectindex: Game.player.sceneObject.index,
                soData: so,
                customAttr: presetCustomAttrs,
                eventData: eventData,
                soSwitchs: soSwitchs,
                soIndex: so.index,
                recordData: recordData,
                moduleCustomAttrs: modulesCustomAttribute
            };
            var soc = Game.currentScene.addSceneObject(so, false, true);
            soc.allowAutoSave = true;
            soc.persetData = null;
            return soc;
        }
    };
    /**
     * 获取场景对象数据
     * @param fromSceneID
     * @param fromSceneObjectindex
     * @param isCopy [可选] 默认值=true
     * @param soSwitchs [可选] 默认值=null 如果存在的话则使用这些开关，否则使用对应的fromSceneID-fromSceneObjectindex的开关（isCopy为false时）
     * @param recordData [可选] 默认值=null 恢复读档数据
     * @return [ServerSceneObject]
     */
    ClientScene.prototype.addSceneObjectFromClone = function (fromSceneID, fromSceneObjectindex, isCopy, presetSceneObjectData, soSwitchs, recordData) {
        if (isCopy === void 0) { isCopy = true; }
        if (presetSceneObjectData === void 0) { presetSceneObjectData = null; }
        if (soSwitchs === void 0) { soSwitchs = null; }
        if (recordData === void 0) { recordData = null; }
        if (fromSceneID < 0 || fromSceneObjectindex < 0)
            return;
        var sceneData = Game.data.sceneList.data[fromSceneID];
        if (!sceneData)
            return null;
        var globalSoData = sceneData.sceneObjectData.sceneObjects[fromSceneObjectindex];
        if (!globalSoData)
            return null;
        var globalSoDataClone = SceneObject.__gcClone(globalSoData);
        // 兼容旧的版本
        if (typeof presetSceneObjectData == "boolean")
            presetSceneObjectData = null;
        // 有预设数据的场合
        if (presetSceneObjectData) {
            ObjectUtils.clone(presetSceneObjectData, globalSoDataClone);
        }
        var soData = new SceneObject();
        for (var s in SceneObject.statusCommonAttributes) {
            soData[s] = globalSoDataClone[s];
        }
        var customAttr = sceneData.sceneObjectData.customAttributes[fromSceneObjectindex];
        var eventData = sceneData.sceneObjectData.events[fromSceneObjectindex];
        // 遍历其模块，生成模块默认值
        if (Config.useNewSceneObjectModel) {
            var modulesCustomAttribute = sceneData.sceneObjectData.modulesCustomAttributes[fromSceneObjectindex];
        }
        // 如果存在存档数据的话应该使用存档数据中的soIndex，如果该位置已存在的话再创建新的位置
        var toIndex = recordData ? recordData.index : fromSceneObjectindex;
        if (Game.currentScene.sceneObjects[toIndex]) {
            soData.index = ArrayUtils.getNullPosition(Game.currentScene.sceneObjects);
        }
        else {
            soData.index = toIndex;
        }
        soData["_isCopy"] = isCopy;
        // 设置状态页需要的数据
        if (!isCopy && !soSwitchs) {
            soSwitchs = SinglePlayerGame.getSceneObjectSwitch(fromSceneID, fromSceneObjectindex);
        }
        soData.persetData = {
            sceneObjectData: sceneData.sceneObjectData,
            fromSceneObjectindex: fromSceneObjectindex,
            soData: globalSoDataClone,
            customAttr: customAttr,
            eventData: eventData,
            soSwitchs: soSwitchs,
            soIndex: soData.index,
            recordData: recordData,
            moduleCustomAttrs: modulesCustomAttribute
        };
        // 创建场景对象
        var soc = this.addSceneObject(soData, false, true);
        soc.allowAutoSave = true;
        soc.persetData = null;
        soc["_isCopy"] = isCopy;
        // 记录复制的来源
        soc["_copyFrom"] = { sceneID: fromSceneID, sceneObjectIndex: fromSceneObjectindex };
        return soc;
    };
    //------------------------------------------------------------------------------------------------------
    // 【网络版专用】玩家
    //------------------------------------------------------------------------------------------------------
    /**
     * 添加玩家
     * @param player
     */
    ClientScene.prototype.addPlayer = function (player) {
        if (this.players.indexOf(player) == -1)
            this.players.push(player);
    };
    /**
     * 移除玩家
     * @param player
     */
    ClientScene.prototype.removePlayer = function (player) {
        ArrayUtils.remove(this.players, player);
    };
    Object.defineProperty(ClientScene.prototype, "localX", {
        //------------------------------------------------------------------------------------------------------
        // 获取数据
        //------------------------------------------------------------------------------------------------------
        /**
         * 获取鼠标X所在的场景位置
         */
        get: function () {
            if (!this.displayObjectView.scrollRect)
                return 0;
            return this.displayObjectView.mouseX - (this.displayObjectView.scrollRect.x / this.displayObjectView.scaleX) + this.displayObjectView.scrollRect.x;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ClientScene.prototype, "localY", {
        /**
         * 获取相对位置
         */
        get: function () {
            if (!this.displayObjectView.scrollRect)
                return 0;
            return this.displayObjectView.mouseY - (this.displayObjectView.scrollRect.y / this.displayObjectView.scaleY) + this.displayObjectView.scrollRect.y;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ClientScene.prototype, "globalPos", {
        /**
         * 获取鼠标绝对位置（相对于舞台）
         */
        get: function () {
            return this.getGlobalPos(this.displayObjectView.mouseX, this.displayObjectView.mouseY);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 获取绝对鼠标位置（相对于舞台）根据指定的场景位置
     * @param localX
     * @param localY
     * @return [Point]
     */
    ClientScene.prototype.getGlobalPos = function (localX, localY) {
        var sceneP = new Point(localX, localY);
        var globalP = this.displayObjectView.localToGlobal(sceneP);
        return globalP;
    };
    //------------------------------------------------------------------------------------------------------
    // 镜头与显示
    //------------------------------------------------------------------------------------------------------
    ClientScene.prototype.onPauseChange = function () {
        // 遍历全部对象停止渲染和恢复渲染(行走图播放、动画播放)
        for (var i = 0; i < this.sceneObjects.length; i++) {
            var so = this.sceneObjects[i];
            if (so) {
                Game.pause ? so.stopRender(true) : so.recoveryRender(true);
            }
        }
    };
    /**
    * 设置视窗位置和大小
    * @rect 要设置的视窗位置和大小
    * @isLimit 是否限制屏幕显示不会超出场景的边缘
    */
    ClientScene.prototype.setViewPort = function (isLimit) {
        if (isLimit === void 0) { isLimit = true; }
        this.displayObject.scaleX = this.camera.scaleX;
        this.displayObject.scaleY = this.camera.scaleY;
        var rect = this.camera.viewPort;
        // 缩放显示在中间
        if (this.displayObject.scaleX != 1 || this.displayObject.scaleY != 1) {
            rect = rect.clone();
            var sw = (1 / this.displayObject.scaleX) * rect.width - rect.width;
            var sh = (1 / this.displayObject.scaleY) * rect.height - rect.height;
            this["__sw"] = sw;
            this["__sh"] = sh;
            rect.x -= sw * 0.5;
            rect.y -= sh * 0.5;
            rect.width += sw;
            rect.height += sh;
        }
        if ((isLimit && !this.editorMode) || this.forceLimitView) {
            if (rect.x > this.width - rect.width)
                rect.x = this.width - rect.width;
            if (rect.y > this.height - rect.height)
                rect.y = this.height - rect.height;
            if (rect.x < 0)
                rect.x = 0;
            if (rect.y < 0)
                rect.y = 0;
        }
        // 追加偏移量
        var cloneRect;
        if (this.camera.offsetX != 0 || this.camera.offsetY != 0) {
            rect = rect.clone();
            rect.x += this.camera.offsetX;
            rect.y += this.camera.offsetY;
            cloneRect = true;
        }
        // 镜头旋转:旋转外层显示对象，让外层显示对象居中
        if (this.camera.rotation == 0) {
            this.displayObjectView.x = this.displayObjectView.y = this.displayObject.x = this.displayObject.y = 0;
        }
        else {
            var sx = this.displayObject.scaleX;
            var sy = this.displayObject.scaleY;
            var dx = (rect.width * (1 - sx) * 0.5);
            var dy = (rect.height * (1 - sy) * 0.5);
            var hw = rect.width * 0.5;
            var hh = rect.height * 0.5;
            this.displayObjectView.x = -rect.width;
            this.displayObjectView.y = -rect.height;
            this.displayObject.x = hw - dx;
            this.displayObject.y = hh - dy;
            if (!cloneRect)
                rect = rect.clone();
            rect.x -= hw;
            rect.y -= hh;
            rect.width *= 2;
            rect.height *= 2;
        }
        this.displayObjectView.scrollRect = rect;
        this.displayObject.rotation = this.camera.rotation;
        // -- 遍历子层：设置子层的视口
        var len = this.displayObjectView.numChildren;
        for (var i = 0; i < len; i++) {
            var layer = this.displayObjectView.getChildAt(i);
            layer.setViewPort(rect);
        }
    };
    /**
     * 开始渲染
     */
    ClientScene.prototype.startRender = function () {
        this.stopRender();
        os.add_ENTERFRAME(this.onRender, this);
    };
    /**
     * 停止渲染
     * @param LayerMoveToZero 是否图层移动归零，是的话就归零，否则推进移动一帧
     */
    ClientScene.prototype.stopRender = function (LayerMoveToZero) {
        if (LayerMoveToZero === void 0) { LayerMoveToZero = false; }
        os.remove_ENTERFRAME(this.onRender, this);
        if (LayerMoveToZero) {
            for (var i = 0; i < this.layers.length; i++) {
                var layer = this.layers[i];
                layer.onRender(LayerMoveToZero);
            }
        }
    };
    /**
     * 刷新镜头
     */
    ClientScene.prototype.updateCamera = function () {
        if (this.camera.sceneObject) {
            this.camera.viewPort.x = Math.floor(this.camera.sceneObject.x - this.camera.viewPort.width * 0.5);
            this.camera.viewPort.y = Math.floor(this.camera.sceneObject.y - this.camera.viewPort.height * 0.5);
        }
        this.setViewPort(true);
    };
    /**
     * 渲染
     */
    ClientScene.prototype.onRender = function () {
        var now = Game.now;
        // 如果暂停状态下，则不进行刷新（所以镜头、图层、对象、对象行为等都不再刷新）
        if (Game.pause)
            return;
        // 刷新镜头
        this.updateCamera();
        // 刷新层
        for (var i = 0; i < this.layers.length; i++) {
            var layer = this.layers[i];
            layer.onRender();
        }
        // 刷新场景对象
        for (var s in this.sceneObjects) {
            var soc = this.sceneObjects[s];
            if (!soc)
                continue;
            soc.update(now);
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 事件
    //------------------------------------------------------------------------------------------------------
    ClientScene.prototype.hasListener = function (type) { return this.displayObject.hasListener.apply(this.displayObject, arguments); };
    ;
    ClientScene.prototype.event = function (type, data) { return this.displayObject.event.apply(this.displayObject, arguments); };
    ;
    ClientScene.prototype.on = function (type, caller, listener, args) { return this.displayObject.on.apply(this.displayObject, arguments); };
    ;
    ClientScene.prototype.once = function (type, caller, listener, args) { return this.displayObject.once.apply(this.displayObject, arguments); };
    ;
    ClientScene.prototype.off = function (type, caller, listener, onceOnly) { return this.displayObject.off.apply(this.displayObject, arguments); };
    ;
    ClientScene.prototype.offAll = function (type) { return this.displayObject.offAll.apply(this, arguments); };
    ;
    /**
     * 事件：基础数据加载完毕（可用于快速切入场景，而后再加载相关资源，flash页游时代几乎都是这样做的）
     * onBaseDataLoaded(scene)
     */
    ClientScene.BASE_DATA_LOADED = "ClientScene_BASE_DATA_LOADED";
    /**
     * 事件：进入新的场景 onInNewScene(sceneID:number,state:number) state:0-切换场景 1-新游戏 2-读取存档
     */
    ClientScene.EVENT_IN_NEW_SCENE = "ClientSceneEVENT_IN_NEW_SCENE";
    /**
     * 任务
     */
    ClientScene.TASK_INSTALL = "ClientScene_TASK_INSTALL";
    return ClientScene;
}(Scene));
/**
 * 绑定get/set属性
 */
ObjectUtils.reDefineGetSet("ClientScene.prototype", {
    id: function (v) {
        var _this = this;
        if (!this.isSetScene) {
            this.isSetScene = true;
            if (!Config.EDIT_MODE) {
                AssetManager.loadJson("asset/json/scene/data/scene" + this.id + ".json", Callback.New(function (mapData) {
                    if (!mapData)
                        return;
                    _this.parse(mapData, Common.gameData);
                    if (_this.createSceneLoadExt) {
                        _this.createSceneLoadExt(onBaseDataLoadedFunction);
                    }
                    else {
                        onBaseDataLoadedFunction.apply(_this);
                    }
                    function onBaseDataLoadedFunction() {
                        var _this = this;
                        this.event(ClientScene.BASE_DATA_LOADED, [this]);
                        this.install(Callback.New(function () {
                            _this.event(EventObject.LOADED, [_this]);
                        }, this));
                    }
                }, this));
            }
        }
    }
});
/**
 * 场景对象
 * 【显示层次】
 * -- 动画层：底层
 * -- 自定义底层（含Avatar）
 * -- 动画层：高层
 * -- 自定义高层
 *
 * *需要修改：
 * -- update 统一，刷新avatar和动画？
 *
 * Created by 黑暗之神KDS on 2018-07-24 02:06:28.
 */
var ClientSceneObject = /** @class */ (function (_super) {
    __extends(ClientSceneObject, _super);
    // static createModule(moduleID: number, soe: SceneObjectEntity, presetData: any = null): SceneObjectModule {
    //     if (soe instanceof ClientSceneObject) {
    //         var soModule = super.createModule(moduleID, soe, presetData);
    //         if (soModule) {
    //             // 修正显示对象
    //         }
    //         return soModule;
    //     }
    // }
    //------------------------------------------------------------------------------------------------------
    // 初始化
    //------------------------------------------------------------------------------------------------------
    function ClientSceneObject(soData, scene) {
        if (scene === void 0) { scene = null; }
        var _this = _super.call(this, soData ? soData.persetData : null) || this;
        //------------------------------------------------------------------------------------------------------
        // 动画
        //------------------------------------------------------------------------------------------------------
        _this.___animations = [];
        _this.scene = scene;
        if (!soData)
            return _this;
        // 没有预设状态页数据的情况：运行时可能会预设（通过clone），而编辑器没有
        if (!soData.persetData) {
            // 初始化
            _this.____beforeInstallAttributeInit();
            // 设置初始的数据
            if (soData) {
                if (Config.EDIT_MODE) {
                    ObjectUtils.clone(soData, _this);
                    for (var i in SceneObject.compoundAttributes) {
                        var attrName = SceneObject.compoundAttributes[i];
                        _this[attrName] = ObjectUtils.depthClone(soData[attrName]);
                    }
                }
                else {
                    ObjectUtils.clone(soData, _this);
                }
            }
            // 安装数据
            _this.____afterInstallAttributeInit();
            // 如果是玩家的场景对象需要安装模块
            if (Config.useNewSceneObjectModel) {
                if (!Config.EDIT_MODE && soData == Game.player.data.sceneObject) {
                    if (!_this.moduleIDs)
                        _this.moduleIDs = [];
                    if (!_this.moduleDisplayList)
                        _this.moduleDisplayList = [];
                    var moduleIDs = _this.moduleIDs.concat();
                    var moduleDisplayList = _this.moduleDisplayList.concat();
                    var presetData = null;
                    if (Game.player.data.sceneObject.___gcRestoreModules) {
                        presetData = Game.player.data.sceneObject.___gcRestoreModules;
                        delete Game.player.data.sceneObject.___gcRestoreModules;
                    }
                    _this.installModulesByTypeValue(moduleIDs, moduleDisplayList, Config.BORN.bornModulesCustomAttribute, presetData);
                }
            }
            // 刷新显示层次
            _this.refreshDisplayListOrder();
        }
        return _this;
    }
    //------------------------------------------------------------------------------------------------------
    //  静态
    //------------------------------------------------------------------------------------------------------
    /**
     * 创建显示对象根据预设显示数据
     */
    ClientSceneObject.createDisplayObjectByPreLayer = function (type, id) {
        if (type == 2 || type == 3) {
            return GameUI.load(id, true);
        }
        else if (type == 4 || type == 5) {
            var animation = new GCAnimation();
            if (Config.EDIT_MODE)
                animation.silentMode = true;
            animation.id = id;
            animation.loop = true;
            animation.showHitEffect = true;
            animation.gotoAndPlay();
            return animation;
        }
    };
    /**
     * 初始化层
     */
    ClientSceneObject.prototype.____beforeInstallAttributeInit = function () {
        // 类
        // 根容器
        this.root = new GameSprite();
        this.root.name = "__SOC";
        this.root["__SOC"] = this;
        // 层
        var layerNames = {
            animationLowLayer: GameSprite,
            customLayer: GameSprite,
            animationHighLayer: GameSprite,
            customHighLayer: GameSprite,
            systemUILayer: Sprite
        };
        for (var i in layerNames) {
            var layer = this[i] = new layerNames[i]();
            this.root.addChild(layer);
        }
        // avatar
        this.avatarContainer = new GameSprite();
        this.avatar = new Avatar();
        this.avatarContainer.addChild(this.avatar);
        // this.customLayer.addChild(this.avatar);
        // 影子
        this.shadow = new Sprite();
        //    this.avatarID = 2;
    };
    /**
     * 安装
     */
    ClientSceneObject.prototype.____afterInstallAttributeInit = function () {
        // 影子
        this.drawShadow();
        this.refreshCommonDisplayList();
        this.avatar.installMaterialData(this.materialData);
    };
    /**
     * 更新显示列表
     * -- 运行时：初始化、切换状态页
     * -- 编辑器：更新了动画、界面、修改属性
     */
    ClientSceneObject.prototype.refreshCommonDisplayList = function () {
        // 清理
        this.clearCommonDisplayList();
        // 获取数据
        var modelData = Game.data.sceneObjectModelList.data[this.modelID];
        var fixModelData = Config.useNewSceneObjectModel ? Game.data.sceneObjectModelList.data[0] : modelData;
        if (!fixModelData || !modelData)
            return;
        // 刷新
        var layer = this.customLayer;
        for (var i = 0; i < fixModelData.preLayer.length; i++) {
            var preLayer = fixModelData.preLayer[i];
            if (preLayer.type != 1 && (preLayer.inEditorShowMode == 1 && Config.EDIT_MODE) || (preLayer.inEditorShowMode == 2 && !Config.EDIT_MODE))
                continue;
            var newLayer = null;
            var needRecordVarName = true;
            switch (preLayer.type) {
                case 1: // 行走图
                    // -- 如果预览不是行走图的话不显示问号行走图
                    if (Config.EDIT_MODE) {
                        if (modelData.editorPreview && modelData.editorPreview.type != 1) {
                            needRecordVarName = false;
                            break;
                        }
                    }
                    // -- 剔除掉模块中的行走图，仅供层级参考
                    newLayer = this.avatar;
                    layer.addChild(this.avatarContainer);
                    layer = this.customHighLayer;
                    needRecordVarName = false;
                    break;
                case 2: // 固定界面
                    newLayer = ClientSceneObject.createDisplayObjectByPreLayer(preLayer.type, preLayer.id);
                    if (newLayer)
                        layer.addChild(newLayer);
                    break;
                case 3: // 选定的界面
                    var displayListInfo = this.displayList[preLayer.varName];
                    if (displayListInfo) {
                        newLayer = ClientSceneObject.createDisplayObjectByPreLayer(preLayer.type, displayListInfo.id);
                        if (newLayer)
                            layer.addChild(newLayer);
                    }
                    break;
                case 4: // 固定的动画
                    var animation = newLayer = ClientSceneObject.createDisplayObjectByPreLayer(preLayer.type, preLayer.id);
                    animation.sceneObject = this;
                    layer.addChild(animation);
                    break;
                case 5: // 选定的动画
                    var displayListInfo = this.displayList[preLayer.varName];
                    if (displayListInfo) {
                        var animation = newLayer = ClientSceneObject.createDisplayObjectByPreLayer(preLayer.type, displayListInfo.id);
                        animation.sceneObject = this;
                        layer.addChild(animation);
                    }
                    break;
            }
            // 安装的位置 0-旧模式/新的公共模块 1~N-新的模块
            if (needRecordVarName) {
                this[preLayer.varName] = newLayer;
                this.commonDisplayObjectVarNames.push(preLayer.varName);
            }
        }
        // 刷新排列
        this.refreshDisplayListOrder();
    };
    /**
     * 刷新顺序【不公开的API-仅内部使用】
     * 规则：
     *  -- 模块根据行走图参考，位于其下方或上方
     *  -- 模块组又根据模块的顺序排列（公共模块永远在最低：即比avatar低或者高的层也都排在其他模块下面）
     * 以下情况刷新：
     *  -- 添加模块后
     *  -- 更换模块顺序后
     *  -- [仅编辑器]相关模块设计结构发生变更后
     */
    ClientSceneObject.prototype.refreshDisplayListOrder = function () {
        var _this = this;
        if (Config.useNewSceneObjectModel) {
            // 插入到指定的层，从startInsert开始
            var addModuleChildToCustomLayer = function (insertToLayer, startInsertIndex, isLowLayer) {
                if (_this.moduleIDs) {
                    for (var s = 0; s < _this.moduleIDs.length; s++) {
                        var startInsert = isLowLayer;
                        var moduleID = _this.moduleIDs[s];
                        var soModule = _this.getModuleAt(s);
                        if (!soModule)
                            return;
                        var moduleData = Game.data.sceneObjectModuleList.data[moduleID];
                        if (moduleData) {
                            // 如果不存在行走图参考则插入一个以作为查考
                            var preLayers = moduleData.preLayer.concat();
                            if (ArrayUtils.matchAttributes(preLayers, { type: SceneObjectModelData.TYPE_AVATAR_TYPE }, true).length == 0) {
                                preLayers.unshift({ type: SceneObjectModelData.TYPE_AVATAR_TYPE });
                            }
                            // 遍历层次插入
                            for (var i = 0; i < preLayers.length; i++) {
                                var preLayerSetting = preLayers[i];
                                if (preLayerSetting.type == SceneObjectModelData.TYPE_AVATAR_TYPE) {
                                    if (!startInsert)
                                        startInsert = true;
                                    else
                                        break;
                                }
                                else if (startInsert) {
                                    var commonDisplayObj = soModule[preLayerSetting.varName];
                                    if (commonDisplayObj) {
                                        insertToLayer.addChildAt(commonDisplayObj, startInsertIndex++);
                                    }
                                }
                            }
                        }
                    }
                }
            };
            var insertToLayer = this.customLayer;
            var insertIndex = 0;
            var commonModuleData = Game.data.sceneObjectModelList.data[0];
            for (var i = 0; i < commonModuleData.preLayer.length; i++) {
                var preLayer = commonModuleData.preLayer[i];
                // 当遇到avatar后
                if (preLayer.type == SceneObjectModelData.TYPE_AVATAR_TYPE) {
                    // 2.插入比avatar底的模块的显示列表
                    addModuleChildToCustomLayer.call(this, insertToLayer, insertIndex, true);
                    insertToLayer = this.customHighLayer;
                    insertIndex = 0;
                    continue;
                }
                else {
                    // -- 1.插入公共模块
                    var commonDisplayObj = this[preLayer.varName];
                    if (commonDisplayObj)
                        insertToLayer.addChildAt(commonDisplayObj, insertIndex++);
                }
            }
            // 3.插入比avatar高的模块的显示列表
            addModuleChildToCustomLayer.call(this, insertToLayer, insertIndex, false);
        }
    };
    /**
     * 清理显示列表
     */
    ClientSceneObject.prototype.clearCommonDisplayList = function () {
        if (!this.commonDisplayObjectVarNames)
            this.commonDisplayObjectVarNames = [];
        for (var i = 0; i < this.commonDisplayObjectVarNames.length; i++) {
            var commonDisplayObjectVarName = this.commonDisplayObjectVarNames[i];
            var commonDisplayObject = this[commonDisplayObjectVarName];
            if (commonDisplayObject) {
                commonDisplayObject.dispose && commonDisplayObject.dispose();
                delete this[commonDisplayObjectVarName];
            }
        }
        this.commonDisplayObjectVarNames.length = 0;
        this.avatarContainer.removeSelf();
    };
    /**
     * 获取当前显示列表的实际显示对象组（可能存在空值或包含avatar）
     */
    ClientSceneObject.prototype.getCustomDisplayLayers = function () {
        var displays = [];
        for (var i = 0; i < this.customLayer.numChildren; i++) {
            displays.push(this.customLayer.getChildAt(i));
        }
        for (var i = 0; i < this.customHighLayer.numChildren; i++) {
            displays.push(this.customHighLayer.getChildAt(i));
        }
        return displays;
    };
    /**
     * 释放
     */
    ClientSceneObject.prototype.dispose = function () {
        if (!this.isDisposed) {
            // 从场景上移除
            if (this.scene && this.scene.sceneObjects[this.index] == this)
                this.scene.removeSceneObject(this);
            // 派发释放事件
            this.event(GameSprite.ON_DISPOSE);
            this.isDisposed = true;
            // 清理出现条件
            this.clearCondition();
            // 清理事件
            EventUtils.clear(this);
            // 清理公共显示层
            this.clearCommonDisplayList();
            // 移除模块
            this.removeAllModules(true);
            // 停止当前播放的动画
            this.stopAllAnimation();
            // 清理avatar
            this.avatar && this.avatar.dispose();
            this.avatar = null;
        }
    };
    //------------------------------------------------------------------------------------------------------
    //  模块
    //------------------------------------------------------------------------------------------------------
    /**
     * 添加模块
     * @param soModule 模块
     * @return [boolean] 是否添加成功
     */
    ClientSceneObject.prototype.addModule = function (soModule) {
        var res = _super.prototype.addModule.call(this, soModule, false);
        if (res) {
            this.refreshDisplayListOrder();
            EventUtils.happen(SceneObjectEntity, SceneObjectEntity.EVENT_ON_ADD_MODULE, [this, soModule]);
        }
        return res;
    };
    /**
     * 添加模块-到指定的位置上
     * @param soModule 模块
     * @param index 指定的位置
     * @return [boolean] 是否添加成功
     */
    ClientSceneObject.prototype.addModuleAt = function (soModule, index) {
        var res = _super.prototype.addModuleAt.apply(this, arguments);
        return res;
    };
    /**
     * 添加模块-根据模块编号
     * -- 模块的属性为默认值
     * @param moduleID 模块编号
     * @return [SceneObjectModule] 被添加的模块
     */
    ClientSceneObject.prototype.addModuleByID = function (moduleID) {
        var res = _super.prototype.addModuleByID.apply(this, arguments);
        return res;
    };
    /**
     * 添加模块-到指定的位置上-根据模块的编号
     * @param moduleID 模块编号
     * @param index 指定的位置
     * @return [SceneObjectModule] 被添加的模块
     */
    ClientSceneObject.prototype.addModuleByIDAt = function (moduleID, index) {
        var res = _super.prototype.addModuleByIDAt.apply(this, arguments);
        return res;
    };
    /**
     * 移除所有模块
     * @param isDispose [可选] 默认值=true 是否销毁模块
     */
    ClientSceneObject.prototype.removeAllModules = function (isDispose) {
        if (isDispose === void 0) { isDispose = true; }
        for (var i = 0; i < this._modules.length; i++) {
            var m = this._modules[i];
            if (m)
                this.removeModuleDisplayObjects(m, i, isDispose);
        }
        _super.prototype.removeAllModules.call(this, isDispose);
    };
    /**
     * 移除指定编号的模块
     * @param moduleID 模块的编号
     * @param isDispose [可选] 默认值=true 是否销毁模块
     * @return [SceneObjectModule] 被移除的模块
     */
    ClientSceneObject.prototype.removeModuleByID = function (moduleID, isDispose) {
        if (isDispose === void 0) { isDispose = true; }
        var index = ArrayUtils.matchAttributes(this._modules, { id: moduleID }, true, "==", true)[0];
        if (index != null) {
            this.removeModuleDisplayObjects(this._modules[index], index, isDispose);
            return _super.prototype.removeModuleByID.call(this, moduleID, isDispose);
        }
        return null;
    };
    /**
     * 移除模块-根据其拥有的模块
     * @param soModule 拥有的模块
     * @param isDispose [可选] 默认值=true 是否销毁模块
     * @return [boolean] 是否移除成功
     */
    ClientSceneObject.prototype.removeModule = function (soModule, isDispose) {
        if (isDispose === void 0) { isDispose = true; }
        var index = this._modules.indexOf(soModule);
        if (index != -1) {
            this.removeModuleDisplayObjects(soModule, index, isDispose);
            return _super.prototype.removeModule.call(this, soModule, isDispose);
        }
        return false;
    };
    /**
     * 移除模块-根据指定的位置
     * @param index 指定的位置
     * @param isDispose [可选] 默认值=true 是否销毁
     * @return [boolean] 是否移除成功
     */
    ClientSceneObject.prototype.removeModuleAt = function (index, isDispose) {
        if (isDispose === void 0) { isDispose = true; }
        var soModule = this._modules[index];
        if (soModule) {
            this.removeModuleDisplayObjects(soModule, index, isDispose);
            return _super.prototype.removeModuleAt.call(this, index, isDispose);
        }
        return false;
    };
    /**
     * 设置已拥有的模块到指定位置
     * @param soModule 拥有的模块
     * @param toIndex 设置到达指定的位置
     * @return [boolean] 是否成功
     */
    ClientSceneObject.prototype.setModuleIndex = function (soModule, toIndex) {
        var res = _super.prototype.setModuleIndex.apply(this, arguments);
        return res;
    };
    /**
     * 设置已拥有的模块到指定位置-根据模块编号
     * @param moduleID 已拥有的模块的编号
     * @param toIndex 设置到达指定的位置
     * @return [boolean] 是否成功
     */
    ClientSceneObject.prototype.setModuleIndexByID = function (moduleID, toIndex) {
        var res = _super.prototype.setModuleIndexByID.apply(this, arguments);
        return res;
    };
    /**
     * 调整模块位置
     * @param fromIndex 模块的原始位置
     * @param toIndex 模块的新位置
     * @return [boolean] 是否成功
     */
    ClientSceneObject.prototype.setModuleIndexByIndex = function (fromIndex, toIndex) {
        var res = _super.prototype.setModuleIndexByIndex.apply(this, arguments);
        this.refreshDisplayListOrder();
        return res;
    };
    /**
     * 移除模块下的全部显示对象
     * @param soModule 模块
     * @param moduleIndex 模块索引
     * @param disposeDisplayObjects [可选] 默认值=true 是否销毁显示对象
     */
    ClientSceneObject.prototype.removeModuleDisplayObjects = function (soModule, moduleIndex, disposeDisplayObjects) {
        if (disposeDisplayObjects === void 0) { disposeDisplayObjects = true; }
        var displayList = this.moduleDisplayList[moduleIndex];
        for (var varName in displayList) {
            var displayObj = soModule[varName];
            if (displayObj) {
                displayObj.removeSelf();
                if (disposeDisplayObjects && displayObj.dispose)
                    displayObj.dispose();
            }
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 系统影子封装
    //------------------------------------------------------------------------------------------------------
    /**
     * 绘制影子
     */
    ClientSceneObject.prototype.drawShadow = function (scalePer) {
        if (scalePer === void 0) { scalePer = 1.0; }
        if (this.isDisposed)
            return;
        // 由上层实现该功能
        if (Config.useNewSceneObjectModel) {
            return;
        }
        this.shadow.graphics.clear();
        if (this.shadowEnable) {
            this.shadow.graphics.drawCircle(0, 0, this.shadowWidth * scalePer, this.shadowWidth * scalePer, "#000000", 0);
            this.shadow.scaleY = this.shadowHeight / this.shadowWidth * this.avatar.scaleY;
            this.shadow.scaleX = this.avatar.scaleX;
            this.shadow.alpha = this.shadowAlpha;
        }
    };
    /**
     * 刷新影子，更新坐标
     */
    ClientSceneObject.prototype.updateShadow = function () {
        this.shadow.x = this.root.x;
        this.shadow.y = this.root.y;
    };
    //------------------------------------------------------------------------------------------------------
    // 渲染和刷新
    //------------------------------------------------------------------------------------------------------
    /**
     * 停止渲染
     * @param stopCurrentFrame [可选] 默认值=false 行走图是否停止在当前帧 true=当前帧 false=初始设定帧
     */
    ClientSceneObject.prototype.stopRender = function (stopCurrentFrame) {
        if (stopCurrentFrame === void 0) { stopCurrentFrame = false; }
        this.avatar.stop(stopCurrentFrame ? this.avatar.getCurrentFrame() : this.avatarFrame);
        var aniLen = this.___animations.length;
        for (var s = 0; s < aniLen; s++) {
            var ani = this.___animations[s];
            ani.stop(ani.currentFrame);
        }
        var customDisplayLayers = this.getCustomDisplayLayers();
        for (var i in customDisplayLayers) {
            var sp = customDisplayLayers[i];
            if (sp instanceof GCAnimation) {
                sp.stop(sp.currentFrame);
            }
        }
    };
    /**
     * 恢复渲染
     * @param continueCurrentFrame [可选] 默认值=false 行走图是否从当前帧开始恢复播放 true=当前帧 false=初始设定帧
     */
    ClientSceneObject.prototype.recoveryRender = function (continueCurrentFrame) {
        if (continueCurrentFrame === void 0) { continueCurrentFrame = false; }
        if (this.autoPlayEnable)
            this.avatar.gotoAndPlay(continueCurrentFrame ? this.avatar.getCurrentFrame() : this.avatarFrame);
        var aniLen = this.___animations.length;
        for (var s = 0; s < aniLen; s++) {
            var ani = this.___animations[s];
            ani.gotoAndPlay(ani.currentFrame);
        }
        var customDisplayLayers = this.getCustomDisplayLayers();
        for (var i in customDisplayLayers) {
            var sp = customDisplayLayers[i];
            if (sp instanceof GCAnimation) {
                sp.gotoAndPlay(sp.currentFrame);
            }
        }
    };
    /**
     * 刷新：执行逻辑应由子类实现，该类下此函数无任何代码实现
     * @param nowTime 游戏时间戳（Game.pause会暂停游戏时间戳）
     */
    ClientSceneObject.prototype.update = function (nowTime) {
    };
    /**
     * 进入新的坐标后进行一些刷新
     */
    ClientSceneObject.prototype.refreshCoordinate = function () {
        this.updateShadow();
    };
    Object.defineProperty(ClientSceneObject.prototype, "actionIndex", {
        //------------------------------------------------------------------------------------------------------
        // avatar
        //------------------------------------------------------------------------------------------------------
        get: function () {
            return this.avatar ? this.avatar.actionIndex : 0;
        },
        set: function (v) {
            this.avatar.actionIndex = v;
            this["_avatarAct"] = this.avatar.actionID;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 同步AVATAR状态到当前场景对象上
     * 目前单机版存档时会使用到
     */
    ClientSceneObject.prototype.syncAvatarStateToSceneObject = function () {
        if (this.avatarID != this.avatar.id) {
            this["_avatarID"] = this.avatar.id;
        }
        if (this.avatarOri != this.avatar.orientation) {
            this["_avatarOri"] = this.avatar.orientation;
        }
        if (!this.avatar.isLoading && this.avatarAct != this.avatar.actionID) {
            this["_avatarAct"] = this.avatar.actionID;
        }
        if (this.avatarFPS != this.avatar.fps) {
            this["_avatarFPS"] = this.avatar.fps;
        }
        if (this.avatarAlpha != this.avatar.alpha) {
            this["_avatarAlpha"] = this.avatar.alpha;
        }
        if (this.avatarHue != this.avatar.hue) {
            this["_avatarHue"] = this.avatar.hue;
        }
        if (this.scale != this.avatar.scaleX) {
            this["_scale"] = this.avatar.scaleX;
        }
    };
    /**
     * 播放动画
     * @param aniID 动画编号
     * @param loop 是否循环播放
     * @param isHit 是否显示被击效果
     * @param fps [可选] 默认值=null 帧率，如果无则使用Config.ANIMATION_FPS
     * @param superposition [可选] 默认值=false 叠加，默认不叠加，即同一个ID播放会重新播放该动画
     *                             停止该动画无法使用ID来停止而必须传入Animation对象
     * @return [GCAnimation]
     */
    ClientSceneObject.prototype.playAnimation = function (aniID, loop, isHit, fps, superposition) {
        var _this = this;
        if (fps === void 0) { fps = null; }
        if (superposition === void 0) { superposition = false; }
        var animation;
        // 覆盖模式
        if (superposition) {
            animation = new GCAnimation();
            this.___animations.push(animation);
        }
        // 非覆盖模式，查找已存在的该动画
        else {
            animation = ArrayUtils.matchAttributes(this.___animations, { id: aniID }, true, "==")[0];
            if (!animation) {
                animation = new GCAnimation();
                this.___animations.push(animation);
            }
        }
        animation.sceneObject = this;
        if (fps)
            animation.fps = fps;
        animation.loop = loop;
        animation.showHitEffect = isHit;
        animation.once(GCAnimation.PLAY_COMPLETED, this, this.stopAnimation, [animation]);
        animation.once(EventObject.LOADED, this, function (animation) {
            if (animation.isDisposed)
                return;
            if (animation.isParticle) {
                _this.animationHighLayer.addChild(animation);
            }
            else {
                animation.addToGameSprite(_this.avatarContainer, _this.animationLowLayer, _this.animationHighLayer);
            }
        }, [animation]);
        animation.id = aniID;
        animation.gotoAndPlay();
        return animation;
    };
    /**
     * 停止动画
     *
     * @param aniID 动画编号/对象
     */
    ClientSceneObject.prototype.stopAnimation = function (aniID) {
        var animation;
        if (aniID instanceof GCAnimation) {
            animation = aniID;
            var animationIdx = this.___animations.indexOf(animation);
            if (animationIdx == -1)
                return;
            this.___animations.splice(animationIdx, 1);
        }
        else {
            var animationIdx = ArrayUtils.matchAttributes(this.___animations, { id: aniID }, true, "==", true)[0];
            if (animationIdx != null) {
                animation = this.___animations.splice(animationIdx, 1)[0];
            }
            else {
                return;
            }
        }
        if (animation) {
            // 延迟释放，以便外部对该动画注册了事件的还能够正常执行
            Callback.CallLaterBeforeRender(animation.dispose, animation);
        }
    };
    /**
     * 停止所有动画
     */
    ClientSceneObject.prototype.stopAllAnimation = function () {
        var aniLen = this.___animations.length;
        for (var s = 0; s < aniLen; s++) {
            var ani = this.___animations[s];
            ani.dispose();
        }
        this.___animations.length = 0;
    };
    //------------------------------------------------------------------------------------------------------
    // 事件
    //------------------------------------------------------------------------------------------------------
    ClientSceneObject.prototype.hasListener = function (type) { return this.root.hasListener.apply(this.root, arguments); };
    ;
    ClientSceneObject.prototype.event = function (type, data) { return this.root.event.apply(this.root, arguments); };
    ;
    ClientSceneObject.prototype.on = function (type, caller, listener, args) { return this.root.on.apply(this.root, arguments); };
    ;
    ClientSceneObject.prototype.once = function (type, caller, listener, args) { return this.root.once.apply(this.root, arguments); };
    ;
    ClientSceneObject.prototype.off = function (type, caller, listener, onceOnly) { return this.root.off.apply(this.root, arguments); };
    ;
    ClientSceneObject.prototype.offAll = function (type) { return this.root.offAll.apply(this, arguments); };
    ;
    return ClientSceneObject;
}(SceneObjectEntity));
/**
 * 绑定get/set属性
 */
ObjectUtils.reDefineGetSet("ClientSceneObject.prototype", {
    isBorn: function (v) {
        if (this.root && Config.EDIT_MODE) {
            if (v) {
                // temp
                // @ts-ignore
                var bornSign = new MyGameCreatorEditorUI.Editor.model.SceneObjectBornSignUI();
                this.root.addChild(bornSign);
            }
        }
    },
    x: function (v) { if (this.root) {
        this.root.x = v;
        Callback.CallLaterBeforeRender(this.refreshCoordinate, this);
    } },
    y: function (v) { if (this.root) {
        this.root.y = v;
        Callback.CallLaterBeforeRender(this.refreshCoordinate, this);
    } },
    avatarID: function (v) {
        if (this.avatar) {
            if (v == this.avatar.id)
                return;
            this.avatar.id = v;
        }
    },
    shadowWidth: function (v) {
        if (this.avatar) {
            Callback.CallLaterBeforeRender(this.drawShadow, this);
        }
    },
    shadowHeight: function (v) {
        if (this.avatar) {
            Callback.CallLaterBeforeRender(this.drawShadow, this);
        }
    },
    shadowAlpha: function (v) {
        if (this.avatar) {
            Callback.CallLaterBeforeRender(this.drawShadow, this);
        }
    },
    shadowEnable: function (v) {
        if (this.avatar) {
            Callback.CallLaterBeforeRender(this.drawShadow, this);
        }
    },
    avatarOri: function (v) { if (this.avatar && this.avatar.orientation != v)
        this.avatar.orientation = v; },
    avatarAct: function (v) { if (this.avatar && this.avatar.actionID != v) {
        this.avatar.actionID = v;
    } },
    avatarFPS: function (v) { if (this.avatar)
        this.avatar.fps = v; },
    avatarFrame: function (v) { if (this.avatar) {
        this.avatar.setCurrentFrame(v, true);
    } },
    avatarAlpha: function (v) { if (this.avatar) {
        this.avatar.alpha = v;
    } },
    avatarHue: function (v) { if (this.avatar) {
        this.avatar.hue = v;
    } },
    layerLevel: function (v) {
        if (!this.root || !this.root.stage)
            return;
        if (this.root.parent != this.scene.sceneObjectHighLayer && v == 2) {
            this.scene.sceneObjectHighLayer.addChild(this.root);
        }
        else if (this.root.parent != this.scene.sceneObjectLayer && v == 1) {
            this.scene.sceneObjectLayer.addChild(this.root);
        }
        else if (this.root.parent != this.scene.sceneObjectLowLayer && v == 0) {
            this.scene.sceneObjectLowLayer.addChild(this.root);
        }
    },
    autoPlayEnable: function (v) {
        if (!this.root || !this.avatar)
            return;
        if (v) {
            this.avatar.play();
        }
        else {
            this.avatar.stop(this.avatar.getCurrentFrame());
        }
    },
    scale: function (v) {
        if (!this.root)
            return;
        this.avatar.scaleX = this.avatar.scaleY = v;
        this.drawShadow();
    }
});
/**
 * 安装模块时将模块的显示对象转化为实体
 * 确保在场景对象模块运行时的构造函数时即可访问到显示对象，如：
 * this.myUI; // [object GUI_1];
 */
(function () {
    var ___soInstallModuleAttributesBeforeConstructor = SceneObject.installModuleAttributesBeforeConstructor;
    SceneObject.installModuleAttributesBeforeConstructor = function (soc, moduleID, moduleName, moduleData, presetData, soModule) {
        // 安装数据
        ___soInstallModuleAttributesBeforeConstructor.apply(this, arguments);
        // 忽略公共模块
        if (moduleData.id == 0)
            return;
        // 行为编辑器预览或游戏运行时
        for (var i = 0; i < moduleData.preLayer.length; i++) {
            var preLayer = moduleData.preLayer[i];
            var id;
            var attributeValue = soModule[preLayer.varName];
            if (attributeValue) {
                id = typeof attributeValue == "number" ? attributeValue : attributeValue.id;
            }
            else {
                id = preLayer.id;
            }
            //
            var newLayer = null;
            var layer = soc.customHighLayer;
            switch (preLayer.type) {
                case 2: // 固定界面
                    newLayer = ClientSceneObject.createDisplayObjectByPreLayer(preLayer.type, MathUtils.int(preLayer.id));
                    if (newLayer)
                        layer.addChild(newLayer);
                    break;
                case 3: // 选定的界面
                    newLayer = ClientSceneObject.createDisplayObjectByPreLayer(preLayer.type, MathUtils.int(id));
                    if (newLayer)
                        layer.addChild(newLayer);
                    break;
                case 4: // 固定的动画
                    var animation = newLayer = ClientSceneObject.createDisplayObjectByPreLayer(preLayer.type, preLayer.id);
                    animation.sceneObject = this;
                    layer.addChild(animation);
                    break;
                case 5: // 选定的动画
                    var animation = newLayer = ClientSceneObject.createDisplayObjectByPreLayer(preLayer.type, MathUtils.int(id));
                    animation.sceneObject = this;
                    layer.addChild(animation);
                    break;
            }
            if (newLayer) {
                soModule[preLayer.varName] = newLayer;
            }
        }
    };
})();
/**
 * 文字字体加载管理类
 * Created by JayLen on 2020-08-22 13:35:52.
 */
var FontLoadManager = /** @class */ (function () {
    function FontLoadManager() {
    }
    /**
     * 保存字体配置
     * @param FONTS
     */
    FontLoadManager.needSave = function (FONTS) {
        Config.FONTS = FONTS;
        EditorData.updateNeedSaveFile(EditorData.NEED_SAVE_CONFIG);
    };
    /**
     * 根据名字获取字体样式
     * @param name 字体名字
     */
    FontLoadManager.getFontByName = function (name) {
        return FontLoadManager.fontFaceList[name];
    };
    //------------------------------------------------------------------------------------------------------
    // 加载字体
    //------------------------------------------------------------------------------------------------------
    /**
     * 加载字体
     * @param fontList 字体列表【 name-名字, path-路径, fonttype-类型, size-大小】
     * @param callBack 完成回调
     */
    FontLoadManager.loadFontFile = function (fontList, callBack) {
        if (callBack === void 0) { callBack = null; }
        if (fontList.length == 0) {
            callBack && callBack.run();
            return;
        }
        for (var i = 0; i < fontList.length; i++) {
            var font = fontList[i];
            new SyncTask(FontLoadManager.FONT_FILE_LOADIMG, function (data) {
                FontLoadManager.toLoadFontFile(data);
            }, [font]);
        }
        new SyncTask(FontLoadManager.FONT_FILE_LOADIMG, function () {
            callBack && callBack.run();
            SyncTask.taskOver(FontLoadManager.FONT_FILE_LOADIMG);
        });
    };
    /**
     * 加载字体文件
     */
    FontLoadManager.toLoadFontFile = function (font) {
        // @ts-ignore
        var fontface = FontLoadManager.fontFaceList[name];
        if (fontface) {
            SyncTask.taskOver(FontLoadManager.FONT_FILE_LOADIMG);
            return;
        }
        //
        var isGoToNext = false;
        var fontType = FontLoadManager.getFontType(font.fonttype);
        fontface = new FontFace(font.name, "url('" + font.path + "') format('" + fontType + "')");
        fontface.loaded.then(function (loadFace) {
            // trace("字体加载完毕，可使用", font.name);
            // @ts-ignore
            document.fonts.add(loadFace);
            FontLoadManager.fontFaceList[font.name] = loadFace;
            doNext();
        }).catch(function (err) {
            // trace("字体加载失败", font.name);
            doNext();
        });
        fontface.load();
        // 保险，因为上面有一定概率未触发导致卡在启动页
        setTimeout(doNext, 2000);
        function doNext() {
            if (isGoToNext)
                return;
            isGoToNext = true;
            SyncTask.taskOver(FontLoadManager.FONT_FILE_LOADIMG);
        }
    };
    /**
     * 获取字体格式
     */
    FontLoadManager.getFontType = function (name) {
        if (!name)
            return "truetype";
        name = name.toLocaleLowerCase();
        if (name == "otf")
            return "opentype";
        else if (name == "eot")
            return "embedded-opentype";
        else if (name == "svg")
            return "svg";
        else if (name == "woff")
            return "woff";
        else
            return "truetype";
    };
    //------------------------------------------------------------------------------------------------------
    // 清理字体
    //------------------------------------------------------------------------------------------------------
    FontLoadManager.deleteFontFile = function (name) {
        var fontface = FontLoadManager.fontFaceList[name];
        if (!fontface)
            return;
        // @ts-ignore
        document.fonts.delete(fontface);
        delete FontLoadManager.fontFaceList[name];
        // trace("+++删除字体+++", name);
    };
    /**
     * 标志
     */
    FontLoadManager.FONT_FILE_LOADIMG = "font_file_loading";
    /**
    * 记录加载字体库
    */
    FontLoadManager.fontFaceList = {};
    return FontLoadManager;
}());
/**
 * Created by 黑暗之神KDS on 2018-07-27 23:29:00.
 */
var GameAudio = /** @class */ (function () {
    function GameAudio() {
    }
    /**
     * 播放BGM ： 地址不相等的情况才重新播放，但音量会改变（如果需要重新播放，可以停止BGM后再播放）
     * @param url BGM地址
     * @param volume 声量大小
     * @param loop [可选] 循环次数 默认值=9999
     * @param isGradient [可选] 是否渐变 默认值=false
     * @param gradientTime [可选] 是否 默认值=1000
     * @param pitch [可选] 播放速率 默认值=1
     */
    GameAudio.playBGM = function (url, volume, loop, isGradient, gradientTime, pitch) {
        if (volume === void 0) { volume = 1; }
        if (loop === void 0) { loop = 9999; }
        if (isGradient === void 0) { isGradient = false; }
        if (gradientTime === void 0) { gradientTime = 1000; }
        if (pitch === void 0) { pitch = 1; }
        var urlInfo = GameAudio.getAudioURL(url);
        url = urlInfo.url;
        if (urlInfo.volume != null)
            volume = urlInfo.volume;
        if (urlInfo.pitch != null)
            pitch = urlInfo.pitch;
        GameAudio.clearBgmTween();
        // 地址和音调不相同的情况
        if (GameAudio.lastBgmURL != url || pitch != GameAudio.lastBGMPitch) {
            // 停止上次的BGM
            if (GameAudio.lastBgmSoundChannel)
                GameAudio.lastBgmSoundChannel.stop();
            // 播放新的BGM
            GameAudio.lastBgmSoundChannel = SoundManager.playSound(url, loop, pitch, Handler.create(this, function (url) {
                if (url == GameAudio.lastBgmURL) {
                    GameAudio.lastBgmURL = GameAudio.lastBgmSoundChannel = null;
                }
            }, [url]));
            if (isGradient && GameAudio.lastBgmSoundChannel)
                GameAudio.lastBgmSoundChannel.volume = 0;
        }
        GameAudio.lastBgmURL = url;
        GameAudio.lastBGMPitch = pitch;
        GameAudio.lastBGMVolume = volume;
        if (!GameAudio.lastBgmSoundChannel)
            return null;
        GameAudio.lastBgmSoundChannel["_selfVolume"] = volume;
        if (isGradient) {
            GameAudio.lastBgmTween = Tween.to(GameAudio.lastBgmSoundChannel, { volume: volume * GameAudio._bgmVolume }, gradientTime, null, Handler.create(this, function () {
                GameAudio.lastBgmTween = null;
            }));
            GameAudio.lastBgmTween["gradientTime"] = gradientTime;
        }
        else {
            GameAudio.lastBgmSoundChannel.volume = volume * GameAudio._bgmVolume;
        }
        return GameAudio.lastBgmSoundChannel;
    };
    /**
     * 停止播放BGM
     * @param isGradient [可选] 默认值=false
     * @param gradientTime [可选] 默认值=1000
     */
    GameAudio.stopBGM = function (isGradient, gradientTime) {
        if (isGradient === void 0) { isGradient = false; }
        if (gradientTime === void 0) { gradientTime = 1000; }
        GameAudio.clearBgmTween();
        if (GameAudio.lastBgmSoundChannel) {
            if (isGradient) {
                GameAudio.lastBgmTween = Tween.to(GameAudio.lastBgmSoundChannel, { volume: 0 }, gradientTime, null, Handler.create(this, function () {
                    GameAudio.lastBgmURL = null;
                    GameAudio.lastBgmSoundChannel = null;
                }));
            }
            else {
                SoundManager.stopSound(GameAudio.lastBgmSoundChannel.url);
                GameAudio.lastBgmURL = null;
                GameAudio.lastBgmSoundChannel = null;
            }
        }
    };
    /**
     * 播放BGS ： 地址不相等的情况才重新播放，但音量会改变（如果需要重新播放，可以停止BGM后再播放）
     * @param url BGM地址
     * @param volume 声量大小
     * @param loop [可选] 循环次数 默认值=9999
     * @param isGradient [可选] 是否渐变 默认值=false
     * @param gradientTime [可选] 是否 默认值=1000
     * @param pitch [可选] 播放速率 默认值=1
     */
    GameAudio.playBGS = function (url, volume, loop, isGradient, gradientTime, pitch) {
        if (volume === void 0) { volume = 1; }
        if (loop === void 0) { loop = 9999; }
        if (isGradient === void 0) { isGradient = false; }
        if (gradientTime === void 0) { gradientTime = 1000; }
        if (pitch === void 0) { pitch = 1; }
        var urlInfo = GameAudio.getAudioURL(url);
        url = urlInfo.url;
        if (urlInfo.volume != null)
            volume = urlInfo.volume;
        if (urlInfo.pitch != null)
            pitch = urlInfo.pitch;
        GameAudio.clearBgsTween();
        if (GameAudio.lastBgsURL != url || pitch != GameAudio.lastBGSPitch) {
            if (GameAudio.lastBgsSoundChannel)
                GameAudio.lastBgsSoundChannel.stop();
            GameAudio.lastBgsSoundChannel = SoundManager.playSound(url, loop, pitch, Handler.create(this, function (url) {
                if (url == GameAudio.lastBgsURL) {
                    GameAudio.lastBgsURL = GameAudio.lastBgsSoundChannel = null;
                }
            }, [url]));
            if (isGradient && GameAudio.lastBgsSoundChannel)
                GameAudio.lastBgsSoundChannel.volume = 0;
        }
        GameAudio.lastBgsURL = url;
        GameAudio.lastBGSPitch = pitch;
        GameAudio.lastBGSVolume = volume;
        if (!GameAudio.lastBgsSoundChannel)
            return null;
        GameAudio.lastBgsSoundChannel["_selfVolume"] = volume;
        if (isGradient) {
            GameAudio.lastBgsTween = Tween.to(GameAudio.lastBgsSoundChannel, { volume: volume * GameAudio._bgsVolume }, gradientTime, null, Handler.create(this, function () {
                GameAudio.lastBgsTween = null;
            }));
            GameAudio.lastBgsTween["gradientTime"] = gradientTime;
        }
        else {
            GameAudio.lastBgsSoundChannel.volume = volume * GameAudio._bgsVolume;
        }
        return GameAudio.lastBgsSoundChannel;
    };
    /**
     * 停止播放BGM
     * @param isGradient [可选] 默认值=false
     * @param gradientTime [可选] 默认值=1000
     */
    GameAudio.stopBGS = function (isGradient, gradientTime) {
        if (isGradient === void 0) { isGradient = false; }
        if (gradientTime === void 0) { gradientTime = 1000; }
        GameAudio.clearBgsTween();
        if (GameAudio.lastBgsSoundChannel) {
            if (isGradient) {
                GameAudio.lastBgsTween = Tween.to(GameAudio.lastBgsSoundChannel, { volume: 0 }, gradientTime, null, Handler.create(this, function () {
                    GameAudio.lastBgsURL = null;
                    GameAudio.lastBgsSoundChannel = null;
                }));
            }
            else {
                SoundManager.stopSound(GameAudio.lastBgsSoundChannel.url);
                GameAudio.lastBgsURL = null;
                GameAudio.lastBgsSoundChannel = null;
            }
        }
    };
    /**
     * 播放音效，播放在场景对象身上时则计算距离来变更声音大小
     * @param url 音效地址
     * @param volume [可选] 默认值=1 音量
     * @param pitch [可选] 播放速率 默认值=1
     * @param soc [可选] 场景对象
     */
    GameAudio.playSE = function (url, volume, pitch, soc) {
        if (volume === void 0) { volume = 1; }
        if (pitch === void 0) { pitch = 1; }
        if (soc === void 0) { soc = null; }
        return GameAudio.playSuperpositionVoice(url, 0, volume, pitch, soc);
    };
    /**
     * 停止SE
     * @param channels [可选] 传入则表示仅停止传入组的音效，否则是全部当前的音效
     */
    GameAudio.stopSE = function (channels) {
        if (channels === void 0) { channels = null; }
        var seArr = channels ? channels instanceof Array ? channels : [channels] : GameAudio.seArr;
        GameAudio.stopSuperpositionVoice(seArr);
    };
    /**
     * 播放语音，播放在场景对象身上时则计算距离来变更声音大小
     * @param url 音效地址
     * @param volume [可选] 默认值=1 音量
     * @param pitch [可选] 播放速率 默认值=1
     * @param soc [可选] 场景对象
     */
    GameAudio.playTS = function (url, volume, pitch, soc) {
        if (volume === void 0) { volume = 1; }
        if (pitch === void 0) { pitch = 1; }
        if (soc === void 0) { soc = null; }
        return GameAudio.playSuperpositionVoice(url, 1, volume, pitch, soc);
    };
    /**
     * 停止语音
     * @param channels [可选] 传入则表示仅停止传入组的语音，否则是全部当前的语音
     */
    GameAudio.stopTS = function (channels) {
        if (channels === void 0) { channels = null; }
        var tsArr = channels ? channels instanceof Array ? channels : [channels] : GameAudio.tsArr;
        GameAudio.stopSuperpositionVoice(tsArr);
    };
    //------------------------------------------------------------------------------------------------------
    // 叠加的声音
    //------------------------------------------------------------------------------------------------------
    /**
     * 播放叠加的声音
     * @param url 声音地址
     * @param mode 模式 0-SE声音 1-TS语音
     * @param volume [可选] 默认值=1
     * @param pitch [可选] 默认值=1
     * @param soc [可选] 默认值=null
     * @return [SoundChannel]
     */
    GameAudio.playSuperpositionVoice = function (url, mode, volume, pitch, soc) {
        if (volume === void 0) { volume = 1; }
        if (pitch === void 0) { pitch = 1; }
        if (soc === void 0) { soc = null; }
        if (mode == 0) {
            var scArr = GameAudio.seArr;
            var globalVolume = GameAudio._seVolume;
        }
        else {
            scArr = GameAudio.tsArr;
            globalVolume = GameAudio._tsVolume;
        }
        var urlInfo = GameAudio.getAudioURL(url);
        url = urlInfo.url;
        if (urlInfo.volume != null)
            volume = urlInfo.volume;
        if (urlInfo.pitch != null)
            pitch = urlInfo.pitch;
        if (!url)
            return;
        var channel = SoundManager.playSound(url, 1, pitch);
        if (!channel) {
            return null;
        }
        channel["_selfVolume"] = volume;
        scArr.push(channel);
        channel.completeHandler = Handler.create(this, function (s) {
            var idx = scArr.indexOf(s);
            if (idx != -1)
                scArr.splice(idx, 1);
        }, [channel]);
        if (!soc || !soc.scene) {
            channel.volume = volume * globalVolume;
        }
        else {
            if (soc.scene.camera.sceneObject) {
                var cameraCenter = new Point(soc.scene.camera.sceneObject.x, soc.scene.camera.sceneObject.y);
            }
            else {
                var viewPort = soc.scene.camera.viewPort;
                var cameraCenter = new Point(viewPort.x + viewPort.width / 2, viewPort.y + viewPort.height / 2);
            }
            var dis = cameraCenter.distance(soc.x, soc.y);
            var disPer = Math.max(1 - dis / (Config.WINDOW_WIDTH * 0.5), 0);
            channel.volume = volume * disPer * globalVolume;
        }
        return channel;
    };
    /**
     * 停止叠加的声音
     * @param channels [可选] 传入则表示仅停止传入组的音效，否则是全部当前的音效
     */
    GameAudio.stopSuperpositionVoice = function (channels) {
        for (var i = 0; i < channels.length; i++) {
            var c = channels[i];
            c.stop();
            if (channels) {
                // 如果集合不是音效集的话，在音效集里面找一下删除掉该音效
                if (channels != GameAudio.seArr) {
                    var idx = GameAudio.seArr.indexOf(c);
                    if (idx != -1) {
                        GameAudio.seArr.splice(idx, 1);
                    }
                }
                // 如果集合不是语音集的话，在语音集里面找一下删除掉该语音
                if (channels != GameAudio.tsArr) {
                    var idx = GameAudio.tsArr.indexOf(c);
                    if (idx != -1) {
                        GameAudio.tsArr.splice(idx, 1);
                    }
                }
            }
        }
        channels.length = 0;
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 清理BGM的缓动
     */
    GameAudio.clearBgmTween = function () {
        if (GameAudio.lastBgmTween) {
            Tween.clearAll(GameAudio.lastBgmSoundChannel);
            GameAudio.lastBgmTween = null;
        }
    };
    /**
     * 清理BGS的缓动
     */
    GameAudio.clearBgsTween = function () {
        if (GameAudio.lastBgsTween) {
            Tween.clearAll(GameAudio.lastBgsSoundChannel);
            GameAudio.lastBgsTween = null;
        }
    };
    Object.defineProperty(GameAudio, "bgmVolume", {
        //------------------------------------------------------------------------------------------------------
        // 
        //------------------------------------------------------------------------------------------------------
        /**
         * 全局背景音乐大小
         */
        get: function () {
            return this._bgmVolume;
        },
        set: function (v) {
            v = MathUtils.float(v);
            this._bgmVolume = v;
            if (this.lastBgmSoundChannel) {
                // 如果BGM处于缓动中，重新开始缓动
                if (GameAudio.lastBgmTween) {
                    var lastProgress = GameAudio.lastBgmTween.progress;
                    var gradientTime = GameAudio.lastBgmTween["gradientTime"] * (1 - GameAudio.lastBgmTween.progress);
                    this.lastBgmSoundChannel.volume = 0;
                    this.clearBgmTween();
                    GameAudio.lastBgmTween = Tween.to(GameAudio.lastBgmSoundChannel, { volume: this.lastBgmSoundChannel["_selfVolume"] * v }, gradientTime, null, Handler.create(this, function () {
                        GameAudio.lastBgmTween = null;
                    }));
                    GameAudio.lastBgmTween.progress = lastProgress;
                    this.lastBgmSoundChannel.volume = (this.lastBgmSoundChannel["_selfVolume"] * v) * lastProgress;
                }
                else {
                    this.lastBgmSoundChannel.volume = this.lastBgmSoundChannel["_selfVolume"] * v;
                }
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameAudio, "bgsVolume", {
        /**
         * 全局场景音效大小
         */
        get: function () {
            return this._bgsVolume;
        },
        set: function (v) {
            v = MathUtils.float(v);
            this._bgsVolume = v;
            if (this.lastBgsSoundChannel) {
                // 如果BGM处于缓动中，重新开始缓动
                if (GameAudio.lastBgsTween) {
                    // debugger
                    var lastProgress = GameAudio.lastBgsTween.progress;
                    var gradientTime = GameAudio.lastBgsTween["gradientTime"] * (1 - GameAudio.lastBgsTween.progress);
                    this.lastBgsSoundChannel.volume = 0;
                    this.clearBgsTween();
                    GameAudio.lastBgsTween = Tween.to(GameAudio.lastBgsSoundChannel, { volume: this.lastBgsSoundChannel["_selfVolume"] * v }, gradientTime, null, Handler.create(this, function () {
                        GameAudio.lastBgsTween = null;
                    }));
                    GameAudio.lastBgsTween.progress = lastProgress;
                    this.lastBgsSoundChannel.volume = (this.lastBgsSoundChannel["_selfVolume"] * v) * lastProgress;
                }
                else {
                    this.lastBgsSoundChannel.volume = this.lastBgsSoundChannel["_selfVolume"] * v;
                }
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameAudio, "seVolume", {
        /**
         * 全局音效大小
         */
        get: function () {
            return this._seVolume;
        },
        set: function (v) {
            v = MathUtils.float(v);
            this._seVolume = v;
            for (var i = 0; i < GameAudio.seArr.length; i++) {
                var c = GameAudio.seArr[i];
                c.volume = c["_selfVolume"] * v;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameAudio, "tsVolume", {
        /**
         * 全局语音大小
         */
        get: function () {
            return this._tsVolume;
        },
        set: function (v) {
            v = MathUtils.float(v);
            this._tsVolume = v;
            for (var i = 0; i < GameAudio.tsArr.length; i++) {
                var c = GameAudio.tsArr[i];
                c.volume = c["_selfVolume"] * v;
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 设置当失去焦点时停止音乐
     * @param isStop
     */
    GameAudio.setBlurStopMusic = function (isStop) {
        SoundManager.autoStopMusic = isStop;
    };
    /**
     * 获取真实音频地址
     */
    GameAudio.getAudioURL = function (url) {
        if (!url)
            url = "";
        var arr = url.split(",");
        url = arr[0];
        var volume = arr[1] != null ? MathUtils.float(arr[1]) : null;
        var pitch = arr[2] != null ? MathUtils.float(arr[2]) : null;
        return { url: url, volume: volume, pitch: pitch };
    };
    /**
     * 全局背景音乐大小
     */
    GameAudio._bgmVolume = 1;
    /**
     * 全局场景音效大小
     */
    GameAudio._bgsVolume = 1;
    /**
     * 全局音效大小
     */
    GameAudio._seVolume = 1;
    /**
     * 全局语音大小
     */
    GameAudio._tsVolume = 1;
    /**
     * 记录全部播放的SE
     */
    GameAudio.seArr = [];
    /**
     * 记录全部播放的语音
     */
    GameAudio.tsArr = [];
    return GameAudio;
}());
/**
 * 游戏命令处理
 * -- COMMAND_STATE_STOP：客户端等待
 * -- COMMAND_STATE_NEED_INPUT：可能堆积了一些需要排队等待玩家输入的命令
 *
 * 1.部分会缓存GameCommand实例，以便直接提交到指定的mainType+indexType中
 *
 *
 * sceneObject -- GameCommand x N
 * Created by 黑暗之神KDS on 2019-01-12 08:01:14.
 */
var GameCommand = /** @class */ (function (_super) {
    __extends(GameCommand, _super);
    //------------------------------------------------------------------------------------------------------
    // 执行
    //------------------------------------------------------------------------------------------------------
    /**
     * 构造函数
     * @param mainType 0-场景相关 1-场景对象相关 2-UI相关 （对应CommandTrigger.COMMAND_MAIN_TYPE_XXX）
     * @param indexType 对应的小类别
     */
    function GameCommand(mainType, indexType) {
        var _this = _super.call(this) || this;
        _this.mainType = mainType;
        _this.indexType = indexType;
        return _this;
    }
    //------------------------------------------------------------------------------------------------------
    // 初始化
    //------------------------------------------------------------------------------------------------------
    /**
     * 初始化
     */
    GameCommand.init = function () {
        this.start();
    };
    /**
     * 启动，一般使用了COMMAND_STATE_STOP后可以主动调用start重新启动
     *      比如网络内核中为了优化，事件中的等待支持了客户端等待，其实现就是先COMMAND_STATE_STOP，然后等待N帧后调用此方法继续执行事件
     * @param triggerLineID [可选] 默认值=null 当存在时则仅停止该触发线的事件执行，否则停止全部
     */
    GameCommand.start = function (triggerLineID) {
        if (triggerLineID === void 0) { triggerLineID = null; }
        if (triggerLineID == null) {
            os.remove_ENTERFRAME(GameCommand.execCommand, GameCommand.execCommand);
            os.add_ENTERFRAME(GameCommand.execCommand, GameCommand.execCommand);
            GameCommand.execCommand();
        }
        else {
            var cmds = GameCommand.cmdTriggerLines[triggerLineID];
            if (cmds)
                cmds.stop = false;
        }
    };
    /**
     * 获取自定义命令在数据中的ID
     * @param cmdID 该ID会大于 CUSTOM_COMMAND_START_ID
     */
    GameCommand.getCustomCmdDataID = function (cmdID) {
        var type = Math.floor(cmdID / GameCommand.CUSTOM_COMMAND_START_ID);
        var localID = cmdID - GameCommand.CUSTOM_COMMAND_START_ID * type;
        var id = GameListData.getID(type, localID);
        return id;
    };
    /**
     * 获取保存数据
     * @return 全排队等待的命令 + 是否等待输入 + 当前输入的触发线ID
     */
    GameCommand.getSaveData = function () {
        var o = {};
        for (var i in this.cmdTriggerLines) {
            var c = this.cmdTriggerLines[i];
            var newFuncs = [];
            for (var s = 0; s < c.funcs.length; s++) {
                var newFunc = c.funcs[s].concat();
                newFunc.shift();
                newFuncs.push(newFunc);
            }
            o[i] = { stop: c.stop, funcs: newFuncs };
        }
        return [o, GameCommand.isNeedPlayerInput, GameCommand.inputTriggerLine];
    };
    //------------------------------------------------------------------------------------------------------
    // 开始执行和结束
    //------------------------------------------------------------------------------------------------------
    /**
     * [场景-事件] 主动开始触发场景事件，默认事件执行者和事件触发者都是玩家的场景对象
     * @param indexType 事件类别，0~N 对应自定义的场景中的事件类别
     * @param inputMessage [可选] 默认值=null 玩家输入值（等同调用事件时传递的参数）
     * @param onCommandExecuteOver [可选] 默认值=null 当命令执行完毕时回调
     * @return 是否触发执行成功
     */
    GameCommand.startSceneCommand = function (indexType, inputMessage, onCommandExecuteOver) {
        if (inputMessage === void 0) { inputMessage = null; }
        if (onCommandExecuteOver === void 0) { onCommandExecuteOver = null; }
        if (GameCommand.mustInScene && !Game.currentScene)
            return false;
        if (!Game.currentScene || Game.currentScene.isDisposed)
            return false;
        var cmd = new GameCommand(CommandTrigger.COMMAND_MAIN_TYPE_SCENE, indexType);
        cmd.startExecute(0, inputMessage, onCommandExecuteOver);
        return true;
    };
    /**
     * [场景对象-事件] 主动开始新触发该事件
     * @param executorSceneObjectIndex 执行事件者的场景对象索引（sceneObject.index）
     * @param indexType 事件类别，0~N 对应自定义的场景对象中的事件类别
     * @param inputMessage [可选] 默认值=null 玩家输入值（等同调用事件时传递的参数）
     * @param onCommandExecuteOver [可选] 默认值=null 当命令执行完毕时回调
     * @param triggerSceneObject [可选] 默认值=null 触发事件的对象，null则表示玩家的场景对象作为触发事件者
     * @return 是否触发执行成功
     */
    GameCommand.startSceneObjectCommand = function (executorSceneObjectIndex, indexType, inputMessage, onCommandExecuteOver, triggerSceneObject) {
        if (inputMessage === void 0) { inputMessage = null; }
        if (onCommandExecuteOver === void 0) { onCommandExecuteOver = null; }
        if (triggerSceneObject === void 0) { triggerSceneObject = null; }
        if (GameCommand.banSceneObjectEvent)
            return false;
        if (GameCommand.mustInScene && !Game.currentScene)
            return false;
        if (!Game.currentScene || Game.currentScene.isDisposed)
            return false;
        var soc = Game.currentScene.sceneObjects[executorSceneObjectIndex];
        if (soc) {
            var hasCommand = soc.hasCommand[indexType];
            if (hasCommand) {
                var cmd = new GameCommand(CommandTrigger.COMMAND_MAIN_TYPE_SCENE_OBJECT, indexType);
                var triggerSceneObjectIndex = triggerSceneObject ? triggerSceneObject.index : null;
                cmd.startExecute(executorSceneObjectIndex, inputMessage, onCommandExecuteOver, triggerSceneObjectIndex, executorSceneObjectIndex);
                return true;
            }
        }
        return false;
    };
    /**
     * [界面-事件] 主动开始执行界面事件，默认事件执行者和事件触发者都是玩家的场景对象
     * @param commandID UI组件标识，格式：{uiID}_{componentID}
     * @param indexType 子事件类别，0~N 对应UI的对象中的事件类别
     * @param inputMessage [可选] 默认值=null 玩家输入值（等同调用事件时传递的参数）
     * @param onCommandExecuteOver [可选] 默认值=null 当命令执行完毕时回调
     * @return 是否触发执行成功
     */
    GameCommand.startUICommand = function (comp, indexType, inputMessage, onCommandExecuteOver) {
        if (inputMessage === void 0) { inputMessage = null; }
        if (onCommandExecuteOver === void 0) { onCommandExecuteOver = null; }
        if (GameCommand.mustInScene && !Game.currentScene)
            return false;
        if (!Game.currentScene || Game.currentScene.isDisposed)
            return false;
        if (comp instanceof UIComponent.GUI_BASE) {
            var hasRootCommand = comp.hasRootCommand[indexType];
            if (hasRootCommand) {
                var cmd = new GameCommand(CommandTrigger.COMMAND_MAIN_TYPE_UI, indexType);
                var guiRootCommandID = comp.guiID + "_root";
                cmd.startExecute(guiRootCommandID, inputMessage, onCommandExecuteOver);
                return false;
            }
            return false;
        }
        var commandID = comp._commondID;
        var hasCommand = comp.hasCommand[indexType];
        if (hasCommand) {
            var cmd = new GameCommand(CommandTrigger.COMMAND_MAIN_TYPE_UI, indexType);
            cmd.startExecute(commandID, inputMessage, onCommandExecuteOver);
            return true;
        }
        return false;
    };
    /**
     * 执行独立公共事件
     * 独立公共事件会启动一条单独的触发线独立运作，并支持跨场景，直到其执行完毕。
     * @param id 公共事件ID
     * @param inputMessage [可选] 默认值=null 玩家输入值（等同调用事件时传递的参数）
     * @param onCommandExecuteOver [可选] 默认值=null 当命令执行完毕时回调
     * @param triggerSceneObject [可选] 默认值=null 触发事件者，如果为null则表示玩家的场景对象
     * @param executorSceneObject [可选] 默认值=null 执行事件者，如果为null则表示玩家的场景对象
     */
    GameCommand.startCommonCommand = function (id, inputMessage, onCommandExecuteOver, triggerSceneObject, executorSceneObject) {
        if (inputMessage === void 0) { inputMessage = null; }
        if (onCommandExecuteOver === void 0) { onCommandExecuteOver = null; }
        if (triggerSceneObject === void 0) { triggerSceneObject = null; }
        if (executorSceneObject === void 0) { executorSceneObject = null; }
        var triggerSceneObjectIndex = triggerSceneObject ? triggerSceneObject.index : null;
        var executorSceneObjectIndex = executorSceneObject ? executorSceneObject.index : null;
        ClientMsgSender.requestTriggerEvent(2, 0, 0, id, inputMessage, onCommandExecuteOver, triggerSceneObjectIndex, executorSceneObjectIndex);
    };
    //------------------------------------------------------------------------------------------------------
    // 执行过程
    // -- 当前触发线在需要玩家输入时会卡住
    // -- 当前触发线在等待时会卡住
    //------------------------------------------------------------------------------------------------------
    /**
     * 事件执行过程
     * [from server]
     * @param triggerLineID 触发线ID
     * @param params 参数
     */
    GameCommand.rpcCall = function (triggerLineID, params) {
        // 根据触发线获取该线事件列表
        var cmds = GameCommand.cmdTriggerLines[triggerLineID];
        if (!cmds) {
            cmds = GameCommand.cmdTriggerLines[triggerLineID] = { stop: false, funcs: [] };
        }
        var cmdID = params.shift();
        var customHead = "command_";
        var custom = false;
        if (cmdID >= GameCommand.CUSTOM_COMMAND_START_ID) {
            cmdID = GameCommand.getCustomCmdDataID(cmdID);
            customHead = "customCommand_";
            custom = true;
        }
        var func = CommandExecuteGame[customHead + cmdID];
        if (!func) {
            if (custom)
                return;
            var gameFuncName = params.shift();
            cmds.funcs.push([GameFunction[gameFuncName], params, GameFunction, 0, gameFuncName]);
            GameCommand.execCommand();
            return;
        }
        cmds.funcs.push([func, [triggerLineID].concat(params), CommandExecuteGame, 1, customHead + cmdID]);
        GameCommand.execCommand();
    };
    /**
     * 执行命令
     */
    GameCommand.execCommand = function () {
        // 遍历所有触发线
        for (var i in GameCommand.cmdTriggerLines) {
            // 单一触发线执行
            var cmds = GameCommand.cmdTriggerLines[i];
            if (cmds.stop)
                continue;
            while (cmds.funcs.length > 0) {
                var cmd = cmds.funcs.shift();
                var state = cmd[0].apply(cmd[2], cmd[1]);
                var inputTriggerLine = cmd[1][0];
                // 停止的情况则该线中断并不再执行，除非不再处于停止状态
                if (state == GameCommand.COMMAND_STATE_STOP) {
                    cmds.stop = true;
                    break;
                }
                // 需要输入的情况如果已处于输入状态则停止，除非上一次输入已完毕
                else if (state == GameCommand.COMMAND_STATE_NEED_INPUT) {
                    if (GameCommand.isNeedPlayerInput) {
                        if (inputTriggerLine != GameCommand.inputTriggerLine) {
                            cmds.funcs.unshift(cmd);
                            break;
                        }
                    }
                    GameCommand.inputTriggerLine = inputTriggerLine;
                    GameCommand.isNeedPlayerInput = true;
                }
            }
        }
    };
    /**
     * 开始执行事件执行
     * @param commandID SceneObject-ID/UI-ID/CommonEvent-ID
     * @param inputMessage [可选] 默认值=null
     * @param onCommandExecuteOver [可选] 默认值=null 当命令执行完毕时回调
     */
    GameCommand.prototype.startExecute = function (commandID, inputMessage, onCommandExecuteOver, triggerSceneObjectIndex, executorSceneObjectIndex) {
        if (inputMessage === void 0) { inputMessage = null; }
        if (onCommandExecuteOver === void 0) { onCommandExecuteOver = null; }
        if (triggerSceneObjectIndex === void 0) { triggerSceneObjectIndex = null; }
        if (executorSceneObjectIndex === void 0) { executorSceneObjectIndex = null; }
        ClientMsgSender.requestTriggerEvent(0, this.mainType, this.indexType, commandID, inputMessage, onCommandExecuteOver, triggerSceneObjectIndex, executorSceneObjectIndex);
    };
    /**
     * 输入信息并继续执行下去
     * @param inputMessage [可选] 默认值=null 输入的信息
     * @param force [可选] 默认值=false 是否强制模式（非强制模式只有客户端判定需要输入时才发送）
     * @param delay [可选] 默认值=1 延迟多少ms发送
     * @param triggerLineID 默认值=-1 提交的触发线
     */
    GameCommand.inputMessageAndContinueExecute = function (inputMessage, force, delay, triggerLineID) {
        if (inputMessage === void 0) { inputMessage = null; }
        if (force === void 0) { force = false; }
        if (delay === void 0) { delay = 1; }
        if (triggerLineID === void 0) { triggerLineID = -1; }
        function doInputMessageAndContinueExecute(inputMessage, force, delay, triggerLineID) {
            if (inputMessage === void 0) { inputMessage = null; }
            if (force === void 0) { force = false; }
            // 当强制提交或需要输入时
            if (force || GameCommand.isNeedPlayerInput) {
                // 当触发线是阻塞的触发线时或未设置时则视为输入结束
                if (triggerLineID == GameCommand.inputTriggerLine || triggerLineID == -1)
                    GameCommand.isNeedPlayerInput = false;
                if (triggerLineID == -1)
                    triggerLineID = GameCommand.inputTriggerLine;
                ClientMsgSender.requestTriggerEvent(1, 0, 0, triggerLineID, inputMessage);
            }
        }
        if (delay == 0) {
            doInputMessageAndContinueExecute.apply(this, arguments);
        }
        else {
            setTimeout(doInputMessageAndContinueExecute, delay, inputMessage, force, delay, triggerLineID);
        }
    };
    /** 自定义命令起始ID */
    GameCommand.CUSTOM_COMMAND_START_ID = 10000;
    /** 命令状态：继续 */
    GameCommand.COMMAND_STATE_CONTINUE = 0;
    /** 命令状态：终止 */
    GameCommand.COMMAND_STATE_STOP = 1;
    /** 命令状态：需要玩家输入 */
    GameCommand.COMMAND_STATE_NEED_INPUT = 2;
    /** 必须在场景之上，如单机版登录界面无需在 */
    GameCommand.mustInScene = true;
    /** 客户端方法集合 triggerLineID 触发线ID，只有传输过来时存在triggerLineID
     *  funcs:[0]方法 [1]参数 [2]类域 [3]类域类别（0=GameFunction 1=CommandExecuteGame） [4]方法名 */
    GameCommand.cmdTriggerLines = {};
    /**
     * 锁定不允许触发场景对象相关的事件
     */
    GameCommand.banSceneObjectEvent = false;
    return GameCommand;
}(IdentityObject));
/**
 * 游戏对话框
 * -- 目前一旦加载后即不释放了一直缓存着
 * Created by 黑暗之神KDS on 2019-01-09 15:06:50.
 */
var GameDialog = /** @class */ (function (_super) {
    __extends(GameDialog, _super);
    /**
     * 构造函数
     * @param dialogID
     */
    function GameDialog(dialogID, dialogList) {
        var _this = _super.call(this) || this;
        /**
         * 对话框
         */
        _this.dialogBox = new UIComponent.UIBitmap();
        /**
         * 头像
         */
        _this.headBox = new UIComponent.UIRoot();
        /**
         * 选项
         */
        _this.optionBox = new GameSprite();
        /**
         * 选项文本
         */
        _this.optionText = new GameSprite();
        /**
         * 名字
         */
        _this.nameText = new UIComponent.UIString();
        /**
         * 对话文本
         */
        _this.dialogText = new UIComponent.UIString();
        /**
         * 跳过标志
         */
        _this.skipAni = new GCAnimation();
        _this.skipAniPoint = new Point();
        /**
         * 最后一段文字位置
         */
        _this.lastTextPosX = 0;
        _this.lastTextPosY = 0;
        /**
         * 记录当前的文本等待的信息 [出现次数]=[等待的帧数]
         */
        _this.waitTimeArr = [];
        /**
         * 是否拥有材质
         */
        _this.dialogMaterialEnabled = true;
        /**
         * 播放中的文本label
         */
        _this.playTextLabels = [];
        /**
        * 名字映射
        */
        _this.nameMapping = {
            dialogBox: _this.dialogBox,
            headBox: _this.headBox,
            optionBox: _this.optionBox,
            dialog: _this.dialogText,
            option: _this.optionText,
            nameBox: _this.nameText,
            skipBox: _this.skipAni
        };
        _this.id = dialogID;
        _this.dialogList = dialogList;
        //排序
        var dialogData = _this.dialogData = _this.dialogList.data[dialogID];
        var list = [];
        for (var key in _this.nameMapping) {
            var data = dialogData[key];
            if (!data)
                continue;
            var content = { box: _this.nameMapping[key], index: data.index ? data.index : 0 };
            list.push(content);
        }
        _this.orderByIndex(list);
        for (var i = 0; i < list.length; i++) {
            _this.addChild(list[i].box);
        }
        //this.updatePostion();
        // 事件
        _this.size(Config.WINDOW_WIDTH, Config.WINDOW_HEIGHT);
        _this.add_CLICK(_this.onSelfClick, _this);
        // 事件注册
        if ((!Config.EDIT_MODE || GameDialog.container) && GameDialog.maskLayer) {
            GameDialog.maskLayer.offAll(EventObject.CLICK);
            GameDialog.maskLayer.add_CLICK(function () {
                if (GameDialog.lastDialog)
                    GameDialog.lastDialog.onClick.apply(GameDialog.lastDialog, [null, false]);
            }, _this);
            //  GameDialog.maskLayer.add_CLICK(this.onClick, this,[null,false]);
        }
        return _this;
    }
    /**
     * 功能：立即显示全文本，当处于文本播放时则会立即显示至全文本
     */
    GameDialog.showall = function () {
        if (!GameDialog.lastDialog)
            return;
        if (GameDialog.lastDialog.playing) {
            GameDialog.lastDialog.waitPlayerClick = false;
            GameDialog.lastDialog.forceShow = true;
            GameDialog.lastDialog.playSpeed = 5;
            GameDialog.lastDialog.playText();
            GameDialog.lastDialog.clearTextMaterials();
            if (GameDialog.showOptionWithLastDialog) {
                GameDialog.showOption(GameDialog.lastDialog.id, GameDialog.showOptionWithLastDialog, true, GameDialog.showOptionWithLastDialogParams[0], GameDialog.showOptionWithLastDialogParams[1], GameDialog.showOptionWithLastDialogParams[2]);
            }
        }
    };
    /**
     * 功能：立刻跳过当前文本
     * @return [boolean] 成功跳过
     */
    GameDialog.skip = function () {
        if (!GameDialog.lastDialog)
            return false;
        if (GameDialog.optionMode) {
            return false;
        }
        // 如果已关闭的情况下则不再允许提交
        if (GameDialog.isCloseDialog)
            return false;
        if (GameDialog.showOptionWithLastDialog) {
            GameDialog.showOption(GameDialog.lastDialog.id, GameDialog.showOptionWithLastDialog, true, GameDialog.showOptionWithLastDialogParams[0], GameDialog.showOptionWithLastDialogParams[1], GameDialog.showOptionWithLastDialogParams[2]);
        }
        else {
            var lastCurrentDialogSign = GameDialog.currentDialogSign;
            GameDialog.isCloseDialog = true;
            EventUtils.happen(GameDialog, GameDialog.EVENT_DIALOG_END, [GameDialog.lastDialog]);
            // 如果不存在新的标识说明没有新的对话，延迟关闭掉对话框界面
            if (GameDialog.currentDialogSign == lastCurrentDialogSign) {
                // delayStop只有一个记录
                if (GameDialog.lastDialog) {
                    GameDialog.lastDialog.clearDelayStop();
                    GameDialog.lastDialog.delayStop = setTimeout(function (lastDialog) {
                        lastDialog.stop();
                    }, GameDialog.delayCloseTime, GameDialog.lastDialog);
                }
            }
            // 提交
            if (GameDialog.lastDialog.submitCallback) {
                GameDialog.lastDialog.submitCallback.run();
            }
            else {
                GameCommand.inputMessageAndContinueExecute();
            }
        }
        return true;
    };
    /**
     * 功能：立刻跳过当前等待玩家操作
     */
    GameDialog.skipWaitPlayerOperation = function () {
        if (!GameDialog.lastDialog)
            return false;
        if (GameDialog.lastDialog.playing && GameDialog.lastDialog.waitPlayerClick) {
            GameDialog.lastDialog.waitPlayerClick = false;
            return true;
        }
        return false;
    };
    /**
     * 停止对话，停止后其所在的触发线也处于停止中
     */
    GameDialog.stop = function () {
        if (GameDialog.lastDialog) {
            GameDialog.lastDialog.stop();
            GameDialog.lastDialog = null;
        }
    };
    Object.defineProperty(GameDialog, "isInDialog", {
        /**
         * 是否显示对话中
         */
        get: function () {
            return GameDialog.lastDialog != null && GameDialog.lastDialog.stage != null && !GameDialog.isCloseDialog;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameDialog, "isPlaying", {
        /**
         * 是否播放中
         */
        get: function () {
            if (!GameDialog.lastDialog)
                return false;
            return GameDialog.lastDialog.playing;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 初始化
     */
    GameDialog.init = function () {
        if (this._inited)
            return;
        this._inited = true;
        this.maskLayer = new Sprite();
        this.maskLayer.size(3000, 3000);
        this.maskLayer.mouseEnabled = true;
    };
    /**
     * 显示对话框
     * @param dialogID 对话框ID
     * @param head 头像ID
     * @param name 名称
     * @param speed 播放速度
     * @param comicSceneObjectIndex 漫画对话框模式 -1无 0-N 场景对象
     * @param msg 对话内容
     * @param submitCallback 提交的方法，默认是提交输入命令
     * @param audio 语音
     * @param exp 表情
     * @param nameColor 名字颜色
     * @param changeData 修改属性数据
     */
    GameDialog.showDialog = function (dialogID, head, name, speed, comicSceneObjectIndex, msg, submitCallback, audio, exp, nameColor, changeData, dialogMaterialEnabled) {
        if (submitCallback === void 0) { submitCallback = null; }
        if (dialogMaterialEnabled === void 0) { dialogMaterialEnabled = true; }
        GameDialog.currentDialogInfo = [0, dialogID, head, name, speed, comicSceneObjectIndex, msg, null, audio, exp, nameColor, changeData];
        GameDialog.currentDialogSign = ObjectUtils.getInstanceID();
        var dialog = GameDialog.getDialog(dialogID);
        dialog.dialogMaterialEnabled = dialogMaterialEnabled;
        // if (submitCallback instanceof Callback) submitCallback = null;
        dialog.submitCallback = submitCallback;
        if (GameDialog.lastDialog) {
            GameDialog.lastDialog.stop();
        }
        dialog.dialogText.visible = dialog.nameText.visible = dialog.headBox.visible = dialog.dialogBox.visible = true;
        dialog.optionBox.visible = false;
        GameDialog.lastDialog = dialog;
        GameDialog.lastDialog.playing = true;
        GameDialog.lastComicSceneObjectIndex = comicSceneObjectIndex;
        GameDialog.optionMode = false;
        GameDialog.isCloseDialog = false;
        GameDialog.addToDialogLayer(dialog);
        EventUtils.happen(GameDialog, GameDialog.EVENT_DIALOG_START, [false, msg, [], name, head, exp, audio, speed, nameColor, changeData]);
        // 播放内容
        dialog.setContent(head, name, speed, msg, audio, exp, nameColor, changeData);
        EventUtils.happen(GameDialog, GameDialog.EVENT_AFTER_DIALOG_START, [false]);
        return dialog;
    };
    /**
     * 显示选项
     * @param dialogID 对话框ID
     * @param options 选项内容
     * @param isShowOptionWithLastDialog [可选] 默认值=false 是否与对话同时显示
     * @param defaultIndex 默认选中索引
     * @param cancelIndex 取消索引
     * @param hideIndexs 隐藏选项的索引
     */
    GameDialog.showOption = function (dialogID, options, isShowOptionWithLastDialog, defaultIndex, cancelIndex, hideIndexs) {
        if (isShowOptionWithLastDialog === void 0) { isShowOptionWithLastDialog = false; }
        if (defaultIndex === void 0) { defaultIndex = -1; }
        if (cancelIndex === void 0) { cancelIndex = -1; }
        if (hideIndexs === void 0) { hideIndexs = []; }
        // 选项和文本一起出现时，且能够获取到上一个文本的情况
        GameDialog.currentDialogSign = ObjectUtils.getInstanceID();
        //如果id为0则清空改变数据
        //if (dialogID && GameDialog.changeData) GameDialog.changeData.id = -1;
        var dialog = GameDialog.getDialog(dialogID);
        // 上一个对话框存在并且样式相同的情况下
        if (!isShowOptionWithLastDialog && GameDialog.lastDialog &&
            GameDialog.lastDialog == dialog && !GameDialog.isCloseDialog) {
            GameDialog.showOptionWithLastDialog = options;
            GameDialog.showOptionWithLastDialogParams = [defaultIndex, cancelIndex, hideIndexs];
            if (!dialog.playing && dialog.hasSkip) {
                GameDialog.showOption(dialog.id, options, true, defaultIndex, cancelIndex, hideIndexs);
            }
            return dialog;
        }
        // 记录选项
        if (isShowOptionWithLastDialog && GameDialog.currentDialogInfo && GameDialog.currentDialogInfo[0] == 0) {
            GameDialog.currentDialogInfo = [1, dialogID, options, isShowOptionWithLastDialog, defaultIndex, cancelIndex, hideIndexs, GameDialog.currentDialogInfo];
        }
        else {
            GameDialog.currentDialogInfo = [1, dialogID, options, isShowOptionWithLastDialog, defaultIndex, cancelIndex, hideIndexs];
        }
        if (GameDialog.lastDialog) {
            var disposeHead = isShowOptionWithLastDialog ? false : true;
            GameDialog.lastDialog.stop(disposeHead);
        }
        GameDialog.lastDialog = dialog;
        GameDialog.optionMode = true;
        GameDialog.isCloseDialog = false;
        dialog.clearDelayStop();
        //
        dialog.skipAni.visible = false;
        dialog.skipAni.stop();
        dialog.dialogText.visible = dialog.nameText.visible = dialog.headBox.visible = dialog.dialogBox.visible = isShowOptionWithLastDialog;
        dialog.optionBox.visible = true;
        if (!isShowOptionWithLastDialog) {
            GameDialog.lastComicSceneObjectIndex = -1;
            dialog.dialogText.removeChildren();
            dialog.nameText.text = "";
            dialog.headBox.removeChildren();
        }
        GameDialog.showOptionWithLastDialog = null;
        GameDialog.showOptionWithLastDialogParams = [-1, -1, []];
        GameDialog.lastComicSceneObjectIndex || (GameDialog.lastComicSceneObjectIndex = -1);
        GameDialog.addToDialogLayer(dialog);
        EventUtils.happen(GameDialog, GameDialog.EVENT_DIALOG_START, [true, null, options, null, null, null, null, 5, null]);
        // 设置选项
        dialog.setOption(options, defaultIndex, cancelIndex, hideIndexs);
        EventUtils.happen(GameDialog, GameDialog.EVENT_AFTER_DIALOG_START, [true]);
        return dialog;
    };
    /**
     * 添加至容器中
     */
    GameDialog.addToDialogLayer = function (dialog) {
        if (Config.EDIT_MODE) {
            if (!GameDialog.container)
                GameDialog.container = Game.layer.uiLayer;
            if (!GameDialog.containerScene)
                GameDialog.containerScene = Game.currentScene;
        }
        else {
            GameDialog.container = Game.layer.uiLayer;
            GameDialog.containerScene = Game.currentScene;
        }
        switch (GameDialog.lastComicSceneObjectIndex) {
            case -1:
                GameDialog.container.addChild(dialog);
                dialog.pos(0, 0);
                break;
            default:
                if (GameDialog.containerScene) {
                    var so = GameDialog.containerScene.sceneObjects[GameDialog.lastComicSceneObjectIndex];
                    // 存在对象且在场景上时
                    if (so && so.inScene) {
                        GameDialog.container.addChild(dialog);
                        GameDialog.bindingSoPostion(dialog, so);
                    }
                    // 否则直接画面显示
                    else {
                        GameDialog.container.addChild(dialog);
                        dialog.pos(0, 0);
                    }
                }
        }
        if (!GameDialog.optionMode) {
            GameDialog.container.addChild(GameDialog.maskLayer);
        }
        else if (GameDialog.maskLayer.stage)
            GameDialog.maskLayer.removeSelf();
    };
    /**
     * 绑定对象
     * @param dialog
     * @param so
     */
    GameDialog.bindingSoPostion = function (dialog, so) {
        GameDialog.refreshDialogPosition(dialog, so);
        stage.off(EventObject.RENDER, GameDialog, GameDialog.refreshDialogPosition);
        stage.on(EventObject.RENDER, GameDialog, GameDialog.refreshDialogPosition, [dialog, so]);
    };
    /**
     * 取消绑定对象
     */
    GameDialog.unbindingSoPosition = function () {
        stage.off(EventObject.RENDER, GameDialog, GameDialog.refreshDialogPosition);
    };
    /**
     * 刷新对话框位置，根据绑定的对象
     * @param dialog
     * @param so
     */
    GameDialog.refreshDialogPosition = function (dialog, so) {
        var gp = so.root.localToGlobal(new Point(0, 0));
        var posx_3 = -0.5 * (dialog.width);
        var layerPos = dialog.parent.globalToLocal(gp);
        dialog.pos(layerPos.x + posx_3, layerPos.y + -dialog.height);
    };
    /**
     * 清理缓存对话框
     */
    GameDialog.clearCacheDialog = function () {
        GameDialog.dialogCache = [];
    };
    /**
     * 获取对话框
     * @param dialogID
     * @return [GameDialog]
     */
    GameDialog.getDialog = function (dialogID) {
        //初始化
        GameDialog.init();
        // 使用最近的对话框，若没有最近的对话框则使用样式1
        if (dialogID == 0) {
            if (GameDialog.lastDialog)
                dialogID = GameDialog.lastDialog.id;
            else {
                dialogID = 1;
            }
        }
        // 找到指定的样式，若找不到则使用样式1
        var dialogData = Common.dialogList.data[dialogID];
        if (!dialogData) {
            dialogID = 1;
            dialogData = Common.dialogList.data[dialogID];
        }
        if (!dialogData) {
            throw ("找不到对话框模板" + dialogID);
        }
        // if (Config.EDIT_MODE) {
        //     return new GameDialog(dialogID, Common.dialogList);
        // }
        var dialog = GameDialog.dialogCache[dialogID];
        if (!dialog) {
            dialog = GameDialog.dialogCache[dialogID] = new GameDialog(dialogID, Common.dialogList);
        }
        return dialog;
    };
    /**
     * 处理内容
     * @param text
     * @param defaultColor
     * @return [string]
     */
    GameDialog.handleText = function (text, defaultColor, dialog) {
        // -- 停顿
        var re = /\[p[0-9]{1,3}\]/g;
        var arr = text.match(re);
        for (var c in arr) {
            var i = arr[c];
            var colorKey = i.substr(2, i.length - 3);
            var waitF = parseInt(colorKey);
            var waitT = "";
            dialog.waitTimeArr.push(waitF);
            for (var s = 0; s < waitF; s++) {
                waitT += GameDialog.KEY_SYMBOL_DELAY;
            }
            text = text.replace(i, waitT);
        }
        // // -- 等待玩家操作
        text = text.replace(/\[\.=\]/g, GameDialog.KEY_SYMBOL_WAIT_PLAYER_CLICK);
        // // -- 跳过
        text = text.replace(/\[\.s\]/g, GameDialog.KEY_SYMBOL_SKIP);
        // --
        return "" + text; // <span style='color:${defaultColor}'></span>
    };
    Object.defineProperty(GameDialog.prototype, "dialogHeadBox", {
        /**
         * 开放显示对象
         */
        /**
         * 头像框
         */
        get: function () {
            var mode = this.dialogData.headBox.perviewMode;
            if (!mode) { //图片
                return this.headImg;
            }
            else if (mode == 1) { //立绘
                return this.headStand;
            }
            else if (mode == 2) { //动画
                return this.headAni;
            }
            else if (mode == 3) { //界面
                return this.headUI;
            }
            return null;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 刷新对话框显示位置
     * @returns DialogData
     */
    GameDialog.prototype.updateDialogPostion = function () {
        //获得数据改变属性
        var dialogData = (GameDialog.changeData && GameDialog.changeData.id == this.dialogData.id) ? this.changeDialog(GameDialog.changeData) : this.dialogData;
        //同步数据
        if (!dialogData.dialogBox.grid9)
            dialogData.dialogBox.grid9 = "0,0,0,0,0";
        ObjectUtils.clone(dialogData.dialogBox, this.dialogBox);
        ObjectUtils.clone(dialogData.nameBox, this.nameText);
        var url = dialogData.dialogBox.image;
        if (!url)
            url = dialogData.dialogBox["skin"] ? dialogData.dialogBox["skin"] : "";
        this.dialogBox.image = url;
        this.nameText.wordWrap = false;
        this.dialogBoxMaterial = this.dialogData.dialogBox.materialData && this.dialogData.dialogBox.materialData.length > 0 && this.dialogData.dialogBox.materialData[0].materials.length > 0;
        this.dialogNameTextMaterial = this.dialogData.nameBox.materialData && this.dialogData.nameBox.materialData.length > 0 && this.dialogData.nameBox.materialData[0].materials.length > 0;
        // 头像
        this.headBox.x = dialogData.headBox.x;
        this.headBox.y = dialogData.headBox.y;
        this.headBox.width = dialogData.headBox.width;
        this.headBox.height = dialogData.headBox.height;
        this.headBox.scaleX = dialogData.headBox.flip ? -1 : 1;
        this.headBox.alpha = dialogData.headBox.alpha;
        this.dialogHeadBoxMaterial = this.dialogData.headBox.materialData && this.dialogData.headBox.materialData.length > 0 && this.dialogData.headBox.materialData[0].materials.length > 0;
        // 对话文本
        this.dialogText.x = dialogData.dialog.x;
        this.dialogText.y = dialogData.dialog.y;
        this.dialogText.width = dialogData.dialog.width;
        this.dialogText.height = dialogData.dialog.height;
        this.dialogText.alpha = dialogData.dialog.alpha;
        this.dialogTextMaterial = this.dialogData.dialog.materialData && this.dialogData.dialog.materialData.length > 0 && this.dialogData.dialog.materialData[0].materials.length > 0;
        // 跳过标志
        this.skipAni.visible = false;
        this.skipAni.scaleX = this.skipAni.scaleY = dialogData.skipBox.scaleNumber;
        this.skipAni.id = dialogData.skipBox.animationID;
        this.skipAni.loop = dialogData.skipBox.playType == 2 ? true : false;
        this.skipAniPoint.x = dialogData.skipBox.posX ? dialogData.skipBox.posX : 0;
        this.skipAniPoint.y = dialogData.skipBox.posY ? dialogData.skipBox.posY : 0;
        this.skipAni.alpha = dialogData.skipBox.alpha;
        return dialogData;
    };
    /**
     * 刷新选项位置
     * @param list
     * @param isRecentStyle 是否最近样式
     */
    GameDialog.prototype.updateOptionPostion = function () {
        //获得数据改变属性
        var dialogData = (GameDialog.changeData && GameDialog.changeData.id == this.dialogData.id) ? this.changeDialog(GameDialog.changeData) : this.dialogData;
        //如果修改数据不存在，则获取上一个样式
        //if(!GameDialog.changeData)dialogData = GameDialog.lastDialog.changeDialogData;
        // 选项
        if (!dialogData.optionBox.grid9img1)
            dialogData.optionBox.grid9img1 = "0,0,0,0,0";
        if (!dialogData.optionBox.grid9img2)
            dialogData.optionBox.grid9img2 = "0,0,0,0,0";
        if (!dialogData.optionBox.grid9img3)
            dialogData.optionBox.grid9img3 = "0,0,0,0,0";
        if (!dialogData.optionBox.grid9img4)
            dialogData.optionBox.grid9img4 = "0,0,0,0,0";
        this.optionBox.x = dialogData.optionBox.x;
        this.optionBox.y = dialogData.optionBox.y;
        this.optionBox.alpha = dialogData.optionBox.alpha;
        this.dialogOptionBoxTextMaterial = this.dialogData.optionBox.materialData && this.dialogData.optionBox.materialData.length > 0 && this.dialogData.optionBox.materialData[0].materials.length > 0;
        // 选项文本
        this.optionText.x = dialogData.option.x;
        this.optionText.y = dialogData.option.y;
        this.optionText.alpha = dialogData.option.alpha;
        this.dialogOptionTextMaterial = this.dialogData.option.materialData && this.dialogData.option.materialData.length > 0 && this.dialogData.option.materialData[0].materials.length > 0;
        return dialogData;
    };
    /**
     * 按照大小排序(从小到大)
     * @param list
     */
    GameDialog.prototype.orderByIndex = function (list) {
        list.sort(function (a, b) {
            if (a.index == b.index)
                return a.index < b.index ? 1 : -1;
            return a.index > b.index ? 1 : -1;
        });
    };
    /**
     * 设置对话内容
     * @param head 头像参数
     * @param name 名称
     * @param playSpeed 文字播放速度
     * @param msg 内容
     * @param audio 语音
     * @param exp 立绘模式时的表情
     * @param nameColor 名字颜色
     * @param changeData 修改组件属性数据
     */
    GameDialog.prototype.setContent = function (head, name, playSpeed, msg, audio, exp, nameColor, changeData) {
        //还原位置
        GameDialog.changeData = changeData;
        var dialogData = this.updateDialogPostion();
        this.changeDialogData = dialogData;
        // -- 清理延迟停止
        this.clearDelayStop();
        this.playSpeed = playSpeed;
        this.playTextIndex = 0;
        this.playTextLabelIndex = 0;
        this.skipAni.visible = false;
        this.skipAni.stop();
        this.lastTextPosX = this.lastTextPosY = 0;
        this.forceShow = false;
        this.hasSkip = false;
        this.playTextLabels.length = 0;
        this.optionClear();
        this.dialogText.removeChildren();
        this.headBox.removeChildren();
        this.nameText.text = name;
        // -- 作用名字材质：克隆数据是为了每次播放时，时间是重置的
        if (this.dialogMaterialEnabled && name && this.dialogNameTextMaterial) {
            this.nameText.installMaterialData(ObjectUtils.depthClone(dialogData.nameBox.materialData));
        }
        if (nameColor)
            this.nameText.color = nameColor;
        // 刷新头像显示
        this.refreshHeadBox(head, exp);
        // 播放语音
        // trace(audio, "+++++++++语音+++++++++++++",GameAudio.tsVolume);
        if (audio) {
            if (GameDialog.tschannel) {
                GameAudio.stopTS(GameDialog.tschannel);
            }
            GameDialog.tschannel = GameAudio.playTS(audio);
            if (GameDialog.tschannel) {
                GameDialog.tschannel.once(EventObject.COMPLETE, this, function (audio) {
                    GameDialog.tschannel = null;
                    EventUtils.happen(GameDialog, GameDialog.EVENT_TS_PLAY_COMPLETE, [true, audio]);
                }, [audio]);
                GameDialog.tschannel.once(EventObject.ERROR, this, function (audio) {
                    GameDialog.tschannel = null;
                    EventUtils.happen(GameDialog, GameDialog.EVENT_TS_PLAY_COMPLETE, [false, audio]);
                }, [audio]);
            }
        }
        // 对话框背景的材质
        if (this.dialogMaterialEnabled && this.dialogBoxMaterial) {
            this.dialogBox.installMaterialData(ObjectUtils.depthClone(dialogData.dialogBox.materialData));
        }
        // text
        this.waitTimeArr.length = 0;
        this.waitStart = 0;
        var textContent = GameDialog.handleText(msg, dialogData.dialog.color, this);
        var Labels = textContent.match(GameDialog.COLOR_FORMAT);
        if (!Labels) {
            EventUtils.happen(GameDialog, GameDialog.EVENT_DIALOG_WORD_PLAY_COMPLETE, [true]);
            this.playing = false;
            //显示跳过标志
            this.skipAni.visible = true;
            if (dialogData.skipBox.posIndex == 0) {
                this.skipAni.x = dialogData.skipBox.x;
                this.skipAni.y = dialogData.skipBox.y;
            }
            else {
                this.skipAni.x = this.dialogText.x + this.lastTextPosX + this.skipAniPoint.x;
                this.skipAni.y = this.dialogText.y + this.lastTextPosY + this.skipAniPoint.y;
            }
            this.skipAni.gotoAndPlay();
            return;
        }
        // 存在材质的话，逐字拆分出来
        if (this.dialogTextMaterial) {
            var newLabels = [];
            for (var i = 0; i < Labels.length; i++) {
                var Label = Labels[i];
                // 抓出前缀
                var LabelHeadIndex = Label.indexOf(">") + 1;
                var LabelHead = Label.substr(0, LabelHeadIndex);
                var LabelTailIndex = Label.lastIndexOf("<");
                var LabelTail = Label.substr(LabelTailIndex);
                var LabelContent = Label.substr(LabelHeadIndex, LabelTailIndex - LabelHeadIndex);
                for (var s = 0; s < LabelContent.length; s++) {
                    var newLabelContent = LabelHead + LabelContent[s] + LabelTail;
                    newLabels.push(newLabelContent);
                }
            }
            Labels = newLabels;
        }
        // trace("--------------------------------------");
        var rowIndex = 0;
        var startX = 0;
        var letterSpaceing = 0;
        for (var i = 0; i < Labels.length; i++) {
            var unitSpan = Labels[i];
            var color = unitSpan.match(/#[0-9a-zA-Z]{6,6}/g)[0];
            if (color == GameDialog.TRANS_PARENT_COLOR) {
                color = dialogData.dialog.color;
            }
            // 根据换行符切割
            // 追加：如果超过了文本宽度则需要切割
            var lines = unitSpan.split("\n");
            for (var s = 0; s < lines.length; s++) {
                if (s > 0) {
                    rowIndex++;
                    startX = 0;
                    letterSpaceing = 0;
                }
                //计算文本居左颜色分割的字间距
                letterSpaceing = dialogData.dialog.letterSpacing ? dialogData.dialog.letterSpacing : 0;
                var text = StringUtils.clearHtmlTag(lines[s]);
                // 去除特殊符号的文本，根据该文本测量文本宽度以便计算位置（含Skip位置）
                var realText = text.replace(GameDialog.KEY_SYMBOL_reg, "");
                var tf = new UIComponent.UIString();
                ObjectUtils.clone(dialogData.dialog, tf);
                tf.wordWrap = false;
                tf.text = realText;
                tf.color = color;
                tf.x = startX + letterSpaceing;
                var tfStartX = startX + letterSpaceing;
                this.lastTextPosY = tf.y = rowIndex * (tf.fontSize + dialogData.dialog.leading);
                this.lastTextPosX = tf.x + tf.textWidth;
                startX = tfStartX + tf.textWidth;
                this.dialogText.addChild(tf);
                this.playTextLabels.push(tf);
                // 记录实际播放的文本
                tf["playText"] = text;
                // --- 自动换行
                if (dialogData.dialog.wordWrap) {
                    var minTextAreaWidth = Math.max(0, dialogData.dialog.width);
                    // --- 如果超出文本则计算低于该文本的宽度
                    if (tfStartX + tf.textWidth > minTextAreaWidth) {
                        // 找到【文字效果】符号的原位置占用，发现是该位置的话则忽略掉
                        var keySymbolMatchs = text.match(GameDialog.KEY_SYMBOL_reg);
                        var keySymbolIndexArr = {};
                        if (keySymbolMatchs) {
                            var startIndex = 0;
                            for (var m = 0; m < keySymbolMatchs.length; m++) {
                                var keySymbol = keySymbolMatchs[0];
                                var keySymbolIndex = text.indexOf(keySymbol, startIndex);
                                for (var x = 0; x < keySymbol.length; x++)
                                    keySymbolIndexArr[keySymbolIndex + x] = true;
                                startIndex = keySymbolIndex + keySymbol.length;
                            }
                        }
                        // -- (*) 目前采用遍历，以后可使用二分法进行优化，遍历的方式100次平均要花费50次找到，二分法7次左右找到
                        for (var g = text.length - 1; g >= 0; g--) {
                            // 如果该索引是文字效果的话则下一个
                            if (keySymbolIndexArr[g])
                                continue;
                            var trySplitText = text.substr(0, g);
                            var trySplitRealText = trySplitText.replace(GameDialog.KEY_SYMBOL_reg, "");
                            tf.text = trySplitRealText;
                            // 找到了符合宽度的字符串片段或已经完毕了
                            if (tfStartX + tf.textWidth <= minTextAreaWidth || g == 0) {
                                // 实际显示切割后满足宽度范围内的在文本
                                tf["playText"] = trySplitText;
                                // 剩余文本以相同样式插入到下一条中
                                var surplusText = text.substr(g);
                                lines.splice(s + 1, 0, surplusText);
                                break;
                            }
                        }
                    }
                }
                // 置空文本，后面使用play的方式播放文本
                tf.text = "";
            }
        }
        // 速度设置
        this.playTextLoopMod = 1;
        if (playSpeed == 0) {
            this.playTextLoopMod = 10;
        }
        else if (playSpeed == 1) {
            this.playTextLoopMod = 7;
        }
        else if (playSpeed == 2) {
            this.playTextLoopMod = 5;
        }
        else if (playSpeed == 3) {
            this.playTextLoopMod = 3;
        }
        // 立即播放
        if (playSpeed == 5) {
            this.playText();
        }
        // 播放开始
        this.playing = this.playSpeed != 5;
        this.playTextLoop = 0;
        os.remove_ENTERFRAME(this.playText, this);
        os.add_ENTERFRAME(this.playText, this);
    };
    /**
     * 改变对话框组件
     * @param change 更改 id-对话框id atts-改变属性 time-时间帧 transitionMode-过渡方式 nonTweenType-无法渐变过渡的属性处理方式 mode-类型(立即，渐变)
     * @param fin 回调
     * @param
     */
    GameDialog.prototype.changeDialog = function (change) {
        var dialogData = new DialogData();
        //复制数据
        for (var attID in this.dialogData) {
            var att = this.dialogData[attID];
            for (var a in att) {
                dialogData[attID][a] = att[a];
            }
        }
        if (!change)
            return dialogData;
        //os.remove_ENTERFRAME(this.dialogMoveFrameUpdate, this);
        //立即变更
        if (change.mode == 0) {
            // for (var compID in change.atts) {
            //     var uiComp = this.nameMapping[compID];
            //     if (uiComp) {
            //         var attsValues = change.atts[compID][0];
            //         for (var attName in attsValues) {
            //             var attValue = attsValues[attName];
            //             this.changes(uiComp, compID, attName, attValue);
            //         }
            //     }
            // }
            for (var compID in change.atts) {
                var comp = dialogData[compID];
                if (comp) {
                    var attsValues = change.atts[compID][0];
                    for (var attName in attsValues) {
                        var attValue = attsValues[attName];
                        comp[attName] = attValue;
                    }
                }
            }
        }
        return dialogData;
        //渐变（暂时作废）
        // else {
        //     var m = {
        //         time: change.time,
        //         curTime: 1,
        //         transData: GameUtils.getTransData(change.transitionMode),
        //         attrInfos: []
        //     }
        //     for (var compID in change.atts) {
        //         var uiComp = this.nameMapping[compID];
        //         if (uiComp) {
        //             var attsValues = change.atts[compID][0];
        //             var useVarAndTransitionAttrs: any = change.atts[compID][1];
        //             for (var attName in attsValues) {
        //                 var oldValue = uiComp[attName];
        //                 var needTween = typeof oldValue == "number";
        //                 var useVarAndTransition: { index: number, change: boolean, type: number } = useVarAndTransitionAttrs[attName];
        //                 if (useVarAndTransition) {
        //                     // 如果并非过渡渐变的话则表示立即变更，效果会受到「无法渐变的属性处理」影响
        //                     if (!useVarAndTransition.change) {
        //                         needTween = false;
        //                     }
        //                 }
        //                 var newValue = attsValues[attName];
        //                 var attrInfo = { uiComp: uiComp, uiCompID: uiComp.id, attName: attName, oldValue: oldValue, needTween: needTween, newValue: newValue, compID: compID };
        //                 m.attrInfos.push(attrInfo);
        //             }
        //         }
        //     }
        //     os.add_ENTERFRAME(this.dialogMoveFrameUpdate, this, [m, change.nonTweenType]);
        // }
    };
    /**
     * 对话框界面元件的逐帧执行的函数
     */
    GameDialog.prototype.dialogMoveFrameUpdate = function (m, nonTweenType) {
        var per = m.curTime / m.time;
        for (var i = 0; i < m.attrInfos.length; i++) {
            var attrInfo = m.attrInfos[i];
            if (!attrInfo.needTween) {
                // 无法渐变过渡的属性处理方式：在第一帧时变动/在最后一帧变动
                if ((nonTweenType == 0 && m.curTime == 1) || (nonTweenType == 1 && per == 1)) {
                    this.changes(attrInfo.uiComp, attrInfo.compID, attrInfo.attName, attrInfo.newValue);
                }
            }
            else {
                var valuePer = GameUtils.getValueByTransData(m.transData, per);
                this.changes(attrInfo.uiComp, attrInfo.compID, attrInfo.attName, (attrInfo.newValue - attrInfo.oldValue) * valuePer + attrInfo.oldValue);
            }
        }
        m.curTime++;
    };
    /**
     * 属性更改
     */
    GameDialog.prototype.changes = function (uiComp, compID, attName, v) {
        if (compID == "skipBox") {
            switch (attName) {
                case "scaleNumber":
                    this.skipAni.scaleX = this.skipAni.scaleY = v;
                    return;
                case "animationID":
                    this.skipAni.id = v;
                    return;
                case "playType":
                    this.skipAni.loop = v == 2 ? true : false;
                    return;
                case "posX":
                    this.skipAniPoint.x = v;
                    return;
                case "posY":
                    this.skipAniPoint.y = v;
                    return;
                case "posIndex":
                    this.dialogData.skipBox.posIndex = v;
                    return;
            }
        }
        if (compID == "headBox") {
            switch (attName) {
                case "flip":
                    this.headBox.scaleX = v ? -1 : 1;
                    return;
            }
        }
        if (compID == "dialog" && (attName != "x" && attName != "y" && attName != "height" && attName != "width")) {
            //遍历文本赋值
            this.playTextLabels.forEach(function (a, i) {
                a[attName] = v;
            });
            return;
        }
        if (uiComp[attName])
            uiComp[attName] = v;
    };
    // private enfren(){
    //     this.playText();
    //     //
    //     .....
    // }
    /**
     * 释放头像
     */
    GameDialog.prototype.disposeHead = function () {
        if (this.headImg) {
            this.headImg.dispose();
            this.headImg = null;
        }
        if (this.headStand) {
            this.headStand.dispose();
            this.headStand = null;
        }
        if (this.headAni) {
            this.headAni.dispose();
            this.headAni = null;
        }
        if (this.headUI) {
            this.headUI.dispose();
            this.headUI = null;
        }
    };
    /**
     * 刷新头像显示
     * @param param 参数
     * @param exp 表情
     */
    GameDialog.prototype.refreshHeadBox = function (param, exp) {
        if (!this.dialogData)
            return;
        var mode = this.dialogData.headBox.perviewMode;
        if (!mode) { //图片
            if (typeof param === "string") {
                if (!this.headImg)
                    this.headImg = new UIComponent.UIBitmap();
                this.headImg.visible = false;
                if (this.headImg.image != param)
                    this.headImg.once(EventObject.LOADED, this, this.refreshBitmapSize);
                else
                    this.refreshBitmapSize();
                this.headBox.addChild(this.headImg);
                this.headImg.image = param;
            }
            else {
                param = null;
            }
        }
        else if (mode == 1) { //立绘
            var standID = MathUtils.int(param);
            if (standID > 0) {
                if (!this.headStand)
                    this.headStand = new UIComponent.UIStandAvatar();
                this.headStand.avatar.syncLoadWhenAssetExist = true;
                if (Config.EDIT_MODE)
                    this.headStand.avatar.forceRender = true;
                this.headStand.avatarID = standID;
                if (!exp || exp < 1)
                    exp = 1;
                this.headStand.actionID = exp;
                this.headStand.scale(this.changeDialogData.headBox.viewscaleX, this.changeDialogData.headBox.viewscaleY);
                this.headStand.isPlay = true;
                this.headStand.playOnce = this.changeDialogData.headBox.viewPlayOnce;
                this.headStand.avatarFPS = this.changeDialogData.headBox.viewFps;
                this.headBox.addChild(this.headStand);
            }
        }
        else if (mode == 2) { //动画
            var aniID = MathUtils.int(param);
            if (aniID > 0) {
                if (!this.headAni)
                    this.headAni = new UIComponent.UIAnimation();
                this.headBox.addChild(this.headAni);
                this.headAni.animation.syncLoadWhenAssetExist = true;
                this.headAni.animation.showHitEffect = true;
                this.headAni.animationID = aniID;
                this.headAni.playFps = this.changeDialogData.headBox.viewFps;
                this.headAni.scale(this.changeDialogData.headBox.viewscaleX, this.changeDialogData.headBox.viewscaleY);
                this.headAni.playType = this.changeDialogData.headBox.viewPlayOnce ? 1 : 2;
            }
        }
        else if (mode == 3) { //界面
            var uiID = MathUtils.int(param);
            if (uiID > 0) {
                if (this.headUI)
                    this.headUI.offAll(EventObject.LOADED);
                this.headUI = GameUI.load(uiID, true);
                this.headUI.visible = false;
                this.headUI.once(EventObject.LOADED, this, this.refreshUISize);
                this.headBox.addChild(this.headUI);
            }
        }
        if (this.dialogMaterialEnabled && this.dialogHeadBoxMaterial) {
            this.headBox.installMaterialData(ObjectUtils.depthClone(this.dialogData.headBox.materialData));
        }
    };
    GameDialog.prototype.refreshBitmapSize = function () {
        var tex = loader.getRes(this.headImg.image);
        if (!tex)
            return;
        if (this.changeDialogData.headBox.locksize) { //锁定尺寸
            if (!this.changeDialogData.headBox.adaptation) { //宽高比例自适应
                this.headImg.width = this.headBox.width;
                this.headImg.height = this.headBox.height;
            }
            else {
                var per = GameUtils.getAutoFitSizePre(new Rectangle(0, 0, tex.width, tex.height), new Rectangle(0, 0, this.headBox.width, this.headBox.height));
                this.headImg.width = per * tex.width;
                this.headImg.height = per * tex.height;
            }
        }
        else {
            this.headImg.width = tex.width;
            this.headImg.height = tex.height;
        }
        this.headImg.visible = true;
    };
    GameDialog.prototype.refreshUISize = function () {
        var _this = this;
        this.headUI.scale(1, 1);
        var uiRect = this.headUI.getBounds();
        if (!uiRect.width || !uiRect.height) {
            Callback.New(function () {
                _this.refreshUISize();
            }, this).delayRun(100);
        }
        else {
            if (this.changeDialogData.headBox.locksize) { //锁定尺寸
                if (!this.changeDialogData.headBox.adaptation) { //宽高比例自适应
                    var perx = this.headBox.width / uiRect.width;
                    var pery = this.headBox.height / uiRect.height;
                    this.headUI.scale(perx, pery);
                }
                else {
                    var per = GameUtils.getAutoFitSizePre(new Rectangle(0, 0, uiRect.width, uiRect.height), new Rectangle(0, 0, this.headBox.width, this.headBox.height));
                    this.headUI.scale(per, per);
                }
            }
            this.headUI.visible = true;
        }
    };
    /**
     * 停止
     */
    GameDialog.prototype.stop = function (disposeHead) {
        if (disposeHead === void 0) { disposeHead = true; }
        os.remove_ENTERFRAME(this.playText, this);
        if (this.parent) {
            this.parent.removeChild(this);
        }
        if (disposeHead)
            this.disposeHead();
        this.playing = false;
        GameDialog.isCloseDialog = true;
        this.clearDelayStop();
        if (GameDialog.maskLayer)
            GameDialog.maskLayer.removeSelf();
        GameDialog.unbindingSoPosition();
        EventUtils.happen(GameDialog, GameDialog.EVENT_DIALOG_CLOSE, [GameDialog.lastDialog]);
    };
    /**
     * 停止播放语音
     */
    GameDialog.prototype.stopTsAudio = function () {
        if (GameDialog.tschannel) {
            GameDialog.tschannel.offAll();
            GameAudio.stopTS(GameDialog.tschannel);
            GameDialog.tschannel = null;
        }
    };
    /**
     * 清理延迟停止的功能
     */
    GameDialog.prototype.clearDelayStop = function () {
        if (this.delayStop) {
            clearTimeout(this.delayStop);
            this.delayStop = null;
        }
        //清理跳过标志延时
        if (this.skipAniDelay) {
            clearTimeout(this.skipAniDelay);
            this.skipAniDelay = null;
        }
    };
    /**
     * 清理选项
     */
    GameDialog.prototype.optionClear = function () {
        this.optionBox.removeChildren();
        this.optionText.removeChildren();
    };
    /**
     * 设置选项
     * @param options 选项
     * @param defaultIndex [可选] 默认值=-1 默认选中索引
     * @param cancelIndex [可选] 默认值=-1 取消索引
     * @param hideIndexs 隐藏选项的索引
     */
    GameDialog.prototype.setOption = function (options, defaultIndex, cancelIndex, hideIndexs) {
        if (defaultIndex === void 0) { defaultIndex = -1; }
        if (cancelIndex === void 0) { cancelIndex = -1; }
        if (hideIndexs === void 0) { hideIndexs = []; }
        this.optionClear();
        var dialogData = this.updateOptionPostion();
        this.changeDialogData = dialogData;
        var column = dialogData.optionBox.column;
        if (!this.optionList) {
            this.optionList = new UIComponent.UIList();
            this.optionList.overSelectMode = true;
        }
        this.hidedIndexs = hideIndexs;
        this.optionList.itemModelClass = GameDialogOption;
        this.optionList.itemWidth = dialogData.optionBox.width;
        this.optionList.itemHeight = dialogData.optionBox.height;
        this.optionList.spaceX = dialogData.optionBox.columnSpaceing;
        this.optionList.spaceY = dialogData.optionBox.rowSpaceing;
        this.optionList.repeatX = column;
        this.optionList.width = column * (dialogData.optionBox.width + dialogData.optionBox.columnSpaceing) + this.optionList.scrollWidth;
        this.optionList.height = Math.ceil(options.length / column) * (dialogData.optionBox.height + dialogData.optionBox.rowSpaceing) + this.optionList.scrollWidth;
        this.optionList.selectImageURL = dialogData.optionBox.selectImageURL;
        this.optionList.selectImageGrid9 = dialogData.optionBox.grid9img4;
        this.optionList.cancelSelectedIndex = (cancelIndex != null && cancelIndex >= 0) ? cancelIndex : -1;
        // LIST内部按键允许的情况
        this.optionList.once(UIComponent.UIList.ITEM_CLICK, this, this.onClick, [{ target: null }, true]);
        // 未支持LIST快捷键操作的话则直接注册ESC取消
        if (!UIComponent.UIList.KEY_BOARD_ENABLED) {
            stage.off(EventObject.KEY_DOWN, this, this.onKeyDow);
            if (cancelIndex >= 0)
                stage.on(EventObject.KEY_DOWN, this, this.onKeyDow);
        }
        //如果存在取消索引则添加右键屏幕取消
        if (cancelIndex > -1 && hideIndexs.indexOf(cancelIndex) < 0) {
            stage.off(EventObject.RIGHT_MOUSE_DOWN, this, this.rightDown);
            stage.once(EventObject.RIGHT_MOUSE_DOWN, this, this.rightDown);
        }
        var items = [];
        for (var i = 0; i < options.length; i++) {
            var d = new UIListItemData();
            items.push(d);
        }
        this.optionList.items = items;
        this.optionTexts = [];
        for (var i = 0; i < options.length; i++) {
            var optionSp = this.optionList.getItemUI(i);
            optionSp.setData(dialogData);
            var opText = new UIComponent.UIString();
            ObjectUtils.clone(dialogData.option, opText);
            opText.wordWrap = false;
            opText.text = options[i];
            opText.x = optionSp.x;
            opText.y = optionSp.y;
            this.optionText.addChild(opText);
            this.optionTexts.push(opText);
            //事件
            optionSp.add_MOUSEDOWN(this.onOptionMouseDown, this, [i]);
            optionSp.add_MOUSEOVER(this.onOptionMouseOver, this, [i]);
            optionSp.add_MOUSEUP(this.onOptionMouseOut, this, [i]);
            optionSp.add_MOUSEOUT(this.onOptionMouseOut, this, [i]);
            // -- 选项文本的材质
            if (this.dialogMaterialEnabled && this.dialogOptionTextMaterial) {
                opText.installMaterialData(ObjectUtils.depthClone(dialogData.option.materialData));
            }
        }
        this.optionBox.addChild(this.optionList);
        UIComponent.UIList.focus = this.optionList;
        defaultIndex = (defaultIndex != null && defaultIndex >= 0) ? defaultIndex : 0;
        this.optionList.selectedIndex = defaultIndex;
        //
        EventUtils.happen(GameDialog, GameDialog.EVENT_DIALOG_WORD_PLAY_COMPLETE, [true]);
        if (this.dialogText.visible && this.nameText.visible && this.headBox.visible && this.dialogBox.visible) {
            //显示跳过标志
            this.skipAni.visible = true;
            if (dialogData.skipBox.posIndex == 0) {
                this.skipAni.x = dialogData.skipBox.x;
                this.skipAni.y = dialogData.skipBox.y;
            }
            else {
                this.skipAni.x = this.dialogText.x + this.lastTextPosX + this.skipAniPoint.x;
                this.skipAni.y = this.dialogText.y + this.lastTextPosY + this.skipAniPoint.y;
            }
            this.skipAni.gotoAndPlay();
        }
        // -- 选项背景框的材质
        if (this.dialogMaterialEnabled && this.dialogOptionBoxTextMaterial) {
            this.optionList.installMaterialData(ObjectUtils.depthClone(dialogData.optionBox.materialData));
        }
    };
    /**
     * 快捷键
     * @param e
     */
    GameDialog.prototype.onKeyDow = function (e) {
        // 修正已注册事件后中途更改了UIComponent.UIList.KEY_BOARD_ENABLED仍然触发该逻辑的错误
        if (UIComponent.UIList.KEY_BOARD_ENABLED)
            return;
        if (e.keyCode == Keyboard.ESCAPE) {
            if (this.optionList.cancelSelectedIndex >= 0 && this.optionList.cancelSelectedIndex < this.optionList.items.length) {
                this.optionList.selectedIndex = this.optionList.cancelSelectedIndex;
                this.onClick({ target: null }, true);
            }
        }
    };
    /**
     * 右快捷键
     */
    GameDialog.prototype.rightDown = function () {
        this.optionList.selectedIndex = this.optionList.cancelSelectedIndex;
        this.onClick({ target: null }, true);
    };
    GameDialog.prototype.onOptionMouseDown = function (index) {
        var text = this.optionText.getChildAt(index);
        if (!text)
            return;
        text.color = this.changeDialogData.option.clickColor;
    };
    GameDialog.prototype.onOptionMouseOver = function (index) {
        if (this.dialogData.optionBox.overSe) {
            GameAudio.playSE(this.optionOverSE, this.changeDialogData.optionBox.overVolume, this.changeDialogData.optionBox.overPitch);
        }
        //文字颜色
        for (var i = 0; i < this.optionText.numChildren; i++) {
            var text = this.optionText.getChildAt(i);
            if (!text)
                continue;
            if (i == index) {
                text.color = this.changeDialogData.option.overColor;
            }
            else {
                text.color = this.changeDialogData.option.color;
            }
        }
    };
    GameDialog.prototype.onOptionMouseOut = function (index) {
        var text = this.optionText.getChildAt(index);
        if (!text)
            return;
        text.color = this.changeDialogData.option.color;
    };
    /**
     * 播放文本
     * @param force 是否强制播放，否则会按照当前播放速度等待一定帧数
     */
    GameDialog.prototype.playText = function (waitFrame) {
        var _this = this;
        if (waitFrame === void 0) { waitFrame = true; }
        if (this.waitPlayerClick)
            return;
        if (waitFrame && this.playSpeed != 5 && this.playTextLoop++ % this.playTextLoopMod != 0)
            return;
        var tf = this.playTextLabels[this.playTextIndex];
        if (!tf) {
            this.playing = false;
            os.remove_ENTERFRAME(this.playText, this);
            if (this.changeDialogData.skipBox.posIndex == 0) {
                this.skipAni.x = this.changeDialogData.skipBox.x;
                this.skipAni.y = this.changeDialogData.skipBox.y;
            }
            else {
                this.skipAni.x = this.dialogText.x + this.lastTextPosX + this.skipAniPoint.x;
                this.skipAni.y = this.dialogText.y + this.lastTextPosY + this.skipAniPoint.y;
            }
            //延迟显示跳过标志
            this.skipAniDelay = setTimeout(function () {
                _this.skipAni.visible = true;
                _this.skipAni.gotoAndPlay();
                EventUtils.happen(GameDialog, GameDialog.EVENT_DIALOG_WORD_PLAY_COMPLETE, [!_this.forceShow]);
            }, (this.playSpeed == 5) ? 0 : this.changeDialogData.skipBox.delayTime * 1000);
            return;
        }
        var word = tf["playText"][this.playTextLabelIndex];
        if (!word) {
            this.playTextLabelIndex = 0;
            this.playTextIndex++;
            this.playText(false);
            return;
        }
        // 如果存在材质的情况
        if (this.dialogMaterialEnabled && this.dialogTextMaterial && this.playSpeed != 5) {
            tf.installMaterialData(ObjectUtils.depthClone(this.dialogData.dialog.materialData));
        }
        this.playTextLabelIndex++;
        if (word == GameDialog.KEY_SYMBOL_DELAY) {
            if (this.waitStart == 0) {
                this.waitStart = this.waitTimeArr.shift();
                EventUtils.happen(GameDialog, GameDialog.EVENT_DIALOG_TEXT_WAIT_TIME, [this.waitStart]);
            }
            this.waitStart--;
            // continue
        }
        else if (word == GameDialog.KEY_SYMBOL_SKIP) {
            this.hasSkip = true;
            if (!this.forceShow && this.playSpeed != 5) {
                this.playing = false;
                this.onClick(null, true, true);
            }
            return;
        }
        else if (word == GameDialog.KEY_SYMBOL_WAIT_PLAYER_CLICK) {
            if (this.playSpeed != 5) {
                this.waitPlayerClick = true;
                EventUtils.happen(GameDialog, GameDialog.EVENT_WAIT_PALYER_OPERATION, [0]);
            }
        }
        else {
            tf.text += word;
            if (!this.forceShow && this.playSpeed != 5)
                EventUtils.happen(GameDialog, GameDialog.EVENT_DIALOG_WORD_PLAY, [word]);
        }
        if (this.playSpeed == 5)
            this.playText();
    };
    /**
     * 清理文本的材质效果
     */
    GameDialog.prototype.clearTextMaterials = function () {
        for (var i_1 = 0; i_1 < this.playTextLabels.length; i_1++) {
            this.playTextLabels[i_1].clearMaterials();
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    GameDialog.prototype.onSelfClick = function (e) {
        if (GameDialog.optionMode) {
            this.onClick(e, false);
        }
    };
    /**
     * 点击时
     * @param e
     * @param listItemClick [可选] 默认值=true 点击list元素
     * @param fromAutoPlaySkipSign [可选] 默认值=false 来自自动播放的[跳过本次对话]标识
     */
    GameDialog.prototype.onClick = function (e, listItemClick, fromAutoPlaySkipSign) {
        if (listItemClick === void 0) { listItemClick = true; }
        if (fromAutoPlaySkipSign === void 0) { fromAutoPlaySkipSign = false; }
        if (Config.EDIT_MODE && !GameDialog.container)
            return;
        if (!listItemClick && GameDialog.optionMode)
            return;
        // if (!listItemClick && GameDialog.optionMode && UIComponent.UIList.KEY_BOARD_ENABLED) return;
        // 如果已关闭的情况下则不再允许提交
        if (GameDialog.isCloseDialog)
            return;
        if (this.playing) {
            if (this.waitPlayerClick) {
                this.waitPlayerClick = false;
                EventUtils.happen(GameDialog, GameDialog.EVENT_WAIT_PALYER_OPERATION, [1]);
                return;
            }
            // 不允许用户操快速显示当前文本的情况
            if (!GameDialog.dialogTextShowAllEnabled)
                return;
            this.forceShow = true;
            this.playSpeed = 5;
            this.playText();
            this.clearTextMaterials();
        }
        else if (GameDialog.showOptionWithLastDialog) {
            GameDialog.showOption(this.id, GameDialog.showOptionWithLastDialog, true, GameDialog.showOptionWithLastDialogParams[0], GameDialog.showOptionWithLastDialogParams[1], GameDialog.showOptionWithLastDialogParams[2]);
        }
        else {
            //
            var lastCurrentDialogSign = GameDialog.currentDialogSign;
            GameDialog.isCloseDialog = true;
            EventUtils.happen(GameDialog, GameDialog.EVENT_DIALOG_END, [GameDialog.lastDialog, fromAutoPlaySkipSign]);
            // 如果不存在新的标识说明没有新的对话，延迟关闭掉对话框界面
            if (GameDialog.currentDialogSign == lastCurrentDialogSign) {
                if (GameDialog.lastDialog) {
                    // delayStop只有一个记录
                    GameDialog.lastDialog.clearDelayStop();
                    GameDialog.lastDialog.delayStop = setTimeout(function (lastDialog) {
                        lastDialog.stop();
                    }, GameDialog.delayCloseTime, this, [GameDialog.lastDialog]);
                }
            }
            if (GameDialog.optionMode) {
                if (this.optionClickSE)
                    GameAudio.playSE(this.optionClickSE, this.changeDialogData.optionBox.clickVolume, this.changeDialogData.optionBox.clikcPitch);
                if (e.target && !(e.target.parent instanceof GameDialogOption))
                    return;
                var index = this.optionList.selectedIndex;
                for (var i = 0; i < this.hidedIndexs.length; i++) {
                    if (this.hidedIndexs[i] <= index)
                        index += 1;
                }
                //关闭Esc和右键快捷操作
                stage.off(EventObject.KEY_DOWN, this, this.onKeyDow);
                stage.off(EventObject.RIGHT_MOUSE_DOWN, this, this.rightDown);
                GameCommand.inputMessageAndContinueExecute([index]);
            }
            else {
                if (GameDialog.lastDialog && GameDialog.lastDialog.submitCallback) {
                    GameDialog.lastDialog.submitCallback.run();
                }
                else {
                    GameCommand.inputMessageAndContinueExecute();
                }
            }
        }
    };
    Object.defineProperty(GameDialog.prototype, "optionClickSE", {
        /**
         * 选项点击时音效
         * @return [string]
         */
        get: function () {
            if (!this.changeDialogData.optionBox.clickSe)
                this.changeDialogData.optionBox.clickSe = "";
            return this.changeDialogData.optionBox.clickSe.split(",")[0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameDialog.prototype, "optionOverSE", {
        /**
         * 光标移入选项内时的音效
         * @return [string]
         */
        get: function () {
            if (!this.changeDialogData.optionBox.overSe)
                this.changeDialogData.optionBox.overSe = "";
            return this.changeDialogData.optionBox.overSe.split(",")[0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameDialog.prototype, "optionUIs", {
        //------------------------------------------------------------------------------------------------------
        // 上层用API
        //------------------------------------------------------------------------------------------------------
        get: function () {
            if (!this.optionList || !this.optionList.stage)
                return [];
            var arr = [];
            for (var i = 0; i < this.optionList.length; i++) {
                var itemUI = this.optionList.getItemUI(i);
                var btn = itemUI["opBtn"];
                arr.push(btn);
            }
            return arr;
        },
        enumerable: false,
        configurable: true
    });
    //------------------------------------------------------------------------------------------------------
    // API功能
    //------------------------------------------------------------------------------------------------------
    /**
     * 事件：当对话框出现前 回调参数：是否选项、文本内容、选项内容（若是选项的话）、名称、头像参数、立绘表情、语音参数、文字播放速度、名字颜色
     * EventUtils.addEventListener(GameDialog,GameDialog.EVENT_DIALOG_START,Callback.New((isOption:boolean,content:string,options:string[],name:string,head:string, exp:number, tsURL:string, speed:number,nameColor:string)=> {},this));
     */
    GameDialog.EVENT_DIALOG_START = "GameDialogEVENT_DIALOG_START";
    /**
     * 事件：当对话框出现后 回调参数：是否选项
     * EventUtils.addEventListener(GameDialog,GameDialog.EVENT_AFTER_DIALOG_START,Callback.New((isOption:boolean)=> {},this));
     */
    GameDialog.EVENT_AFTER_DIALOG_START = "GameDialogEVENT_AFTER_DIALOG_START";
    /**
     * 事件：当对话框文本结束时 fromAutoPlaySkipSign:boolean = 是否来自文本播放时出现的[跳过本次对话]
     * EventUtils.addEventListener(GameDialog,GameDialog.EVENT_DIALOG_END,Callback.New((gameDialog:GameDialog,fromAutoPlaySkipSign:boolean)=> {},this));
     */
    GameDialog.EVENT_DIALOG_END = "GameDialogEVENT_DIALOG_END";
    /**
     * 事件：当对话框关闭时
     * EventUtils.addEventListener(GameDialog,GameDialog.EVENT_DIALOG_CLOSE,Callback.New((gameDialog:GameDialog)=> {},this));
     */
    GameDialog.EVENT_DIALOG_CLOSE = "GameDialogEVENT_DIALOG_CLOSE";
    /**
     * 事件：当文本框文本播放时 回调参数：当前文字
     * EventUtils.addEventListener(GameDialog,GameDialog.EVENT_DIALOG_WORD_PLAY,Callback.New((word:string)=> {},this));
     */
    GameDialog.EVENT_DIALOG_WORD_PLAY = "GameDialogEVENT_DIALOG_WORD_PLAY";
    /**
     * 事件：当文本播放完成时 isAuto 表示是否来自自动播放
     * EventUtils.addEventListener(GameDialog,GameDialog.EVENT_DIALOG_WORD_PLAY_COMPLETE,Callback.New((isAuto:boolean)=> {},this));
     */
    GameDialog.EVENT_DIALOG_WORD_PLAY_COMPLETE = "GameDialogEVENT_DIALOG_WORD_PLAY_COMPLETE";
    /**
     * 事件：当语音播放完毕时派发（如果该次对话的语音未播放完成时，玩家手动跳过了该次对话的话则不会抛出该事件）
     * EventUtils.addEventListener(GameDialog,GameDialog.EVENT_TS_PLAY_COMPLETE,Callback.New((success:boolean,audioURL:string)=> {
     *   // to do
     * },this));
     */
    GameDialog.EVENT_TS_PLAY_COMPLETE = "GameDialogEVENT_TS_PLAY_COMPLETE";
    /**
     * 事件：当播放文本时遇到等待玩家操作时以及玩家操作完毕后抛出该事件 state=0表示等待玩家操作 state=1表示玩家操作完毕
     * EventUtils.addEventListener(GameDialog,GameDialog.EVENT_WAIT_PALYER_OPERATION,Callback.New((state:number)=> {
     *   // to do
     * },this));
     */
    GameDialog.EVENT_WAIT_PALYER_OPERATION = "GameDialogEVENT_WAIT_PALYER_OPERATION";
    /**
     * 事件：当播放文本时遇到等待时间（帧数）时抛出事件 frameCount=等待的帧数
     * EventUtils.addEventListener(GameDialog,GameDialog.EVENT_DIALOG_TEXT_WAIT_TIME,Callback.New((frameCount:number)=> {
     *   // to do
     * },this));
     */
    GameDialog.EVENT_DIALOG_TEXT_WAIT_TIME = "GameDialogEVENT_DIALOG_TEXT_WAIT_TIME";
    /**
     * 事件：恢复存档时的对话前调用
     * EventUtils.addEventListener(GameDialog,GameDialog.EVENT_BEFORE_RECOVERY_DIALOG,Callback.New((success:boolean,audioURL:string)=> {
     *   // to do
     * },this));
     */
    GameDialog.EVENT_BEFORE_RECOVERY_DIALOG = "GameDialogEVENT_BEFORE_RECOVERY_DIALOG";
    /**
     * 允许用户操快速显示当前文本（空格键/鼠标左键点击）
     */
    GameDialog.dialogTextShowAllEnabled = true;
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 透明色，根据大小写区分的形式给与默认的颜色
     */
    GameDialog.TRANS_PARENT_COLOR = "#FfFffF";
    /**
     * 颜色格式
     */
    GameDialog.COLOR_FORMAT = /<span style=['"]color:#[0-9a-zA-Z]{6,6}['"]>(.|\n)*?<\/span>/g;
    /**
     * 等待的符号
     */
    GameDialog.KEY_SYMBOL_DELAY = String.fromCharCode(1);
    GameDialog.KEY_SYMBOL_WAIT_PLAYER_CLICK = String.fromCharCode(2);
    GameDialog.KEY_SYMBOL_SKIP = String.fromCharCode(3);
    GameDialog.KEY_SYMBOL_reg = new RegExp(GameDialog.KEY_SYMBOL_DELAY + "|" + GameDialog.KEY_SYMBOL_WAIT_PLAYER_CLICK + "|" + GameDialog.KEY_SYMBOL_SKIP, "g");
    /**
     * 延迟关闭对话框时间：由于下一条事件不确定是否
     */
    GameDialog.delayCloseTime = 100;
    /**
     * 对话框缓存
     */
    GameDialog.dialogCache = [];
    return GameDialog;
}(Sprite));
var GameDialogOption = /** @class */ (function (_super) {
    __extends(GameDialogOption, _super);
    function GameDialogOption() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GameDialogOption.prototype.setData = function (dialogData) {
        if (this.isDisposed)
            return;
        var opBtn = this.opBtn = new UIComponent.UIButton();
        this.addChild(opBtn);
        opBtn.width = dialogData.optionBox.width;
        opBtn.height = dialogData.optionBox.height;
        opBtn.image1 = dialogData.optionBox.image1;
        opBtn.grid9img1 = dialogData.optionBox.grid9img1;
        opBtn.image2 = dialogData.optionBox.image2;
        opBtn.grid9img2 = dialogData.optionBox.grid9img2;
        opBtn.image3 = dialogData.optionBox.image3;
        opBtn.grid9img3 = dialogData.optionBox.grid9img3;
    };
    GameDialogOption.prototype.dispose = function () {
        if (!this.isDisposed) {
            this.__isDisposed = true;
            if (this.opBtn)
                this.opBtn.dispose();
            this.opBtn = null;
            this.destroy();
        }
        _super.prototype.disposeSelfAsset.call(this);
    };
    return GameDialogOption;
}(UIComponent.UIRoot));
/**
 * 图像
 * -- 每次接受到一组头像都是独立的（内部等待时间），不会占用玩家输入流程，
 *    事件已停止，但这边不阻止输入，记录一下事件线程ID，读档时需要恢复线程ID（可以映射）
 *    当出现对话时临时再占用输入通道
 *    -- 未在阻塞输入时：直接开始阻塞并要求输入（提交至该图像组的事件线）
 *    -- 在阻塞时则忽略，直到阻塞结束时才进行下去
 *
 * Created by 黑暗之神KDS on 2019-02-06 21:03:38.
 */
var GameImage = /** @class */ (function (_super) {
    __extends(GameImage, _super);
    function GameImage() {
        var _this = _super.call(this) || this;
        _this.mouseEnabled = true;
        return _this;
    }
    Object.defineProperty(GameImage, "imageLayer", {
        get: function () {
            if (GameImage._imageLayer) {
                return GameImage._imageLayer;
            }
            return Game.layer.imageLayer;
        },
        set: function (v) {
            GameImage._imageLayer = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameImage, "uiLayer", {
        get: function () {
            if (GameImage._uiLayer) {
                return GameImage._uiLayer;
            }
            return Game.layer.uiLayer;
        },
        set: function (v) {
            GameImage._uiLayer = v;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 初始化
     */
    GameImage.init = function () {
        // 存在创建版本时则忽略，说明是新工程了，不再支持图像（网络版本暂时仍然支持）
        // 此处仍然应该使用CREATED_GC_VERSION，因为此前是用它来标记的。
        if (Config.CREATED_GC_VERSION && Config.SINGLE_PLAYER_CORE)
            return;
        os.add_ENTERFRAME(this.update, this, [true]);
        if (!Config.EDIT_MODE) {
            EventUtils.addEventListener(GameUI, GameUI.EVENT_CLOSE_SYSTEM_UI, Callback.New(this.onUIClose, this));
            EventUtils.addEventListener(GameUI, GameUI.EVENT_OPEN_SYSTEM_UI, Callback.New(this.onUIOpen, this));
        }
    };
    /**
     * 当打开UI界面时
     */
    GameImage.onUIOpen = function (uiID) {
        var passageID = GameImage.UI_START_PASSAGE + uiID;
        var ui = GameUI.get(uiID);
        if (!ui)
            return;
        GameImage.imageInfos[passageID] = { image: ui };
    };
    /**
     * 当关闭UI界面时
     */
    GameImage.onUIClose = function (uiID) {
        var passageID = GameImage.UI_START_PASSAGE + uiID;
        var imageInfo = GameImage.imageInfos[passageID];
        if (imageInfo && (imageInfo.image instanceof UIComponent.UIRoot)) {
            var ui = imageInfo.image;
            if (ui) {
                delete GameImage.imageInfos[passageID];
            }
        }
    };
    /**
     * 清理全部图片和动画
     */
    GameImage.clear = function () {
        // 清理全部显示
        for (var i in GameImage.imageInfos) {
            var ani = GameImage.imageInfos[i].image;
            if (ani && ani.dispose) {
                ani.dispose();
            }
        }
        GameImage.imageInfos = {};
        // 清理全部组
        for (var s = 0; s < this.executeGroups.length; s++) {
            var group = this.executeGroups[s];
            if (group)
                group.dispose();
        }
        this.executeGroups = [];
    };
    /**
     * 清理所有组的指定通道的
     */
    GameImage.clearPassageMoveEffect = function (id) {
        for (var s = 0; s < this.executeGroups.length; s++) {
            var group = this.executeGroups[s];
            group.clearPassageMoveEffect(id);
        }
    };
    /**
     * 监听图像播放完毕
     */
    GameImage.listenerImageOver = function (triggerLineID) {
        GameImage.listeningWaitImagePlayOvers.push(triggerLineID);
        var c;
        EventUtils.addEventListener(GameImage, GameImage.EVENT_PLAY_OVER, c = Callback.New(function (triggerLineID, groupTriggerLineID) {
            if (groupTriggerLineID == triggerLineID && !GameImage.isPlaying(groupTriggerLineID)) {
                ArrayUtils.remove(GameImage.listeningWaitImagePlayOvers, triggerLineID);
                GameCommand.inputMessageAndContinueExecute(null, true, 1, triggerLineID);
                EventUtils.removeEventListener(GameImage, GameImage.EVENT_PLAY_OVER, c);
            }
        }, this, [triggerLineID]));
    };
    /**
     * 添加图像到图像层中，根据编号的大小插入到对应层中
     * @param id 编号
     * @param image 图像
     */
    GameImage.addImageToLayer = function (id, image) {
        // 记录优先度
        // image.useDPCoord = true;
        // image.dpDisplayPriority = id;
        var newImageInfo = {
            image: image
        };
        var insertImageInfo;
        for (var i in GameImage.imageInfos) {
            var imageInfo = GameImage.imageInfos[i];
            var layerID = parseInt(i);
            if (layerID > id && !(imageInfo.image instanceof UIComponent.UIRoot)) {
                insertImageInfo = imageInfo;
            }
        }
        if (insertImageInfo) {
            var index = GameImage.imageLayer.getChildIndex(insertImageInfo.image);
            if (index != -1) {
                GameImage.imageLayer.addChildAt(image, index);
            }
        }
        else {
            GameImage.imageLayer.addChild(image);
        }
        GameImage.imageInfos[id] = newImageInfo;
        // 刷新显示层次
        // GameImage.imageLayer.updateChildZOrder();
    };
    //------------------------------------------------------------------------------------------------------
    // 图像命令组
    //------------------------------------------------------------------------------------------------------
    /**
     * 添加组
     * @param imageFunctions imageFunction=对应的GameImage方法 args=参数
     * @param
     */
    GameImage.addGroup = function (triggerLineID, imageInfos) {
        if (imageInfos.length == 0)
            return;
        var groupID = ArrayUtils.getNullPosition(GameImage.executeGroups);
        var group = GameImage.executeGroups[groupID] = new GameImageGroup;
        group.setData(triggerLineID, imageInfos);
        group.checkMainPlayOver();
    };
    /**
     * 是否存在播放中的图像（还处于等待中或播放对话中则算作播放）
     * @param triggerLineID 触发线 -1则表示全部触发线（即判定全局是否存在图像组）
     * @return [boolean]
     */
    GameImage.isPlaying = function (triggerLineID) {
        if (triggerLineID == -1) {
            var m = ArrayUtils.matchAttributes(GameImage.executeGroups, { isPlaying: true, mainPlayOver: false }, true);
            return m.length != 0;
        }
        var m = ArrayUtils.matchAttributes(GameImage.executeGroups, { triggerLineID: triggerLineID, isPlaying: true, mainPlayOver: false }, true);
        return m.length != 0;
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 刷新
     * @param realFrame [可选] 默认值=true 推进帧
     */
    GameImage.update = function (realFrame) {
        if (realFrame === void 0) { realFrame = true; }
        for (var i = 0; i < GameImage.executeGroups.length; i++) {
            var group = GameImage.executeGroups[i];
            if (!group)
                continue;
            var isRealPlayOver = group.update(realFrame);
            if (isRealPlayOver) {
                GameImage.executeGroups.splice(i, 1);
                i--;
            }
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 存档和恢复
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取存档数据
     * @return [any]
     */
    GameImage.getSaveData = function () {
        var o = {};
        // 存在创建版本时则忽略，说明是新工程了，不再支持图像（网络版本暂时仍然支持）
        if (Config.CREATED_GC_VERSION && Config.SINGLE_PLAYER_CORE) {
            if (GameDialog.lastDialog && GameDialog.lastDialog.stage) {
                dialog = GameDialog.lastDialog;
                o.dialog = {};
                // 用于区分图像系统中虚拟提交和真提交
                o.dialog.submitEnabled = GameImage.submitEnabled;
                o.dialog.childIndex = GameDialog.lastDialog.parent ? GameDialog.lastDialog.parent.getChildIndex(GameDialog.lastDialog) : null;
                // 用于区分是否来自图像系统
                if (dialog.submitCallback) {
                    o.dialog.submitCallback = dialog.submitCallback ? true : false;
                }
                o.dialog.currentDialogInfo = GameDialog.currentDialogInfo;
            }
            return o;
        }
        // imageInfos + executeGroups + allUI + dialog
        // 图像组
        o.executeGroups = [];
        // 
        for (var i = 0; i < GameImage.executeGroups.length; i++) {
            var group = GameImage.executeGroups[i];
            if (group)
                o.executeGroups.push(group.getSaveData());
            else
                o.executeGroups.push(null);
        }
        // 全图像状态
        o.imageInfos = [];
        for (var passageID in GameImage.imageInfos) {
            var imageInfo = GameImage.imageInfos[passageID];
            if (imageInfo.image instanceof GameImage) {
                var p = imageInfo.image;
                o.imageInfos.push([0, passageID, p.image, p.pivotType, p.x, p.y, p.width, p.height, p.rotation, p.alpha, p.blendMode]);
            }
            else if (imageInfo.image instanceof GCAnimation) {
                var a = imageInfo.image;
                o.imageInfos.push([1, passageID, a.id, a.x, a.y, a.scaleX, a.scaleY, a.rotation, a.alpha, a.loop, a.fps]);
            }
            else if (imageInfo.image instanceof UIComponent.UIStandAvatar) {
                var s = imageInfo.image;
                o.imageInfos.push([2, passageID, s.x, s.y, s.rotation, s.alpha, s.scaleX, s.scaleY, s.avatarID, s.avatarFPS, s.isPlay]);
            }
            else if (imageInfo.image instanceof UIComponent.UIRoot) {
                if (SinglePlayerGame.fileSaveConfig.ui) {
                    var u = imageInfo.image;
                    o.imageInfos.push([3, passageID, u.x, u.y, u.rotation, u.alpha, u.scaleX, u.scaleY, u.guiID]);
                }
            }
        }
        // 界面排序
        o.uis = []; // -1 表示 GameDialog，用于记录顺序
        var uiComps = [];
        o.uiComps = uiComps; // 组件细节
        var numchildren = Game.layer.uiLayer.numChildren;
        var dialog;
        for (var i = 0; i < numchildren; i++) {
            var ui = Game.layer.uiLayer.getChildAt(i);
            if (SinglePlayerGame.fileSaveConfig.ui && ui instanceof UIComponent.UIRoot) {
                var root = ui;
                if (GameUI.get(MathUtils.int(root.guiID))) {
                    o.uis.push(root.guiID);
                    if (SinglePlayerGame.fileSaveConfig.uiComp) {
                        // 遍历预设的组件
                        var allComps = [];
                        var uiCompInfos = {};
                        uiComps.push(uiCompInfos);
                        ArrayUtils.getTreeNodeArray(root, "_childs", allComps);
                        allComps.forEach(function (comp) {
                            if (comp instanceof UIComponent.UIBase) {
                                var uiCompAtts = uiCompInfos[comp.id] = {};
                                // 基础属性记录
                                for (var b in UIComponent.UIBase.BASE_ATTRS_OBJ) {
                                    uiCompAtts[b] = comp[b];
                                }
                                // 自定义属性记录
                                var __compCustomAttributes = GameUI["__compCustomAttributes"];
                                if (__compCustomAttributes) {
                                    var customAttrs = __compCustomAttributes[comp.className];
                                    for (var c in customAttrs) {
                                        var b = customAttrs[c];
                                        uiCompAtts[b] = comp[b];
                                    }
                                }
                            }
                        });
                    }
                }
            }
            else if (ui instanceof GameDialog && !GameDialog.isCloseDialog) {
                o.uis.push(-1);
                if (SinglePlayerGame.fileSaveConfig.uiComp)
                    uiComps.push(null);
                dialog = ui;
            }
        }
        // 对话框
        if (dialog) {
            o.dialog = {};
            // 用于区分图像系统中虚拟提交和真提交
            o.dialog.submitEnabled = GameImage.submitEnabled;
            // 用于区分是否来自图像系统
            if (dialog.submitCallback) {
                o.dialog.submitCallback = dialog.submitCallback ? true : false;
            }
            o.dialog.currentDialogInfo = GameDialog.currentDialogInfo;
        }
        // 正在监听的等待图像播放完毕的行为
        o.listeningWaitImagePlayOvers = GameImage.listeningWaitImagePlayOvers;
        return o;
    };
    /**
     * 恢复存档数据
     * @return [any]
     */
    GameImage.recoverySaveData = function (o) {
        // 存在创建版本时则忽略，说明是新工程了，不再支持图像（网络版本暂时仍然支持）
        if (Config.CREATED_GC_VERSION && Config.SINGLE_PLAYER_CORE) {
            // 恢复对话框
            if (o.dialog) {
                var dialogType = o.dialog.currentDialogInfo.shift();
                // 对话框
                if (dialogType == 0) {
                    if (o.dialog.submitCallback == null) {
                        EventUtils.happen(GameDialog, GameDialog.EVENT_BEFORE_RECOVERY_DIALOG);
                        GameDialog.showDialog.apply(GameDialog, o.dialog.currentDialogInfo);
                    }
                    else {
                        gameDialogLayer = i;
                    }
                }
                // 选项
                else if (dialogType == 1) {
                    // 存在文本显示的话直接显示
                    if (o.dialog.currentDialogInfo.length <= 6)
                        o.dialog.currentDialogInfo.splice(5, 0, []);
                    if (o.dialog.currentDialogInfo[2] && o.dialog.currentDialogInfo[6]) {
                        var dialogInfo = o.dialog.currentDialogInfo[6];
                        dialogInfo.shift();
                        dialogInfo[3] = 5;
                        EventUtils.happen(GameDialog, GameDialog.EVENT_BEFORE_RECOVERY_DIALOG);
                        GameDialog.showDialog.apply(GameDialog, dialogInfo);
                    }
                    // debugger
                    // if(o.dialog.currentDialogInfo[10])GameDialog.changeData = o.dialog.currentDialogInfo[10];
                    GameDialog.showOption.apply(GameDialog, o.dialog.currentDialogInfo);
                }
                // 设置索引
                if (GameDialog.lastDialog && GameDialog.lastDialog.parent && o.dialog.childIndex != null)
                    GameDialog.lastDialog.parent.setChildIndex(GameDialog.lastDialog, o.dialog.childIndex);
            }
            return;
        }
        // 还原UI
        var uis = o.uis;
        var uiComps = o.uiComps;
        var gameDialogLayer = -1;
        for (var i = 0; i < uis.length; i++) {
            var id = uis[i];
            if (id == -1) {
                var dialogType = o.dialog.currentDialogInfo.shift();
                // 对话框
                if (dialogType == 0) {
                    if (o.dialog.submitCallback == null) {
                        EventUtils.happen(GameDialog, GameDialog.EVENT_BEFORE_RECOVERY_DIALOG);
                        GameDialog.showDialog.apply(GameDialog, o.dialog.currentDialogInfo);
                    }
                    else {
                        gameDialogLayer = i;
                    }
                }
                // 选项
                else if (dialogType == 1) {
                    // 存在文本显示的话直接显示
                    if (o.dialog.currentDialogInfo.length <= 6)
                        o.dialog.currentDialogInfo.splice(5, 0, []);
                    if (o.dialog.currentDialogInfo[2] && o.dialog.currentDialogInfo[6]) {
                        var dialogInfo = o.dialog.currentDialogInfo[6];
                        dialogInfo.shift();
                        dialogInfo[3] = 5;
                        EventUtils.happen(GameDialog, GameDialog.EVENT_BEFORE_RECOVERY_DIALOG);
                        GameDialog.showDialog.apply(GameDialog, dialogInfo);
                    }
                    GameDialog.showOption.apply(GameDialog, o.dialog.currentDialogInfo);
                }
            }
            else {
                var ui = GameUI.show(id);
                // 恢复组件属性细节
                if (uiComps.length == uis.length) {
                    var allComps = [], nodeObjs2 = {};
                    ArrayUtils.getTreeNodeArray(ui, "_childs", allComps);
                    for (var s = 0; s < allComps.length; s++) {
                        var nodeComp = allComps[s];
                        if (nodeComp instanceof UIComponent.UIBase) {
                            nodeObjs2[nodeComp.id] = nodeComp;
                        }
                    }
                    var uiCompInfos = uiComps[i];
                    for (var compID in uiCompInfos) {
                        var uiComp = nodeObjs2[compID];
                        if (uiComp) {
                            var uiCompAtts = uiCompInfos[compID];
                            for (var attName in uiCompAtts) {
                                var value = uiCompAtts[attName];
                                uiComp[attName] = value;
                            }
                            uiComp.onConditionCheck();
                        }
                    }
                }
            }
        }
        // 还原图像集
        for (var i = 0; i < o.imageInfos.length; i++) {
            var p = o.imageInfos[i];
            var type = p.shift();
            if (type == 0) {
                var img = new GameImage();
                img.image = p[1];
                img.pivotType = p[2];
                img.x = p[3];
                img.y = p[4];
                img.width = p[5];
                img.height = p[6], img.rotation = p[7], img.alpha = p[8], img.blendMode = p[9];
                GameImage.addImageToLayer(p[0], img);
            }
            else if (type == 1) {
                var ani = new GCAnimation();
                ani.id = p[1];
                ani.x = p[2];
                ani.y = p[3];
                ani.scaleX = p[4];
                ani.scaleY = p[5];
                ani.rotation = p[6];
                ani.alpha = p[7];
                ani.loop = p[8];
                ani.fps = p[9];
                GameImage.addImageToLayer(p[0], ani);
                ani.play();
            }
            else if (type == 2) {
                var sa = new UIComponent.UIStandAvatar();
                sa.avatarID = p[7];
                sa.x = p[1];
                sa.y = p[2];
                sa.rotation = p[3];
                sa.alpha = p[4];
                sa.scaleX = p[5];
                sa.scaleY = p[6];
                sa.avatarFPS = p[8];
                sa.isPlay = p[9];
                GameImage.addImageToLayer(p[0], sa);
            }
            else if (type == 3) {
                var ui = GameUI.get(p[7]);
                if (ui) {
                    ui.x = p[1];
                    ui.y = p[2];
                    ui.rotation = p[3];
                    ui.alpha = p[4];
                    ui.scaleX = p[5];
                    ui.scaleY = p[6];
                    GameImage.imageInfos[p[0]] = { image: ui };
                }
            }
        }
        // 添加图像组
        for (var i = 0; i < o.executeGroups.length; i++) {
            var groupData = o.executeGroups[i];
            if (!groupData)
                continue;
            var group = new GameImageGroup;
            group.recoverySaveData(groupData);
            GameImage.executeGroups[i] = group;
            // 对话框状态还原
            if (group["_waitDialog"] && o.dialog.submitCallback && gameDialogLayer != -1) {
                var d = o.dialog.currentDialogInfo;
                group["doShowDialog"].call(group, d[0], d[1], d[2], d[3], d[4], d[5], d[4], d[6], d[7], d[8], o.dialog.submitEnabled, true);
            }
        }
        // 还原图像等待事件监听行为
        for (var i = 0; i < o.listeningWaitImagePlayOvers.length; i++) {
            GameImage.listenerImageOver(o.listeningWaitImagePlayOvers[i]);
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 图像系统镜头和深度处理
    //------------------------------------------------------------------------------------------------------
    //------------------------------------------------------------------------------------------------------
    // 静态：图像处理
    //------------------------------------------------------------------------------------------------------
    /**
     * 监听图像组播放完毕
     * EventUtils.addEventListener(GameImage, GameImage.EVENT_PLAY_OVER, c = Callback.New((groupTriggerLineID: number) => {}, this));
     */
    GameImage.EVENT_PLAY_OVER = "GameImage_EVENT_PLAY_OVER";
    GameImage.UI_START_PASSAGE = 100000000;
    /**
     * 操作方法和参数组
     */
    GameImage.executeGroups = [];
    /**
     * 图像集管理 id = {image:GameImage|GameAnimation|UIStandAvatar|UIRoot}
     */
    GameImage.imageInfos = {};
    /**
     * 正在监听的等待图像完成的触发线
     */
    GameImage.listeningWaitImagePlayOvers = [];
    return GameImage;
}(UIComponent.UIBitmap));
/**
 * 图像组
 */
var GameImageGroup = /** @class */ (function () {
    function GameImageGroup() {
        this.delayFrame = 0;
        // 主时间结束，主时间只计算等待了的时间
        // 比如显示图片A，60帧移动图片A，等待30帧，这里只要30帧后该值就为true
        this.mainPlayOver = false;
        /**
         * 操作方法和参数
         */
        this.executeFuncs = [];
        /**
         * 移动中的图像 image
         */
        this.motionImages = [];
        /**
         * 移动中的动画 animation/立绘
         */
        this.motionAnimations = [];
        /**
         * 自动旋转
         */
        this.autoRotations = [];
        /**
         * 变化色调
         */
        this.changeTonals = [];
        /**
         * 变化界面的组件的多种属性 var passageID = GameImage.UI_START_PASSAGE + uiID;
         */
        this.motionUICompAttrs = [];
    }
    /**
     * 释放
     */
    GameImageGroup.prototype.dispose = function () {
        if (GameCommand.isNeedPlayerInput && this.triggerLineID == GameCommand.inputTriggerLine) {
            GameCommand.isNeedPlayerInput = false;
        }
        this.motionImages = null;
        this.motionAnimations = null;
        this.changeTonals = null;
        this.isDisposed = true;
    };
    /**
     * 清理组内指定通道的所有移动的命令
     * @param id 指定通道
     */
    GameImageGroup.prototype.clearPassageMoveEffect = function (id) {
        var arr = [this.motionImages, this.motionAnimations, this.autoRotations, this.changeTonals];
        for (var i in arr) {
            var mArr = arr[i];
            var m = ArrayUtils.matchAttributes(mArr, { id: id }, true);
            if (m.length == 1) {
                mArr.splice(mArr.indexOf(m[0]), 1);
            }
        }
    };
    /**
     * 设置数据
     */
    GameImageGroup.prototype.setData = function (triggerLineID, imageInfos) {
        var _this = this;
        this.triggerLineID = triggerLineID;
        imageInfos = ObjectUtils.depthClone(imageInfos);
        var funcMapping = [
            this.showImage,
            this.moveImage,
            this.autoRotation,
            this.changeTonal,
            this.deleteImage,
            this.showAnimation,
            this.moveAnimation,
            null,
            this.delay,
            this.showDialog,
            function () {
                // @ts-ignore
                _this.addDoFunction(GameAudio.playSE, arguments, true, "GameAudio", "playSE");
            },
            this.showStandAvatar,
            function () {
                var args = [];
                // @ts-ignore
                for (var i = 0; i < arguments.length; i++)
                    args.push(arguments[i]); // if (i != 10) 支持了起始帧，移动时如果处于未播放状态下则允许使用
                _this.moveStandAvatar.apply(_this, args);
            },
            function () {
                var args = [];
                // @ts-ignore
                for (var i = 0; i < arguments.length; i++)
                    if (i != 0 && i != 7)
                        args.push(arguments[i]);
                // @ts-ignore
                args.unshift(arguments[7]);
                _this.showUI.apply(_this, args);
            },
            function () {
                var args = [];
                // @ts-ignore
                for (var i = 0; i < arguments.length; i++)
                    if (i != 0 && i != 7 && i != 9)
                        args.push(arguments[i]);
                // @ts-ignore
                args.unshift(arguments[9], arguments[7]);
                _this.moveUI.apply(_this, args);
            },
            this.hideUI,
            this.changeUICompAttrs
        ];
        // 对话命令执行
        var imageInfosClone = imageInfos.concat();
        imageInfosClone.reverse();
        var lastDialog = ArrayUtils.matchAttributes(imageInfosClone, { "0": 9 }, true)[0];
        if (lastDialog) {
            lastDialog.splice(10, 1); //删除10-漫画对话框指定数值变量ID
            lastDialog[11] = true;
        }
        // 遍历命令执行
        for (var i = 0; i < imageInfos.length; i++) {
            var imageInfo = imageInfos[i];
            var type = imageInfo.shift();
            funcMapping[type].apply(this, imageInfo);
        }
    };
    /**
     * 显示图片
     * @param passageID 通道ID，表示占用的通道，同一个通道代表同一个对象
     * @param url 地址
     * @param pivotType
     * @param x 坐标x
     * @param y 坐标y
     * @param width [可选] 默认值=0
     * @param height [可选] 默认值=0
     * @param rotation [可选] 默认值=0
     * @param alpha [可选] 默认值=1
     * @param blendMode [可选] 默认值=null
     */
    GameImageGroup.prototype.showImage = function (passageID, url, pivotType, x, y, width, height, rotation, alpha, blendMode) {
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (blendMode === void 0) { blendMode = null; }
        this.executeFuncs.push({ func: this.doShowImage, params: arguments, funcName: "doShowImage", cls: null });
        this.update(false);
    };
    /**
     * 移动图片
     * @param passageID 通道ID，表示占用的通道，同一个通道代表同一个对象
     * @param time
     * @param pivotType
     * @param x
     * @param y
     * @param width [可选] 默认值=0
     * @param height [可选] 默认值=0
     * @param rotation [可选] 默认值=0
     * @param alpha [可选] 默认值=1
     * @param blendMode [可选] 默认值=null
     * @param tweenType:number
     */
    GameImageGroup.prototype.moveImage = function (passageID, time, pivotType, x, y, width, height, rotation, alpha, blendMode, tweenID) {
        if (pivotType === void 0) { pivotType = 0; }
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (blendMode === void 0) { blendMode = null; }
        if (tweenID === void 0) { tweenID = null; }
        this.executeFuncs.push({ func: this.doMoveImage, params: arguments, funcName: "doMoveImage", cls: null });
        this.update(false);
    };
    /**
     * 自动旋转
     * @param id
     * @param rotation
     */
    GameImageGroup.prototype.autoRotation = function (passageID, angle) {
        this.executeFuncs.push({ func: this.doAutoRotation, params: arguments, funcName: "doAutoRotation", cls: null });
        this.update(false);
    };
    /**
     * 更改色调
     * @param passageID 通道ID，表示占用的通道，同一个通道代表同一个对象
     * @param r
     * @param g
     * @param b
     * @param gray
     * @param t
     */
    GameImageGroup.prototype.changeTonal = function (passageID, r, g, b, gray, t, mr, mg, mb, tweenID) {
        if (mr === void 0) { mr = 1; }
        if (mg === void 0) { mg = 1; }
        if (mb === void 0) { mb = 1; }
        if (tweenID === void 0) { tweenID = null; }
        this.executeFuncs.push({ func: this.doChangeTonal, params: arguments, funcName: "doChangeTonal", cls: null });
        this.update(false);
    };
    /**
     * 删除图片/动画
     * @param passageID 通道ID，表示占用的通道，同一个通道代表同一个对象
     */
    GameImageGroup.prototype.deleteImage = function (passageID) {
        this.executeFuncs.push({ func: this.doDeleteImage, params: arguments, funcName: "doDeleteImage", cls: null });
        this.update(false);
    };
    /**
     * 显示动画
     * @param passageID 通道ID，表示占用的通道，同一个通道代表同一个对象
     * @param url
     * @param x
     * @param y
     * @param scaleX [可选] 默认值=1
     * @param scaleY [可选] 默认值=1
     * @param rotation [可选] 默认值=0
     * @param alpha [可选] 默认值=1
     * @param fps [可选] 默认值=20
     */
    GameImageGroup.prototype.showAnimation = function (passageID, url, x, y, scaleX, scaleY, rotation, alpha, loop, fps) {
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (loop === void 0) { loop = 0; }
        if (fps === void 0) { fps = 20; }
        this.executeFuncs.push({ func: this.doShowAnimation, params: arguments, funcName: "doShowAnimation", cls: null });
        this.update(false);
    };
    /**
     * 移动动画
     * @param passageID 通道ID，表示占用的通道，同一个通道代表同一个对象
     * @param time
     * @param x
     * @param y
     * @param scaleX [可选] 默认值=1
     * @param scaleY [可选] 默认值=1
     * @param rotation [可选] 默认值=0
     * @param alpha [可选] 默认值=1
     */
    GameImageGroup.prototype.moveAnimation = function (passageID, time, x, y, scaleX, scaleY, rotation, alpha, tweenID) {
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (tweenID === void 0) { tweenID = null; }
        this.executeFuncs.push({ func: this.doMoveAnimation, params: arguments, funcName: "doMoveAnimation", cls: null });
        this.update(false);
    };
    /**
     * 显示对话框
     * @param dialogID 对话框ID
     * @param head 头像ID
     * @param name 名称
     * @param speed 播放速度
     * @param comicSceneObjectIndex 漫画对话框模式 -1无 0-N 场景对象
     * @param msg 对话内容
     * @param realComicSceneObjectIndex 经过转化的具体场景对象ID（动态计算）
     * @param audio 语音
     * @param exp 表情
     * @param nameColor 名字颜色
     * @param [private] submit 提交，即对话完成后提交（比如最后的对话才提交，其他都不提交）
     
     */
    GameImageGroup.prototype.showDialog = function (dialogID, head, name, speed, comicSceneObjectIndex, msg, realComicSceneObjectIndex, audio, exp, nameColor, submit) {
        if (submit === void 0) { submit = false; }
        this.executeFuncs.push({ func: this.doShowDialog, params: arguments, funcName: "doShowDialog", cls: null });
        this.update(false);
    };
    /**
     * 显示立绘
     * @param passageID 通道ID，表示占用的通道，同一个通道代表同一个对象
     * @param x [可选] 默认值=0 坐标x
     * @param y [可选] 默认值=0 坐标y
     * @param rotation [可选] 默认值=0 旋转角度
     * @param alpha [可选] 默认值=1 透明度
     * @param scaleX [可选] 默认值=1 缩放x
     * @param scaleY [可选] 默认值=1 缩放y
     * @param standAvatarID [可选] 默认值=1 立绘ID
     * @param fps [可选] 默认值=12 帧率
     * @param isPlay [可选] 默认值=false 是否播放
     * @param startFrame [可选] 默认值=0 起始帧
     * @param expressionID [可选] 默认值=1 表情ID
     * @param hue [可选] 默认值=0 色相
     */
    GameImageGroup.prototype.showStandAvatar = function (passageID, x, y, rotation, alpha, scaleX, scaleY, standAvatarID, fps, isPlay, startFrame, expressionID, hue) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (standAvatarID === void 0) { standAvatarID = 1; }
        if (fps === void 0) { fps = 12; }
        if (isPlay === void 0) { isPlay = false; }
        if (startFrame === void 0) { startFrame = 0; }
        if (expressionID === void 0) { expressionID = 1; }
        if (hue === void 0) { hue = 0; }
        this.executeFuncs.push({ func: this.doShowStandAvatar, params: arguments, funcName: "doShowStandAvatar", cls: null });
        this.update(false);
    };
    /**
     * 移动立绘
     * @param passageID 通道ID，表示占用的通道，同一个通道代表同一个对象
     * @param x [可选] 默认值=0 坐标x
     * @param y [可选] 默认值=0 坐标y
     * @param rotation [可选] 默认值=0 旋转角度
     * @param alpha [可选] 默认值=1 透明度
     * @param scaleX [可选] 默认值=1 缩放x
     * @param scaleY [可选] 默认值=1 缩放y
     * @param frame [可选] 默认值=30 移动花费的总帧数
     * @param fps [可选] 默认值=12 帧率
     * @param isPlay [可选] 默认值=true 是否播放
     * @param startFrame [可选] 默认值= 1
     * @param expressionID [可选] 默认值=1 表情ID
     * @param hue [可选] 默认值=0 色相
     * @param tweenID [可选] 默认值=0 缓动方式
     */
    GameImageGroup.prototype.moveStandAvatar = function (passageID, x, y, rotation, alpha, scaleX, scaleY, frame, fps, isPlay, startFrame, expressionID, hue, tweenID) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (frame === void 0) { frame = 30; }
        if (fps === void 0) { fps = 12; }
        if (isPlay === void 0) { isPlay = true; }
        if (startFrame === void 0) { startFrame = 1; }
        if (expressionID === void 0) { expressionID = 1; }
        if (hue === void 0) { hue = 0; }
        if (tweenID === void 0) { tweenID = 0; }
        this.executeFuncs.push({ func: this.doMoveStandAvatar, params: arguments, funcName: "doMoveStandAvatar", cls: null });
        this.update(false);
    };
    GameImageGroup.prototype.showUI = function (uiID, x, y, ro, alpha, scaleX, scaleY) {
        this.executeFuncs.push({ func: this.doShowUI, params: arguments, funcName: "doShowUI", cls: null });
        this.update(false);
    };
    GameImageGroup.prototype.moveUI = function (uiID, frame, x, y, ro, alpha, scaleX, scaleY, tweenID) {
        this.executeFuncs.push({ func: this.doMoveUI, params: arguments, funcName: "doMoveUI", cls: null });
        this.update(false);
    };
    GameImageGroup.prototype.hideUI = function (uiID) {
        this.executeFuncs.push({ func: this.doHideUI, params: arguments, funcName: "doHideUI", cls: null });
        this.update(false);
    };
    /**
     * 更改界面元件属性
     * @param frame 时间帧
     * @param trans 过渡方式
     * @param changeCompAttrInfo 修改的属性集
     * @param nonTweenType 无法渐变过渡的属性处理方式：0-在第一帧时变动 1-在最后一帧时变动
     * @param noData 预留
     * @param immediately 是否立即
     */
    GameImageGroup.prototype.changeUICompAttrs = function (frame, trans, changeCompAttrInfo, nonTweenType, noData, immediately) {
        this.executeFuncs.push({ func: this.doChangeUICompAttrs, params: arguments, funcName: "doChangeUICompAttrs", cls: null });
        this.update(false);
    };
    /**
     * 添加执行的方法
     * 比如需要添加一个播放音效：GameImage.addDoFunction(GameAudio.playSE, ["xx.mp3",1,1], true);
     * @param f 方法
     * @param args 参数
     * @param immediatelyRender 是否立刻刷新（否则会在下一帧时才执行）
     */
    GameImageGroup.prototype.addDoFunction = function (f, args, immediatelyRender, cls, funcName) {
        this.executeFuncs.push({ func: f, params: args, funcName: funcName, cls: cls });
        this.update(false);
    };
    /**
     * 等待：这里是共用等待时间
     */
    GameImageGroup.prototype.delay = function (time) {
        this.executeFuncs.push({ func: this.doDelay, params: arguments, funcName: "doDelay", cls: null });
        this.update(false);
    };
    GameImageGroup.prototype.pause = function () {
        this._pause = true;
    };
    GameImageGroup.prototype.continue = function () {
        this._pause = false;
    };
    Object.defineProperty(GameImageGroup.prototype, "isPlaying", {
        /**
         * 是否存在播放中的图像
         */
        get: function () {
            return !this._pause && (this.executeFuncs.length > 0 || this.delayFrame > 0 || this.motionImages.length > 0 || this.motionAnimations.length > 0 || this.motionUICompAttrs.length > 0);
        },
        enumerable: false,
        configurable: true
    });
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    GameImageGroup.prototype.checkMainPlayOver = function () {
        // 确保等待时间以及函数和运动状态完毕后才真正完毕
        if (this.delayFrame <= 0) {
            // 卡时间结束
            if (!this._waitDialog) {
                if (!this.mainPlayOver && this.executeFuncs.length == 0) {
                    this.mainPlayOver = true;
                    EventUtils.happen(GameImage, GameImage.EVENT_PLAY_OVER, [this.triggerLineID]);
                }
            }
        }
    };
    //------------------------------------------------------------------------------------------------------
    // update
    //------------------------------------------------------------------------------------------------------
    /**
     * 刷新
     * @param forwardFrame [可选] 默认值=true 推进帧
     * @return [boolean]
     */
    GameImageGroup.prototype.update = function (forwardFrame) {
        if (forwardFrame === void 0) { forwardFrame = true; }
        if (this._pause)
            return false;
        // return;
        // 执行函数
        var isShowDialog = false;
        while (this.executeFuncs.length > 0) {
            // this.isPlayerOver = false;
            if (this.delayFrame > 0 || this._waitDialog)
                break;
            var f = this.executeFuncs.shift();
            f.func.apply(this, f.params);
            isShowDialog = "doShowDialog" == f.funcName;
            // if (this.executeFuncs.length == 0) this.isPlayerOver = true;
        }
        // 推进一帧
        if (forwardFrame) {
            this.delayFrame--;
            // 确保等待时间以及函数和运动状态完毕后才真正完毕
            if (this.delayFrame <= 0) {
                // 卡时间结束
                if (!this._waitDialog) {
                    if (!this.mainPlayOver && this.executeFuncs.length == 0) {
                        this.mainPlayOver = true;
                        EventUtils.happen(GameImage, GameImage.EVENT_PLAY_OVER, [this.triggerLineID]);
                    }
                    // 该组生命周期结束
                    if (this.executeFuncs.length == 0 && this.motionImages.length == 0 && this.motionAnimations.length == 0 && this.autoRotations.length == 0 && this.changeTonals.length == 0 && this.motionUICompAttrs.length == 0) {
                        if (!isShowDialog) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
            }
            // 执行移动效果
            for (var i = 0; i < this.motionImages.length; i++) {
                var m = this.motionImages[i];
                var per = m.curTime / m.time;
                var imageInfo = GameImage.imageInfos[m.id];
                if (imageInfo && (imageInfo.image instanceof GameImage)) {
                    var image = imageInfo.image;
                    if (m.curTime == 1) {
                        m.x = image.x;
                        m.y = image.y;
                        m.width = image.width;
                        m.height = image.height;
                        m.rotation = image.rotation;
                        m.alpha = image.alpha;
                    }
                    var func = m.tween;
                    image.pivotType = m.pivotType;
                    image.blendMode = m.blendMode;
                    image.x = func(per, m.x, m.x2 - m.x, 1);
                    image.y = func(per, m.y, m.y2 - m.y, 1);
                    var newW = func(per, m.width, m.width2 - m.width, 1);
                    var newH = func(per, m.height, m.height2 - m.height, 1);
                    if (newW != image.width || newH != image.height) {
                        image.width = newW;
                        image.height = newH;
                        // image.event(EventObject.RESIZE);
                    }
                    image.rotation = func(per, m.rotation, m.rotation2 - m.rotation, 1);
                    image.alpha = func(per, m.alpha, m.alpha2 - m.alpha, 1);
                }
                m.curTime++;
                if (per == 1) {
                    this.motionImages.splice(i, 1);
                    i--;
                }
            }
            // 执行移动动画效果
            for (var i = 0; i < this.motionAnimations.length; i++) {
                var a = this.motionAnimations[i];
                var per = a.curTime / a.time;
                var imageInfo = GameImage.imageInfos[a.id];
                var standAvatar;
                if (imageInfo.image instanceof UIComponent.UIStandAvatar) {
                    standAvatar = imageInfo.image;
                }
                if (imageInfo && ((imageInfo.image instanceof GCAnimation) || standAvatar || (imageInfo.image instanceof UIComponent.UIRoot))) {
                    var ani = imageInfo.image;
                    if (a.curTime == 1) {
                        a.x = ani.x;
                        a.y = ani.y;
                        a.scaleX = ani.scaleX;
                        a.scaleY = ani.scaleY;
                        a.rotation = ani.rotation;
                        a.alpha = ani.alpha;
                        // 立绘的情形
                        if (standAvatar) {
                            a.avatarFPS = standAvatar.avatarFPS;
                            a.startFrame = standAvatar.avatar.currentFrame;
                        }
                    }
                    var func = a.tween;
                    ani.x = func(per, a.x, a.x2 - a.x, 1);
                    ani.y = func(per, a.y, a.y2 - a.y, 1);
                    ani.scaleX = func(per, a.scaleX, a.scaleX2 - a.scaleX, 1);
                    ani.scaleY = func(per, a.scaleY, a.scaleY2 - a.scaleY, 1);
                    ani.rotation = func(per, a.rotation, a.rotation2 - a.rotation, 1);
                    ani.alpha = func(per, a.alpha, a.alpha2 - a.alpha, 1);
                    if (standAvatar) {
                        standAvatar.avatarFPS = func(per, a.avatarFPS, a.saAvatarFPS2 - a.avatarFPS, 1);
                        // 未播放状态下才设置帧
                        if (!standAvatar.isPlay)
                            standAvatar.avatarFrame = func(per, a.startFrame, a.saStartFrame2 - a.startFrame, 1);
                    }
                }
                a.curTime++;
                if (per == 1) {
                    this.motionAnimations.splice(i, 1);
                    i--;
                }
            }
            // 执行界面元件属性变更
            for (var i = 0; i < this.motionUICompAttrs.length; i++) {
                var isDel = this.updateOneUICompAttrs(i);
                if (isDel) {
                    this.motionUICompAttrs.splice(i, 1);
                    i--;
                }
            }
            // 执行自动旋转
            for (var i = 0; i < this.autoRotations.length; i++) {
                var roInfo = this.autoRotations[i];
                var id = roInfo.id;
                var angle = roInfo.angle;
                var imageInfo = GameImage.imageInfos[id];
                if (!imageInfo)
                    continue;
                imageInfo.image.rotation += angle;
            }
            // 执行色调变换
            for (var i = 0; i < this.changeTonals.length; i++) {
                var t = this.changeTonals[i];
                var l = t.tween;
                var imageInfo = GameImage.imageInfos[t.id];
                if (!imageInfo)
                    continue;
                var per = t.curTime / t.time;
                var targetObj = imageInfo.image;
                if (t.curTime == 1) {
                    t.old = targetObj.getTonal().concat();
                }
                targetObj.setTonal(l(per, t.old[0], t.r - t.old[0], 1), l(per, t.old[1], t.g - t.old[1], 1), l(per, t.old[2], t.b - t.old[2], 1), l(per, t.old[3], t.gray - t.old[3], 1), l(per, t.old[4], t.mr - t.old[4], 1), l(per, t.old[5], t.mg - t.old[5], 1), l(per, t.old[6], t.mb - t.old[6], 1));
                t.curTime++;
                if (per == 1) {
                    this.changeTonals.splice(i, 1);
                    i--;
                }
            }
        }
        return false;
    };
    /**
     * 推进一次界面元件移动
     * @param i
     * @return 是否删除
     */
    GameImageGroup.prototype.updateOneUICompAttrs = function (i) {
        var c = this.motionUICompAttrs[i];
        var per = c.curTime / c.time;
        var imageInfo = GameImage.imageInfos[c.id];
        // 如果是界面的场合
        if (imageInfo && imageInfo.image instanceof UIComponent.UIBase) {
            var ui = imageInfo.image;
            if (Config.CREATED_GC_VERSION != null || c.trans) {
                var refreshTrans = false;
                // 满足间隔时间才允许刷新
                if (c["lastTime"] == null || c.curTime - c["lastTime"] >= c.trans.refreshInterval / Game.oneFrame) {
                    c["lastTime"] = c.curTime;
                    refreshTrans = true;
                }
            }
            // 遍历所有的组件
            for (var compID in c.atts) {
                var compArr = c.atts[compID];
                var comp = compArr[0];
                var compAttrs = compArr[1];
                // 遍历其属性
                for (var attrName in compAttrs) {
                    var toValueInfo = compAttrs[attrName];
                    var newValue;
                    // 获取到达的值
                    if (toValueInfo.useVarType == 0) {
                        newValue = Game.player.variable.getVariable(toValueInfo.userVarIndex);
                    }
                    else if (toValueInfo.useVarType == 1) {
                        newValue = Game.player.variable.getString(toValueInfo.userVarIndex);
                    }
                    else if (toValueInfo.useVarType == 2) {
                        newValue = Game.player.variable.getSwitch(toValueInfo.userVarIndex) ? true : false;
                    }
                    else {
                        newValue = toValueInfo.newValue;
                    }
                    // 过渡
                    if (toValueInfo.needTween) {
                        if (Config.CREATED_GC_VERSION != null || c.trans) {
                            if (refreshTrans) {
                                var value = GameUtils.getValueByTransData(c.trans, per);
                                comp[attrName] = toValueInfo.oldValue + (newValue - toValueInfo.oldValue) * value;
                            }
                        }
                        else {
                            var func = c.tween;
                            comp[attrName] = func(per, toValueInfo.oldValue, newValue - toValueInfo.oldValue, 1);
                        }
                    }
                    // 无过渡的属性：直接设置
                    else {
                        if ((c.nonTweenType == 0 && c.curTime == 1) || (c.nonTweenType == 1 && c.curTime == c.time)) {
                            comp[attrName] = newValue;
                        }
                    }
                }
            }
        }
        c.curTime++;
        if (per == 1) {
            return true;
        }
        return false;
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 显示图片
     */
    GameImageGroup.prototype.doShowImage = function (id, url, pivotType, x, y, width, height, rotation, alpha, blendMode) {
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (blendMode === void 0) { blendMode = null; }
        var imageInfo = GameImage.imageInfos[id];
        this.doDeleteImage(id);
        var newImage = new GameImage();
        if (width != null)
            newImage.width = width;
        if (height != null)
            newImage.height = height;
        newImage.image = url;
        newImage.x = x;
        newImage.y = y;
        newImage.alpha = alpha;
        newImage.rotation = rotation;
        newImage.blendMode = blendMode;
        newImage.pivotType = pivotType;
        GameImage.addImageToLayer(id, newImage);
    };
    GameImageGroup.prototype.doMoveImage = function (id, time, pivotType, x, y, width, height, rotation, alpha, blendMode, tweenID) {
        if (pivotType === void 0) { pivotType = 0; }
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (blendMode === void 0) { blendMode = null; }
        if (tweenID === void 0) { tweenID = null; }
        if (time < 1)
            time = 1;
        var imageInfo = GameImage.imageInfos[id];
        if (!imageInfo || !(imageInfo.image instanceof GameImage))
            return;
        var mArr = ArrayUtils.matchAttributes(this.motionImages, { id: id }, true);
        if (mArr.length == 1) {
            this.motionImages.splice(this.motionImages.indexOf(mArr[0]), 1);
        }
        var image = imageInfo.image;
        var m = { id: id, time: time, curTime: 1, pivotType: pivotType, blendMode: blendMode, x2: x, y2: y, width2: width, height2: height, rotation2: rotation, alpha2: alpha, tween: GameUtils.getTween(tweenID)[0], tweenID: tweenID };
        this.motionImages.push(m);
    };
    GameImageGroup.prototype.doAutoRotation = function (id, angle) {
        var imageInfo = GameImage.imageInfos[id];
        if (!imageInfo)
            return;
        var mArr = ArrayUtils.matchAttributes(this.autoRotations, { id: id }, true);
        if (mArr.length == 1) {
            this.autoRotations.splice(this.autoRotations.indexOf(mArr[0]), 1);
        }
        var m = { id: id, angle: angle };
        this.autoRotations.push(m);
    };
    /**
     * 删除通道
     * @param id 通道ID
     */
    GameImageGroup.prototype.doDeleteImage = function (id) {
        var imageInfo = GameImage.imageInfos[id];
        if (imageInfo) {
            // 显示对象中移除
            GameImage.imageLayer.removeChild(imageInfo.image);
            // 如果是动画则释放掉动画
            if (imageInfo.image instanceof GCAnimation) {
                imageInfo.image.dispose();
            }
            // 如果是立绘则释放掉立绘
            else if (imageInfo.image instanceof UIComponent.UIStandAvatar) {
                imageInfo.image.dispose();
            }
            // 如果是图片则释放掉图片
            else if (imageInfo.image instanceof GameImage) {
                imageInfo.image.dispose();
            }
            // 清理掉此前的移动效果：所有组，而非当前组
            GameImage.clearPassageMoveEffect(id);
            // 从列表中删除
            delete GameImage.imageInfos[id];
        }
    };
    /**
     * 显示动画
     */
    GameImageGroup.prototype.doShowAnimation = function (id, aniId, x, y, scaleX, scaleY, rotation, alpha, loop, fps) {
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (loop === void 0) { loop = 0; }
        if (fps === void 0) { fps = 20; }
        var imageInfo = GameImage.imageInfos[id];
        this.doDeleteImage(id);
        var animation = new GCAnimation();
        animation.id = aniId;
        animation.loop = loop == 1 ? true : false;
        animation.gotoAndPlay();
        if (scaleX)
            animation.scaleX = scaleX;
        if (scaleY)
            animation.scaleY = scaleY;
        animation.x = x;
        animation.y = y;
        animation.alpha = alpha;
        animation.rotation = rotation;
        animation.fps = fps;
        GameImage.addImageToLayer(id, animation);
    };
    GameImageGroup.prototype.doChangeTonal = function (id, r, g, b, gray, t, mr, mg, mb, tweenID) {
        if (mr === void 0) { mr = 1; }
        if (mg === void 0) { mg = 1; }
        if (mb === void 0) { mb = 1; }
        if (tweenID === void 0) { tweenID = null; }
        var imageInfo = GameImage.imageInfos[id];
        if (!imageInfo)
            return;
        var mArr = ArrayUtils.matchAttributes(this.changeTonals, { id: id }, true);
        if (mArr.length == 1) {
            this.changeTonals.splice(this.changeTonals.indexOf(mArr[0]), 1);
        }
        var m = { id: id, time: t, curTime: 1, r: r, g: g, b: b, gray: gray, mr: mr, mg: mg, mb: mb, tween: GameUtils.getTween(tweenID)[0], tweenID: tweenID };
        this.changeTonals.push(m);
    };
    GameImageGroup.prototype.doMoveAnimation = function (id, time, x, y, scaleX, scaleY, rotation, alpha, tweenID) {
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (tweenID === void 0) { tweenID = null; }
        if (time < 1)
            time = 1;
        var imageInfo = GameImage.imageInfos[id];
        if (!imageInfo || !(imageInfo.image instanceof GCAnimation))
            return;
        var mArr = ArrayUtils.matchAttributes(this.motionAnimations, { id: id }, true);
        if (mArr.length == 1) {
            this.motionAnimations.splice(this.motionAnimations.indexOf(mArr[0]), 1);
        }
        var image = imageInfo.image;
        var m = { id: id, time: time, curTime: 1, x2: x, y2: y, scaleX2: scaleX, scaleY2: scaleY, rotation2: rotation, alpha2: alpha, tween: GameUtils.getTween(tweenID)[0], tweenID: tweenID };
        this.motionAnimations.push(m);
    };
    /**
     * 显示对话
     */
    GameImageGroup.prototype.doShowDialog = function (dialogID, head, name, speed, comicSceneObjectIndex, msg, realComicSceneObjectIndex, audio, exp, nameColor, submitEnabled, force) {
        var _this = this;
        if (submitEnabled === void 0) { submitEnabled = false; }
        if (force === void 0) { force = false; }
        // 未阻塞输入通道时：开始输入阻塞 + 当前图像域阻塞
        if (force || !GameCommand.isNeedPlayerInput) {
            GameCommand.inputTriggerLine = this.triggerLineID;
            GameCommand.isNeedPlayerInput = true;
            this._waitDialog = true;
            GameImage.submitEnabled = submitEnabled;
            if (!submitEnabled) {
                EventUtils.addEventListener(GameDialog, GameDialog.EVENT_DIALOG_END, Callback.New(function (submitEnabled) {
                    if (_this.isDisposed)
                        return;
                    if (GameCommand.inputTriggerLine == _this.triggerLineID) {
                        GameCommand.isNeedPlayerInput = false;
                    }
                    _this._waitDialog = false;
                    // 延迟到下一帧执行update，以免最后一个文本直接就提交了
                    Callback.CallLaterBeforeRender(_this.update, _this, [false]);
                }, GameDialog, [submitEnabled]), true);
            }
            GameDialog.showDialog(dialogID, head, name, speed, realComicSceneObjectIndex, msg, Callback.New(function (submitEnabled) {
                if (_this.isDisposed)
                    return;
                if (submitEnabled) {
                    _this._waitDialog = false;
                    _this.update(false);
                    GameCommand.inputMessageAndContinueExecute(null, true, 1, _this.triggerLineID);
                }
            }, this, [submitEnabled]), audio, exp, nameColor, null);
        }
        // 阻塞的情况:加入回队列中，下一帧再继续请求对话
        else {
            this.delayFrame += 1;
            this.executeFuncs.unshift({ func: this.doShowDialog, params: arguments, funcName: "doShowDialog", cls: null });
        }
    };
    /**
     * 显示立绘
     */
    GameImageGroup.prototype.doShowStandAvatar = function (passageID, x, y, rotation, alpha, scaleX, scaleY, standAvatarID, fps, isPlay, startFrame, expressionID, hue) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (standAvatarID === void 0) { standAvatarID = 1; }
        if (fps === void 0) { fps = 12; }
        if (isPlay === void 0) { isPlay = false; }
        if (startFrame === void 0) { startFrame = 0; }
        if (expressionID === void 0) { expressionID = 1; }
        if (hue === void 0) { hue = 0; }
        var imageInfo = GameImage.imageInfos[passageID];
        this.doDeleteImage(passageID);
        var newAvatar = new UIComponent.UIStandAvatar();
        newAvatar.avatarID = standAvatarID;
        newAvatar.x = x;
        newAvatar.y = y;
        newAvatar.alpha = alpha;
        newAvatar.rotation = rotation;
        newAvatar.scaleX = scaleX;
        newAvatar.scaleY = scaleY;
        newAvatar.avatarFPS = fps;
        newAvatar.isPlay = isPlay;
        newAvatar.avatarFrame = startFrame;
        newAvatar.actionID = expressionID;
        newAvatar.hue = hue;
        GameImage.addImageToLayer(passageID, newAvatar);
    };
    GameImageGroup.prototype.doMoveStandAvatar = function (passageID, x, y, rotation, alpha, scaleX, scaleY, frame, fps, isPlay, startFrame, expressionID, hue, tweenID) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (frame === void 0) { frame = 30; }
        if (fps === void 0) { fps = 12; }
        if (isPlay === void 0) { isPlay = true; }
        if (startFrame === void 0) { startFrame = 1; }
        if (expressionID === void 0) { expressionID = 1; }
        if (hue === void 0) { hue = 0; }
        if (tweenID === void 0) { tweenID = 0; }
        if (frame < 1)
            frame = 1;
        var imageInfo = GameImage.imageInfos[passageID];
        if (!imageInfo || !(imageInfo.image instanceof UIComponent.UIStandAvatar))
            return;
        var mArr = ArrayUtils.matchAttributes(this.motionAnimations, { id: passageID }, true);
        if (mArr.length == 1) {
            this.motionAnimations.splice(this.motionAnimations.indexOf(mArr[0]), 1);
        }
        var image = imageInfo.image;
        // image.avatarFPS = fps;
        image.isPlay = isPlay;
        image.actionID = expressionID;
        image.hue = hue;
        var m = { saStartFrame2: startFrame, saAvatarFPS2: fps, id: passageID, time: frame, curTime: 1, x2: x, y2: y, scaleX2: scaleX, scaleY2: scaleY, rotation2: rotation, alpha2: alpha, tween: GameUtils.getTween(tweenID)[0], tweenID: tweenID };
        this.motionAnimations.push(m);
    };
    GameImageGroup.prototype.doShowUI = function (uiID, x, y, rotation, alpha, scaleX, scaleY) {
        // return;
        var passageID = GameImage.UI_START_PASSAGE + uiID;
        var imageInfo = GameImage.imageInfos[passageID];
        if (imageInfo && imageInfo.image instanceof UIComponent.UIRoot) {
            var ui = imageInfo.image;
            if (!ui)
                return;
        }
        else {
            ui = GameUI.load(uiID);
            if (!ui)
                return;
            GameImage.imageInfos[passageID] = { image: ui };
        }
        ui.x = x;
        ui.y = y;
        ui.rotation = rotation;
        ui.alpha = alpha;
        ui.scaleX = scaleX;
        ui.scaleY = scaleY;
        GameImage.uiLayer.addChild(ui);
    };
    GameImageGroup.prototype.doMoveUI = function (uiID, frame, x, y, rotation, alpha, scaleX, scaleY, tweenID) {
        if (frame < 1)
            frame = 1;
        var passageID = GameImage.UI_START_PASSAGE + uiID;
        var imageInfo = GameImage.imageInfos[passageID];
        if (!imageInfo || !(imageInfo.image instanceof UIComponent.UIRoot))
            return;
        var ui = imageInfo.image;
        if (!ui)
            return;
        var mArr = ArrayUtils.matchAttributes(this.motionAnimations, { id: passageID }, true);
        if (mArr.length == 1) {
            this.motionAnimations.splice(this.motionAnimations.indexOf(mArr[0]), 1);
        }
        var m = { id: passageID, time: frame, curTime: 1, x2: x, y2: y, scaleX2: scaleX, scaleY2: scaleY, rotation2: rotation, alpha2: alpha, tween: GameUtils.getTween(tweenID)[0], tweenID: tweenID };
        this.motionAnimations.push(m);
    };
    GameImageGroup.prototype.doHideUI = function (uiID) {
        var passageID = GameImage.UI_START_PASSAGE + uiID;
        var imageInfo = GameImage.imageInfos[passageID];
        if (!imageInfo || !(imageInfo.image instanceof UIComponent.UIRoot))
            return;
        var ui = imageInfo.image;
        if (ui) {
            delete GameImage.imageInfos[passageID];
            ui.removeSelf();
            var mArr = ArrayUtils.matchAttributes(this.motionAnimations, { id: passageID }, true);
            if (mArr.length == 1) {
                this.motionAnimations.splice(this.motionAnimations.indexOf(mArr[0]), 1);
            }
        }
    };
    GameImageGroup.prototype.doChangeUICompAttrs = function (frame, trans, changeCompAttrInfo, nonTweenType, noData, immediately) {
        var isAllImmediately = immediately == null ? false : (immediately == 0 ? true : false);
        // -- 找到界面，如果找不到界面就忽略
        var passageID = GameImage.UI_START_PASSAGE + changeCompAttrInfo.uiID;
        var imageInfo = GameImage.imageInfos[passageID];
        if (!imageInfo || !(imageInfo.image instanceof UIComponent.UIRoot))
            return;
        var ui = imageInfo.image;
        if (!ui)
            return;
        // -- 此处实时计算子对象集合，可优化
        var nodeArray1 = [], nodeObjs2 = {};
        ArrayUtils.getTreeNodeArray(ui, "_childs", nodeArray1);
        for (var s = 0; s < nodeArray1.length; s++) {
            var nodeComp = nodeArray1[s];
            if (nodeComp instanceof UIComponent.UIBase) {
                nodeObjs2[nodeComp.id] = nodeComp;
            }
        }
        var atts = {};
        for (var compID in changeCompAttrInfo.atts) {
            var nodeComp = nodeObjs2[compID];
            if (!nodeComp)
                continue;
            var needChangeAtts = changeCompAttrInfo.atts[compID][1];
            // 使用变量以及过渡渐变
            // @ts-ignore
            var useVarAndTransitionAttrs = changeCompAttrInfo.atts[compID][2];
            // useVarType=null表示使用常量
            var attrInfos = {};
            for (var attrName in needChangeAtts) {
                var newValue = needChangeAtts[attrName];
                var oldValue = nodeComp[attrName];
                var needTween = typeof oldValue == "number"; //UIComponent.UIBase.BASE_ATTRS_OBJ[attrName] ? true : false;
                // 该属性是否立即变更属性，变更后则忽略此属性的update变更
                var useVarType = null;
                var userVarIndex = 0;
                // 存在该属性时才根据该属性的设定进行配置 V0.9808前不支持
                if (useVarAndTransitionAttrs) {
                    // type = 0-数值变量 1-字符串变量 2-开关变量
                    var useVarAndTransition = useVarAndTransitionAttrs[attrName];
                    if (useVarAndTransition) {
                        useVarType = useVarAndTransition.type;
                        userVarIndex = useVarAndTransition.index;
                        // 如果并非过渡渐变的话则表示立即变更，效果会受到「无法渐变的属性处理」影响
                        if (!useVarAndTransition.change) {
                            needTween = false;
                        }
                    }
                }
                attrInfos[attrName] = { oldValue: oldValue, newValue: newValue, needTween: needTween, useVarType: useVarType, userVarIndex: userVarIndex };
            }
            atts[compID] = [nodeComp, attrInfos];
        }
        //兼容v0.98102
        var m;
        var transdata = GameUtils.getTransData(trans);
        if (Config.CREATED_GC_VERSION == null && !transdata) {
            m = { id: passageID, time: frame, curTime: 1, tween: GameUtils.getTween(Number(trans))[0], tweenID: trans, trans: null, nonTweenType: nonTweenType, atts: atts };
        }
        else {
            if (!transdata)
                transdata = new TransData();
            m = { id: passageID, time: frame, curTime: 1, trans: transdata, nonTweenType: nonTweenType, atts: atts };
        }
        this.motionUICompAttrs.push(m);
        // 如果是立即模式下则直接设置一次
        if (isAllImmediately) {
            m.time = 1;
            var isDel = this.updateOneUICompAttrs(this.motionUICompAttrs.length - 1);
            if (isDel)
                this.motionUICompAttrs.pop();
        }
    };
    GameImageGroup.prototype.doDelay = function (time) {
        if (time < 1)
            time = 1;
        this.delayFrame = time;
    };
    //------------------------------------------------------------------------------------------------------
    // 存档读档
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取存档数据
     * @return [any]
     */
    GameImageGroup.prototype.getSaveData = function () {
        var o = {};
        o.triggerLineID = this.triggerLineID;
        o.delayFrame = this.delayFrame;
        o.mainPlayOver = this.mainPlayOver;
        o.pause = this.pause;
        o._waitDialog = this._waitDialog;
        o.executeFuncs = [];
        for (var i = 0; i < this.executeFuncs.length; i++) {
            var executeFunc = this.executeFuncs[i];
            var executeFuncData = o.executeFuncs[i] = {};
            ObjectUtils.clone(executeFunc, executeFuncData);
            executeFuncData.params = [];
            for (var s = 0; s < executeFunc.params.length; s++)
                executeFuncData.params.push(executeFunc.params[s]);
            delete executeFuncData["func"];
        }
        o.motionImages = [];
        for (var i = 0; i < this.motionImages.length; i++) {
            var motionImage = this.motionImages[i];
            var motionImageData = o.motionImages[i] = {};
            ObjectUtils.clone(motionImage, motionImageData);
            delete motionImageData["tween"];
        }
        o.motionAnimations = [];
        for (var i = 0; i < this.motionAnimations.length; i++) {
            var motionAnimation = this.motionAnimations[i];
            var motionAnimationData = o.motionAnimations[i] = {};
            ObjectUtils.clone(motionAnimation, motionAnimationData);
            delete motionAnimationData["tween"];
        }
        o.changeTonals = [];
        for (var i = 0; i < this.motionAnimations.length; i++) {
            var changeTonal = this.changeTonals[i];
            var changeTonalData = o.changeTonals[i] = {};
            ObjectUtils.clone(changeTonal, changeTonalData);
            delete changeTonalData["tween"];
        }
        o.motionUICompAttrs = [];
        for (var i = 0; i < this.motionUICompAttrs.length; i++) {
            var motionUICompAttr = this.motionUICompAttrs[i];
            var motionUICompAttrData = o.motionUICompAttrs[i] = {};
            ObjectUtils.clone(motionUICompAttr, motionUICompAttrData);
            delete motionUICompAttrData["tween"];
            // 清空掉引用的组件对象
            motionUICompAttrData.atts = {};
            for (var compID in motionUICompAttr.atts) {
                var c = motionUICompAttr.atts[compID];
                var compRecord = c[0];
                c[0] = null;
                motionUICompAttrData.atts[compID] = ObjectUtils.depthClone(c);
                c[0] = compRecord;
            }
        }
        o.autoRotations = this.autoRotations;
        return o;
    };
    /**
     * 恢复存档数据（triggerLineID需要被替换成新的，如果存在的话）
     * @param o
     */
    GameImageGroup.prototype.recoverySaveData = function (o) {
        this.triggerLineID = o.triggerLineID;
        // 为了替换触发线时能够找到对应的实例：这里由于先恢复了再恢复命令，导致触发线唯一ID变更了，配合SinglePlayerGame.recoveryTriggerEventSaveDataAndBehaviors
        o.gameImageGroup = this;
        this.delayFrame = o.delayFrame;
        this.mainPlayOver = o.mainPlayOver;
        this.pause = o.pause;
        this._waitDialog = o._waitDialog;
        for (var i = 0; i < o.executeFuncs.length; i++) {
            var executeFuncData = o.executeFuncs[i];
            var executeFunc = this.executeFuncs[i] = {};
            ObjectUtils.clone(executeFuncData, executeFunc);
            executeFunc.func = executeFunc.cls ? globalThis[executeFunc.cls][executeFunc.funcName] : this[executeFunc.funcName];
        }
        for (var i = 0; i < o.motionImages.length; i++) {
            var motionImageData = o.motionImages[i];
            var motionImage = this.motionImages[i] = {};
            ObjectUtils.clone(motionImageData, motionImage);
            motionImage.tween = GameUtils.getTween(motionImage.tweenID)[0];
        }
        for (var i = 0; i < o.motionAnimations.length; i++) {
            var motionAnimationData = o.motionAnimations[i];
            var motionAnimation = this.motionAnimations[i] = {};
            ObjectUtils.clone(motionAnimationData, motionAnimation);
            motionAnimation.tween = GameUtils.getTween(motionAnimation.tweenID)[0];
        }
        for (var i = 0; i < o.motionAnimations.length; i++) {
            var changeTonalData = o.changeTonals[i];
            var changeTonal = this.changeTonals[i] = {};
            ObjectUtils.clone(changeTonalData, changeTonal);
            changeTonal.tween = GameUtils.getTween(changeTonal.tweenID)[0];
        }
        for (var i = 0; i < o.motionUICompAttrs.length; i++) {
            var motionUICompAttrData = o.motionUICompAttrs[i];
            var motionUICompAttr = this.motionUICompAttrs[i] = {};
            var m = this.motionUICompAttrs[i];
            ObjectUtils.clone(motionUICompAttrData, motionUICompAttr);
            motionUICompAttr.tween = GameUtils.getTween(motionUICompAttr.tweenID)[0];
            // 还原引用的组件对象
            var passageID = motionUICompAttr.id;
            var uiID = passageID - GameImage.UI_START_PASSAGE;
            var ui = GameUI.get(uiID);
            if (ui) {
                var uiCompsInfo = GameUI.getAllCompChildren(ui, true);
                for (var compID in m.atts) {
                    var uiComp = uiCompsInfo.keyValue[compID];
                    if (uiComp) {
                        m.atts[compID][0] = uiComp;
                    }
                    else {
                        delete m.atts[compID];
                    }
                }
            }
        }
        this.autoRotations = o.autoRotations;
    };
    return GameImageGroup;
}());
/**
 * 图像层
 * Created by 黑暗之神KDS on 2020-11-27 10:10:13.
 */
var GameImageLayer = /** @class */ (function (_super) {
    __extends(GameImageLayer, _super);
    /**
     * 构造函数
     */
    function GameImageLayer() {
        var _this = _super.call(this) || this;
        /**
         * 相机
         */
        _this.camera = new Camera();
        /**
         * 相机更改记录
         */
        _this.cameraRecord = new Camera;
        // var halfW = Config.WINDOW_WIDTH / 2;
        // var halfH = Config.WINDOW_HEIGHT / 2;
        if (Config.EDIT_MODE || Config.WINDOW_WIDTH != null) {
            // 计算分辨率对角线长度
            _this.initRoot();
        }
        else {
            EventUtils.addEventListener(ClientWorld, ClientWorld.EVENT_BEFORE_INITED, Callback.New(_this.initRoot, _this), true);
        }
        return _this;
    }
    /**
     * 初始化坐标
     */
    GameImageLayer.initDPCoord = function () {
        var code = "\n                (function(){\n                    var ___export = {};\n                    " + Config.IMAGE_LAYER_DP_COORD_JS + "\n                    if(typeof dpCoordToRealCoord != \"undefined\")___export.dpCoordToRealCoord = dpCoordToRealCoord;\n                    if(typeof realCoordToDPCoord != \"undefined\")___export.realCoordToDPCoord = realCoordToDPCoord;\n                    return ___export;\n                })();\n            ";
        GameImageLayer.dpCoordFuncObject = eval(code);
    };
    /**
     * 设置通道显示对象
     */
    GameImageLayer.setImageSprite = function (passageID, sp) {
        GameImageLayer.imageSprites[passageID] = { displayObject: sp };
    };
    /**
     *
     * @param passageID
     */
    GameImageLayer.getImageSprite = function (passageID) {
        var info = GameImageLayer.imageSprites[passageID];
        return info ? info.displayObject : null;
    };
    /**
     * 删除通道
     * -- 清理显示对象
     * --
     * @param passageID
     */
    GameImageLayer.deletePassage = function (passageID) {
        // 清理所有帧刷
        this.clearPassageFrameUpdate(passageID);
        // 清理掉显示对象
        var spInfo = GameImageLayer.imageSprites[passageID];
        if (spInfo) {
            var displayObject = spInfo.displayObject;
            displayObject.removeSelf();
            // 图像层的显示对象都释放掉，界面层除外
            if (displayObject instanceof GCAnimation || displayObject instanceof UIComponent.UIAvatar || displayObject instanceof UIComponent.UIBitmap ||
                (displayObject instanceof UIComponent.GUI_BASE && displayObject.useDPCoord)) {
                displayObject.dispose();
            }
            delete GameImageLayer.imageSprites[passageID];
        }
    };
    /**
     * 注册帧刷效果，支持注册多个
     * @param passageID
     * @param onUpdate
     * @param thisPtr
     * @param args [可选] 默认值=null
     * @param sign [可选] 默认值=null 标识，清理时可清理指定的标识
     */
    GameImageLayer.regPassageFrameUpdate = function (passageID, onUpdate, thisPtr, args, sign) {
        if (args === void 0) { args = null; }
        if (sign === void 0) { sign = null; }
        // 注册
        var passageFrameUpdateArr = GameImageLayer.imageFrameUpdates[passageID];
        if (!passageFrameUpdateArr)
            passageFrameUpdateArr = GameImageLayer.imageFrameUpdates[passageID] = [];
        passageFrameUpdateArr.push({ onUpdate: onUpdate, thisPtr: thisPtr, sign: sign, args: args });
        os.add_ENTERFRAME(onUpdate, thisPtr, args);
    };
    /**
     * 清理移动效果
     * @param passageID
     * @param sign [可选] 默认值=null 标识，清理时可清理指定的标识
     */
    GameImageLayer.clearPassageFrameUpdate = function (passageID, sign) {
        if (sign === void 0) { sign = null; }
        var passageFrameUpdateArr = GameImageLayer.imageFrameUpdates[passageID];
        if (!passageFrameUpdateArr)
            return;
        if (sign == null) {
            for (var i = 0; i < passageFrameUpdateArr.length; i++) {
                var frameUpdateInfo = passageFrameUpdateArr[i];
                if (frameUpdateInfo) {
                    os.remove_ENTERFRAME(frameUpdateInfo.onUpdate, frameUpdateInfo.thisPtr);
                }
            }
            passageFrameUpdateArr.length = 0;
        }
        else {
            for (var i = 0; i < passageFrameUpdateArr.length; i++) {
                var frameUpdateInfo = passageFrameUpdateArr[i];
                if (frameUpdateInfo && frameUpdateInfo.sign == sign) {
                    os.remove_ENTERFRAME(frameUpdateInfo.onUpdate, frameUpdateInfo.thisPtr);
                    passageFrameUpdateArr.splice(i, 1);
                    i--;
                }
            }
        }
    };
    GameImageLayer.getPassageFrameUpdates = function () {
        return this.imageFrameUpdates;
    };
    GameImageLayer.prototype.initRoot = function () {
        if (this.inited)
            return;
        this.inited = true;
        // 深度坐标系编译
        if (!GameImageLayer.dpCoordInited) {
            GameImageLayer.dpCoordInited = true;
            GameImageLayer.initDPCoord();
        }
        var halfW = Config.WINDOW_WIDTH / 2;
        var halfH = Config.WINDOW_HEIGHT / 2;
        this.root = new GameSprite();
        // 计算分辨率对角线长度
        var ObliqueLineDistance = Point.distance2(0, 0, Config.WINDOW_WIDTH, Config.WINDOW_HEIGHT) + 2;
        this.rootParent = new GameSprite();
        this.rootParentSize = ObliqueLineDistance;
        this.addChild(this.rootParent);
        this.rootRotationArea = new GameSprite();
        this.rootParent.addChild(this.rootRotationArea);
        // this.rootParent.addChild(this.root);
        // this.rootParent.x = -ObliqueLineDistance * 0.5;
        // this.rootParent.y = -ObliqueLineDistance * 0.5;
        // this.root.x = (ObliqueLineDistance - Config.WINDOW_WIDTH) * 0.5;
        // this.root.y = (ObliqueLineDistance - Config.WINDOW_HEIGHT) * 0.5;
        // this.x = halfW;
        // this.y = halfH;
        var w2 = (ObliqueLineDistance - Config.WINDOW_WIDTH) / 2;
        var h2 = (ObliqueLineDistance - Config.WINDOW_HEIGHT) / 2;
        /// 
        // this.addChild(this.rootParent);
        this.rootRotationArea.addChild(this.root);
        this.x = 0;
        this.y = 0;
        this.rootRotationArea.pivotX = w2 + halfW;
        this.rootRotationArea.pivotY = h2 + halfH;
        this.rootRotationArea.x = halfW;
        this.rootRotationArea.y = halfH;
        this.rootParent.x = 0;
        this.rootParent.y = 0;
        this.root.x = w2;
        this.root.y = h2;
        this.rootRealDPostion = new Point(this.rootParent.x + this.root.x - w2, this.rootParent.y + this.root.y - halfH);
        // 非编辑器模式下直接裁剪
        if (!Config.EDIT_MODE) {
            this.rootParent.scrollRect = new Rectangle(0, 0, this.rootParentSize, this.rootParentSize);
        }
        this.width = Config.WINDOW_WIDTH;
        this.height = Config.WINDOW_HEIGHT;
        // this.graphics.drawRect(0, 0, 100, 100, "#FF00000");
        // 代理方法
        ObjectUtils.agentFunction(this, "root", ["addChild", "addChildren", "addChildAt", "setChildIndex", "removeChild", "removeSelf", "removeChildByName", "removeChildAt", "removeChildren"], "Callback.CallLaterBeforeRender(this.updateFrame, this, [true]);");
        ObjectUtils.agentFunction(this, "root", ["getChildIndex", "getChildByName", "getChildAt", "replaceChild", "contains"]);
        ObjectUtils.agentFunction(this, "root", ["doRepaint", "setMaterialValueFast", "setMaterialDirty", "setMaterialsByGameSprite", "swapMaterialPass", "swapMaterialIndex", "setMaterialIndex", "clearMaterialsInPass",
            "clearMaterials", "getMaterialPassLength", "getMaterialLength", "getMaterialAt", "getMaterialByID", "removeMaterialByID", "removeMaterialAt", "removeMaterial",
            "addMaterialAtByID", "addMaterialByID", "addMaterialAt", "addMaterial", "installMaterialData", "getAllMaterialDatas"]);
        os.add_ENTERFRAME(this.updateFrame, this, [false]);
        this.on(EventObject.DISPLAY, this, this.updateFrame, [false]);
    };
    GameImageLayer.prototype.updateFrame = function (force) {
        if (force === void 0) { force = false; }
        if (!this.stage || !this.rootRotationArea)
            return;
        var isCameraDirty = force || this.cameraRecord.viewPort.x != this.camera.viewPort.x || this.cameraRecord.viewPort.y != this.camera.viewPort.y ||
            this.cameraRecord.scaleX != this.camera.scaleX || this.cameraRecord.scaleY != this.camera.scaleY ||
            this.cameraRecord.offsetX != this.camera.offsetX || this.cameraRecord.offsetY != this.camera.offsetY ||
            this.cameraRecord.z != this.camera.z;
        this.rootRotationArea.rotation = this.camera.rotation;
        // 显示层次刷新
        var imageLength = this.root.numChildren;
        var imageArr = [];
        var elseImageArr = [];
        for (var i = 0; i < imageLength; i++) {
            var child = this.getChildAt(i);
            if (child instanceof GameSprite) {
                if (child.useDPCoord) {
                    imageArr.push(child);
                }
                else {
                    elseImageArr.push(child);
                }
            }
        }
        this.updateChildZOrder(imageArr);
        this.updateChildZOrder(elseImageArr, imageArr.length);
        // 需要刷新相机的场合
        if (isCameraDirty) {
            // 重新记录
            this.cameraRecord.viewPort.x = this.camera.viewPort.x;
            this.cameraRecord.viewPort.y = this.camera.viewPort.y;
            this.cameraRecord.scaleX = this.camera.scaleX;
            this.cameraRecord.scaleY = this.camera.scaleY;
            this.cameraRecord.offsetX = this.camera.offsetX;
            this.cameraRecord.offsetY = this.camera.offsetY;
            this.cameraRecord.z = this.camera.z;
            // 更新镜头
            for (var i = 0; i < imageArr.length; i++) {
                var child = imageArr[i];
                child.dpCameraX = -(this.camera.viewPort.x + this.camera.offsetX);
                child.dpCameraY = -(this.camera.viewPort.y + this.camera.offsetY);
                child.dpCameraZ = this.camera.z;
                // ttttt 1帧未能刷新
                child.dpCoordToRealCoord();
            }
        }
    };
    GameImageLayer.prototype.updateChildZOrder = function (imageArr, startIndex, useZ) {
        if (imageArr === void 0) { imageArr = null; }
        if (startIndex === void 0) { startIndex = 0; }
        if (useZ === void 0) { useZ = true; }
        if (!imageArr) {
            var imageLength = this.root.numChildren;
            var imageArr = [];
            for (var i = 0; i < imageLength; i++) {
                var child = this.getChildAt(i);
                if (child instanceof GameSprite) {
                    imageArr.push(child);
                }
            }
        }
        if (useZ) {
            imageArr.sort(function (a, b) {
                if (a.dpZ == b.dpZ) {
                    return a.dpDisplayPriority < b.dpDisplayPriority ? -1 : 1;
                }
                return a.dpZ > b.dpZ ? -1 : 1;
            });
        }
        else {
            imageArr.sort(function (a, b) {
                return a.dpDisplayPriority < b.dpDisplayPriority ? -1 : 1;
            });
        }
        var arrLen = imageArr.length;
        for (var j = 0; j < arrLen; j++) {
            this.root.setChildIndex(imageArr[j], j + startIndex);
        }
    };
    Object.defineProperty(GameImageLayer.prototype, "numChildren", {
        //------------------------------------------------------------------------------------------------------
        // 相机操作
        //------------------------------------------------------------------------------------------------------
        //------------------------------------------------------------------------------------------------------
        // 重写方法
        //------------------------------------------------------------------------------------------------------
        get: function () {
            return this.root.numChildren;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameImageLayer.prototype, "filterEnabled", {
        get: function () {
            return this.root.filterEnabled;
        },
        set: function (v) {
            this.root.filterEnabled = v;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 通道
     */
    GameImageLayer.imageLayerPassageData = [];
    //------------------------------------------------------------------------------------------------------
    // 运行时图像层系统
    //------------------------------------------------------------------------------------------------------
    GameImageLayer.imageSprites = {};
    GameImageLayer.imageFrameUpdates = {};
    return GameImageLayer;
}(GameSprite));
/**
 * 游戏显示层次
 * -- 场景层
 * -- 图像层
 * -- UI层
 * 重写 initLayer 可以自定义层次关系
 * Created by 黑暗之神KDS on 2019-01-09 15:09:23.
 */
var GameLayer = /** @class */ (function (_super) {
    __extends(GameLayer, _super);
    /**
     * 构造函数
     */
    function GameLayer() {
        var _this = _super.call(this) || this;
        /**
         * 场景层
         */
        _this.sceneLayer = new GameSprite();
        /**
        * 图像层
        */
        _this.imageLayer = new GameImageLayer();
        /**
         * UI层
         */
        _this.uiLayer = new GameSprite();
        _this.graphics.drawRect(0, 0, 1, 1, "#000000");
        _this.initLayer();
        return _this;
    }
    /**
     * 初始化层次
     */
    GameLayer.prototype.initLayer = function () {
        this.addChild(this.sceneLayer);
        this.addChild(this.imageLayer);
        this.addChild(this.uiLayer);
        stage.addChild(this);
    };
    return GameLayer;
}(GameSprite));
var GameSpriteMaterialPass = /** @class */ (function (_super) {
    __extends(GameSpriteMaterialPass, _super);
    //------------------------------------------------------------------------------------------------------
    // 构造和释放
    //------------------------------------------------------------------------------------------------------
    function GameSpriteMaterialPass(gameSprite) {
        var _this = _super.call(this) || this;
        /**
         * 可出现的变量宏 MU材质编号_变量名称
         */
        _this.varMacros = [];
        /**
         * 材质ID
         */
        _this.kdsSetMaterialMacros = [];
        /**
         * 材质数据
         */
        _this.materials = [];
        /**
         * 材质数据对应的[传递参数前计算的函数]
         */
        _this.materialsPerShaderFuncs = [];
        /**
         * 材质数据的时间过渡记录值
         * 储存的时间过渡变量信息（因为一个材质可能多个）
         * muVarName = shader变量名
         * current = 当前帧
         * totalFrame = 总帧
         * transData = 过渡数据
         */
        _this.materialsTransInfos = [];
        /**
         * 请求监听变量的Callback函数
         */
        _this.listenVarCallbacks = [];
        /**
         * 请求监听字符串变量的Callback函数
         */
        _this.listenStrVarCallbacks = [];
        /**
         * 请求的时间循环函数
         */
        _this.timeFuncs = [];
        /**
         * 请求加载的图片资源
         */
        _this.imageLoads = [];
        if (Render.isWebGL)
            WebGLFilter.enable();
        _this._action = new GameSpriteMaterialPassActionGL();
        _this._action.data = _this;
        _this.gameSprite = gameSprite;
        if (Config.EDIT_MODE) {
            EventUtils.addEventListener(EUIWindowDataStructureConfig, EUIWindowDataStructureConfig.EVENT_CUSTOM_DATA_CHANGED, Callback.New(_this.onCustomDataChange, _this));
        }
        return _this;
    }
    /**
     * 释放
     */
    GameSpriteMaterialPass.prototype.dispose = function () {
        this.clearRegFuncs();
    };
    /**
     * 清理掉注册的函数
     */
    GameSpriteMaterialPass.prototype.clearRegFuncs = function () {
        // 清理掉监听数值变量
        for (var i = 0; i < this.listenVarCallbacks.length; i++) {
            var cbs = this.listenVarCallbacks[i];
            var varID = cbs[0];
            var cb = cbs[1];
            Game.player.removeListenerPlayerVariable(0, varID, cb);
        }
        this.listenVarCallbacks.length = 0;
        /// 清理掉监听字符串变量
        for (var i = 0; i < this.listenStrVarCallbacks.length; i++) {
            var cbs = this.listenStrVarCallbacks[i];
            var varID = cbs[0];
            var cb = cbs[1];
            Game.player.removeListenerPlayerVariable(2, varID, cb);
        }
        this.listenVarCallbacks.length = 0;
        // 清理掉时间相关的函数
        for (var i = 0; i < this.timeFuncs.length; i++) {
            os.remove_ENTERFRAME(this.timeFuncs[i], this);
        }
        this.timeFuncs.length = 0;
        // 清理掉请求加载的图片资源
        for (var i = 0; i < this.imageLoads.length; i++) {
            var url = this.imageLoads[i];
            AssetManager.disposeImage(url);
        }
        this.imageLoads.length = 0;
        // 清理所有时间相关的函数
        for (var i = 0; i < this.materialsTransInfos.length; i++) {
            var transV = this.materialsTransInfos[i];
            if (TransData.isUseFrame(transV.transData)) {
                os.remove_ENTERFRAME(transV.funcSign, this);
            }
            else {
                clearInterval(transV.funcSign);
            }
        }
        this.materialsTransInfos.length = 0;
    };
    //------------------------------------------------------------------------------------------------------
    // 编辑器
    //------------------------------------------------------------------------------------------------------
    GameSpriteMaterialPass.prototype.onCustomDataChange = function (mode) {
        // 当更改了材质的情况则清理缓存
        if (mode == EUIWindowDataStructureConfig.MODE_CUSTOM_MATERIAL) {
            GameSpriteMaterialPass.materialSettingAttrsCache = [];
            GameSpriteMaterialPass.materialSettingBlockMappingCache = [];
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    GameSpriteMaterialPass.color2RGB = function (color) {
        if (typeof color != "string")
            return [0, 0, 0];
        var r = MathUtils.int("0x" + color.substr(1, 2)) / 255;
        var g = MathUtils.int("0x" + color.substr(3, 2)) / 255;
        var b = MathUtils.int("0x" + color.substr(5, 2)) / 255;
        return [r, g, b];
    };
    Object.defineProperty(GameSpriteMaterialPass.prototype, "action", {
        //------------------------------------------------------------------------------------------------------
        // 
        //------------------------------------------------------------------------------------------------------
        get: function () {
            return this._action;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSpriteMaterialPass.prototype, "type", {
        get: function () {
            return GameSpriteMaterialPass.shaderType;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 刷新渲染数据，计算当前所有附加的材质
     * -- 当材质发生增删改的时候需要刷新
     */
    GameSpriteMaterialPass.prototype.refreshRenderData = function () {
        this.shaderSize = false;
        this.clearRegFuncs();
        this.shaderData = {};
        this.varMacros = [];
        this.materialsPerShaderFuncs = [];
        this.materialsTransInfos = [];
        var varMacrosForID = [];
        var varInBlockMapping = {};
        this.kdsSetMaterialMacros.length = 0;
        var len = this.materials.length;
        for (var i = 0; i < len; i++) {
            var material = this.materials[i];
            if (material.enable != null && !material.enable)
                continue;
            var materialID = material.id;
            // 获取材质配置
            var materialSetting = Game.data.materialList.data[materialID];
            if (!materialSetting)
                continue;
            if (materialSetting.shaderSize) {
                this.shaderSize = true;
            }
            // 缓存执行方法
            if (!Config.EDIT_MODE) {
                var perShaderClacFunc = GameSpriteMaterialPass.materialSettingPerShaderClacTSCode[materialID];
                if (!perShaderClacFunc) {
                    eval("perShaderClacFunc = GameSpriteMaterialPass.materialSettingPerShaderClacTSCode[materialID] = function(shader,sp){" + materialSetting.customPreShaderClacJS + "}");
                }
                this.materialsPerShaderFuncs[i] = perShaderClacFunc;
            }
            // 修正材质数据
            CustomCompositeSetting.fixShaderTsValue(materialID, material, materialSetting);
            // 游戏运行时：获取材质数据缓存
            var mAttrs = GameSpriteMaterialPass.materialSettingAttrsCache[materialID];
            if (!mAttrs) {
                var mAttrArr = CustomCompositeSetting.getAllAttributes(materialSetting, true, varInBlockMapping);
                mAttrs = {};
                for (var m = 0; m < mAttrArr.length; m++) {
                    var mAttr = mAttrArr[m];
                    mAttrs[mAttr.attr.varName] = mAttr;
                }
                GameSpriteMaterialPass.materialSettingAttrsCache[materialID] = mAttrs;
                GameSpriteMaterialPass.materialSettingBlockMappingCache[materialID] = varInBlockMapping;
            }
            else {
                varInBlockMapping = GameSpriteMaterialPass.materialSettingBlockMappingCache[materialID];
            }
            // 计算 idValue & varNameValue
            var idValue = {};
            var varNameValue = {};
            for (var s in material) {
                var mAttr = mAttrs[s];
                if (!mAttr)
                    continue;
                var oriValue = material[s];
                if (typeof oriValue == "function")
                    continue;
                varNameValue[s] = oriValue;
                idValue[mAttr.attr.id] = oriValue;
            }
            // 获取材质下属性集
            for (var s in material) {
                var oriValue = material[s];
                if (typeof oriValue == "function")
                    continue;
                var mAttr = mAttrs[s];
                var runtimeValue = this.getMaterialRuntimeValue(material, s, oriValue, mAttr, idValue, varNameValue, varInBlockMapping[s]);
                this.shaderData["mu" + materialID + "_" + s] = runtimeValue;
                // 变量宏
                if (runtimeValue != null) {
                    this.varMacros.push("MU" + materialID + "_" + s);
                    varMacrosForID.push(s);
                }
            }
            this.kdsSetMaterialMacros.push(materialID);
        }
        // 代码唯一标识为使用的材质和当前已使用的变量
        this.kdsSetMaterialMacrosID = "_" + this.kdsSetMaterialMacros.join("_") + "-" + varMacrosForID.join("-") + "-" + this.varMacros.join("-");
    };
    /**
     * 获取材质运行时的值，用于设置shaderValue
     * 会将currentFrame反储存至 material.____timeInfo[varName] = 帧/时间
     * @param material
     * @param varName
     * @param oriValue
     * @param attrSetting
     * @return [any]
     */
    GameSpriteMaterialPass.prototype.getMaterialRuntimeValue = function (material, varName, oriValue, attrSetting, idValue, varNameValue, block) {
        var _this = this;
        // return null 处理
        function returnNullHandle() {
            if (compType == 13 || compType == 22 || compType == 14) {
                var uvInfoName = "mu" + material.id + "_" + varName + "_UVInfo";
                this.shaderData[uvInfoName] = [0, 0, 0, 0];
            }
        }
        // 不存在设定时返回null
        if (!attrSetting || !block) {
            returnNullHandle.apply(this);
            return null;
        }
        ;
        // 获取对应的组件类型
        var compType = attrSetting.attr.compData.compType;
        // 是否允许作为shaderValue使用
        if (CustomAttributeSetting.getShaderUniformType(attrSetting.attr) == null) {
            returnNullHandle.apply(this);
            return null;
        }
        // 块条件都不满足的话则忽略掉
        var canShowInBlock = CustomCompositeBlock.meetConditionData(block, idValue, varNameValue);
        if (!canShowInBlock) {
            returnNullHandle.apply(this);
            return null;
        }
        // 是否满足出现条件
        var canShow = CustomCompositeAttributeSetting.meetConditionData(attrSetting.attrConditions, idValue, varNameValue);
        // 未能显示的属性（未满足条件）
        if (!canShow) {
            returnNullHandle.apply(this);
            return null;
        }
        // 属性类别：颜色
        if (compType == 12) {
            return GameSpriteMaterialPass.color2RGB(oriValue);
        }
        // 属性类别：时间 从0-1 第一帧是0，持续多少帧
        else if (compType == 41) {
            var transData = GameUtils.getTransData(oriValue);
            if (!transData || transData.timeType == 0) {
                transData = new TransData();
                transData.timeType = 2;
            }
            var isLoop = TransData.isLoop(transData);
            // 帧刷：从0-1，非循环则一次，否则循环执行
            if (TransData.isUseFrame(transData)) {
                var totalFrame = transData.totalTime - 1;
                if (totalFrame <= 0)
                    return null;
                if (!material.____timeInfo)
                    material.____timeInfo = {};
                var currentFrame = MathUtils.int(material.____timeInfo[varName]);
                if (currentFrame > totalFrame)
                    currentFrame = totalFrame;
                var transV = { muVarName: "mu" + material.id + "_" + varName, currentFrame: currentFrame, totalFrame: totalFrame, transData: transData, isLoop: isLoop, value: null, funcSign: null, lastRefresh: null };
                var f;
                os.add_ENTERFRAME(f = function (transV, material, varName) {
                    // 非循环则制作完毕后终止
                    if (transV.currentFrame > transV.totalFrame) {
                        if (!transV.isLoop) {
                            // @ts-ignore
                            os.remove_ENTERFRAME(arguments.callee, _this);
                            // 不移除数据，以便保持最后一帧的状态持续
                            // var idx = this.materialsTransInfos.indexOf(transV);
                            // this.materialsTransInfos.splice(idx, 1);
                            return;
                        }
                        else {
                            transV.lastRefresh = 0;
                            transV.currentFrame = 0;
                        }
                    }
                    // 满足间隔时间才允许刷新
                    if (transV.lastRefresh == null || transV.currentFrame - transV.lastRefresh >= transV.transData.refreshInterval / Game.oneFrame) {
                        // trace("刷新-------------------------------------", transV.currentFrame, transV.lastRefresh);
                        transV.lastRefresh = transV.currentFrame;
                        // 脏标记
                        var per = transV.currentFrame / transV.totalFrame;
                        var value = GameUtils.getValueByTransData(transV.transData, per);
                        transV.value = value;
                        // 允许渲染提交
                        Callback.CallLaterBeforeRender(_this.gameSprite.doRepaint, _this.gameSprite);
                    }
                    transV.currentFrame++;
                    if (!material.____timeInfo)
                        material.____timeInfo = {};
                    material.____timeInfo[varName] = transV.currentFrame;
                }, this, [transV, material, varName]);
                transV.funcSign = f;
                // 当前帧立即调用一次
                f.apply(this, [transV, material, varName]);
            }
            else if (TransData.isUseTime(transData)) {
                totalFrame = Math.floor(transData.totalTime * 1000 / transData.refreshInterval);
                // 间隔时间
                if (!material.____timeInfo)
                    material.____timeInfo = {};
                var currentFrame = MathUtils.int(material.____timeInfo[varName]);
                if (currentFrame > totalFrame)
                    currentFrame = totalFrame;
                // 最后一帧必须是1
                var transV = { muVarName: "mu" + material.id + "_" + varName, currentFrame: currentFrame, totalFrame: totalFrame, transData: transData, isLoop: isLoop, value: null, funcSign: null, lastRefresh: null };
                var f;
                var interSign = setInterval(f = function (transV, material, varName) {
                    if (transV.currentFrame > transV.totalFrame) {
                        if (!transV.isLoop) {
                            clearInterval(transV.funcSign);
                            // 不移除数据，以便保持最后一帧的状态持续
                            // var idx = this.materialsTransInfos.indexOf(transV);
                            // this.materialsTransInfos.splice(idx, 1);
                            return;
                        }
                        else {
                            transV.currentFrame = 0;
                        }
                    }
                    var per = transV.currentFrame == transV.totalFrame ? 1 : transV.currentFrame / transV.totalFrame;
                    var value = GameUtils.getValueByTransData(transV.transData, per);
                    transV.value = value;
                    transV.currentFrame++;
                    // 允许渲染提交
                    Callback.CallLaterBeforeRender(_this.gameSprite.doRepaint, _this.gameSprite);
                    if (!material.____timeInfo)
                        material.____timeInfo = {};
                    material.____timeInfo[varName] = transV.currentFrame;
                }, transData.refreshInterval, transV, material, varName);
                transV.funcSign = interSign;
                // 当前帧立即调用一次
                f.apply(this, [transV, material, varName]);
            }
            if (totalFrame == null)
                return null;
            this.materialsTransInfos.push(transV);
            return 0;
        }
        // 属性类别：变量
        else if (compType == 6) {
            if (Config.EDIT_MODE || Config.BEHAVIOR_EDIT_MODE) {
                return 0;
            }
            var varID = MathUtils.int(oriValue);
            if (varID == 0)
                return 0;
            var cb = Callback.New(function (shaderValueName, typeID, varID, value) {
                // -- 直接修改shaderData
                _this.shaderData[shaderValueName] = value;
                _this.gameSprite.repaint();
            }, this, ["mu" + material.id + "_" + varName]);
            this.listenVarCallbacks.push([varID, cb]);
            Game.player.addListenerPlayerVariable(0, varID, cb, false, false);
            return Game.player.variable.getVariable(oriValue);
        }
        // 属性类别：贴图，如果该贴图尚未加载完成则去加载，否则
        else if (compType == 13 || compType == 22 || compType == 14) {
            var uvInfoName = "mu" + material.id + "_" + varName + "_UVInfo";
            // 字符串变量
            if (compType == 14) {
                var strVarID = GameUtils.getVarID(oriValue);
                if (strVarID != 0) {
                    if (Config.EDIT_MODE || Config.BEHAVIOR_EDIT_MODE) {
                        returnNullHandle.apply(this);
                        return null;
                    }
                    // 转换为当前值，让下面显示图片
                    oriValue = Game.player.variable.getString(strVarID);
                    // 监听
                    var cb = Callback.New(function (shaderValueName, uvInfoName, oldUrl, material, varName, typeID, varID, value) {
                        // -- 清理掉旧的图片URL
                        var oldTexIdx = _this.imageLoads.indexOf(oldUrl);
                        if (oldTexIdx != -1) {
                            _this.imageLoads.splice(oldTexIdx, 1);
                            AssetManager.disposeImage(oldUrl);
                        }
                        // -- 直接修改shaderData
                        _this.shaderData[shaderValueName] = getTextureValue.apply(_this, [value, material, varName, uvInfoName]);
                        _this.gameSprite.repaint();
                    }, this, ["mu" + material.id + "_" + varName, uvInfoName, oriValue, material, varName]);
                    this.listenStrVarCallbacks.push([strVarID, cb]);
                    Game.player.addListenerPlayerVariable(2, strVarID, cb, false, false);
                }
            }
            // @ts-ignore
            function getTextureValue(oriValue, material, varName, uvInfoName) {
                var _this = this;
                //
                if (typeof oriValue != "string") {
                    returnNullHandle.apply(this);
                    return null;
                }
                var tex = AssetManager.getImage(oriValue);
                if (!tex) {
                    this.imageLoads.push(oriValue);
                    AssetManager.loadImage(oriValue, Callback.New(function (shaderValueName, uvInfoName, tex) {
                        // -- 直接修改shaderData
                        _this.shaderData[shaderValueName] = tex ? tex.source : null;
                        if (tex)
                            _this.shaderData[uvInfoName] = [tex.uv[2] - tex.uv[0], tex.uv[5] - tex.uv[1], tex.uv[0], tex.uv[1]];
                        else
                            _this.shaderData[uvInfoName] = [0, 0, 0, 0];
                        _this.gameSprite.repaint();
                    }, this, ["mu" + material.id + "_" + varName, uvInfoName]), true, true, true);
                    this.shaderData[uvInfoName] = [0, 0, 0, 0];
                    return null;
                }
                else {
                    // 引用计数+1
                    if (tex.url) {
                        this.imageLoads.push(tex.url);
                        AssetManager.loadImage(tex.url, null, true, true, false);
                    }
                    // 如果未能预渲染的话，无法获得
                    if (!tex["__rendered"]) {
                        var sp = new Sprite;
                        sp.texture = tex;
                        sp.texture["__rendered"] = true;
                        AssetManager.prerender(sp);
                        sp.texture = null;
                        sp.destroy(true);
                    }
                    this.shaderData[uvInfoName] = [tex.uv[2] - tex.uv[0], tex.uv[5] - tex.uv[1], tex.uv[0], tex.uv[1]];
                    return tex.source;
                }
            }
            return getTextureValue.apply(this, [oriValue, material, varName, uvInfoName]);
        }
        return oriValue;
    };
    GameSpriteMaterialPass.shaderType = 0x800;
    // 缓存的材质 [materialID] = { [varName: string]: CustomCompositeAttributeSetting };
    GameSpriteMaterialPass.materialSettingAttrsCache = [];
    GameSpriteMaterialPass.materialSettingBlockMappingCache = [];
    // 缓存材质的传递参数前计算的函数，以便直接调用，如果没有则为空 [id] => 方法
    GameSpriteMaterialPass.materialSettingPerShaderClacTSCode = [];
    return GameSpriteMaterialPass;
}(Filter));
var GameSpriteMaterialPassActionGL = /** @class */ (function (_super) {
    __extends(GameSpriteMaterialPassActionGL, _super);
    function GameSpriteMaterialPassActionGL() {
        return _super.call(this) || this;
    }
    //------------------------------------------------------------------------------------------------------
    // gcide_canvasbuilder.System
    //------------------------------------------------------------------------------------------------------
    GameSpriteMaterialPassActionGL.prototype.apply3d = function (scope, sprite, context, x, y) {
        var b = scope.getValue("bounds");
        var shaderValue = Value2D.create(0x01, 0);
        shaderValue.setFilters([this.data]);
        var tMatrix = Matrix.TEMP;
        tMatrix.identity();
        context.ctx.drawTarget(scope, 0, 0, b.width, b.height, tMatrix, "src", shaderValue);
        shaderValue.setFilters(null);
    };
    ;
    Object.defineProperty(GameSpriteMaterialPassActionGL.prototype, "typeMix", {
        /**
         * 获取类型
         */
        get: function () {
            return GameSpriteMaterialPass.shaderType;
        },
        enumerable: false,
        configurable: true
    });
    GameSpriteMaterialPassActionGL.prototype.setValueMix = function (shader) {
        shader.defines.add(this.data.type);
        var o = shader;
    };
    ;
    //------------------------------------------------------------------------------------------------------
    // 设置渲染用的uniform值
    //------------------------------------------------------------------------------------------------------
    GameSpriteMaterialPassActionGL.prototype.setValue = function (shader) {
        // 设置传递值
        var shaderData = this.data.shaderData;
        for (var i in shaderData) {
            shader[i] = shaderData[i];
        }
        // 根据此项计算用于渲染的代码
        shader.kdsSetMaterialMacros = this.data.kdsSetMaterialMacros;
        shader.kdsSetMaterialMacrosID = this.data.kdsSetMaterialMacrosID;
        shader.kdsVarMacros = this.data.varMacros;
        var sp = this.data.gameSprite;
        // 传输尺寸的情况
        if (this.data.shaderSize) {
            if (sp.hasTilingAttribute) {
                if (sp instanceof ClientSceneLayer) {
                    if (!sp.drawMode) {
                        var tex = AssetManager.getImage(sp.mapUrl);
                        if (tex) {
                            shader["renderTargetSize"] = [tex.width + 8, tex.height + 8];
                        }
                    }
                    else {
                        // 图块需要倒置
                        shader["u_yFilp"] = 1.0;
                        var selfBounds = sp.getSelfBounds();
                        shader["renderTargetSize"] = [selfBounds.width + 8, selfBounds.height + 8];
                    }
                }
            }
            else {
                var selfBounds = sp.getSelfBounds();
                shader["renderTargetSize"] = [selfBounds.width + 8, selfBounds.height + 8];
            }
        }
        // 不传输尺寸的情况
        else {
            if (sp instanceof ClientSceneLayer && sp.drawMode) {
                shader["u_yFilp"] = 1.0;
            }
        }
        // 材质参数预计算，编辑器模式实时计算，非编辑器环境需要预编译
        if (Config.EDIT_MODE) {
            var materials = this.data.materials;
            var materialsLen = materials.length;
            var materialListData = Game.data.materialList.data;
            for (var s = 0; s < materialsLen; s++) {
                var material = materials[s];
                var materialSetting = materialListData[material.id];
                if (materialSetting && materialSetting.customPreShaderClacJS) {
                    try {
                        eval(materialSetting.customPreShaderClacJS);
                    }
                    catch (e) {
                        trace("材质" + material.id + "参数传递前额外计算报错：", e.stack);
                    }
                }
            }
        }
        // 运行时使用预编译
        else {
            var materials = this.data.materials;
            var materialsLen = materials.length;
            var materialListData = Game.data.materialList.data;
            for (var s = 0; s < materialsLen; s++) {
                var material = materials[s];
                var perShaderClacFunc = this.data.materialsPerShaderFuncs[s];
                if (perShaderClacFunc) {
                    perShaderClacFunc.apply(this, [shader, sp]);
                }
            }
        }
        // 时间参数
        var materialsTransInfos = this.data.materialsTransInfos;
        if (materialsTransInfos) {
            for (var s = 0; s < materialsTransInfos.length; s++) {
                var m = materialsTransInfos[s];
                shader[m.muVarName] = m.value;
                // trace("传递参数", m.muVarName, per, value, m.oooo, "最终值===", shader[m.muVarName])
            }
        }
        // trace("更新滤镜效果", shader["renderTargetSize"])
    };
    ;
    return GameSpriteMaterialPassActionGL;
}(FilterActionGL));
/**
 * 游戏UI 管理器
 * Created by 黑暗之神KDS on 2018-10-12 13:40:11.
 */
var GameUI = /** @class */ (function () {
    function GameUI() {
    }
    //------------------------------------------------------------------------------------------------------
    // 判断
    //------------------------------------------------------------------------------------------------------
    /**
     * 是否已打开
     * @param uiID
     * @return [boolean]
     */
    GameUI.isOpened = function (uiID) {
        var ui = GameUI.get(uiID);
        if (ui && ui.stage)
            return true;
        return false;
    };
    //------------------------------------------------------------------------------------------------------
    // 系统单例界面系统
    // 相同ID的界面只存在一个，如若需要多个可以使用 load(id,true) 方式来克隆界面
    //------------------------------------------------------------------------------------------------------
    /**
     * 加载UI
     * @param id
     * @param copy [可选] 默认值=false
     * @return [UIComponent]
     */
    GameUI.load = function (id, copy) {
        if (copy === void 0) { copy = false; }
        var data = Common.uiList.data[id];
        if (!data)
            return null;
        // 编辑模式
        if (Config.EDIT_MODE) {
            if (data) {
                return GameUI.parse(data.uiDisplayData, false, null, id);
            }
            return GameUI.getEmptyRoot(id);
        }
        // 运行时模式
        // -- 非克隆模式下若已存在该UI则直接返回
        if (!copy && this.uiDatas[id]) {
            return this.uiDatas[id];
        }
        // 查询是否存在该类
        var instanceClassName = data.uiDisplayData.instanceClassName;
        var classObj = window[instanceClassName];
        if (!classObj)
            classObj = window["GUI_" + id];
        if (!classObj) {
            var emptyRoot = this.uiDatas[id] = new UIComponent.UIRoot;
            GameUI.parse(data.uiDisplayData, false, null, id, emptyRoot);
            return emptyRoot;
        }
        if (id == 0) {
            root = this.uiDatas[id] = GameUI.getEmptyRoot(id);
            return root;
        }
        // 新建立
        var root = new classObj();
        if (!copy) {
            this.uiDatas[id] = root;
        }
        return root;
    };
    /**
     * 获取已存在的系统组界面（包含此前打开过后关闭掉的，释放掉的话则不再该列表内）
     * @return { [uiID: number]: GUI_BASE }
     */
    GameUI.getAllSystemGroupUIs = function () {
        return GameUI.uiDatas;
    };
    /**
     * 获取界面
     */
    GameUI.get = function (id) {
        return GameUI.uiDatas[id];
    };
    /**
     * 释放UI
     */
    GameUI.dispose = function (id) {
        var ui = GameUI.uiDatas[id];
        if (ui) {
            delete GameUI.uiDatas[id];
            ui.dispose();
            EventUtils.happen(GameUI, GameUI.EVENT_CLOSE_SYSTEM_UI, [id]);
        }
    };
    /**
     * 显示界面
     * @param id
     */
    GameUI.show = function (id) {
        var ui = this.load(id);
        Game.layer.uiLayer.addChild(ui);
        EventUtils.happen(GameUI, GameUI.EVENT_OPEN_SYSTEM_UI, [id]);
        return ui;
    };
    /**
     * 隐藏界面
     * @param id 同ID则指同一个界面
     */
    GameUI.hide = function (id) {
        var ui = GameUI.uiDatas[id];
        if (ui && ui.stage) {
            Game.layer.uiLayer.removeChild(ui);
            EventUtils.happen(GameUI, GameUI.EVENT_CLOSE_SYSTEM_UI, [id]);
        }
    };
    /**
     * 隐藏全部界面
     */
    GameUI.hideAll = function () {
        for (var id in GameUI.uiDatas) {
            var ui = GameUI.uiDatas[id];
            if (ui.stage) {
                ui.removeSelf();
                EventUtils.happen(GameUI, GameUI.EVENT_CLOSE_SYSTEM_UI, [id]);
            }
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 初始化
     */
    GameUI.init = function () {
        for (var i in UIComponent) {
            window[i] = UIComponent[i];
        }
    };
    /**
     * 空UI界面
     */
    GameUI.getEmptyRoot = function (id) {
        var root = new UIComponent.UIRoot(true, id);
        Callback.New(function () { root.event(EventObject.LOADED); }, this).delayRun(0);
        return root;
    };
    /**
     * 解析UI
     * -- 先有根容器
     * -- 新建子容器并且赋值属性
     * -- 执行 子容器的constructorInit函数
     * -- 然后建立子容器的子容器并赋值属性
     * -- 执行 子容器的子容器的constructorInit函数
     * -- 执行根容器的constructorInit函数
     * @param data UI数据，使用该数据生成对应的控件对象，不更改此数据
     * @param newID [可选] 默认值=false [可选] 默认值=false 是否作为新的ID（如复制数据时由于ID是唯一的，应作为新的ID来处理）
     * @param childList 用于装载所有的UI-ID
     * @param uiID [可选] 默认值=null
     * @param root [可选] 默认值=null 传入进来的根容器，若不传入则新建一个容器
     * @param syncLoadedEventWhenAssetExist [可选] 默认值=false 当资源存在时同步派发加载完成事件，否则需要等待一帧（异步派发）
     * @return [UIComponent]
     */
    GameUI.parse = function (data, newID, childList, uiID, root, syncLoadedEventWhenAssetExist) {
        if (newID === void 0) { newID = false; }
        if (childList === void 0) { childList = null; }
        if (uiID === void 0) { uiID = null; }
        if (root === void 0) { root = null; }
        if (syncLoadedEventWhenAssetExist === void 0) { syncLoadedEventWhenAssetExist = false; }
        if (!root)
            root = new UIComponent.UIRoot(true, data.id);
        if (!root || !data || !data.root) {
            return null;
        }
        root["hasRootCommand"] = data.hasRootCommand ? data.hasRootCommand.concat() : [];
        if (!root["compsIDInfo"])
            root["compsIDInfo"] = {};
        addChild(root, data.root.children);
        function addChild(parent, childDatas) {
            if (!childDatas)
                return;
            for (var i = 0; i < childDatas.length; i++) {
                var childData = childDatas[i];
                var compClass = childData.type;
                if (!compClass)
                    continue;
                // 将UIGUI直接替换成实际的用户制作类
                var childInstance;
                if (!Config.EDIT_MODE && compClass == "UIGUI") {
                    var data = Game.data.uiList.data[childData.guiID];
                    if (data) {
                        // 优先查找该控件实现的类
                        if (childData.instanceClassName && window[childData.instanceClassName]) {
                            childInstance = new window[childData.instanceClassName](false, childData.guiID);
                        }
                        // 然后查找该控件所属界面所实现的类
                        else if (data.uiDisplayData.instanceClassName && window[data.uiDisplayData.instanceClassName]) {
                            childInstance = new window[data.uiDisplayData.instanceClassName](false, childData.guiID);
                        }
                        // 否则直接创建无继承类的GUI
                        else {
                            var guiCls = window["GUI_" + childData.guiID];
                            if (guiCls) {
                                childInstance = new guiCls(false, childData.guiID);
                                childInstance.onlyForPreload = root.onlyForPreload;
                            }
                            else {
                                throw ("can not find class GUI_" + childData.guiID + ".");
                            }
                        }
                    }
                    else {
                        childInstance = new UIComponent.UIRoot(false, childData.guiID);
                    }
                }
                else {
                    var clsObj = UIComponent[childData.type];
                    if (!clsObj)
                        continue;
                    childInstance = new clsObj();
                }
                //图片类型宽高使用配置中的数据不自动使用tex宽高
                if (childInstance instanceof UIComponent.UIBitmap)
                    childInstance.defaultStateImage = false;
                // 设置其所属根容器
                childInstance.guiRoot = root;
                if (childList)
                    childList.push(childInstance);
                var childrenData = childData.children;
                for (var s in childData) {
                    if (s == "children" || (!Config.EDIT_MODE && GameUI.excludeAttrDataMapping[s]))
                        continue;
                    var attr = childData[s];
                    if (newID && s == "id") {
                        childInstance["__id"] = attr;
                        continue;
                    }
                    if (typeof attr == "boolean" || typeof attr == "number" || typeof attr == "string") {
                        var realAttrName = GameUI.attrDataMapping[s];
                        if (!Config.EDIT_MODE && realAttrName) {
                            childInstance[realAttrName] = attr;
                        }
                        else {
                            childInstance[s] = attr;
                        }
                    }
                    else {
                        try {
                            childInstance[s] = ObjectUtils.depthClone(attr);
                        }
                        catch (e) { }
                    }
                }
                // 记录变量名称
                if (!root[childInstance.name]) {
                    root[childInstance.name] = childInstance;
                }
                // 根据唯一ID记录名称
                root["compsIDInfo"][childInstance.id] = childInstance;
                parent.addChild(childInstance);
                childInstance.constructorInit(uiID, syncLoadedEventWhenAssetExist);
                addChild(childInstance, childrenData);
            }
        }
        root.constructorInit(uiID, syncLoadedEventWhenAssetExist);
        if (!root.onlyForPreload)
            EventUtils.happen(GameUI, GameUI.EVENT_CREATE_UI, [root]);
        return root;
    };
    /**
     * 获取其全部子组件对象
     * @param keyValueMode 是否包含 keyValue 格式的，有则返回值中的keyValue存在值
     * @param conditionFunc [可选] 默认值=null  条件方法，通过条件筛选需要的组件，不存在方法或返回true都视为需要该组件 conditionFunc(uiComp:Sprite)
     */
    GameUI.getAllCompChildren = function (ui, keyValueMode, conditionFunc) {
        if (conditionFunc === void 0) { conditionFunc = null; }
        var allComps = [];
        ArrayUtils.getTreeNodeArray(ui, "_childs", allComps);
        if (keyValueMode) {
            var nodeObjs2 = {};
            var len = allComps.length;
            for (var s = 0; s < len; s++) {
                var nodeComp = allComps[s];
                if (nodeComp instanceof UIComponent.UIBase) {
                    if (!conditionFunc || conditionFunc.apply(this, [nodeComp])) {
                        nodeObjs2[nodeComp.id] = nodeComp;
                    }
                }
            }
            return { arr: allComps, keyValue: nodeObjs2 };
        }
        return { arr: allComps, keyValue: null };
    };
    /**
     * 测试UI子节点是否加载完成，当全部子节点加载完成时界面（根容器）才会派发 EventObject.LOADED 事件
     */
    GameUI.EVENT_TEST_LOAD_CHILD_UI = "EVENT_TEST_LOAD_CHILD_UI";
    /**
     * 事件：打开系统界面
     */
    GameUI.EVENT_OPEN_SYSTEM_UI = "GameUIEVENT_OPEN_SYSTEM_UI";
    /**
     * 事件：关闭系统界面
     */
    GameUI.EVENT_CLOSE_SYSTEM_UI = "GameUIEVENT_CLOSE_SYSTEM_UI";
    /**
     * 事件：创建界面时
     */
    GameUI.EVENT_CREATE_UI = "GameUIEVENT_CREATE_UI";
    /**
     * UI任务名称头
     */
    GameUI.uiTaskHead = "kds.ui.active";
    /**
     * UI配置数据 [id] = [object UIComponent.UIRoot]
     */
    GameUI.uiDatas = {};
    /**
     * 属性数据映射(用于编辑时和运行时区分)
     */
    GameUI.attrDataMapping = { "mouseEventEnabledData": "mouseEventEnabled" };
    /**
     * 游戏运行时排除的属性
     */
    GameUI.excludeAttrDataMapping = { "showOnEditor": true, "mouseEventEnabledInEditor": true };
    return GameUI;
}());
/**
 * 立绘
 * Created by 黑暗之神KDS on 2020-01-26 23:03:02.
 */
var StandAvatar = /** @class */ (function (_super) {
    __extends(StandAvatar, _super);
    function StandAvatar() {
        var _this = _super.call(this) || this;
        _this.ori = 4;
        _this.actID = 1;
        return _this;
    }
    Object.defineProperty(StandAvatar.prototype, "oriMode", {
        // @ts-ignore
        get: function () {
            return 1;
        },
        set: function (v) {
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StandAvatar.prototype, "flip", {
        get: function () {
            return this._flip;
        },
        set: function (v) {
            if (v == this._flip)
                return;
            this._flip = v;
            this.orientation = v ? 6 : 4;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StandAvatar.prototype, "gameDataAvatarList", {
        /**
         * 获取数据库AVATAR列表
         */
        get: function () {
            return Common.standAvatarList;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StandAvatar.prototype, "gameDataAvatarURL", {
        /**
         * 获取数据库AVATAR路径
         */
        get: function () {
            return "asset/json/standAvatar/data/standAvatar";
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StandAvatar.prototype, "disposeAvatarAsset", {
        /**
         * 释放资源的方法
         */
        get: function () {
            return AssetManager.disposeStandAvatarAsset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StandAvatar.prototype, "myClass", {
        /**
         * 获取我的类型
         */
        get: function () {
            return StandAvatar;
        },
        enumerable: false,
        configurable: true
    });
    return StandAvatar;
}(Avatar));
/**
 * Created by 黑暗之神KDS on 2019-02-04 16:43:35.
 */
var GameFunction = /** @class */ (function () {
    function GameFunction() {
    }
    Object.defineProperty(GameFunction, "scene", {
        get: function () {
            return Config.EDIT_MODE && this._scene ? this._scene : typeof Game == "undefined" ? null : Game.currentScene;
        },
        set: function (scene) {
            this._scene = scene;
        },
        enumerable: false,
        configurable: true
    });
    //------------------------------------------------------------------------------------------------------
    // 图像和画面
    //------------------------------------------------------------------------------------------------------
    /**
     * 震动
     * 当前帧直接震动，总计震动了duration帧
     * @param strength 幅度
     * @param duration 帧数
     */
    GameFunction.shake = function (strength, duration) {
        // 游戏暂停时等待
        if (Game && Game.pause) {
            Callback.CallLater(GameFunction.shake, GameFunction, [strength, duration]);
            return;
        }
        var me = arguments.callee;
        if (GameFunction.lock) {
            var args = arguments;
            this["shakeCB"] = Callback.New(function () {
                me.apply(this, args);
            }, this).delayRun(1, setFrameout);
            return;
        }
        if (this["shakeCB"]) {
            this["shakeCB"].stopDelay(clearFrameout);
        }
        var scene = this.scene;
        ;
        if (!scene || scene.isDisposed)
            return;
        if (duration == 0) {
            scene.camera.offsetX = 0;
            scene.camera.offsetY = 0;
            return;
        }
        ;
        scene.camera.offsetX = strength * (Math.random() < 0.5 ? 1 : -1);
        scene.camera.offsetY = strength * (Math.random() < 0.5 ? 1 : -1);
        this["shakeCB"] = Callback.New(function () {
            me.apply(this, [strength, duration - 1]);
        }, this).delayRun(1, setFrameout);
    };
    /**
     * 色调
     * 当前帧直接更改色调，总计更改了t帧
     * @param r 红色
     * @param g 绿色
     * @param b 蓝色
     * @param gray 灰度
     * @param t 时间（帧）
     * @param mr 红色曝光
     * @param mg 绿色曝光
     * @param mb 蓝色曝光
     * @param layer 层次（后期追加的高级特性）
     * @param tCur 当前的T
     */
    GameFunction.tonal = function (r, g, b, gray, t, mr, mg, mb, layer, tCur) {
        if (layer === void 0) { layer = -1; }
        if (tCur === void 0) { tCur = null; }
        // 游戏暂停时等待
        if (Game && Game.pause) {
            Callback.CallLater(GameFunction.tonal, GameFunction, [r, g, b, gray, t, mr, mg, mb, layer, tCur]);
            return;
        }
        var me = arguments.callee;
        if (GameFunction.lock) {
            var args = arguments;
            this["tonalCB"] = Callback.New(function () {
                me.apply(this, args);
            }, this).delayRun(1, setFrameout);
            return;
        }
        if (this["tonalCB"]) {
            this["tonalCB"].stopDelay(clearFrameout);
        }
        if (t < 1)
            t = 1;
        var s, scene = this.scene;
        if (!scene || scene.isDisposed)
            return;
        // 最初的调用
        if (!tCur) {
            tCur = 1;
            s = scene.displayObject.getTonal();
            this["tonalCB_startValue"] = s;
        }
        else {
            s = this["tonalCB_startValue"];
        }
        var per = tCur / t;
        function toValue(from, to, per) {
            return from - (from - to) * per;
        }
        scene.displayObject.setTonal(toValue(s[0], r, per), toValue(s[1], g, per), toValue(s[2], b, per), toValue(s[3], gray, per), toValue(s[4], mr, per), toValue(s[5], mg, per), toValue(s[6], mb, per));
        tCur++;
        if (tCur > t) {
            return;
        }
        ;
        this["tonalCB"] = Callback.New(function () {
            me.apply(this, [r, g, b, gray, t, mr, mg, mb, layer, tCur]);
        }, this).delayRun(1, setFrameout);
    };
    /**
     * 相机移动
     * 当前帧直接开始移动，总计移动了t帧
     * @param type 0-直接坐标 1-锁定对象
     * @param x 指定的坐标x
     * @param y 指定的坐标y
     * @param soIndex 锁定的对象
     * @param tween 缓动
     * @param t 帧数
     * @param tCur 当前的帧数（首次为null）
     */
    GameFunction.cameraMove = function (type, x, y, soIndex, tween, t, tCur, window_width, window_height) {
        if (tCur === void 0) { tCur = null; }
        if (window_width === void 0) { window_width = null; }
        if (window_height === void 0) { window_height = null; }
        // 游戏暂停时等待
        if (Game && Game.pause) {
            Callback.CallLater(GameFunction.cameraMove, GameFunction, [type, x, y, soIndex, tween, t, tCur, window_width, window_height]);
            return;
        }
        if (!window_width)
            window_width = Config.WINDOW_WIDTH;
        if (!window_height)
            window_height = Config.WINDOW_HEIGHT;
        var me = arguments.callee;
        if (this["cameraMoveCB"]) {
            this["cameraMoveCB"].stopDelay(clearFrameout);
        }
        var scene = this.scene;
        if (!scene || scene.isDisposed)
            return;
        var startRect = scene.camera.viewPort;
        if (tCur == null) {
            this["cameraMove_from"] = new Point(startRect.x, startRect.y);
            tCur = 1;
            scene.camera.sceneObject = null;
            scene.updateCamera();
        }
        var fromP = this["cameraMove_from"];
        var toP, soc;
        if (type == 1) {
            if (soIndex >= 0) {
                soc = scene.sceneObjects[soIndex];
                if (soc) {
                    toP = new Point(soc.x - window_width * 0.5, soc.y - window_height * 0.5);
                }
            }
        }
        else {
            toP = new Point(x - window_width * 0.5, y - window_height * 0.5);
        }
        if (!toP) {
            return;
        }
        var curP, per;
        if (tween) {
            per = Ease.strongOut(tCur, 0, 1, t);
        }
        else {
            per = tCur / t;
        }
        curP = Point.interpolate(toP, fromP, per);
        scene.camera.viewPort.x = curP.x;
        scene.camera.viewPort.y = curP.y;
        scene.updateCamera();
        tCur++;
        if (tCur > t) {
            if (type == 1) {
                scene.camera.sceneObject = soc;
                scene.updateCamera();
            }
            return;
        }
        ;
        this["cameraMoveCB"] = Callback.New(function () {
            me.apply(this, [type, x, y, soIndex, tween, t, tCur, window_width, window_height]);
        }, this).delayRun(1, setFrameout);
    };
    /**
     * 雾图形变更
     * @param url
     * @param sx
     * @param sy
     * @param dx
     * @param dy
     * @param alpha
     * @param blendMode
     */
    GameFunction.fogSet = function (url, sx, sy, dx, dy, alpha, blendMode) {
        // 游戏暂停时等待
        if (Game && Game.pause) {
            Callback.CallLater(GameFunction.fogSet, GameFunction, [url, sx, sy, dx, dy, alpha, blendMode]);
            return;
        }
        var scene = this.scene;
        ;
        if (sx == 0)
            sx = 1;
        if (sy == 0)
            sy = 1;
        scene.fogLayer.scaleX = sx;
        scene.fogLayer.scaleY = sy;
        scene.fogLayer.xLoop = true;
        scene.fogLayer.yLoop = true;
        scene.fogLayer.xMove = dx;
        scene.fogLayer.yMove = dy;
        scene.fogLayer.alpha = alpha;
        scene.fogLayer.blendMode = blendMode == 0 ? null : "lighter";
        if (scene.fogLayer.mapUrl != url)
            scene.fogLayer.setBigImage(url);
    };
    //------------------------------------------------------------------------------------------------------
    // 播放音乐
    //------------------------------------------------------------------------------------------------------
    /**
      * 播放语音
      * @param soIndex 场景对象 -1表示全局，如果在场景对象身上播放，则相机离其越近越声音大
      * @param url 音效地址
      * @param volume 音量 0-1
      * @param pitch 音调 0-2 1=正常
      */
    GameFunction.playTS = function (soIndex, url, volume, pitch) {
        if (soIndex == -1) {
            GameAudio.playTS(url, volume, pitch);
            return;
        }
        var soc = this.scene.sceneObjects[soIndex];
        if (!soc)
            return;
        GameAudio.playTS(url, volume, pitch, soc);
    };
    /**
     * 停止音效
     */
    GameFunction.stopTS = function () {
        GameAudio.stopTS();
    };
    /**
     * 播放音效
     * @param soIndex 场景对象 -1表示全局，如果在场景对象身上播放，则相机离其越近越声音大
     * @param url 音效地址
     * @param volume 音量 0-1
     * @param pitch 音调 0-2 1=正常
     */
    GameFunction.playSE = function (soIndex, url, volume, pitch) {
        if (soIndex == -1) {
            GameAudio.playSE(url, volume, pitch);
            return;
        }
        var soc = this.scene.sceneObjects[soIndex];
        if (!soc)
            return;
        GameAudio.playSE(url, volume, pitch, soc);
    };
    /**
     * 停止音效
     */
    GameFunction.stopSE = function () {
        GameAudio.stopSE();
    };
    /**
     * 播放背景音乐
     * @param bgmURL 背景音乐地址
     * @param volume 音量大小 0-1
     * @param pitch 音调 0-2 1=正常
     * @param fadeIn 淡入时间 ms
     */
    GameFunction.playBGM = function (bgmURL, volume, pitch, fadeIn) {
        GameAudio.playBGM(bgmURL, volume, 99999, fadeIn != 0, fadeIn * 1000, pitch);
    };
    /**
     * 播放环境音效
     * @param bgsURL 环境音效地址
     * @param volume 音量大小 0-1
     * @param pitch 音调 0-2 1=正常
     * @param fadeIn 淡入时间 ms
     */
    GameFunction.playBGS = function (bgsURL, volume, pitch, fadeIn) {
        GameAudio.playBGS(bgsURL, volume, 99999, fadeIn != 0, fadeIn * 1000, pitch);
    };
    /**
     * 停止背景音乐
     * @param fadeOut 淡出时间 ms
     */
    GameFunction.stopBGM = function (fadeOut) {
        GameAudio.stopBGM(fadeOut != 0, fadeOut * 1000);
    };
    /**
     * 停止播放环境音效
     * @param fadeOut 淡出时间 ms
     */
    GameFunction.stopBGS = function (fadeOut) {
        GameAudio.stopBGS(fadeOut != 0, fadeOut * 1000);
    };
    //------------------------------------------------------------------------------------------------------
    // 菜单和UI
    //------------------------------------------------------------------------------------------------------
    /**
     * 打开UI
     * @param id 界面ID
     */
    GameFunction.openUI = function (id) {
        GameUI.show(id);
    };
    /**
     * 关闭UI
     * @param id 界面ID
     */
    GameFunction.closeUI = function (id) {
        GameUI.hide(id);
    };
    /**
     * 执行客户端代码
     * @param code
     */
    GameFunction.executeScript = function (code) {
        eval(code);
    };
    return GameFunction;
}());
for (var i in GameFunction) {
    if (i == "scene")
        continue;
    var attr = GameFunction[i];
    if (typeof attr == "function") {
        GameFunction.prototype[i] = attr;
    }
}
/**
 * Created by 黑暗之神KDS on 2018-07-27 02:34:31.
 */
var ClientMsgSender = /** @class */ (function () {
    function ClientMsgSender() {
    }
    /**
     * 发送字符串消息
     * @param msg
     * @param threadID [可选] 默认值=-1 指定发送的线程，未指定则说明是当前玩家所在的场景线程 2=主线程 3~N=场景线程 -1=表示默认玩家所在的线程
     */
    ClientMsgSender.send = function (msg, threadID) {
        if (threadID === void 0) { threadID = -1; }
        if (threadID == -1)
            threadID = ClientMsgSender.threadID;
        if (threadID == -1)
            return;
        if (ClientMain.conn)
            ClientMain.conn.sendMsg(msg, threadID);
    };
    /**
     * 远程调用客户端的方法（需要服务器设置调用权限）
     * -- 在玩家进入场景后才能使用该方法
     * @param className 调用的类
     * @param funcName 调用的方法
     * @param params 方法参数
     * @param onReturn 服务器返回值回调，超时会被删除
     * @param threadID 指定发送的线程，未指定则说明是当前玩家所在的场景线程 2=主线程 3~N=场景线程 -1=表示默认玩家所在的线程
     */
    ClientMsgSender.rpc = function (className, funcName, params, onReturn, threadID) {
        if (params === void 0) { params = []; }
        if (onReturn === void 0) { onReturn = null; }
        if (threadID === void 0) { threadID = -1; }
        if (threadID == -1)
            threadID = ClientMsgSender.threadID;
        if (threadID == -1)
            return;
        var onReturnID;
        if (onReturn) {
            onReturnID = ++ClientMsgSender.onReturnCount;
            ClientMsgSender.onReturns[onReturnID] = onReturn;
            setTimeout(function (onReturnID) {
                delete ClientMsgSender.onReturns[onReturnID];
            }, ClientMsgSender.ONRETURN_OVER_TIME, onReturnID);
        }
        else {
            onReturnID = 0;
        }
        var obj = { c: className, f: funcName, p: params, r: onReturnID };
        if (ClientMain.conn)
            ClientMain.conn.sendMsgObj(obj, threadID);
    };
    /**
     * 处理RPC回调
     * @param success 是否成功
     * @param onReturnID 回调标识
     * @param res 回调结果
     * @param domainName 错误时返回的域
     * @param funcName 错误时返回的名称
     */
    ClientMsgSender.rpcReturn = function (success, onReturnID, res, domainName, funcName) {
        var onReturn = ClientMsgSender.onReturns[onReturnID];
        delete ClientMsgSender.onReturns[onReturnID];
        if (!success) {
            trace("error:\u670D\u52A1\u5668\u6CA1\u6709\u627E\u5230\u65B9\u6CD5[" + domainName + "::" + funcName + "]\u6216\u65E0\u6743\u9650\uFF01");
            return;
        }
        onReturn && onReturn.runWith([res]);
    };
    //------------------------------------------------------------------------------------------------------
    // 系统发送消息
    //------------------------------------------------------------------------------------------------------
    /**
     * 请求触发事件
     * @param type 0-新触发事件 1-继续执行事件 2-主动调用公共事件（多线模式）
     * @param mainType 主事件类别（新触发事件时填写） 0-场景相关 1-场景对象相关 2-UI相关 （对应CommandTrigger.COMMAND_MAIN_TYPE_XXX）
     * @param indexType 子事件类别（新触发事件时填写）
     * @param commandID 命令标识
     * @param inputMessage 玩家输入的信息
     * @param onCommandExecuteOver [可选] 默认值=null 当命令执行完毕时回调
     * @param triggerSceneObjectIndex [可选] 默认值=null 触发事件者场景对象的索引
     * @param executorSceneObjectIndex [可选] 默认值=null 执行事件者场景对象的索引
     */
    ClientMsgSender.requestTriggerEvent = function (type, mainType, indexType, commandID, inputMessage, onCommandExecuteOver, triggerSceneObjectIndex, executorSceneObjectIndex) {
        if (inputMessage === void 0) { inputMessage = null; }
        if (onCommandExecuteOver === void 0) { onCommandExecuteOver = null; }
        if (triggerSceneObjectIndex === void 0) { triggerSceneObjectIndex = null; }
        if (executorSceneObjectIndex === void 0) { executorSceneObjectIndex = null; }
        var onReturnID;
        if (onCommandExecuteOver) {
            onReturnID = ++ClientMsgSender.onCmdReturnCount;
            ClientMsgSender.onCmdReturns[onReturnID] = onCommandExecuteOver;
        }
        else {
            onReturnID = 0;
        }
        var sendParams = [type, mainType, indexType, [commandID, inputMessage, onReturnID], triggerSceneObjectIndex, executorSceneObjectIndex];
        if (ClientMsgSender.requestTriggerEventSend) {
            ClientMsgSender.requestTriggerEventSend.runWith(sendParams);
        }
        else {
            ClientMsgSender.rpc("ServerWorld", "triggerEvent", sendParams);
        }
    };
    /**
     * 处理RPC回调
     * @param success 是否成功
     * @param onReturnID 回调标识
     * @param res 回调结果
     * @param domainName 错误时返回的域
     * @param funcName 错误时返回的名称
     */
    ClientMsgSender.cmdReturn = function (onReturnID) {
        var onReturn = ClientMsgSender.onCmdReturns[onReturnID];
        delete ClientMsgSender.onCmdReturns[onReturnID];
        onReturn && onReturn.run();
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 请求监听玩家变量
     * @param isListen 是否监听
     * @param type 类别 0-变量 1-开关 2-字符串
     * @param varID 变量ID
     */
    ClientMsgSender.requestListenPlayerVariable = function (isListen, type, varID) {
        ClientMsgSender.rpc("ServerWorld", "listenerPlayerVariable", [isListen, type, varID]);
    };
    /**
     * 请求获取世界变量
     * @param type 0-变量 1-开关 2-字符串
     * @param varID 变量ID
     */
    ClientMsgSender.requestGetWorldVariable = function (type, varID) {
        ClientMsgSender.rpc("ServerWorld", "requestGetWorldVariable", [type, varID]);
    };
    /**
     * 服务器返回值回调集合
     */
    ClientMsgSender.onReturns = {};
    ClientMsgSender.onReturnCount = 0;
    ClientMsgSender.ONRETURN_OVER_TIME = 60000;
    /**
     * 调用事件完毕时回调集合
     */
    ClientMsgSender.onCmdReturns = {};
    ClientMsgSender.onCmdReturnCount = 0;
    ClientMsgSender.ON_CMD_RETURN_OVER_TIME = 60000;
    return ClientMsgSender;
}());
/**
 * 网络连接类，创建实例以便使用
 * Created by 黑暗之神KDS on 2018-05-21 03:02:36.
 */
var NetConn = /** @class */ (function () {
    function NetConn() {
        /**
         * 消息片段
         */
        this.jsonMsgFragmentArr = [];
        this.jsonMsgFragmentSize = 0;
        this.jsonMsgFragmentNow = 0;
        this.msgFragmentArr = [];
        this.msgFragmentSize = 0;
        this.msgFragmentNow = 0;
    }
    // private jsonMsgFragment: string = "";
    // private msgFragment: string = "";
    /**
     * 开始连接
     * @param key
     * @param host 地址
     * @param port 端口
     * @param onConnect 当连接成功时
     * @param onMsg 当接受消息时回调
     * @param onClose [可选] 默认值=null 当连接断开时
     */
    NetConn.prototype.connect = function (key, host, port, onConnect, onMsg, onClose) {
        if (onClose === void 0) { onClose = null; }
        this.key = key;
        this.host = host;
        this.port = port;
        this.onConnect = onConnect;
        this.onClose = onClose;
        this.onMsg = onMsg;
        var startTime = new Date().getTime();
        // alert("ws://" + host + ":" + port + "/")
        var ws = this.ws = new WebSocket("ws://" + host + ":" + port + "/");
        // var ws: WebSocket = NetManager.ws = new WebSocket("ws://10.0.0.229:3456/");
        var _this = this;
        ws.onopen = function () {
            _this.onWSOpen();
        };
        // ws.onerror
        ws.onclose = function (e) {
            var isTimeout = new Date().getTime() - startTime >= 2000;
            _this.onWSClose(isTimeout);
        };
        ws.onmessage = function (msg) {
            _this.onWSMessage(msg);
        };
    };
    /**
     * 当网络关闭时
     */
    NetConn.prototype.close = function () {
        if (this.ws) {
            this.ws.close();
            this.ws = null;
        }
    };
    /**
     * 当网络连接成功后
     */
    NetConn.prototype.onWSOpen = function () {
        this.isConnect = true;
        // 固定发送0 + key（demo阶段，这里随机生成key了）
        this.ws.send('0' + this.key);
    };
    /**
     * 当网络关闭时
     * -- 挤号时仅触发此项
     * -- 当连接时连接不上服务器则触发一次 onWSError 后触发 onWSClose，目前忽略了onWSError
     * -- 当服务器主动关闭时
     */
    NetConn.prototype.onWSClose = function (isTimeout) {
        // trace("网络错误");
        this.isConnect = false;
        this.onClose && this.onClose.runWith([isTimeout]);
    };
    /**
     * 当接受到消息时
     * @param msg
     */
    NetConn.prototype.onWSMessage = function (msg) {
        var sysMsgID = msg.data.substr(0, 1);
        var msgContent = msg.data.substr(1);
        if (sysMsgID == "0") {
            if (msgContent == "onClientConnected") {
                this.onConnect && this.onConnect.run();
            }
        }
        else if (sysMsgID == "1") {
            // 取得头文字
            var msgType = msgContent.substr(0, 1);
            var msgBody = msgContent.substr(1);
            // trace("收到消息:", msgType, msgBody.length)
            // 普通字符串消息
            if (msgType == "0") {
                this.onMsg.runWith([msgType, msgBody]);
            }
            // 普通字符串消息片段
            else if (msgType == "3") {
                var fragSendIndex = parseInt(msgBody.substr(0, 3));
                this.msgFragmentSize = parseInt(msgBody.substr(3, 3));
                msgBody = msgBody.substr(6);
                this.msgFragmentArr[fragSendIndex] = msgBody;
                this.msgFragmentNow++;
                if (this.msgFragmentNow == this.msgFragmentSize) {
                    this.onMsg.runWith(["0", this.msgFragmentArr.join("")]);
                    this.msgFragmentArr.length = 0;
                    this.msgFragmentNow = 0;
                }
            }
            // JSON消息
            else if (msgType == "1") {
                this.onMsg.runWith([msgType, msgBody]);
            }
            // JSON消息片段
            else if (msgType == "2") {
                // 获取长度
                var fragSendIndex = parseInt(msgBody.substr(0, 3));
                this.jsonMsgFragmentSize = parseInt(msgBody.substr(3, 3));
                msgBody = msgBody.substr(6);
                this.jsonMsgFragmentArr[fragSendIndex] = msgBody;
                this.jsonMsgFragmentNow++;
                if (this.jsonMsgFragmentNow == this.jsonMsgFragmentSize) {
                    this.onMsg.runWith(["1", this.jsonMsgFragmentArr.join("")]);
                    this.jsonMsgFragmentArr.length = 0;
                    this.jsonMsgFragmentNow = 0;
                }
            }
            // 关闭连接消息
            else if (msgType == "4") {
                this.isConnect = false;
                this.close();
            }
        }
    };
    /**
     * 发送消息
     * @param msg 消息字符串
     * @param passageID [可选] 默认值=1
     */
    NetConn.prototype.sendMsg = function (msg, passageID) {
        if (passageID === void 0) { passageID = 1; }
        if (this.isConnect) {
            this.ws.send("1" + passageID + ",0" + msg);
        }
    };
    /**
     * 发送消息：打包成JSON字符串发送
     * @param msgObj 消息对象
     * @param passageID [可选] 默认值=1
     */
    NetConn.prototype.sendMsgObj = function (msgObj, passageID) {
        if (passageID === void 0) { passageID = 1; }
        if (this.isConnect) {
            this.ws.send("1" + passageID + ",1" + JSON.stringify(msgObj));
        }
    };
    return NetConn;
}());
/**
 * Soul Base Client
 * 通用游戏框架客户端入口：基于该框架的入口应继承于此类
 * 启动后即可连接服务器
 * Created by 黑暗之神KDS on 2018-05-21 23:45:09.
 */
var ClientMain = /** @class */ (function () {
    /**
     * 构造函数
     * @param is3D [可选] 默认值=false 是否3D
     */
    function ClientMain(is3D) {
        if (is3D === void 0) { is3D = false; }
        /**
         * 串行任务：初始化
         */
        this.initTask = "ClientMainInitTask";
        // 兼容项目层不存在的创建
        if (typeof globalThis["SceneObjectModule"] == "undefined")
            globalThis["SceneObjectModule"] = SceneObjectModuleBase;
        // 初始化引擎 (*)可优化不加载3D相关的代码
        os.init(0, 0, true, is3D);
        // 层次
        Game.layer = new GameLayer();
        // 默认
        stage.alignH = "center";
        stage.alignV = "middle";
        if (Browser.onMobile) {
            // stage.screenMode = "horizontal";
            // stage.screenAdaptationEnabled = true;
        }
        SoundManager.autoStopMusic = false;
        // 阻止按键冒泡
        document.addEventListener("keydown", function (e) {
            // -- 输入框的时候不阻止
            if (stage.focus instanceof Input && e.keyCode != Keyboard.TAB)
                return;
            // -- PC端的话不阻止
            if (os.platform == 2)
                return;
            // F5刷新-F11浏览器禁止
            if (!Config.USE_FN || (e.keyCode != Keyboard.F11 && e.keyCode != Keyboard.F5 && e.keyCode != Keyboard.F12)) {
                e.stopPropagation();
                window.event.returnValue = false;
            }
        });
        // 阻止鼠标滚轮
        // @ts-ignore
        os.canvas.onmousewheel = function (e) {
            e = e || window.event;
            if (e.preventDefault)
                e.preventDefault();
            e.returnValue = false;
            return false;
        };
        this.init();
    }
    /**
     * 初始化
     */
    ClientMain.prototype.init = function () {
        // 初始化帧刷
        this.initFrameout();
        // 快捷键状态
        this.initHotKey();
        // 初始化文件操作工具
        FileUtils.init();
        // 初始化命令执行器
        GameCommand.init();
        // 初始化游戏
        Game.init();
        // ui初始化
        GameUI.init();
        // 发布版加载缓存初始化文件（合并的JSON）
        new SyncTask(this.initTask, this.loadStartupJson, [], this);
        // 安装通用配置文件
        new SyncTask(this.initTask, this.installDataConfig, [Config.JSON_CONFIG, Config], this);
        // 加载字体
        new SyncTask(this.initTask, this.loadFontFile, [], this);
        // 初始化配置
        new SyncTask(this.initTask, this.initConfig, [], this);
        // 加载游戏数据
        new SyncTask(this.initTask, this.loadGameData, [], this);
        // 安装游戏数据
        new SyncTask(this.initTask, this.installGameData, [], this);
        // 初始化完毕
        new SyncTask(this.initTask, this.initOver, [], this);
    };
    /**
     * 初始化帧刷函数
     */
    ClientMain.prototype.initFrameout = function () {
        os.add_ENTERFRAME(doFrameout, this);
    };
    ClientMain.prototype.initHotKey = function () {
        stage.add_KEYDOWN(function (e) {
            ClientMain.ctrlKey = e.ctrlKey;
            ClientMain.shiftKey = e.shiftKey;
            ClientMain.altKey = e.altKey;
            if ((e.altKey && e.keyCode == Keyboard.ENTER)) {
                os.fullscreen = !os.fullscreen;
            }
            else if (Config.USE_FN && e.keyCode == Keyboard.F5) {
                window.location.reload();
            }
        }, this);
        stage.add_KEYUP(function (e) {
            ClientMain.ctrlKey = e.ctrlKey;
            ClientMain.shiftKey = e.shiftKey;
            ClientMain.altKey = e.altKey;
        }, this);
        stage.on(EventObject.MOUSE_DOWN, this, function () {
            window.focus();
        });
    };
    //------------------------------------------------------------------------------------------------------
    // 安装数据文件
    //------------------------------------------------------------------------------------------------------
    /**
     * 发布版加载缓存初始化文件（合并的JSON）
     */
    ClientMain.prototype.loadStartupJson = function () {
        var _this = this;
        // 非打包发布版本直接忽略，还是加载单个的JSON文件
        if (!Config.RELEASE_GAME) {
            SyncTask.taskOver(this.initTask);
            return;
        }
        var oldLoadJson1 = FileUtils.loadJsonFile;
        // 加载合并文件
        FileUtils.loadJsonFile("asset/json/startup.json", Callback.New(function (startupJsons) {
            if (!startupJsons) {
                alert("找不到合并版的Json!");
                return;
            }
            FileUtils.loadJsonFile = function (localURL, onFin, onErrorTips) {
                if (onErrorTips === void 0) { onErrorTips = true; }
                var bigJsonCacheObj = startupJsons[localURL];
                if (bigJsonCacheObj) {
                    onFin.delayRun(0, null, [bigJsonCacheObj]);
                    return;
                }
                oldLoadJson1.apply(FileUtils, [localURL, onFin, onErrorTips]);
            };
            SyncTask.taskOver(_this.initTask);
        }, this));
    };
    /**
    * 客户端环境配置文件处理
    */
    ClientMain.prototype.installDataConfig = function (url, configObj) {
        FileUtils.loadJsonFile(url, new Callback(function (cfgJson) {
            ObjectUtils.clone(cfgJson, configObj);
            // 初始化图像系统（需要依赖Config设定）
            GameImage.init();
            SyncTask.taskOver(this.initTask);
        }, this));
    };
    /**
     * 加载配置的字体文件
     */
    ClientMain.prototype.loadFontFile = function () {
        if (Config.startupPreloadFonts == null)
            Config.startupPreloadFonts = true;
        if (Config.startupPreloadFonts) {
            //加载字体 
            var list = Config.FONTS ? Config.FONTS : [];
            var __this = this;
            FontLoadManager.loadFontFile(list, Callback.New(function () {
                SyncTask.taskOver(__this.initTask);
            }, this));
        }
        else {
            SyncTask.taskOver(this.initTask);
        }
    };
    /**
     * 初始化Config
     */
    ClientMain.prototype.initConfig = function () {
        Config.init();
        // 根据配置刷新
        stage.width = Config.WINDOW_WIDTH;
        stage.height = Config.WINDOW_HEIGHT;
        stage.bgColor = Config.STAGE_BACKGROUND_COLOR;
        stage.scaleMode = "showall";
        SyncTask.taskOver(this.initTask);
    };
    /**
     * 客户端环境加载游戏制作数据
     */
    ClientMain.prototype.loadGameData = function () {
        var task = new AsynTask(Callback.New(SyncTask.taskOver, this, [this.initTask]));
        var onloadDataOver = Callback.New(task.complete, task, []);
        task.execute(Game.data.loadDialogList(onloadDataOver));
        task.execute(Game.data.loadTileList(onloadDataOver));
        task.execute(Game.data.loadAutoTileList(onloadDataOver));
        // 单机内核才需要加载自定义命令
        if (Config.SINGLE_PLAYER_CORE)
            task.execute(Game.data.loadCustomCommandType(onloadDataOver));
        task.execute(Game.data.loadDataStructureList(onloadDataOver));
        task.execute(Game.data.loadCustomModuleList(onloadDataOver));
        task.execute(Game.data.loadGameAttributeConfig(onloadDataOver));
        task.execute(Game.data.loadSceneObjectModuleList(onloadDataOver));
        task.execute(Game.data.loadSceneObjectModelList(onloadDataOver));
        task.execute(Game.data.loadUIList(onloadDataOver));
        task.execute(Game.data.loadCustomEventType(onloadDataOver));
        task.execute(Game.data.loadMaterialList(onloadDataOver));
    };
    /**
     * 客户端环境安装游戏制作数据
     */
    ClientMain.prototype.installGameData = function () {
        // 执行
        CustomCompositeSetting.runCode(Game.data);
        // 材质初始化
        Shader2D.initMaterial();
        SyncTask.taskOver(this.initTask);
    };
    /**
     * 初始化完毕
     */
    ClientMain.prototype.initOver = function () {
        Config.TILE_SPLIT_SIZE_LOCK = true;
        EventUtils.happen(ClientWorld, ClientWorld.EVENT_BEFORE_INITED);
        EventUtils.happen(ClientWorld, ClientWorld.EVENT_INITED);
    };
    //------------------------------------------------------------------------------------------------------
    // 连接服务器
    //------------------------------------------------------------------------------------------------------
    /**
     * 开始登陆
     * @param onLoginSuccess 当登陆成功时
     * @param onLoginFail 当登陆失败时 onLoginFail(isTimeout:boolean) isTimeout 是否来自于超时，否则应该是服务器人数已满
     */
    ClientMain.prototype.startLogin = function (onLoginSuccess, onLoginFail) {
        if (onLoginFail === void 0) { onLoginFail = null; }
        // 登陆
        ClientMain.conn = new NetConn();
        ClientMain.conn.connect(Game.playerKey, Config.GAME_SERVER_HOST, Config.GAME_SERVER_PORT, null, new Callback(this.onServerMsg, this), onLoginFail);
        // 当通信通道线路安排好时
        var si = setInterval(function () {
            if (ClientMsgSender.threadID != null) {
                onLoginSuccess && onLoginSuccess.run();
                clearInterval(si);
            }
        }, 0);
    };
    /**
     * 当接受到消息时
     * @param msgType 接受的消息模式 0-字符串 1-JSON
     * @param msgContent 接收到的内容
     */
    ClientMain.prototype.onServerMsg = function (msgType, msgContent) {
        // trace("接受到消息", msgContent.substr(1));
        // 普通消息
        if (msgType == "0") {
            EventUtils.happen(ClientWorld, ClientWorld.EVENT_STRING_MESSAGE, [msgContent]);
        }
        // RPC方式调用
        else {
            try {
                var msgObj = JSON.parse(msgContent);
                var domainObj = window[msgObj.c];
                var func = domainObj[msgObj.f];
            }
            catch (e) {
                // trace("解析消息错误", msgContent.length);
            }
            // trace("接受RPC方法：", msgObj.c, msgObj.f)
            func.apply(domainObj, msgObj.p);
        }
    };
    return ClientMain;
}());
var __setFrameoutFunc = [];
var __fCount = 0;
// @ts-ignore
var setFrameout = function (func, frame) {
    var arg = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        arg[_i - 2] = arguments[_i];
    }
    var t = new Date().getTime() + "_" + Math.random();
    __setFrameoutFunc.push([func, __fCount, frame, arg, t]);
    return t;
};
var clearFrameout = function (t) {
    var m = ArrayUtils.matchAttributes(__setFrameoutFunc, { 4: t }, true, "==", true);
    if (m.length == 1) {
        __setFrameoutFunc.splice(m[0], 1);
    }
};
// frameout
var doFrameout = function () {
    __fCount++;
    // -- setFrameout impl
    var __execSetFrameoutFunc = [];
    for (var s = 0; s < __setFrameoutFunc.length; s++) {
        var arr = __setFrameoutFunc[s];
        if (__fCount - arr[1] >= arr[2]) {
            __execSetFrameoutFunc.push(arr);
            __setFrameoutFunc.splice(s, 1);
            s--;
        }
    }
    var len = __execSetFrameoutFunc.length;
    for (var s = 0; s < len; s++) {
        var arr = __execSetFrameoutFunc[s];
        arr[0].apply(this, arr[3]);
    }
};
/**
 * Created by 黑暗之神KDS on 2019-06-03 18:56:43.
 */
// @ts-ignore
var ClientPlayer = /** @class */ (function (_super) {
    __extends(ClientPlayer, _super);
    /**
     * 构造函数
     * @param isMyPlayer [可选] 默认值=false
     */
    function ClientPlayer(isMyPlayer) {
        if (isMyPlayer === void 0) { isMyPlayer = false; }
        var _this = _super.call(this) || this;
        if (isMyPlayer)
            _this.initMyPlayer();
        return _this;
    }
    /**
     * 初始化我的游戏玩家对象
     */
    ClientPlayer.prototype.initMyPlayer = function () {
        this.variable = new Variable();
        this.event = new EventDispatcher();
        this.requestSyncPlayerVars = [[], [], []];
    };
    /**
     * 监听玩家变量
     * 该变量首次监听时会与服务器-该编号的变量同步一次，此后一旦服务器变量改动会通知客户端同步
     * 其他非首次的监听直接来自客户端缓存
     * @param type 0-变量 1-开关 2-字符串
     * @param varID 变量ID
     * @param onChange 当变量改变时回调 onChange(typeID:number,varID:number,value:number|string)
     * @param isOnce 是否只监听一次，但是仍然需要调用 removeListenerPlayerVariable 移除（如某些地方为了优化延迟移除监听）
     * @param immediatelyCallback 立刻回调，如果本地已有数据则立刻回调，单机版的话数据都是本地的
     */
    ClientPlayer.prototype.addListenerPlayerVariable = function (type, varID, onChange, isOnce, immediatelyCallback) {
        if (isOnce === void 0) { isOnce = false; }
        if (immediatelyCallback === void 0) { immediatelyCallback = true; }
        var rqArr = this.requestSyncPlayerVars[type];
        // 当未能同步的情况下：请求同步
        if (!rqArr[varID]) {
            rqArr[varID] = true;
            ClientMsgSender.requestListenPlayerVariable(true, type, varID);
        }
        // 当已同步的情况下直接返回（单机版执行该逻辑，首次会直接返回一下）
        else {
            if (immediatelyCallback) {
                var funcs = [this.variable.getVariable, this.variable.getSwitch, this.variable.getString];
                var value = funcs[type].apply(this.variable, [varID]);
                onChange.runWith([type, varID, value]);
                if (isOnce)
                    return;
            }
        }
        var typeEvent = ClientPlayer.getEventType(type, varID);
        this.event[isOnce ? "once" : "on"](typeEvent, onChange.caller, onChange.callbackFunc, onChange.args);
    };
    /**
     * 取消监听玩家变量
     * 当所有监听该编号的变量都取消了后则通知服务器-取消该编号变量的同步
     * @param type 0-变量 1-开关 2-字符串
     * @param varID 变量ID
     * @param onChange 当变量改变时回调
     */
    ClientPlayer.prototype.removeListenerPlayerVariable = function (type, varID, onChange) {
        var typeEvent = ClientPlayer.getEventType(type, varID);
        this.event.off(typeEvent, onChange.caller, onChange.callbackFunc);
        if (!this.event.hasListener(typeEvent)) {
            var rqArr = this.requestSyncPlayerVars[type];
            if (rqArr) {
                delete rqArr[varID];
                ClientMsgSender.requestListenPlayerVariable(false, type, varID);
            }
        }
    };
    /**
     * [FROM RPC] 玩家变量改变的函数
     * 同时会同步至本地缓存中
     * @param type
     * @param varID
     */
    ClientPlayer.playerVariableChange = function (type, varID, value) {
        var typeEvent = ClientPlayer.getEventType(type, varID);
        var funcs = [Game.player.variable.setVariable, Game.player.variable.setSwitch, Game.player.variable.setString];
        funcs[type].apply(Game.player.variable, [varID, value]);
        Game.player.event.event(typeEvent, [type, varID, value]);
    };
    /**
     * 获取事件类型
     * @param type 0-变量 1-开关 2-字符串
     * @param varID 变量ID
     * @return [string]
     */
    ClientPlayer.getEventType = function (type, varID) {
        return "" + ClientPlayer.EVENT_TYPE + type + "_" + varID;
    };
    /**
     * 事件类别
     */
    ClientPlayer.EVENT_TYPE = "VariableSystemEvent";
    return ClientPlayer;
}(Player));
/**
 * 世界-客户端
 * Created by 黑暗之神KDS on 2019-06-02 22:49:26.
 */
var ClientWorld = /** @class */ (function () {
    function ClientWorld() {
    }
    //------------------------------------------------------------------------------------------------------
    //
    //------------------------------------------------------------------------------------------------------
    /**
    * 初始化
    * -- 加载 config
    * -- 加载 全对话框制作数据
    * -- 加载 全图块列表配置数据 [后期优化可动态]
    * -- 加载 全数据结构数据
    * -- 加载 全自定义模块数据（含全部制作数据）
    * -- 加载 全游戏配置数据（世界和玩家数据配置）
    * -- 加载 全场景对象模型数据
    * -- 加载 全UI配置数据 [后期优化可动态]
    * -- 加载 全脚本数据
    * @param onInited
    */
    ClientWorld.init = function () {
        ClientMain.self = new ClientMain();
    };
    /**
     * 登录
     * @param onLoginSuccess 登录成功时
     * @param onLoginFail [可选] 默认值=null 当登陆失败时 onLoginFail(isTimeout:boolean) isTimeout 是否来自于超时，否则应该是服务器人数已满
     */
    ClientWorld.startLogin = function (onLoginSuccess, onLoginFail) {
        if (onLoginFail === void 0) { onLoginFail = null; }
        ClientMain.self.startLogin(onLoginSuccess, onLoginFail);
    };
    /**
     * 登出
     */
    ClientWorld.logout = function () {
        ClientMain.conn.close();
    };
    //------------------------------------------------------------------------------------------------------
    // 变量：网络版本
    //------------------------------------------------------------------------------------------------------
    /**
     * 请求获取世界变量
     * @param type 0-世界变量 1-世界开关 2-世界字符串
     * @param varID 变量ID
     * @param onResponse 回调 onResponse(isSuccess:boolean,type:number,varID:number,value:number|string);
     */
    ClientWorld.requestGetVariable = function (type, varID, onResponse) {
        ClientMsgSender.requestGetWorldVariable(type, varID);
        var evType = ClientWorld.getEventType(type, varID);
        EventUtils.addEventListener(ClientWorld, evType, onResponse, true);
    };
    //------------------------------------------------------------------------------------------------------
    // 单机版：Private
    //------------------------------------------------------------------------------------------------------
    /**
     * 写入世界变量
     * @param index 编号
     * @param value 数值
     */
    ClientWorld.setWorldVariable = function (index, value) {
        ClientWorld.variable.setVariable(index, value);
    };
    /**
     * 读取世界变量
     * @param index 编号
     * @return [number] 数值
     */
    ClientWorld.getWorldVariable = function (index) {
        return ClientWorld.variable.getVariable(index);
    };
    /**
     * 写入世界开关
     * @param index 编号
     * @param value 开关值 1/0
     */
    ClientWorld.setWorldSwitch = function (index, value) {
        ClientWorld.variable.setSwitch(index, value);
    };
    /**
     * 读取世界开关变量
     * @param index 编号
     * @return [number] 返回值 1/0
     */
    ClientWorld.getWorldSwitch = function (index) {
        return ClientWorld.variable.getSwitch(index);
    };
    /**
     * 写入世界字符串
     * @param index 编号
     * @param value 字符串值
     */
    ClientWorld.setWorldString = function (index, value) {
        ClientWorld.variable.setString(index, value);
    };
    /**
     * 读取世界字符串变量
     * @param index 编号
     * @return [string] 返回值
     */
    ClientWorld.getWorldString = function (index) {
        return ClientWorld.variable.getString(index);
    };
    /**
     * 监听当世界变量的改变时
     * @param type 0-变量 1-开关 2-字符串
     * @param onChange onChange(type:number,varID:number,value:number|string);
     */
    ClientWorld.addListenerVariable = function (type, varID, onChange) {
        EventUtils.addEventListener(ClientWorld, "worldVar" + type + "_" + varID, onChange);
    };
    /**
     * 取消监听：当世界变量改变时
     * @param type 0-变量 1-开关 2-字符串
     * @param onChange
     */
    ClientWorld.removeListenerVariable = function (type, varID, onChange) {
        EventUtils.removeEventListener(ClientWorld, "worldVar" + type + "_" + varID, onChange);
    };
    //------------------------------------------------------------------------------------------------------
    // 私有实现
    //------------------------------------------------------------------------------------------------------
    /**
    * 获取事件类型
    * @param isGetMode 是否获取模式
    * @param type 0-变量 1-开关 2-字符串
    * @param varID 变量ID
    * @return [string]
    */
    ClientWorld.getEventType = function (type, varID) {
        return "" + ClientWorld.EVENT_GET_WORLD_VAR + type + "_" + varID;
    };
    /**
     * 响应获取的全局变量
     * @param isSuccess 成功响应（无权限则不成功）
     * @param type 变量类别
     * @param varID 变量
     * @param value 值
     */
    ClientWorld.reponseGetVariable = function (isSuccess, type, varID, value) {
        var arr = ["variables", "switchs", "strings"];
        ClientWorld.variable[arr[type]][varID] = value;
        var evType = this.getEventType(type, varID);
        EventUtils.happen(ClientWorld, evType, [isSuccess, type, varID, value]);
    };
    /**
     * 事件：初始化完毕（仅限于游戏运行时）
     */
    ClientWorld.EVENT_INITED = "ClientMain_EVENT_INITED";
    /**
     * 初始化前派发，用于底层实现在初始化前做的一些逻辑
     */
    ClientWorld.EVENT_BEFORE_INITED = "ClientMain_EVENT_BEFORE_INITED";
    /**
     * 事件：行为编辑器预览端初始化完毕
     */
    ClientWorld.EVENT_BEHAVIOR_VIEW_INITED = "BehaviorViewClientWorldInited";
    /**
     * 事件：接收字符串消息
     * EventUtils.addEventListener(ClientMain); callback(msg:string)
     */
    ClientWorld.EVENT_STRING_MESSAGE = "ClientMain_EVENT_STRING_MESSAGE";
    /**
     * 事件：获取世界变量
     */
    ClientWorld.EVENT_GET_WORLD_VAR = "ClientWorld_EVENT_GET_WORLD_VAR";
    /**
     * 请求同步玩家变量的数组
     */
    ClientWorld.requestSyncVars = [[], [], []];
    /**
     * 事件变量本地缓存，获取的值是最近从服务器中获取的值（如若已监听则是接近最新的值）
     */
    ClientWorld.variable = new Variable();
    /**
     * ui点击事件集 id-CommandPage 0~N
     */
    ClientWorld.uiCustomCommandPages = {};
    return ClientWorld;
}());
/**
 * 游戏总管理基类
 * Created by 黑暗之神KDS on 2018-07-28 20:49:42.
 */
var GameBase = /** @class */ (function () {
    //------------------------------------------------------------------------------------------------------
    // 游戏时间戳
    // -- 场景渲染
    // -- 对象刷新
    // -- 上层自定义逻辑自行实现
    //------------------------------------------------------------------------------------------------------
    function GameBase() {
        /**
         * 暂停状态改变事件派发
         */
        this.EVENT_PAUSE_CHANGE = "GameEVENT_PAUSE_CHANGE";
        //------------------------------------------------------------------------------------------------------
        // 制作数据
        //------------------------------------------------------------------------------------------------------
        /**
         * 数据
         */
        this.data = new GameData();
        /**
         * 帧数
         */
        this._frameCount = 0;
        /**
         * 时间相关
         */
        this._startTime = new Date().getTime();
        this._staticTime = 0;
        this._staticInterval = 0;
        this._now = 0;
        this._timeMultiplier = 1;
        /**
         * 暂停时间推进（影响Game.now）
         */
        this._pause = false;
        this.__initGameTime();
    }
    GameBase.prototype.__initGameTime = function () {
        var _this = this;
        EventUtils.addEventListener(ClientWorld, ClientWorld.EVENT_INITED, Callback.New(function () {
            os.add_ENTERFRAME(_this.onEnterFrame, _this);
        }, this), true);
    };
    Object.defineProperty(GameBase.prototype, "frameCount", {
        get: function () {
            return this._frameCount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameBase.prototype, "oneFrame", {
        get: function () {
            return 1000 / os['fps'];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameBase.prototype, "now", {
        get: function () {
            return this._now;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameBase.prototype, "pause", {
        get: function () {
            return Game._pause;
        },
        set: function (v) {
            if (Game._pause == v)
                return;
            Game._pause = v;
            EventUtils.happen(this, this.EVENT_PAUSE_CHANGE);
        },
        enumerable: false,
        configurable: true
    });
    GameBase.prototype.onEnterFrame = function () {
        if (!Game._pause) {
            this._now += this._timeMultiplier * this.oneFrame;
            this._frameCount++;
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * [网络版 Server RPC]设置玩家登录数据
     * @param playerID 玩家唯一UID
     * @param worldData 来自服务器的世界数据（可公开部分）
     * @param heartBeatInterval 心跳间隔（秒）
     */
    GameBase.prototype.setLoginData = function (playerID, worldData, heartBeatInterval) {
        Game.player.uid = playerID;
        Game.player.key = Game.playerKey;
        ClientMsgSender.heartBeatInterval = heartBeatInterval;
        var t = Math.floor(ClientMsgSender.heartBeatInterval / 2) * 1000;
        setInterval(function () {
            if (ClientMsgSender.threadID != null || ClientMsgSender.threadID != 2) {
                ClientMsgSender.rpc("ServerPlayer", "HeartBeat");
            }
        }, t);
        // 装载客户端允许装载的世界属性
        for (var i in worldData) {
            ClientWorld.data[i] = worldData[i];
        }
    };
    /**
     * 初始化
     */
    GameBase.prototype.init = function () {
        this.player = new ClientPlayer(true);
    };
    //------------------------------------------------------------------------------------------------------
    // 单机版存档读档
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取存档数据
     * @return [any]
     */
    GameBase.prototype.getSaveData = function () {
        return [Game.now];
    };
    /**
     * 恢复存档数据
     * @param data
     * @return [any]
     */
    GameBase.prototype.recoverySaveData = function (data) {
        // 恢复游戏时间，让Game.now当前与存档时是一致的值即可
        var now = new Date().getTime();
        Game._startTime = now - data[0];
    };
    return GameBase;
}());
// 兼容项目层不存在的创建
// @ts-ignore
var Game = new GameBase;
/**
 * 单机游戏类
 * -- 单场景管理
 * -- 对象行为
 * -- 事件：场景、场景对象、界面、主动调用公共事件
 * -- 转化命令通信
 * -- 新游戏和读取存档
 *
 * 存档读档（世界数据、世界变量、玩家变量、玩家数据、NPC对象开关）
 * -- *此前进行到一半的行为（如移动A-B-C）(可以自定义保存场景的当前移动状态和目的地)
 * -- 如点击事件这种非自动触发的事件，虽然事件还原，但未能调用响应逻辑，如锁死操作（恢复时抛出事件？mainType+indexType?）
 *    目前通过派发EVENT_RECOVER_TRIGGER事件上层监听完成。
 * -- 读档后相关的资源预载入
 * -- 时实读档后可能存在的问题：如变量，还有检查其他的东西。
 *
 * 【存档安全流程】
 * -- 1.储存BAK存档文件
 * -- 2.将BAK存档文件覆盖正式存档
 * -- 3.删除BAK存档文件
 *
 * 【读档安全流程】
 * -- 1.读取BAK存档文件，如果存在并文件有效可用，则使用BAK存档的内容
 * -- 2.读取正式存档文件，如果存在并文件有效可用，则读取成功，否则返回失败
 *
 * 以上使用于普通存档位（gamedataX.gcdata）和全局数据档案（life.gcdata）
 * 储存普通存档位时也会同时储存全局数据档案，也可以直接储存全局数据档案
 * 相关储存/删除存档会加锁操作，以便同时内调用多次仅按照调用先后顺序执行而不会由于冲突报错
 *
 * Created by 黑暗之神KDS on 2020-02-02 02:20:56.
 */
var SinglePlayerGame = /** @class */ (function () {
    function SinglePlayerGame() {
    }
    /**
     * 读档需要载入的资源集
     */
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    SinglePlayerGame.init = function (onFin) {
        var _this = this;
        SinglePlayerGame.GC_LIFE_DATA_PATH = SinglePlayerGame.toWebSaveFileURL("savedata/life.gcdata");
        SinglePlayerGame.GC_LIFE_DATA_PATH_BAK = SinglePlayerGame.toWebSaveFileURL("savedata/life.gcdatabak");
        // 重写命令调用实现的方法：同步
        Command.prototype.callExecuteFunction = function (triggerLineID, player, params, gameFunc) {
            if (gameFunc === void 0) { gameFunc = null; }
            var p = gameFunc ? [gameFunc].concat(params) : params;
            var args = ObjectUtils.depthClone([triggerLineID, [this.type].concat(p)]);
            GameCommand.rpcCall.apply(GameCommand, args);
        };
        // 重写玩家进入场景：将数据储存回纯数据SceneObject中
        Player.prototype.toScene = function (sceneID, x, y) {
            var _this = this;
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            // 锁定方法
            GameCommand.banSceneObjectEvent = true;
            // 记录玩家身上的全触发线（允许2-界面 3-独立公共事件 4-独立片段事件 且触发者和执行者都是玩家自身）
            var crossTriggerLines = ArrayUtils.matchAttributes(Game.player.sceneObject.triggerLines, { trigger: Game.player.sceneObject, executor: Game.player.sceneObject }, false);
            crossTriggerLines = ArrayUtils.matchAttributes(crossTriggerLines, { mainType: CommandTrigger.COMMAND_MAIN_TYPE_SCENE }, false, "!=");
            crossTriggerLines = ArrayUtils.matchAttributes(crossTriggerLines, { mainType: CommandTrigger.COMMAND_MAIN_TYPE_SCENE_OBJECT }, false, "!=");
            for (var i in crossTriggerLines) {
                var crossTriggerLine = crossTriggerLines[i];
                crossTriggerLine.lock = true;
            }
            var lastScene = Game.currentScene;
            var lastPlayerSceneObject = Game.player.sceneObject;
            // 非可跨场景触发器派发结束事件并销毁
            for (var i in Game.player.sceneObject.triggerSingleLines) {
                var myTrigger = Game.player.sceneObject.triggerSingleLines[i];
                if (myTrigger.mainType == CommandTrigger.COMMAND_MAIN_TYPE_SCENE || myTrigger.trigger != Game.player.sceneObject || myTrigger.executor != Game.player.sceneObject) {
                    EventUtils.happen(myTrigger, CommandTrigger.EVENT_OVER);
                    myTrigger.dispose();
                    delete Game.player.sceneObject.triggerSingleLines[i];
                }
            }
            for (var i in Game.player.sceneObject.triggerLines) {
                var myTrigger = Game.player.sceneObject.triggerLines[i];
                if (myTrigger.mainType == CommandTrigger.COMMAND_MAIN_TYPE_SCENE || myTrigger.trigger != Game.player.sceneObject || myTrigger.executor != Game.player.sceneObject) {
                    if (!myTrigger.isDisposed)
                        EventUtils.happen(myTrigger, CommandTrigger.EVENT_OVER);
                    myTrigger.dispose();
                }
            }
            // 清理掉所有
            Game.player.sceneObject.triggerLines = {};
            var checkChangeScene = function (lastScene, lastPlayerSceneObject) {
                if (Game.currentScene && lastScene != Game.currentScene) {
                    // GameFunction.lock = false;
                    GameFunction.scene = Game.currentScene;
                    // 如果销毁对象的模式的话：重新装入事件
                    if (lastPlayerSceneObject != Game.player.sceneObject) {
                        for (var i in crossTriggerLines) {
                            var crossTriggerLine = crossTriggerLines[i];
                            crossTriggerLine.lock = false;
                            crossTriggerLine.trigger = Game.player.sceneObject;
                            crossTriggerLine.executor = Game.player.sceneObject;
                            crossTriggerLine.scene = Game.currentScene;
                            Game.player.sceneObject.triggerLines[crossTriggerLine.id] = crossTriggerLine;
                        }
                    }
                    // 否则刷新事件
                    else {
                        Game.player.sceneObject.x = x;
                        Game.player.sceneObject.y = y;
                        // 装入跨场景的触发器
                        for (var i in crossTriggerLines) {
                            var crossTriggerLine = crossTriggerLines[i];
                            crossTriggerLine.lock = false;
                            crossTriggerLine.scene = Game.currentScene;
                            Game.player.sceneObject.triggerLines[crossTriggerLine.id] = crossTriggerLine;
                        }
                    }
                    // 解锁
                    GameCommand.banSceneObjectEvent = false;
                }
                else {
                    Callback.CallLaterBeforeRender(checkChangeScene, _this, [lastScene, lastPlayerSceneObject]);
                }
            };
            Callback.CallLaterBeforeRender(checkChangeScene, this, [lastScene, lastPlayerSceneObject]);
            // 记录对象开关
            SinglePlayerGame.recordSceneObjectSwitch();
            EventUtils.happen(this.sceneObject, Command.EVENT_SYSTEM_COMMAND_START, [2]);
            // 同步场景对象数据
            Game.player.sceneObject.syncAvatarStateToSceneObject();
            ObjectUtils.cloneExcludeNonExistentAttribute(Game.player.sceneObject, Game.player.data.sceneObject);
            Game.player.data.sceneObject.x = x;
            Game.player.data.sceneObject.y = y;
            EventUtils.happen(ClientScene, ClientScene.EVENT_IN_NEW_SCENE, [sceneID, 0]);
        };
        // 重写ClientSceneObject的初始化，追加初始化一些属性
        var ClientSceneObjectInit = ClientSceneObject.prototype["____beforeInstallAttributeInit"];
        ClientSceneObject.prototype["____beforeInstallAttributeInit"] = function () {
            this.switchs = [0, 0, 0, 0, 0, 0, 0];
            this.triggerLines = {};
            this.triggerSingleLines = {};
            this.customCommandPages = [];
            ClientSceneObjectInit.apply(this);
        };
        Game.currentScene = ClientScene.EMPTY = new ClientScene;
        Game.player.sceneObject = new ClientSceneObject(new SceneObject, Game.currentScene);
        Game.player.sceneObject.player = Game.player;
        // 重写UI加载
        // var uiLoad = GameUI.load;
        var uiParse = GameUI.parse;
        var uiCmdLoaded = [];
        var uiCommandParse = function (id) {
            if (!uiCmdLoaded[id]) {
                uiCmdLoaded[id] = true;
                var uiData = Game.data.uiList.data[id];
                if (uiData) {
                    for (var uicompID in uiData.uiCommandData) {
                        if (uicompID == "id" || uicompID == "data")
                            continue;
                        var uiCommandData = uiData.uiCommandData[uicompID];
                        var commandDatas = uiCommandData.commands;
                        var commands = ClientWorld.uiCustomCommandPages[id + "_" + uicompID] = [];
                        for (var s in commandDatas) {
                            var cmdData = commandDatas[s];
                            if (!cmdData || cmdData.length == 0)
                                continue;
                            commands[s] = new CommandPage(cmdData);
                        }
                    }
                }
            }
        };
        // GameUI.load = function (id: number, copy: boolean = false): UIComponent.UIRoot {
        //     var ui = uiLoad.apply(GameUI, arguments);
        //     uiCommandParse(id);
        //     return ui;
        // }
        GameUI.parse = function (data, newID, childList, uiID, root, syncLoadedEventWhenAssetExist) {
            if (newID === void 0) { newID = false; }
            if (childList === void 0) { childList = null; }
            if (uiID === void 0) { uiID = null; }
            if (root === void 0) { root = null; }
            if (syncLoadedEventWhenAssetExist === void 0) { syncLoadedEventWhenAssetExist = false; }
            uiCommandParse(data.id);
            return uiParse.apply(GameUI, arguments);
        };
        // 加载场景的事件
        ClientScene.prototype.createSceneLoadExt = function (onFin) {
            var scene = this;
            Game.data.loadScene(scene.id, Callback.New(function () {
                var sceneData = Game.data.sceneList.data[scene.id];
                if (sceneData) {
                    var sceneObjDatas = sceneData.sceneObjectData;
                    // 自定义类别事件初始化（存在缓存则直接使用，否则新创建）
                    var customCommands = SinglePlayerGame.customCommandsCache[scene.id];
                    if (customCommands) {
                        scene.customCommandPages = customCommands;
                    }
                    else {
                        for (var s in sceneObjDatas.customCommands) {
                            var commands = sceneObjDatas.customCommands[s];
                            if (commands == null)
                                continue;
                            scene.customCommandPages[s] = new CommandPage(commands);
                        }
                    }
                }
                onFin.apply(scene);
            }, this));
        };
        // 场景预加载：扩展加载场景对象和事件
        AssetManager.preLoadSceneAssetExt = Callback.New(function (sceneID, onFin) {
            var loadSoTask = new AsynTask(Callback.New(function () {
                // trace("SO任务完成了", loadSoTask._asynCount, loadSoTask._asynCount);
                onFin();
            }, _this));
            Game.data.loadScene(sceneID, Callback.New(function () {
                var sceneData = Game.data.sceneList.data[sceneID];
                if (sceneData) {
                    var sceneObjDatas = sceneData.sceneObjectData;
                    // 加载场景对象
                    if (sceneData.mapData.preloadSceneObjectAsset) {
                        var sceneObjects = sceneObjDatas.sceneObjects;
                        var len = sceneObjects.length;
                        for (var i = 0; i < len; i++) {
                            var soObj = sceneObjects[i];
                            if (!soObj || soObj.isBorn)
                                continue;
                            loadSoTask.execute(1);
                            // 加载主状态页对象
                            AssetManager.preLoadSceneObjectAsset(soObj, Callback.New(loadSoTask.complete, loadSoTask));
                            // 加载可能存在的其他状态页对象
                            var statusPages = sceneObjDatas.statusPages[i];
                            for (var s in statusPages) {
                                var stp = statusPages[s];
                                loadSoTask.execute(1);
                                AssetManager.preLoadSceneObjectAsset(stp.so, Callback.New(loadSoTask.complete, loadSoTask));
                            }
                        }
                    }
                    // 缓存事件页，并加载相关事件中的资源
                    var customCommands = SinglePlayerGame.customCommandsCache[sceneID] = [];
                    for (var i = 0; i < sceneData.sceneObjectData.customCommands.length; i++) {
                        var commands = sceneObjDatas.customCommands[i];
                        if (commands == null)
                            continue;
                        var cmdPage = customCommands[i] = new CommandPage(commands);
                        if (sceneData.mapData.preloadSceneCommandAsset) {
                            loadSoTask.execute(1);
                            // trace("预加载事件页------");
                            AssetManager.preLoadCommandPage(cmdPage, Callback.New(loadSoTask.complete, loadSoTask));
                        }
                    }
                }
                // 任务完成
                loadSoTask.execute(1);
                // trace("SO任务一共---", loadSoTask.length);
                loadSoTask.complete();
            }, _this));
        }, this);
        // 场景卸载
        AssetManager.disposeSceneAssetExt = Callback.New(function (sceneID) {
            Game.data.loadScene(sceneID, Callback.New(function () {
                var sceneData = Game.data.sceneList.data[sceneID];
                if (sceneData) {
                    var sceneObjDatas = sceneData.sceneObjectData;
                    var customCommands = SinglePlayerGame.customCommandsCache[sceneID];
                    // 卸载场景对象
                    if (sceneData.mapData.preloadSceneObjectAsset) {
                        var sceneObjects = sceneObjDatas.sceneObjects;
                        var len = sceneObjects.length;
                        for (var i = 0; i < len; i++) {
                            var soObj = sceneObjects[i];
                            if (!soObj || soObj.isBorn)
                                continue;
                            // 加载主状态页对象
                            AssetManager.disposeSceneObject(soObj);
                            // 加载可能存在的其他状态页对象
                            var statusPages = sceneObjDatas.statusPages[i];
                            for (var s in statusPages) {
                                var stp = statusPages[s];
                                AssetManager.disposeSceneObject(stp.so);
                            }
                        }
                    }
                    // 卸载场景事件
                    for (var i = 0; i < sceneData.sceneObjectData.customCommands.length; i++) {
                        var commands = sceneObjDatas.customCommands[i];
                        if (commands == null)
                            continue;
                        // 使用SinglePlayerGame记录的缓存事件页（缓存事件页本身并不置空，保留到游戏结束，纯数据量一般并不占用多少内存空间）
                        var cmdPage = customCommands[i];
                        if (sceneData.mapData.preloadSceneCommandAsset && cmdPage) {
                            AssetManager.disposeCommandPage(cmdPage);
                        }
                    }
                }
            }, _this));
        }, this);
        // 场景添加场景对象自动计算index
        var oriAddSceneObject = ClientScene.prototype.addSceneObject;
        ClientScene.prototype.addSceneObject = function (soData, isSoc, useModelClass) {
            if (isSoc === void 0) { isSoc = false; }
            if (useModelClass === void 0) { useModelClass = false; }
            var scene = this;
            var inSceneSo = scene.sceneObjects[soData.index];
            if (inSceneSo && inSceneSo != soData) {
                soData.index = ArrayUtils.getNullPosition(scene.sceneObjects);
            }
            return oriAddSceneObject.apply(this, arguments);
        };
        // 预加载场景：追加场景对象以及事件等
        var preloadScene = AssetManager.preLoadSceneAsset;
        AssetManager.preLoadSceneAsset = function (id, complete, syncCallbackWhenAssetExist, autoDispose) {
            if (complete === void 0) { complete = null; }
            if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
            if (autoDispose === void 0) { autoDispose = false; }
            Game.data.loadScene(id, Callback.New(preloadScene, AssetManager, [id, complete, syncCallbackWhenAssetExist, autoDispose]));
        };
        // 玩家变量：当改变后派发事件 + 监听立即回调
        Game.player.variable["listener"] = Game.player;
        ClientPlayer.prototype["onVarChange"] = function (type, varID, value) {
            var typeEvent = ClientPlayer.getEventType(type, varID);
            Game.player["event"].event(typeEvent, [type, varID, value]);
        };
        var addListenerPlayerVariable = ClientPlayer.prototype.addListenerPlayerVariable;
        ClientPlayer.prototype.addListenerPlayerVariable = function (type, varID, onChange, isOnce, immediatelyCallback) {
            if (isOnce === void 0) { isOnce = false; }
            if (immediatelyCallback === void 0) { immediatelyCallback = true; }
            this.requestSyncPlayerVars[type][varID] = true;
            addListenerPlayerVariable.apply(this, arguments);
        };
        // 世界变量：当改变后派发事件
        ClientWorld.variable["listener"] = ClientWorld;
        ClientWorld["onVarChange"] = function (type, varID, value) {
            EventUtils.happen(ClientWorld, "worldVar" + type + "_" + varID, [type, varID, value]);
        };
        // 场景对象条件：根据条件改变让对象出现或消失
        var refreshDisappearStatus = SceneObjectEntity.prototype["refreshDisappearStatus"];
        // @ts-ignore
        SceneObjectEntity.prototype["refreshDisappearStatus"] = function () {
            if (!Game.currentScene || !this.statusPages)
                return;
            var so = this;
            var stateInfo = refreshDisappearStatus.apply(this, arguments);
            // 需要出现时：如果已在场景的记录列表中才添加（初始创建时不调用该函数）
            if (stateInfo.state == 1) {
                if (Game.currentScene.sceneObjects[so.index] == so) {
                    Game.currentScene.addSceneObject(so, true);
                }
            }
            // 需要消失时：但不需要从记录列表中移除
            else if (stateInfo.state == 2) {
                Game.currentScene.removeSceneObject(so, false);
            }
            // 如果切换了状态页的话
            if (stateInfo.changeStatusPage) {
                // 如果在场景上则刷新显示列表
                if (so.inScene)
                    so.refreshCommonDisplayList();
                if (so.scene) {
                    EventUtils.happen(SceneObjectEntity, SceneObjectEntity.EVENT_CHANGE_STATUS_PAGE, [this]);
                    EventUtils.happen(this, SceneObjectEntity.EVENT_CHANGE_STATUS_PAGE_FOR_INSTANCE, [this]);
                }
            }
            return stateInfo;
        };
        // 场景对象开关：追加刷新出现或者消失的状态
        ClientSceneObject.prototype.setSwitchs = function (varID, value) {
            this.switchs[varID] = value;
            this.refreshDisappearStatus();
        };
        // 单机版无需在场景上（如标题）
        GameCommand.mustInScene = false;
        // 传输实现类
        Command.init(ClientWorld);
        // 内核扩展
        SinglePlayerGame.initMain(onloadDataOver);
        // 通信转化
        ClientMsgSender.requestTriggerEventSend = Callback.New(SinglePlayerGame.triggerEvent, SinglePlayerGame);
        // 对话框延迟小时时间归零（由于单机版本无网络延迟）
        GameDialog.delayCloseTime = 0;
        // 异步任务
        var task = new AsynTask(onFin);
        var onloadDataOver = Callback.New(task.complete, task, []);
        // 加载全部公共事件
        task.execute(SinglePlayerGame.initCommands(onloadDataOver));
        // 读取全局信息
        task.execute(SinglePlayerGame.loadLifeData(onloadDataOver));
    };
    /**
     * 储存全局信息
     * @param onFin 当储存完毕时 onFin(success:boolean)
     * @param globalData [可选] 默认值=null 全局数据，必须是支持打包为Json格式的数据
     * @param completeProcess [可选] 默认值=true 完整流程，如果true则先储存BAK，再覆盖，再删除BAK，否则只储存BAK。如果是非PC版则不会走bak流程
     * @param taskLock [可选] 默认值=true 任务锁，存在则使用存档任务锁
     * @param ifNullGlobalDataSaveLastGlobalData [可选] 默认值=false 如果自定义数据globalData为空则储存上一次的记录值
     */
    SinglePlayerGame.saveLifeData = function (onFin, globalData, completeProcess, taskLock, ifNullGlobalDataSaveLastGlobalData) {
        var _this = this;
        if (globalData === void 0) { globalData = null; }
        if (completeProcess === void 0) { completeProcess = true; }
        if (taskLock === void 0) { taskLock = true; }
        if (ifNullGlobalDataSaveLastGlobalData === void 0) { ifNullGlobalDataSaveLastGlobalData = false; }
        // globalData
        var packageGlobalData = {
            ___globalData: globalData,
            ___useNewGlobalData: true
        };
        // 同时写入到当前的全局数据中，以便当前是直接可以访问的
        var currentCustomGlobalData = SinglePlayerGame.currentCustomGlobalData;
        if (!currentCustomGlobalData)
            currentCustomGlobalData = SinglePlayerGame.currentCustomGlobalData = {};
        for (var i = 0; i < SinglePlayerGame.regSaveCustomGlobalDataCallbacks.length; i++) {
            var cbInfo = SinglePlayerGame.regSaveCustomGlobalDataCallbacks[i];
            var value = cbInfo.globalDataFunction.run();
            packageGlobalData[cbInfo.globalDataName] = value;
            currentCustomGlobalData[cbInfo.globalDataName] = value;
        }
        globalData = packageGlobalData;
        var saveLifeDataF = function () {
            var saveGameFin = Callback.New(function (success) {
                onFin && onFin.runWith([success]);
                if (taskLock)
                    SyncTask.taskOver(SinglePlayerGame.TASK_MODIFY_FILE);
            }, _this);
            // 如果没有关于SinglePlayerGame.saveIDs的信息则等待SinglePlayerGame.saveIDs
            if (!SinglePlayerGame.saveIDs) {
                Callback.CallLater(SinglePlayerGame.saveLifeData, SinglePlayerGame, [saveGameFin, globalData, completeProcess]);
                return;
            }
            // 仅PC平台需要BAK文件
            var needBak = os.platform == 2 ? true : false;
            var GC_LIFE_DATA_PATH1 = needBak ? SinglePlayerGame.GC_LIFE_DATA_PATH_BAK : SinglePlayerGame.GC_LIFE_DATA_PATH;
            // 二周目变量
            var worldVarialbeData = ClientWorld.variable.getTransportableData();
            // 如果空数据的话直接返回
            if (ifNullGlobalDataSaveLastGlobalData && packageGlobalData.___globalData == null) {
                packageGlobalData.___globalData = SinglePlayerGame.globalData;
            }
            var lifeData = { variable: worldVarialbeData, saveIDs: SinglePlayerGame.saveIDs, globalData: globalData };
            FileUtils.save(lifeData, GC_LIFE_DATA_PATH1, Callback.New(function (success) {
                // 如果不成功的话则直接返回
                if (!success) {
                    saveGameFin.runWith([success]);
                    return;
                }
                // 非完整bak流程或无需bak流程则直接返回
                if (!completeProcess || !needBak) {
                    saveGameFin.runWith([success]);
                }
                // 完整bak流程：覆盖后删除
                else {
                    FileUtils.cloneFile(SinglePlayerGame.GC_LIFE_DATA_PATH_BAK, SinglePlayerGame.GC_LIFE_DATA_PATH, Callback.New(function (success) {
                        if (!success) {
                            saveGameFin.runWith([success]);
                            return;
                        }
                        FileUtils.deleteFile(SinglePlayerGame.GC_LIFE_DATA_PATH_BAK, Callback.New(function (success) {
                            saveGameFin.runWith([success]);
                        }, _this));
                    }, _this));
                }
            }, _this));
        };
        if (taskLock) {
            new SyncTask(SinglePlayerGame.TASK_MODIFY_FILE, saveLifeDataF);
        }
        else {
            saveLifeDataF.apply(this);
        }
    };
    /**
     * 覆盖全局信息：将储存的BAK文件覆盖一下
     * @param onFin
     */
    SinglePlayerGame.saveLifeData2_Cover = function (onFin) {
    };
    SinglePlayerGame.saveGlobalData = function (onFin, globalData) {
        if (globalData === void 0) { globalData = null; }
        SinglePlayerGame.saveLifeData(onFin, globalData);
    };
    /**
     * 读取全局信息：载入全局变量、载入存档记录集
     * @param onFin
     */
    SinglePlayerGame.loadLifeData = function (onFin) {
        var _this = this;
        var url = SinglePlayerGame.GC_LIFE_DATA_PATH;
        // 本地版本需要优先读取BAK，如果BAK文件存在则使用BAK文件否则使用正式版本
        SinglePlayerGame.loadSaveFile(SinglePlayerGame.GC_LIFE_DATA_PATH_BAK, Callback.New(function (data) {
            SinglePlayerGame.disposeSaveFile(SinglePlayerGame.GC_LIFE_DATA_PATH_BAK, true);
            if (data) {
                SinglePlayerGame.doLoadLifeData(data, onFin);
            }
            else {
                SinglePlayerGame.loadSaveFile(url, Callback.New(function (data) {
                    SinglePlayerGame.disposeSaveFile(url, true);
                    SinglePlayerGame.doLoadLifeData(data, onFin);
                }, _this), false, true, false);
            }
        }, this), false, true, false);
    };
    SinglePlayerGame.doLoadLifeData = function (data, onFin) {
        var _this = this;
        if (data) {
            // 载入全局变量
            if (data.variable)
                ObjectUtils.clone(data.variable, ClientWorld.variable);
            // 载入存档记录集
            if (data.saveIDs)
                SinglePlayerGame.saveIDs = data.saveIDs;
            // 记录全局数据
            var packageGlobalData = data.globalData;
            // 新版全局自定义数据
            if (packageGlobalData && packageGlobalData.___useNewGlobalData) {
                // 兼容旧版本
                SinglePlayerGame.globalData = packageGlobalData.___globalData;
                SinglePlayerGame.currentCustomGlobalData = packageGlobalData;
            }
            else {
                SinglePlayerGame.globalData = data.globalData;
            }
            // 检查实际存在的文件，对比saveIDs如果不匹配的话则修正。V0.985后的存档也会在具体档案中储存indexInfo
            if (FileUtils.hasFileOperationJurisdiction) {
                // 获取存档信息
                var newSaveIDsObj = {};
                if (!SinglePlayerGame.saveIDs)
                    SinglePlayerGame.saveIDs = [];
                FileUtils.getDirectoryListing("savedata", Callback.New(function (fos) {
                    if (!fos) {
                        SinglePlayerGame.saveIDs = [];
                        onFin.delayRun(0);
                        return;
                    }
                    var fosClone = fos.concat();
                    fosClone.sort(function (a, b) { return a.lastModifyDate.getTime() < a.lastModifyDate.getTime() ? -1 : 1; });
                    // 同步处理
                    var syncTaskName = "doLoadLifeData";
                    // 添加可能不存在于SinglePlayerGame.saveIDs的实际存档文件记录
                    var fileIDs = [];
                    for (var i = 0; i < fosClone.length; i++) {
                        var fo = fosClone[i];
                        if (fo.isDirectory)
                            continue;
                        var fileNameArr = fo.fileName.split(".");
                        var ext = fileNameArr.pop();
                        // 如果是存档文件的话则：
                        if (ext == "gcdatabak" || ext == "gcdata") {
                            var fileName = fileNameArr.join(".");
                            if (newSaveIDsObj[fileName])
                                continue;
                            newSaveIDsObj[fileName] = true;
                            var fileNmaeIDStr = fileName.replace("gamedata", "");
                            if (fileNmaeIDStr == "" || fileNmaeIDStr == "life")
                                continue;
                            var fileNameID = MathUtils.int(fileNmaeIDStr);
                            var m = ArrayUtils.matchAttributes(SinglePlayerGame.saveIDs, { id: fileNameID }, true)[0];
                            if (!m) {
                                // 需要读取文件
                                new SyncTask(syncTaskName, function (fileNameID, localPath, lastModifyDate) {
                                    FileUtils.loadJsonFile(localPath, Callback.New(function (fileNameID, lastModifyDate, jsonObj) {
                                        if (jsonObj) {
                                            var indexInfo = jsonObj[15];
                                            if (!indexInfo)
                                                indexInfo = {};
                                            var newSaveID = {
                                                id: fileNameID,
                                                indexInfo: indexInfo,
                                                now: lastModifyDate.getTime()
                                            };
                                            SinglePlayerGame.saveIDs.push(newSaveID);
                                        }
                                        // 此次任务结束：由于可能是同步完成的，此处强制等待1帧
                                        Callback.New(SyncTask.taskOver, SyncTask, [syncTaskName]).delayRun(0, setFrameout);
                                    }, _this, [fileNameID, lastModifyDate]));
                                }, [fileNameID, fo.localPath, fo.lastModifyDate]);
                            }
                            fileIDs.push(fileNameID);
                        }
                    }
                    new SyncTask(syncTaskName, function () {
                        // 移除掉实际已经不存在的文件
                        for (var i = 0; i < SinglePlayerGame.saveIDs.length; i++) {
                            var saveIDInfo = SinglePlayerGame.saveIDs[i];
                            if (!saveIDInfo || fileIDs.indexOf(saveIDInfo.id) == -1) {
                                SinglePlayerGame.saveIDs.splice(i, 1);
                                i--;
                            }
                        }
                        // 回调
                        onFin.delayRun(0);
                        // 此次任务结束
                        SyncTask.taskOver(syncTaskName);
                    });
                }, this));
                return;
            }
            else if (!SinglePlayerGame.saveIDs) {
                SinglePlayerGame.saveIDs = [];
            }
        }
        else {
            SinglePlayerGame.saveIDs = [];
        }
        onFin.delayRun(0);
    };
    /**
     * 新游戏初始化
     */
    SinglePlayerGame.newGameInit = function (soData, x, y) {
        if (soData === void 0) { soData = null; }
        if (x === void 0) { x = null; }
        if (y === void 0) { y = null; }
        // 安装玩家自定义数据
        Game.player.uid = 1;
        if (soData)
            ObjectUtils.clone(soData, this);
        Player.installCustomData(Game.player);
        var so = Game.player.data.sceneObject = new SceneObject();
        ObjectUtils.clone(Config.BORN.so, so);
        // 测试环境下直接进入到
        if (x != null && y != null) {
            so.x = x;
            so.y = y;
        }
        SceneObject.installCustomData(so, Config.BORN.customAttribute, false);
        so.playerUID = Game.player.uid;
    };
    /**
     * 新的游戏
     */
    SinglePlayerGame.newGame = function () {
        // 获取可能存在的场景测试
        var sceneTest = window.location.href.split("?scene=").pop();
        if (sceneTest) {
            var sceneInfo = sceneTest.split(",");
            if (sceneInfo.length == 4) {
                // 验证
                var rd = MathUtils.int(sceneInfo[3].substr(0, 4));
                var fpw = MathUtils.int(sceneInfo[3].substr(4));
                var tpw = MathUtils.int(new Date().getTime() * 2.5 + rd * 100000);
                var dt = MathUtils.int((tpw - fpw) / 1000);
                // 24小时内有效
                if (dt <= 60 * 60 * 24) {
                    var sceneID = MathUtils.int(sceneInfo[0]);
                    var x = MathUtils.int(sceneInfo[1]);
                    var y = MathUtils.int(sceneInfo[2]);
                    this.newGameInit(null, x, y);
                    EventUtils.happen(ClientScene, ClientScene.EVENT_IN_NEW_SCENE, [sceneID, 1]);
                    return;
                }
            }
        }
        // 安装新游戏的玩家数据
        this.newGameInit();
        // 进入出生点
        EventUtils.happen(ClientScene, ClientScene.EVENT_IN_NEW_SCENE, [Config.BORN.sceneID, 1]);
    };
    /**
     * 存档：支持事件执行中调用存档
     * -- 设备储存（PC、移动端等设备以文件形式的储存）
     * -- cookies 缓存（Web支持LocalStorage的形式储存）
     * -- 云存档（GC游戏平台自动支持云存档服务，）
     * @param index 存档位置
     * @param onFin 存档完毕时回调 onFin(success:boolean)
     * @param indexInfo 存档目录用的信息（写入至LIFE-DATA，用于在读档列表中看到一些自定义的信息，可以使用SinglePlayerGame.getSaveInfo来获取）
     * @param customData 自定义数据，可以被JSON化的数据对象
     *                  （上层自己添加的状态需要保存和恢复的话需要自行编写相关的逻辑，根据参数 ）
     * @param globalData 全局数据，全局数据在任何新的游戏、存档都通用的数据（比如用于储存用户的按键设置）
     */
    SinglePlayerGame.saveGame = function (index, onFin, indexInfo, customData, globalData) {
        if (indexInfo === void 0) { indexInfo = null; }
        if (customData === void 0) { customData = null; }
        if (globalData === void 0) { globalData = null; }
        // ====== 在任务队列前即获取数据并深度复制，以便保存这一帧瞬间的状态
        index = MathUtils.int(index);
        var now = new Date().getTime();
        var customDataObj = null;
        // 需要预加载的UI
        var needLoadUIs = [];
        // 世界自定义数据
        var worldSaveData = ClientWorld.data;
        // 玩家变量
        var playerVarialbeData = Game.player.variable.getTransportableData();
        // 玩家场景对象同步
        Game.player.sceneObject.syncAvatarStateToSceneObject();
        ObjectUtils.cloneExcludeNonExistentAttribute(Game.player.sceneObject, Game.player.data.sceneObject);
        var playerData = Game.player.data;
        // -- 玩家场景对象的模块数据
        var playerSoModuleDatas = null;
        if (Config.useNewSceneObjectModel) {
            playerSoModuleDatas = SceneObjectEntity.getModulesSaveData(Game.player.sceneObject);
        }
        // 保存全场景的对象开关
        SinglePlayerGame.recordSceneObjectSwitch();
        // -------------- 【单机额外】
        // BGM/BGS
        var audioInfo = [GameAudio.lastBgmURL, GameAudio.lastBGMPitch, GameAudio.lastBGMVolume, GameAudio.lastBgsURL, GameAudio.lastBGSPitch, GameAudio.lastBGSVolume, GameAudio.bgmVolume, GameAudio.bgsVolume, GameAudio.seVolume, GameAudio.tsVolume];
        // 除玩家外的对象（基础属性 + 自定义属性 + 行为）
        var sceneObjectData = SinglePlayerGame.getCurrentSceneObject();
        // 正在执行的事件
        var triggerEventDatas = SinglePlayerGame.getTriggerEventSaveData();
        var triggerEventData = triggerEventDatas[0];
        needLoadUIs = needLoadUIs.concat(triggerEventDatas[1]);
        // 图片系统+UI显示+对话框+GameCommand
        var gameCommandData = SinglePlayerGame.getGameCommandData();
        // 当前场景的状态：镜头、雾气、色调
        var sceneStatus = SinglePlayerGame.getSceneStatusData();
        // 打包数据
        // 原自定义数据 = ___customData
        // 注册的数据 = packageCustomData[dataName]
        var packageCustomData = {
            ___customData: customData,
            ___useNewCustomData: true
        };
        for (var i = 0; i < SinglePlayerGame.regSaveCustomDataCallbacks.length; i++) {
            var cbInfo = SinglePlayerGame.regSaveCustomDataCallbacks[i];
            packageCustomData[cbInfo.dataName] = cbInfo.dataFunction.run();
        }
        var saveData = [Game.getSaveData(), now, Game.currentScene.id, worldSaveData, playerVarialbeData, playerData, SinglePlayerGame.sceneDatas, audioInfo, triggerEventData, sceneObjectData, gameCommandData, sceneStatus, packageCustomData, needLoadUIs, playerSoModuleDatas, indexInfo];
        saveData = ObjectUtils.depthClone(saveData);
        // == 使用任务队列来执行储存，储存时优先储存全局数据后再储存当前存档的数据
        new SyncTask(SinglePlayerGame.TASK_MODIFY_FILE, function () {
            var _this = this;
            var saveGameFin = Callback.New(function (success) {
                onFin && onFin.runWith([success]);
                SyncTask.taskOver(SinglePlayerGame.TASK_MODIFY_FILE);
            }, this);
            // 不在场景上则失败
            if (!Game.currentScene) {
                saveGameFin.runWith([false]);
                return;
            }
            // 全局存档：全局变量储存（二周目）、记录档案个数
            var idx = ArrayUtils.matchAttributes(SinglePlayerGame.saveIDs, { id: index }, true, "==", true)[0];
            if (idx == null) {
                SinglePlayerGame.saveIDs.push({ id: index, indexInfo: indexInfo, now: now });
            }
            else {
                SinglePlayerGame.saveIDs[idx] = { id: index, indexInfo: indexInfo, now: now };
            }
            // 储存全局数据：储存lifeBak后再储存当前存档bak，如果两者都成功的话则一起覆盖完成，完成的话再删除BAK存档
            // 储存全局数据：储存lifeBak
            SinglePlayerGame.saveLifeData(Callback.New(function (success) {
                if (!success) {
                    saveGameFin.runWith([false]);
                    return;
                }
                // -- 储存单个文件
                var gameFile = SinglePlayerGame.toWebSaveFileURL("savedata/gamedata" + index + ".gcdata");
                // -- PC端需要储存单个文件
                var needBak = os.platform == 2 ? true : false;
                if (needBak) {
                    var gameFileBAK = SinglePlayerGame.toWebSaveFileURL("savedata/gamedata" + index + ".gcdatabak");
                    FileUtils.save(saveData, gameFileBAK, Callback.New(function () {
                        // 覆盖阶段
                        FileUtils.cloneFile(SinglePlayerGame.GC_LIFE_DATA_PATH_BAK, SinglePlayerGame.GC_LIFE_DATA_PATH, Callback.New(function (success) {
                            if (!success) {
                                saveGameFin.runWith([success]);
                                return;
                            }
                            FileUtils.cloneFile(gameFileBAK, gameFile, Callback.New(function (success) {
                                if (!success) {
                                    saveGameFin.runWith([success]);
                                    return;
                                }
                                // 删除阶段
                                FileUtils.deleteFile(SinglePlayerGame.GC_LIFE_DATA_PATH_BAK, Callback.New(function (success) {
                                    FileUtils.deleteFile(gameFileBAK, Callback.New(function (success) {
                                        saveGameFin.runWith([true]);
                                    }, _this));
                                }, _this));
                            }, _this));
                        }, _this));
                    }, _this));
                }
                // 非PC端不需要储存单个文件
                else {
                    FileUtils.save(saveData, gameFile, Callback.New(function (success, localURL) {
                        saveGameFin.runWith([success]);
                    }, _this));
                }
            }, this), globalData, false, false, true);
        });
    };
    /**
     * 注册与存档绑定的自定义数据
     * @param dataName 数据名
     * @param dataFunction 数据函数回调，通过此回调获取需要储存的数据
     */
    SinglePlayerGame.regSaveCustomData = function (dataName, dataFunction) {
        SinglePlayerGame.regSaveCustomDataCallbacks.push({ dataName: dataName, dataFunction: dataFunction });
    };
    /**
     * 注册与游戏绑定的自定义数据（与存档无关，游戏启动即会自动加载的数据 GC-LifeData）
     * @param globalDataName 全局数据名称
     * @param globalDataFunction 数据函数回调，通过此回调获取需要储存的数据
     */
    SinglePlayerGame.regSaveCustomGlobalData = function (globalDataName, globalDataFunction) {
        SinglePlayerGame.regSaveCustomGlobalDataCallbacks.push({ globalDataName: globalDataName, globalDataFunction: globalDataFunction });
    };
    /**
     * 读档
     * @param index 读档位置
     * @param onFin 读档完毕回调 onFin(success:boolean,customData:any);
     * @param onProgress [可选] 默认值=null 加载进度回调 onProgress(current:number,count:number); 当前加载数,加载总数
     */
    SinglePlayerGame.loadGame = function (index, onFin, onProgress) {
        var _this = this;
        if (onProgress === void 0) { onProgress = null; }
        index = MathUtils.int(index);
        // 不存在存档的话读取失败
        var m = ArrayUtils.matchAttributes(SinglePlayerGame.saveIDs, { id: index }, true);
        if (m.length != 1) {
            onFin.runWith([false]);
            return;
        }
        var url = SinglePlayerGame.toWebSaveFileURL("savedata/gamedata" + index + ".gcdata");
        // 优先读取BAK存档，如果失败才找正式存档
        var urlBAK = SinglePlayerGame.toWebSaveFileURL("savedata/gamedata" + index + ".gcdatabak");
        SinglePlayerGame.loadSaveFile(urlBAK, Callback.New(function (saveData) {
            SinglePlayerGame.disposeSaveFile(urlBAK, true);
            if (saveData) {
                SinglePlayerGame.doLoadGame(index, onFin, onProgress, saveData);
            }
            else {
                SinglePlayerGame.loadSaveFile(url, Callback.New(function (saveData) {
                    SinglePlayerGame.disposeSaveFile(url, true);
                    SinglePlayerGame.doLoadGame(index, onFin, onProgress, saveData);
                }, _this));
            }
        }, this), false, true, false);
    };
    /**
     * 获取当前存档的自定义数据，读档后才能够获取
     * @param dataName 数据名
     */
    SinglePlayerGame.getSaveCustomData = function (dataName) {
        return this.currentSaveFileCustomData ? this.currentSaveFileCustomData[dataName] : null;
    };
    /**
     * 读取自定义全局数据
     * @param 全局数据名称
     */
    SinglePlayerGame.getSaveCustomGlobalData = function (globalDataName) {
        var g = SinglePlayerGame.currentCustomGlobalData;
        return g ? g[globalDataName] : "";
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 档案文件地址转换（非PC平台在WEB端需要）
     */
    SinglePlayerGame.toWebSaveFileURL = function (url) {
        if (os.platform == 2)
            return url;
        var locahostURL = window.location.href;
        var newHead;
        // 如果是运行在测试的独立窗口中的游戏
        if (Config.INDIA_APPLICATION_GAME_INFO) {
            newHead = "";
        }
        else {
            // 位于GC的云储存中，如 http://material.gamecreator.com.cn/releaseProject/1509_982b3355f8538b169c0b4d617e93cfdb
            // 支持http/https的material或者global 
            var gcCloudHeadReg = /https{0,1}:\/\/(material|global)\.gamecreator\.com\.cn\//g;
            if (locahostURL.search(gcCloudHeadReg) == 0) {
                var projectSID = locahostURL.replace(gcCloudHeadReg, "").split("/")[1];
                if (projectSID && projectSID.search(/\d+_/g) != -1) {
                    newHead = projectSID + "/";
                }
                else {
                    newHead = locahostURL.split("?").shift() + "/" + (Config.gameSID ? Config.gameSID + "/" : "");
                }
            }
            else {
                newHead = locahostURL.split("?").shift() + "/" + (Config.gameSID ? Config.gameSID + "/" : "");
            }
        }
        if (url.indexOf(newHead) == 0) {
            return url;
        }
        return newHead + url;
    };
    /**
     * 加载档案文件(WEB端使用专有域)
     */
    SinglePlayerGame.loadSaveFile = function (url, complete, syncCallbackWhenAssetExist, useRef, onErrorTips) {
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        if (onErrorTips === void 0) { onErrorTips = true; }
        // PC端：直接读取文件
        if (os.platform == 2) {
            AssetManager.loadJson.apply(AssetManager, arguments);
        }
        // 非PC端
        else {
            url = SinglePlayerGame.toWebSaveFileURL(url);
            // 如果是独立窗口则直接读取文件
            var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
            if (indiaAppGameInfo) {
                // 获取已存在的资源时以防外部修改导致再次读档时数据错乱，此处使用克隆数据
                AssetManager.loadJson(url, Callback.New(function (jsonObj) {
                    complete.runWith([ObjectUtils.depthClone(jsonObj)]);
                }, this), syncCallbackWhenAssetExist, useRef, onErrorTips);
                return;
            }
            // 否则查询cookies
            if (IndexedDBManager.support && IndexedDBManager.used) {
                IndexedDBManager.getIndexDBJson(url, function (value) {
                    complete.delayRun(0, null, [value]);
                });
            }
            else {
                var saveData = LocalStorage.getJSON(url);
                complete.delayRun(0, null, [saveData]);
            }
        }
    };
    /**
     * 卸载档案文件(WEB端忽略)
     */
    SinglePlayerGame.disposeSaveFile = function (url, force) {
        if (force === void 0) { force = false; }
        if (os.platform == 2)
            AssetManager.disposeJson(url, force);
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    SinglePlayerGame.doLoadGame = function (index, onFin, onProgress, saveData) {
        var _this = this;
        if (onProgress === void 0) { onProgress = null; }
        if (!saveData) {
            onFin.runWith([false]);
            return;
        }
        // 清理当前的全部触发线：玩家的以及所有场景对象
        for (var i in Game.player.sceneObject.triggerLines) {
            var t = Game.player.sceneObject.triggerLines[i];
            t.dispose();
        }
        Game.player.sceneObject.triggerLines = {};
        Game.player.sceneObject.triggerSingleLines = {};
        GameCommand.inputTriggerLine = -1;
        GameCommand.cmdTriggerLines = {};
        if (Game.currentScene) {
            for (var s in Game.currentScene.sceneObjects) {
                var so = Game.currentScene.sceneObjects[s];
                if (so && so instanceof SceneObjectEntity) {
                    for (var i in so.triggerLines) {
                        var t = Game.player.sceneObject.triggerLines[i];
                        t.dispose();
                    }
                }
                so.triggerLines = {};
                so.triggerSingleLines = {};
            }
        }
        // 装载存档数据
        SinglePlayerGame.saveDateTime = saveData[1];
        var sceneID = saveData[2];
        var worldSaveData = saveData[3];
        var playerVarialbeData = saveData[4];
        var playerData = saveData[5];
        // 初始化玩家数据
        this.newGameInit(playerData.sceneObject);
        // 载入世界自定义数据（只要设定中存在的数据都会恢复覆盖掉，如果在游戏内修改了不在设定外的数据且游戏中实时读档才可能不会恢复）
        var attrs = CustomCompositeSetting.getAllAttributes(Game.data.customGameAttribute.worldAttributeSetting, false);
        CustomAttributeSetting.installAttributeFromRecordData(ClientWorld.data, worldSaveData, attrs, Game.data.customGameAttribute.worldAttributeConfig.attrs);
        // 载入玩家变量
        ObjectUtils.clone(playerVarialbeData, Game.player.variable);
        // 载入玩家基础数据和自定义数据（只要设定中存在的数据都会恢复覆盖掉，如果在游戏内修改了不在设定外的数据且游戏中实时读档才可能不会恢复）
        ObjectUtils.clone(playerData.sceneObject, Game.player.data.sceneObject);
        SceneObject.installCustomData(Game.player.data.sceneObject, Config.BORN.customAttribute);
        Player.installFilePlayerData(Game.player, playerData);
        // 载入玩家场景对象模块
        if (Config.useNewSceneObjectModel) {
            var playerSoModuleDatas = saveData[14];
            Game.player.data.sceneObject.___gcRestoreModules = playerSoModuleDatas;
        }
        // 对象开关
        SinglePlayerGame.sceneDatas = saveData[6];
        // 音频
        SinglePlayerGame.audioInfo = saveData[7];
        // 事件
        SinglePlayerGame.triggerLinesRecord = saveData[8];
        // 对象
        SinglePlayerGame.soDatas = saveData[9];
        // 图像系统+UI+GameCommand+对话框
        SinglePlayerGame.GameCommandData = saveData[10];
        // 场景状态
        SinglePlayerGame.sceneStatus = saveData[11];
        // 自定义数据
        var packageCustomData = saveData[12];
        // 兼容旧的档案
        if (packageCustomData == null || !packageCustomData["___useNewCustomData"]) {
            // 旧档案，直接就是该数据
            var customData = packageCustomData;
        }
        else {
            this.currentSaveFileCustomData = packageCustomData;
            customData = packageCustomData.___customData;
        }
        // 需要额外预加载的界面（ID集）
        var needLoadUIs = saveData[13];
        if (!needLoadUIs)
            needLoadUIs = [];
        // 预加载资源异步任务
        var preLoadTask = new AsynTask(Callback.New(function () {
            // 游戏时间戳
            var gameSaveData = saveData[0];
            Game.recoverySaveData(gameSaveData);
            EventUtils.happen(ClientScene, ClientScene.EVENT_IN_NEW_SCENE, [sceneID, 2]);
            onFin.runWith([true, customData]);
        }, this));
        // 预加载资源
        AssetManager.batchPreLoadAsset(Callback.New(function () {
            preLoadTask.execute(1);
            // 当前场景中克隆来源来自其他场景，则需要预先加载这些来源的场景
            // 自动释放，不占引用
            for (var i = 0; i < SinglePlayerGame.soDatas.length; i++) {
                var recordSo = SinglePlayerGame.soDatas[i].so;
                var copyFrom = recordSo["_copyFrom"];
                if (copyFrom) {
                    preLoadTask.execute(1);
                    Game.data.loadScene(copyFrom.sceneID, Callback.New(function () {
                        preLoadTask.complete();
                    }, _this));
                }
            }
            preLoadTask.complete();
        }, this), onProgress, [], [], [], [], [], needLoadUIs, [], [], [], false, true);
    };
    /**
     * 获取全存档信息，返回全部存档信息
     * @return 格式：
     *       id = 存档的唯一编号，如[1,3,61] 表示存档了1号、3号、61号文件
     *       now = 存档时unix时间戳
     *       indexInfo = 自定义信息（比如存放地图名称，方便档案列表中玩家可以快速识别）
     */
    SinglePlayerGame.getSaveInfo = function () {
        return SinglePlayerGame.saveIDs.concat();
    };
    /**
     * 获取指定存档信息
     * @param 指定的存档信息（目录中的简单信息），null 表示无该存档
     */
    SinglePlayerGame.getSaveInfoByID = function (id) {
        return ArrayUtils.matchAttributes(SinglePlayerGame.saveIDs, { id: id }, true)[0];
    };
    /**
     * 获取存档的全局数据，即saveGame的参数globalData储存的值
     */
    SinglePlayerGame.getGlobalData = function () {
        return this.globalData;
    };
    /**
     * 删除全局数据
     * @param onFin 是否删除成功 onFin(success:boolean)
     */
    SinglePlayerGame.deleteGlobalData = function (onFin) {
        if (onFin === void 0) { onFin = null; }
        new SyncTask(SinglePlayerGame.TASK_MODIFY_FILE, function () {
            var saveGameFin = Callback.New(function (success) {
                onFin && onFin.runWith([success]);
                SyncTask.taskOver(SinglePlayerGame.TASK_MODIFY_FILE);
            }, this);
            FileUtils.deleteFile(SinglePlayerGame.GC_LIFE_DATA_PATH, saveGameFin);
        });
    };
    /**
     * 删除存档
     * @param onFin 回调是否删除成功 onFin(success:boolean)
     */
    SinglePlayerGame.delSaveFile = function (index, onFin) {
        new SyncTask(SinglePlayerGame.TASK_MODIFY_FILE, function () {
            var _this = this;
            var saveGameFin = Callback.New(function (success) {
                onFin && onFin.runWith([success]);
                SyncTask.taskOver(SinglePlayerGame.TASK_MODIFY_FILE);
            }, this);
            // 不存在存档的话忽略
            var idx = ArrayUtils.matchAttributes(SinglePlayerGame.saveIDs, { id: index }, true, "==", true)[0];
            if (idx == null) {
                saveGameFin && saveGameFin.runWith([false]);
                return;
            }
            SinglePlayerGame.saveIDs.splice(idx, 1);
            var urlBak = SinglePlayerGame.toWebSaveFileURL("savedata/gamedata" + index + ".gcdatabak");
            var url = SinglePlayerGame.toWebSaveFileURL("savedata/gamedata" + index + ".gcdata");
            // 清理掉相关的BAK文件
            FileUtils.deleteFile(urlBak, Callback.New(function (success) {
                FileUtils.deleteFile(url, Callback.New(function (success) {
                    SinglePlayerGame.saveLifeData(saveGameFin, SinglePlayerGame.globalData, true, false);
                }, _this));
            }, this));
        });
    };
    /**
     * 同步场景开关数据
     * @param saveExtraObjects [可选] 默认值=false 保存额外的场景对象，比如存档时应当保存当前场景的这些开关对象
     */
    SinglePlayerGame.recordSceneObjectSwitch = function (saveExtraObjects) {
        if (saveExtraObjects === void 0) { saveExtraObjects = false; }
        if (!Game.currentScene || Game.currentScene == ClientScene.EMPTY)
            return;
        var sceneData = Game.data.sceneList.data[Game.currentScene.id];
        var switchs = [];
        for (var i = 0; i < sceneData.sceneObjectData.sceneObjects.length; i++) {
            var soData = sceneData.sceneObjectData.sceneObjects[i];
            if (!soData || soData.isBorn)
                continue;
            var so = Game.currentScene.sceneObjects[i];
            if (so)
                switchs[i] = so["switchs"];
        }
        this.sceneDatas[Game.currentScene.id] = { sceneObjectSwitchs: switchs };
    };
    /**
     * 获取对象开关，一般用于更换场景后安装对象的开关
     * @param sceneID 场景ID
     * @param soIndex 对象ID
     * @return [number]
     */
    SinglePlayerGame.getSceneObjectSwitch = function (sceneID, soIndex) {
        var sceneData = this.sceneDatas[Game.currentScene.id];
        if (!sceneData)
            return null;
        return sceneData.sceneObjectSwitchs[soIndex];
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 请求触发事件
     * @param player 玩家
     * @param type 0-新事件 1-继续执行事件 2-主动调用公共事件（多线模式）
     * @param mainType
     * @param indexType
     * @param params 场景对象:[evIndex,playerInput,onReturnID]  UI:[id,playerInput,onReturnID]
     */
    SinglePlayerGame.triggerEvent = function (type, mainType, indexType, params, triggerSceneObjectIndex, executorSceneObjectIndex) {
        if (triggerSceneObjectIndex === void 0) { triggerSceneObjectIndex = null; }
        if (executorSceneObjectIndex === void 0) { executorSceneObjectIndex = null; }
        if (!Game.currentScene)
            return;
        if (params.length < 1)
            return;
        var onReturnID = params[2];
        // 新事件（主动调用公共事件除外）
        if (type == 0) {
            SinglePlayerGame.startTriggerCommandV2(mainType, indexType, params, onReturnID != 0 ? Callback.New(function (onReturnID, trigger) {
                EventUtils.addEventListener(trigger, CommandTrigger.EVENT_OVER, Callback.New(ClientMsgSender.cmdReturn, ClientMsgSender, [onReturnID]), true);
            }, this, [onReturnID]) : null, triggerSceneObjectIndex, executorSceneObjectIndex);
            return;
        }
        var commandID = params[0];
        var playerInput = params[1];
        if (playerInput == null)
            playerInput = [];
        switch (type) {
            // 1-继续执行事件：允许提交
            case 1:
                // 优先查找自身的触发器
                var trigger = Game.player.sceneObject.triggerLines[commandID];
                if (trigger) {
                    CommandPage.executeEvent(trigger, playerInput);
                }
                // 查询其他场景对象身上的触发器：因为单机版只有一个玩家可用于输入的
                else {
                    var len = Game.currentScene.sceneObjects.length;
                    for (var i = 0; i < len; i++) {
                        var targetSo = Game.currentScene.sceneObjects[i];
                        if (!targetSo)
                            continue;
                        trigger = targetSo.triggerLines[commandID];
                        if (trigger) {
                            CommandPage.executeEvent(trigger, playerInput);
                            break;
                        }
                    }
                }
                break;
            // 2-调用独立公共事件
            case 2:
                var commonEvCmd = ClientWorld.commonEventPages[commandID];
                if (commonEvCmd) {
                    // 获取触发事件者
                    var triggerSceneObject = null;
                    if (triggerSceneObjectIndex != null) {
                        triggerSceneObject = Game.currentScene.sceneObjects[triggerSceneObjectIndex];
                    }
                    if (triggerSceneObject == null)
                        triggerSceneObject = Game.player.sceneObject;
                    // 获取执行事件者
                    var executorSceneObject = null;
                    if (executorSceneObjectIndex != null) {
                        executorSceneObject = Game.currentScene.sceneObjects[executorSceneObjectIndex];
                    }
                    if (executorSceneObject == null)
                        executorSceneObject = Game.player.sceneObject;
                    // 获取触发器
                    var trigger_1 = new CommandTrigger(CommandTrigger.COMMAND_MAIN_TYPE_CALL_COMMON_EVENT, commandID, Game.currentScene, triggerSceneObject, true, executorSceneObject);
                    // 监听完成事件
                    if (onReturnID != 0 && trigger_1)
                        EventUtils.addEventListener(trigger_1, CommandTrigger.EVENT_OVER, Callback.New(ClientMsgSender.cmdReturn, ClientMsgSender, [onReturnID]), true);
                    // 开始触发独立公共事件
                    commonEvCmd.startTriggerEvent(trigger_1, playerInput);
                }
                break;
        }
    };
    SinglePlayerGame.startTriggerCommandV2 = function (mainType, indexType, params, onTriggerCreated, triggerSceneObjectIndex, executorSceneObjectIndex) {
        if (triggerSceneObjectIndex === void 0) { triggerSceneObjectIndex = null; }
        if (executorSceneObjectIndex === void 0) { executorSceneObjectIndex = null; }
        var scene = Game.currentScene;
        if (!scene || indexType < 0)
            return;
        if (params.length < 1)
            return;
        var commandID = params[0];
        var playerInput = params[1];
        if (playerInput == null)
            playerInput = [];
        switch (mainType) {
            // 场景事件：触发者和执行者都是玩家的场景对象
            case CommandTrigger.COMMAND_MAIN_TYPE_SCENE:
                // @ts-ignore
                var cmdPage = scene.customCommandPages[indexType];
                if (cmdPage) {
                    var trigger = Game.player.sceneObject.getCommandTrigger(mainType, indexType, scene, Game.player.sceneObject);
                    if (trigger) {
                        onTriggerCreated && onTriggerCreated.runWith([trigger]);
                        cmdPage.startTriggerEvent(trigger, playerInput);
                    }
                    return trigger;
                }
                break;
            // 场景对象事件：触发者和执行者根据triggerSceneObjectIndex/executorSceneObjectIndex
            case CommandTrigger.COMMAND_MAIN_TYPE_SCENE_OBJECT:
                if (commandID < 0)
                    return;
                var so = scene.sceneObjects[commandID];
                if (so) {
                    // 确定触发事件者
                    var triggerSceneObject = Game.player.sceneObject;
                    if (triggerSceneObjectIndex != null) {
                        triggerSceneObject = scene.sceneObjects[triggerSceneObjectIndex];
                    }
                    // 获取触发器
                    var trigger_2 = triggerSceneObject.getCommandTrigger(mainType, indexType, scene, so);
                    if (trigger_2) {
                        onTriggerCreated && onTriggerCreated.runWith([trigger_2]);
                        var cmdPage_1 = so.customCommandPages[indexType];
                        if (cmdPage_1) {
                            cmdPage_1.startTriggerEvent(trigger_2, playerInput);
                            return trigger_2;
                        }
                    }
                }
                break;
            // UI事件：触发者和执行者都是玩家的场景对象
            case CommandTrigger.COMMAND_MAIN_TYPE_UI:
                var commands = ClientWorld.uiCustomCommandPages[commandID];
                if (commands) {
                    var cmdPage_2 = commands[indexType];
                    if (cmdPage_2) {
                        var trigger = Game.player.sceneObject.getCommandTrigger(mainType, indexType, scene, Game.player.sceneObject, commandID);
                        if (trigger) {
                            onTriggerCreated && onTriggerCreated.runWith([trigger]);
                            cmdPage_2.startTriggerEvent(trigger, playerInput);
                        }
                        return trigger;
                    }
                }
                break;
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------
    /**
     * 内核初始化
     * @param onFin
     */
    SinglePlayerGame.initMain = function (onFin) {
        ClientMain.prototype.startLogin = function (onLoginSuccess) {
            onLoginSuccess && onLoginSuccess.run();
        };
    };
    /**
     * 初始化公共事件
     * @param onFin
     */
    SinglePlayerGame.initCommands = function (onFin) {
        var task = new AsynTask(onFin);
        task.execute("commonEvent");
        ClientWorld.commonEventPages = [];
        Game.data.loadCommonEventList(Callback.New(function () {
            var wsList = Game.data.commonEventList.data;
            for (var i in wsList) {
                var scriptData = wsList[i];
                var ws = new CommandPage(scriptData.commands);
                ClientWorld.commonEventPages[i] = ws;
            }
            task.complete();
            Game.data.commonEventList = null;
        }, this));
    };
    //------------------------------------------------------------------------------------------------------
    // 恢复存档数据
    //------------------------------------------------------------------------------------------------------
    /**
     * 恢复存档数据，一般以读档形式进入场景后恢复数据，包含：
     * -- 所有对象的属性和行为（进行到一半的行为会接着继续执行）
     * -- 所有图像系统的图片、立绘、动画的状态，正在执行中的任务也会得到恢复继续中途继续执行
     * -- 所有正在执行的事件会恢复中途继续执行
     * -- 所有已打开的界面和层次
     * -- 恢复之前正在播放的BGM和BGS（背景音乐、场景音效）
     * -- 恢复之前的场景雾效果、色调、镜头状态
     */
    SinglePlayerGame.recoveryData = function () {
        EventUtils.happen(SinglePlayerGame, SinglePlayerGame.EVENT_ON_BEFORE_RECOVERY_DATA);
        // 图像系统
        SinglePlayerGame.recoveryGameImage();
        // 场景对象
        SinglePlayerGame.recoveryCurrentSceneObject();
        // 场景状态
        SinglePlayerGame.recoverySceneStatusData();
        // 事件
        SinglePlayerGame.recoveryTriggerEventSaveDataAndBehaviors();
        EventUtils.happen(SinglePlayerGame, SinglePlayerGame.EVENT_ON_AFTER_RECOVERY_DATA);
    };
    //------------------------------------------------------------------------------------------------------
    // 储存和恢复除玩家外的场景对象（仅限于当前场景）
    //------------------------------------------------------------------------------------------------------
    SinglePlayerGame.getCurrentSceneObject = function () {
        var soDatas = [];
        for (var i = 0; i < Game.currentScene.sceneObjects.length; i++) {
            var so = Game.currentScene.sceneObjects[i];
            if (!so)
                continue;
            // 同步avatar属性
            so.syncAvatarStateToSceneObject();
            // 创建数据
            var soData = new SceneObject();
            // 基础属性
            ObjectUtils.cloneExcludeNonExistentAttribute(so, soData);
            // 自定义属性
            var modelData = Common.sceneObjectModelList.data[soData.modelID];
            if (modelData) {
                if (Config.useNewSceneObjectModel) {
                    var fixModelData = Common.sceneObjectModelList.data[0];
                }
                else {
                    fixModelData = modelData;
                }
                for (var s = 0; s < fixModelData.varAttributes.length; s++) {
                    var attr = fixModelData.varAttributes[s];
                    soData[attr.varName] = so[attr.varName];
                }
            }
            // 对象的行为
            var behaviors = so.getBehaviors();
            var behaviorDatas = [];
            if (behaviors) {
                for (var s = 0; s < behaviors.length; s++) {
                    behaviorDatas.push(behaviors[s].getSaveData());
                }
            }
            // 追加储存是否克隆状态
            soData["_isCopy"] = so.isCopy;
            // 追加储存克隆来源
            soData["_copyFrom"] = so._copyFrom;
            soData["allowAutoSave"] = so.allowAutoSave;
            // -- 玩家场景对象的模块数据
            var soModuleDatas = null;
            if (Config.useNewSceneObjectModel) {
                soModuleDatas = SceneObjectEntity.getModulesSaveData(so);
                soData.moduleIDs = so.moduleIDs ? so.moduleIDs.concat() : [];
            }
            soDatas.push({ so: soData, behaviorDatas: behaviorDatas, moduleDatas: soModuleDatas });
        }
        return soDatas;
    };
    /**
     * 恢复场景对象
     */
    SinglePlayerGame.recoveryCurrentSceneObject = function () {
        // 当前预设的NPC
        var presetSceneObjects = Game.currentScene.getPresetSceneObjectDatas();
        // 恢复场景对象数据
        var soDatas = SinglePlayerGame.soDatas;
        for (var i = 0; i < soDatas.length; i++) {
            var soData = soDatas[i];
            var copyFrom = soData.so["_copyFrom"];
            var soc;
            var modelData;
            // 预设的场景对象数据
            var presetSceneObjectData;
            var fromSceneID = Game.currentScene.id;
            var fromSceneObjectindex = soData.so.index;
            // 对象开关
            var soSwitchs = SinglePlayerGame.getSceneObjectSwitch(Game.currentScene.id, soData.so.index);
            // 存在复制来源的话
            if (copyFrom) {
                var sceneData = Game.data.sceneList.data[copyFrom.sceneID];
                // 如果不存在该场景的话则表示已被删除
                if (sceneData) {
                    presetSceneObjectData = sceneData.sceneObjectData.sceneObjects[copyFrom.sceneObjectIndex];
                    if (presetSceneObjectData) {
                        fromSceneID = copyFrom.sceneID;
                        fromSceneObjectindex = copyFrom.sceneObjectIndex;
                    }
                }
            }
            // 新建的场景对象
            else if (soData.so["allowAutoSave"]) {
                if (Config.useNewSceneObjectModel) {
                    SceneObjectEntity.recoveryModulesData[soData.so.index] = { needCheckModulesCustomAttributes: false, presetData: soData.moduleDatas };
                }
                soc = Game.currentScene.addNewSceneObject(soData.so.modelID, null, soSwitchs, soData.so);
                // if (Config.useNewSceneObjectModel) {
                //     recoveryCurrentSceneObjectModules(soc, null, soData.moduleDatas);
                // }
                continue;
            }
            // 不存在复制来源的话则视为当前的场景
            else {
                presetSceneObjectData = presetSceneObjects[soData.so.index];
            }
            if (soData.so.index == Game.player.sceneObject.index)
                continue;
            // 对象开关
            var soSwitchs = SinglePlayerGame.getSceneObjectSwitch(Game.currentScene.id, soData.so.index);
            // 如若不存在的话：由于复制源已经删掉了，这里就不再创建了
            if (!presetSceneObjectData) {
                continue;
            }
            // 找得到预设的对象，将数据恢复到预设的对象中即可
            // * 该对象未必是原预设的对象，此处以后可以再处理，如何决定该对象已经不是该对象了
            else {
                // -- 记录需要恢复的模块数据，以便创建对象时进行恢复
                if (Config.useNewSceneObjectModel) {
                    var sceneData = Game.data.sceneList.data[Game.currentScene.id];
                    // var sceneObjDatas = sceneData.sceneObjectData;
                    // if (soc.currentStatusPageIndex == 0) {
                    //     var modulesCustomAttributes = sceneObjDatas.modulesCustomAttributes[soc.index];
                    // }
                    // else {
                    //     var stps = sceneObjDatas.statusPages[soc.index];
                    //     if (stps) {
                    //         var stp = stps[soc.currentStatusPageIndex - 1];
                    //         modulesCustomAttributes = stp.modulesCustomAttribute;
                    //     }
                    // }
                    SceneObjectEntity.recoveryModulesData[soData.so.index] = { needCheckModulesCustomAttributes: true, presetData: soData.moduleDatas };
                    // recoveryCurrentSceneObjectModules(soc, modulesCustomAttributes, soData.moduleDatas);
                }
                // 添加对象，传入自定义数据进去恢复
                soc = Game.currentScene.addSceneObjectFromClone(fromSceneID, fromSceneObjectindex, soData.so['_isCopy'], null, soSwitchs, soData.so);
                // -- 恢复模块数据
                // if (Config.useNewSceneObjectModel) {
                //     var sceneData: SceneData = Game.data.sceneList.data[Game.currentScene.id];
                //     var sceneObjDatas = sceneData.sceneObjectData;
                //     if (soc.currentStatusPageIndex == 0) {
                //         var modulesCustomAttributes = sceneObjDatas.modulesCustomAttributes[soc.index];
                //     }
                //     else {
                //         var stps = sceneObjDatas.statusPages[soc.index];
                //         if (stps) {
                //             var stp = stps[soc.currentStatusPageIndex - 1];
                //             modulesCustomAttributes = stp.modulesCustomAttribute;
                //         }
                //     }
                //     recoveryCurrentSceneObjectModules(soc, modulesCustomAttributes, soData.moduleDatas);
                // }
            }
            // 恢复模块
            // // 恢复存档数据
            // if (soc.inScene) {
            //     // -- 基础数据
            //     for (var s in SceneObject.self) {
            //         soc[s] = soData.so[s];
            //     }
            //     // -- 自定义
            //     modelData = Common.sceneObjectModelList.data[soc.modelID];
            //     if (modelData) {
            //         // 不存在预设的情况恢复的自定义
            //         if (!presetSceneObjectData) {
            //             // 安装自定义模型数据，以便得到自定义数据的最初默认值
            //             var formatCustomData = CustomAttributeSetting.formatCustomData(null, modelData.varAttributes);
            //             SceneObject.installCustomData(soc, formatCustomData);
            //             // 在这种情况下仅供配置的属性应当来自存档，否则不正确（比如该对象来自某克隆源，该源的xx值设置为3，而模型默认值是1）
            //             for (var s in modelData.varAttributes) {
            //                 var attrSetting = modelData.varAttributes[s];
            //                 if (attrSetting.onlyConfig) {
            //                     soc[attrSetting.varName] = soData.so[attrSetting.varName];
            //                 }
            //             }
            //         }
            //         // 安装来自存档的数据
            //         CustomAttributeSetting.installAttributeFromRecordData(soc, soData.so, modelData.varAttributes, null, 3);
            //     }
            // }
        }
        function recoveryCurrentSceneObjectModules(soc, modulesCustomAttribute, presetData) {
            if (!Config.useNewSceneObjectModel)
                return;
            var moduleIDs = soc.moduleIDs.concat();
            var moduleDisplayList = soc.moduleDisplayList.concat();
            // 没有的话使用默认值
            if (!modulesCustomAttribute) {
                modulesCustomAttribute = [];
                for (var i = 0; i < moduleIDs.length; i++) {
                    var moduleID = moduleIDs[i];
                    var moduleData = Game.data.sceneObjectModuleList.data[moduleID];
                    if (!moduleData) {
                        moduleIDs.splice(i, 1);
                        moduleDisplayList.splice(i, 1);
                        i--;
                    }
                    modulesCustomAttribute.push(CustomAttributeSetting.formatCustomData(null, moduleData.varAttributes));
                }
            }
            soc.installModulesByTypeValue(moduleIDs, moduleDisplayList, modulesCustomAttribute, presetData);
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 储存和恢复图像系统以及界面
    //------------------------------------------------------------------------------------------------------
    SinglePlayerGame.getGameCommandData = function () {
        var o = [];
        // 记录GameCommon的命令触发线集合，已执行的命令，但正在排队等待玩家输入的记录集
        o[0] = GameCommand.getSaveData();
        // 记录图像系统+UI+对话框（来源于事件或者图像系统（需要监听完成情况））
        o[1] = GameImage.getSaveData();
        return o;
    };
    SinglePlayerGame.recoveryGameImage = function () {
        var o = SinglePlayerGame.GameCommandData[1];
        GameImage.recoverySaveData(o);
    };
    //------------------------------------------------------------------------------------------------------
    // 储存和恢复场景状态
    //------------------------------------------------------------------------------------------------------
    SinglePlayerGame.getSceneStatusData = function () {
        // 镜头、雾气、色调
        var o = {};
        o.camera = Game.currentScene.camera.getSaveData();
        o.fog = Game.currentScene.fogLayer.getSaveData();
        o.tonal = Game.currentScene.displayObject.getTonal();
        return o;
    };
    SinglePlayerGame.recoverySceneStatusData = function () {
        var o = SinglePlayerGame.sceneStatus;
        Game.currentScene.camera.recoverySaveData(o.camera);
        Game.currentScene.fogLayer.recoverySaveData(o.fog);
        var t = o.tonal;
        Game.currentScene.displayObject.setTonal(t[0], t[1], t[2], t[3], t[4], t[5], t[6]);
        // 音频恢复
        var a = SinglePlayerGame.audioInfo;
        if (SinglePlayerGame.saveConfig.audioVolume) {
            GameAudio.bgmVolume = a[6];
            GameAudio.bgsVolume = a[7];
            GameAudio.seVolume = a[8];
            if (a[9] != null) {
                GameAudio.tsVolume = a[9];
            }
        }
        if (SinglePlayerGame.saveConfig.bgm) {
            GameAudio.playBGM(a[0], a[2], 99999, true, 500, a[1]);
        }
        if (SinglePlayerGame.saveConfig.bgs) {
            GameAudio.playBGS(a[3], a[5], 99999, true, 500, a[4]);
        }
    };
    //------------------------------------------------------------------------------------------------------
    // 关于储存和恢复事件、行为、图像、GameCommand的数据
    // 【关于事件】
    //   -- 只有正在执行的事件才会保存：isExecuteing
    //   -- 事件只有遇到pause时才会存在进行到一半的事件，如系统事件：对话、选项、等待、等待玩家输入、等待行为结束、等待图像结束、图像包含对话
    //      -- 等待：触发器唯一等待计时器，恢复后会从中途开始
    //      -- 对话、选项、存在对话的图像系统、等待玩家输入：
    //      -- 等待行为结束：还原行为后同时对应的触发器开始监听派发出去的行为
    //      -- 等待图像结束：【还原图像】
    //      -- 除选项外都已经偏移了index，也就是说恢复时直接执行下一行事件了（有等待计时的则需要等待才执行）
    //      -- 可以自定义设定pause事件以及决定偏移
    //   -- 由于之前派发出去的命令可能需要等待玩家输入之类的，需要还原现场
    // 【关于行为】
    //   -- 恢复全部对象的所有层行为,以及每层
    //   -- *当对象需要移动A-B-C时，移动到A-B时存档后，未到达B这个格子，而仍然属于A，然后继续向前移动则是B而非C了
    //------------------------------------------------------------------------------------------------------
    /**
     * 获取当前触发事件的数据:全场景对象的身上正在执行的触发器
     *    -- 除选项外都已经偏移了index，也就是说恢复时直接执行下一行事件了（有等待计时的则需要等待才执行）
     * @return [any]
     */
    SinglePlayerGame.getTriggerEventSaveData = function () {
        // 这里获取了当前场景下所有玩家的触发器，因为其他场景对象身上可能也带有触发器
        var triggerLines = [];
        var needLoadUIs = [];
        if (SinglePlayerGame.saveConfig.event) {
            for (var s = 0; s < Game.currentScene.sceneObjects.length; s++) {
                var so = Game.currentScene.sceneObjects[s];
                if (!so)
                    continue;
                for (var i in so.triggerLines) {
                    var trigger = so.triggerLines[i];
                    if (!trigger.isExecuteing)
                        continue;
                    // 如果是界面事件的话还需要预加载界面支持，因为可能该界面存档时已经被关闭了
                    if (trigger.mainType == CommandTrigger.COMMAND_MAIN_TYPE_UI && typeof trigger.from == "string") {
                        var uiID = MathUtils.int(trigger.from.split("_")[0]);
                        needLoadUIs.push(uiID);
                    }
                    triggerLines.push(trigger.getSaveData());
                }
            }
        }
        return [triggerLines, needLoadUIs];
    };
    /**
     * 恢复触发事件的
     */
    SinglePlayerGame.recoveryTriggerEventSaveDataAndBehaviors = function () {
        // 仅视为CommandTrigger格式
        var now = new Date().getTime();
        var intervalTime = now - SinglePlayerGame.saveDateTime;
        var triggerLines = SinglePlayerGame.triggerLinesRecord;
        var allTriggers = [];
        // 触发事件
        for (var i = 0; i < triggerLines.length; i++) {
            var o = triggerLines[i];
            // 查询对应的事件触发类别，存在的话则继续
            var executor = Game.currentScene.sceneObjects[o.executor];
            if (!executor)
                continue;
            var trigger = Game.currentScene.sceneObjects[o.trigger];
            if (!trigger)
                continue;
            if (executor) {
                // o.from 是在界面的触发器需要，用于创建trigger标识
                var cmdTrigger = trigger.getCommandTrigger(o.mainType, o.indexType, Game.currentScene, executor, o.from);
                if (cmdTrigger) {
                    var recoverySuccess = cmdTrigger.recoverySaveData(o, Game.currentScene, ClientWorld.commonEventPages, intervalTime);
                    if (recoverySuccess) {
                        allTriggers.push({ trigger: cmdTrigger, data: o });
                    }
                }
            }
        }
        // 还原GameCommand，需要替换inputTriggerLine
        var GameCommandData = SinglePlayerGame.GameCommandData[0];
        // 查询是否有正在输入的触发线
        var inputTriggerLine = GameCommandData[2];
        var m = ArrayUtils.matchAttributesD2(allTriggers, "data", { id: inputTriggerLine }, true);
        if (m.length == 1) {
            GameCommand.inputTriggerLine = m[0].trigger.id;
            GameCommand.isNeedPlayerInput = GameCommandData[1];
        }
        // 还原触发线，将GameCommand中缓存的排队函数还原触发线，以便读档后能够提交成功
        var cmdTriggerLines = GameCommandData[0];
        for (var triggerLineID in cmdTriggerLines) {
            var m = ArrayUtils.matchAttributesD2(allTriggers, "data", { id: triggerLineID }, true);
            if (m.length == 1) {
                var newTriggerLineID = m[0].trigger.id;
                var funcsData = cmdTriggerLines[triggerLineID].funcs;
                var newFuncs = [];
                for (var i = 0; i < funcsData.length; i++) {
                    var newFunc = funcsData[i];
                    newFunc[1][0] = newTriggerLineID;
                    var spoceType = newFunc[2];
                    var gameFuncName = newFunc[3];
                    var executeFunction;
                    if (spoceType == 0) {
                        executeFunction = GameFunction[gameFuncName];
                    }
                    else {
                        executeFunction = CommandExecuteGame[gameFuncName];
                    }
                    newFunc.unshift(executeFunction);
                    newFuncs.push(newFunc);
                }
                GameCommand.cmdTriggerLines[newTriggerLineID] = { stop: cmdTriggerLines[triggerLineID].stop, funcs: newFuncs };
            }
        }
        // 替换图像系统中图像所有记录中的group的触发线
        var GameImageData = SinglePlayerGame.GameCommandData[1];
        if (GameImageData.executeGroups) {
            for (var i = 0; i < GameImageData.executeGroups.length; i++) {
                var groupData = GameImageData.executeGroups[i];
                if (!groupData)
                    continue;
                var oldGroupTriggerLineID = groupData.triggerLineID;
                var m = ArrayUtils.matchAttributesD2(allTriggers, "data", { id: oldGroupTriggerLineID }, true);
                if (m.length == 1) {
                    groupData.triggerLineID = m[0].trigger.id;
                    // 找到
                    if (groupData.gameImageGroup) {
                        groupData.gameImageGroup.triggerLineID = groupData.triggerLineID;
                        delete groupData.gameImageGroup;
                    }
                    // trace("替换图像系统触发线--->", oldGroupTriggerLineID, groupData.triggerLineID)
                }
            }
        }
        // 替换图像系统中正在监听等待完成的触发线
        if (GameImageData.listeningWaitImagePlayOvers) {
            for (var i = 0; i < GameImageData.listeningWaitImagePlayOvers.length; i++) {
                var oldListenerWaitOverTriggerLineID = GameImageData.listeningWaitImagePlayOvers[i];
                var m = ArrayUtils.matchAttributesD2(allTriggers, "data", { id: oldListenerWaitOverTriggerLineID }, true);
                if (m.length == 1) {
                    GameImageData.listeningWaitImagePlayOvers[i] = m[0].trigger.id;
                    // trace("替换等待图像系统触发线--->", oldListenerWaitOverTriggerLineID, m[0].trigger.id)
                }
            }
        }
        // 恢复行为：由于事件中可能关联了行为（监听了行为）
        var soDatas = SinglePlayerGame.soDatas;
        for (var i = 0; i < soDatas.length; i++) {
            var soData = soDatas[i];
            var soc = Game.currentScene.sceneObjects[soData.so.index];
            if (!soc)
                continue;
            var soBehaviorDataArr = soData.behaviorDatas;
            if (!soBehaviorDataArr)
                continue;
            for (var beLayer = 0; beLayer < soBehaviorDataArr.length; beLayer++) {
                var behaviorDataX = soBehaviorDataArr[beLayer];
                var soBehaviorData = behaviorDataX[0];
                var behaviorIndex = behaviorDataX[1];
                var loop = behaviorDataX[2];
                var delayFrame = behaviorDataX[3];
                if (delayFrame == null)
                    delayFrame = 0;
                var targetSceneObjectIndex = behaviorDataX[4];
                var executorIndex = behaviorDataX[5];
                var fromTrigger = targetSceneObjectIndex == -1 || targetSceneObjectIndex == null ? Game.player.sceneObject : Game.currentScene.sceneObjects[targetSceneObjectIndex];
                var fromExecutor = executorIndex == -1 || executorIndex == null ? Game.player.sceneObject : Game.currentScene.sceneObjects[executorIndex];
                // 查询是否来源于触发事件，是的话则由触发事件派发行为
                var behaviorfromTrigger = false;
                for (var s = 0; s < allTriggers.length; s++) {
                    var triggerData = allTriggers[s];
                    var n = ArrayUtils.matchAttributes(triggerData.data.behaviors, { soIndex: soc.index, behaviorIndex: beLayer }, true);
                    if (n.length > 0) {
                        behaviorfromTrigger = true;
                        triggerData.trigger.addBehavior(soc, soBehaviorData, loop, fromTrigger, false, behaviorIndex, false, false, delayFrame, fromExecutor);
                        break;
                    }
                }
                // 如果不来源于触发事件则普通的追加行为
                if (!behaviorfromTrigger) {
                    soc.addBehavior(soBehaviorData, loop, fromTrigger, null, false, behaviorIndex, false, false, delayFrame, fromExecutor);
                }
            }
        }
        // 恢复事件执行：需要等上面的都恢复后再启动
        for (var s = 0; s < allTriggers.length; s++) {
            // @ts-ignore
            var cmdTrigger = allTriggers[s].trigger;
            EventUtils.happen(SinglePlayerGame, SinglePlayerGame.EVENT_RECOVER_TRIGGER, [cmdTrigger]);
            cmdTrigger.recovery();
        }
        SinglePlayerGame.triggerLinesRecord = null;
    };
    /**
     * 事件：读档后恢复的事件触发线
     * EventUtils.addEventListener(SinglePlayerGame,SinglePlayerGame.EVENT_RECOVER_TRIGGER,Callback.New((trigger:CommandTrigger)=>{
     *    // to do
     * },this));
     */
    SinglePlayerGame.EVENT_RECOVER_TRIGGER = "SinglePlayerGameEVENT_RECOVER_TRIGGER";
    /**
     * 事件：调用recoveryData前派发
     */
    SinglePlayerGame.EVENT_ON_BEFORE_RECOVERY_DATA = "SinglePlayerGameEVENT_BEFORE_RECOVER_DATA";
    /**
     * 事件：调用recoveryData后派发
     */
    SinglePlayerGame.EVENT_ON_AFTER_RECOVERY_DATA = "SinglePlayerGameEVENT_ON_AFTER_RECOVER_DATA";
    /**
     * 旧设定，配置项
     */
    SinglePlayerGame.fileSaveConfig = {
        // 界面：存档时记录当前已打开的界面，在读档时会打开这些界面
        ui: true,
        // 界面组件：存档时记录当前已打开的界面组件当前的属性值
        uiComp: true,
    };
    /**
     * 用户可设定的存档配置 以后新增的话可以判断NULL
     */
    SinglePlayerGame.saveConfig = {
        // 事件：存档时记录当前正在执行的事件，在读档时会恢复
        event: true,
        // 全局音量：BGM/BGS/SE/TS 音量
        audioVolume: true,
        // 当前正在播放的BGM
        bgm: true,
        // 当前正在播放的BGS
        bgs: true
    };
    /**
     * 记录场景对象的开关
     * [sceneID] = [index][switchIndex]
     */
    SinglePlayerGame.sceneDatas = [];
    /**
     * 记录场景的页面
     */
    SinglePlayerGame.customCommandsCache = [];
    /**
     * 存档TASK
     */
    SinglePlayerGame.TASK_MODIFY_FILE = "__SinglePlayerGame__TASK_MODIFY_FILE";
    //------------------------------------------------------------------------------------------------------
    // 自定义存档数据的储存和读取
    //------------------------------------------------------------------------------------------------------
    /**
     * 已注册的与存档绑定的自定义数据获取函数
     */
    SinglePlayerGame.regSaveCustomDataCallbacks = [];
    /**
     * 已注册的与游戏绑定的自定义全局数据获取函数
     */
    SinglePlayerGame.regSaveCustomGlobalDataCallbacks = [];
    return SinglePlayerGame;
}());
/**
 * Created by JayLen on 2021-12-06 11:48:00.
 */
var GCPolyfill = /** @class */ (function () {
    function GCPolyfill() {
    }
    GCPolyfill.init = function () {
        // 游戏渲染
        var minFilters = ["LINEAR", "NEAREST", "NEAREST_MIPMAP_NEAREST", "LINEAR_MIPMAP_NEAREST", "NEAREST_MIPMAP_LINEAR", "LINEAR_MIPMAP_LINEAR"];
        var magFilters = ["LINEAR", "NEAREST"];
        var oldTexParameteri = WebGLRenderingContext.prototype.texParameteri;
        WebGLRenderingContext.prototype.texParameteri = function (target, pname, param) {
            switch (pname) {
                case WebGLRenderingContext.TEXTURE_MIN_FILTER:
                    var v = minFilters.filter(function (v) { return WebGLRenderingContext[v] == param; });
                    param = WebGLRenderingContext.LINEAR;
                    break;
                case WebGLRenderingContext.TEXTURE_MAG_FILTER:
                    var v1 = magFilters.filter(function (v) { return WebGLRenderingContext[v] == param; });
                    param = Config.GAME_MAG_FILTER ? Config.GAME_MAG_FILTER : 0x2600; //需要兼容旧版本
                    break;
            }
            oldTexParameteri.call(this, target, pname, param);
        };
        // 扩展
        ClientMain.prototype["initOver"] = function () {
            //使用大容量存储
            if (IndexedDBManager && IndexedDBManager.support) {
                if (window.name != null && os.platform == 0) {
                    try {
                        var parentInfo = JSON.parse(window.name);
                        IndexedDBManager.databaseName = parentInfo.id;
                        IndexedDBManager.used = true;
                    }
                    catch (e) {
                        IndexedDBManager.used = false;
                    }
                }
                else {
                    if (Config.gameSID) {
                        IndexedDBManager.databaseName = Config.gameSID.toString();
                        IndexedDBManager.used = true;
                    }
                    else {
                        IndexedDBManager.used = false;
                    }
                }
            }
            Config.TILE_SPLIT_SIZE_LOCK = true;
            SinglePlayerGame.init(Callback.New(function () {
                EventUtils.happen(ClientWorld, ClientWorld.EVENT_BEFORE_INITED);
                EventUtils.happen(ClientWorld, ClientWorld.EVENT_INITED);
            }, this));
        };
        // 软件环境
        gcParent.window["onunload"] = window["onunload"] = function (isRealClose) {
            gcParent.window["onunload"] = window["onunload"] = null;
            GameAudio.stopBGM();
            GameAudio.stopSE();
            GameAudio.stopBGS();
            GameAudio.stopTS();
            if (typeof mainDomain_kdsrpg != "undefined") {
                mainDomain_frameRef(-1);
            }
            return false;
        };
        //
        window.addEventListener("mousedown", function (e) {
            if (typeof mainDomain_kdsrpg == "undefined")
                return;
            var ev = new Event("mousedown");
            ev.domain = "midCanvas";
            ev.clientX = e.clientX;
            ev.clientY = e.clientY + 32;
            if (gcParent != window)
                gcParent.window.dispatchEvent(ev);
        });
        window.addEventListener("mousemove", function (e) {
            if (typeof mainDomain_kdsrpg == "undefined")
                return;
            var ev = new Event("mousemove");
            ev.domain = "midCanvas";
            ev.clientX = e.clientX;
            ev.clientY = e.clientY + 32;
            if (gcParent != window)
                gcParent.window.dispatchEvent(ev);
        });
        window.addEventListener("onmouseup", function (e) {
            if (typeof mainDomain_kdsrpg == "undefined")
                return;
            var ev = new Event("mouseup");
            ev.domain = "midCanvas";
            ev.clientX = e.clientX;
            ev.clientY = e.clientY + 32;
            if (gcParent != window)
                gcParent.window.dispatchEvent(ev);
        });
        // 修正旧的工程的错误 CumtomGameNumber => CustomGameNumber
        if (typeof window["CumtomGameNumber"] != "undefined") {
            if (typeof window["CustomGameNumber"] == "undefined") {
                window["CustomGameNumber"] = window["CumtomGameNumber"];
            }
            else {
                for (var i in window["CumtomGameNumber"]) {
                    if (!window["CustomGameNumber"][i]) {
                        window["CustomGameNumber"][i] = window["CumtomGameNumber"][i];
                    }
                }
            }
        }
    };
    return GCPolyfill;
}());
/**
 * 入口函数
 */
var playerMap = {};
// Game.playerKey = "5230_asdasdasd";
var layer3Test;
function main() {
    // 单机版内核标志
    Config.SINGLE_PLAYER_CORE = true;
    // 扩展
    GCPolyfill.init();
    // 初始化
    ClientWorld.init();
}
//初始化GameUI
GameUI.init();
//# sourceMappingURL=index.js.map